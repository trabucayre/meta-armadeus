diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/Kconfig linux-3.13/drivers/armadeus/Kconfig
--- linux-3.13/drivers/armadeus/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,32 @@
+#
+# Armadeus custom linux-3.13/drivers configuration
+#
+
+menuconfig ARMADEUS_DRIVERS
+	bool "Support for specific Armadeus linux-3.13/drivers"
+	---help---
+	  This menu will give you access on some Armadeus linux-3.13/drivers and tool.
+
+if ARMADEUS_DRIVERS
+
+comment "Misc."
+source "drivers/armadeus/generic/Kconfig"
+source "drivers/armadeus/as1531_platform/Kconfig"
+source "drivers/armadeus/mxs_lradc/Kconfig"
+source "drivers/armadeus/gpio/Kconfig"
+source "drivers/armadeus/imxlkeypad/Kconfig"
+source "drivers/armadeus/max1027/Kconfig"
+source "drivers/armadeus/max9768/Kconfig"
+
+comment "FPGA related"
+source "drivers/armadeus/fpga/Kconfig"
+
+comment "Handheld related"
+source "drivers/armadeus/pwm/Kconfig"
+source "drivers/armadeus/backlight/Kconfig"
+source "drivers/armadeus/display/Kconfig"
+
+comment "Communication bus related"
+source "drivers/armadeus/isp1761/Kconfig"
+
+endif # ARMADEUS_DRIVERS
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/Makefile linux-3.13/drivers/armadeus/Makefile
--- linux-3.13/drivers/armadeus/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,34 @@
+#
+# Main Makefile for the Armadeus linux-3.13/drivers
+#
+# Add your subdirectories to obj- target
+#
+
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+# Part executed when called from kernel build system:
+
+obj-$(CONFIG_ARMADEUS_DRIVERS)	+= gpio/ pwm/ backlight/ isp1761/ \
+	imxlkeypad/ fpga/ max1027/ max9768/ display/ as1531_platform/ \
+	mxs_lradc/ imx_counter/
+
+else
+# Part executed when called from standard make in this directory:
+
+ARMADEUS_BASE_DIR=../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+ifeq ($(LINUX_DIR),)
+LINUX_DIR:=$(ARMADEUS_LINUX_DIR)
+endif
+KDIR	:= $(LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ./Makefile.in
+	
+install:
+	echo "Installing Armadeus linux-3.13/drivers..."
+	 $(MAKE) -C $(LINUX_DIR) SUBDIRS=$(PWD) INSTALL_MOD_PATH=$(TARGET_DIR) linux-3.13/drivers/armadeus_install
+    
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/Makefile.in linux-3.13/drivers/armadeus/Makefile.in
--- linux-3.13/drivers/armadeus/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/Makefile.in	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,13 @@
+#
+# Helpers Makefile for the Armadeus linux-3.13/drivers
+#
+
+default:
+	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) ARCH=arm CROSS_COMPILE=$(PWD)/$(ARMADEUS_TOOLCHAIN_PATH)/arm-linux- linux-3.13/drivers/armadeus
+
+clean:
+	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) clean
+	rm -f linux-3.13/drivers/armadeus.order
+	rm -rf .tmp_versions/
+	rm -f Module.markers
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/as1531_platform/Kconfig linux-3.13/drivers/armadeus/as1531_platform/Kconfig
--- linux-3.13/drivers/armadeus/as1531_platform/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/as1531_platform/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,11 @@
+#
+#
+
+config ARMADEUS_AS1531_PLAT
+	tristate "AS1531 platform data"
+	default n
+	depends on ARMADEUS_DRIVERS
+	select SENSORS_AS1531
+	---help---
+	  Specific platform data for as1531 plugged on apf27-Dev board
+	  on SPI3.
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/as1531_platform/Makefile linux-3.13/drivers/armadeus/as1531_platform/Makefile
--- linux-3.13/drivers/armadeus/as1531_platform/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/as1531_platform/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,24 @@
+#
+# Makefile for the Armadeus specific as1531 platform module 
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_ARMADEUS_AS1531_PLAT)	+= as1531_plat.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/as1531_platform/as1531_plat.c linux-3.13/drivers/armadeus/as1531_platform/as1531_plat.c
--- linux-3.13/drivers/armadeus/as1531_platform/as1531_plat.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/as1531_platform/as1531_plat.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,121 @@
+/*
+ * as1531.c
+ *
+ * Platform data for driver as1531.
+ *
+ * Copyright (c) 2010 Fabien Marteau <fabien.marteau@armadeus.com>
+ * sponsored by ARMadeus Systems.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/sysfs.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/mutex.h>
+#include <linux/spi/spi.h>
+#include <linux/platform_device.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/iomux-mx1-mx2.h>
+#include <mach/gpio.h>
+#include <../mach-imx/include/mach/spi_imx.h>
+
+#define AS1531_CS (GPIO_PORTE | 21)
+/* spi3*/
+#define AS1531_SPI_BUS_NUM 2
+
+
+struct spi_device *as1531_spi_dev;
+
+static int as1531_pins[] = {
+	(AS1531_CS | GPIO_OUT | GPIO_GPIO),
+};
+
+static int as1531_init_gpio(void)
+{
+	gpio_set_value(AS1531_CS, 1);
+	return mxc_gpio_setup_multiple_pins(as1531_pins, ARRAY_SIZE(as1531_pins), "as1531");
+}
+
+static void as1531_exit_gpio(void)
+{
+	mxc_gpio_release_multiple_pins(as1531_pins, ARRAY_SIZE(as1531_pins));
+}
+
+/* Chip select command for as1531 */
+static void as1531_cs(u32 command)
+{
+	if (command == SPI_CS_DEASSERT)
+		gpio_set_value(AS1531_CS, 1);
+	else
+		gpio_set_value(AS1531_CS, 0);
+}
+
+static struct spi_imx_chip as1531_hw = {
+	.cs_control     = as1531_cs,
+};
+
+static struct spi_board_info spi_as1531_board[] = {
+	{
+		.modalias		= "as1531",
+		.controller_data	= &as1531_hw,
+		.max_speed_hz		= 1000000, /* 1MHz */
+		.bus_num		= AS1531_SPI_BUS_NUM, 
+		.mode			= SPI_MODE_3,
+		.chip_select		= 0,
+		.platform_data		= NULL,
+	}
+};
+
+
+static int __init as1531_plat_init(void)
+{
+	if (as1531_init_gpio() < 0) {
+		printk(KERN_ERR "Can't initialize gpio CS for as1531 spi\n");
+		return -1;
+	}
+
+	as1531_spi_dev = spi_new_device(
+			spi_busnum_to_master(AS1531_SPI_BUS_NUM),
+			spi_as1531_board);
+	if (as1531_spi_dev == NULL) {
+		printk(KERN_ERR "Can't register as1531_spi_dev\n");
+		goto register_error;
+	}
+
+	return 0;
+register_error:
+	return -1;
+}
+
+static void __exit as1531_plat_exit(void)
+{
+	spi_unregister_device(as1531_spi_dev);
+	as1531_exit_gpio();
+}
+
+module_init(as1531_plat_init);
+module_exit(as1531_plat_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Fabien Marteau <fabien.marteau@armadeus.com>");
+MODULE_DESCRIPTION("Platform data for AS1531 ADC");
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/backlight/Kconfig linux-3.13/drivers/armadeus/backlight/Kconfig
--- linux-3.13/drivers/armadeus/backlight/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/backlight/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,11 @@
+#
+#
+
+config IMX_BACKLIGHT
+        tristate "i.MX backlight driver"
+        default n
+        depends on ARMADEUS_DRIVERS && BACKLIGHT_LCD_SUPPORT
+        ---help---
+        This driver allows you to control the backlight of your graphic LCD, if it's
+        connected to the i.MXL/i.MX27 "CONTRAST" pin.
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/backlight/Makefile linux-3.13/drivers/armadeus/backlight/Makefile
--- linux-3.13/drivers/armadeus/backlight/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/backlight/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,25 @@
+#
+# Makefile for the i.MXL backlight driver
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_IMX_BACKLIGHT) += imx_bl.o
+imx_bl-objs := imx_bl_2.6.23.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/backlight/imx_bl_2.6.23.c linux-3.13/drivers/armadeus/backlight/imx_bl_2.6.23.c
--- linux-3.13/drivers/armadeus/backlight/imx_bl_2.6.23.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/backlight/imx_bl_2.6.23.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,217 @@
+/*
+ *  Backlight Driver for i.MX based platforms
+ *
+ *  Copyright (c) 2007 Julien Boibessot - Armadeus Project
+ *
+ *  Based on Backlight Driver for Sharp Zaurus Handhelds
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+#include <linux/version.h>
+#include <mach/imxfb.h>        /* Backlight machinfo struct is defined here */
+#include <mach/hardware.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+#ifdef CONFIG_ARCH_IMX
+#define LCDC_BASE_ADDR 		IMX_LCDC_BASE
+#endif /* CONFIG_ARCH_IMX */
+#define MXC_IO_ADDRESS		IO_ADDRESS
+#else
+#ifdef CONFIG_ARCH_MX1
+#include <mach/mx1.h>
+#define LCDC_BASE_ADDR		MX1_LCDC_BASE_ADDR
+#define MXC_IO_ADDRESS		MX1_IO_ADDRESS
+#else
+# include <mach/mx2x.h>
+#define LCDC_BASE_ADDR		MX27_LCDC_BASE_ADDR
+#define MXC_IO_ADDRESS		MX27_IO_ADDRESS
+#endif /* CONFIG_ARCH_MX1 */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) */
+
+#define DRIVER_NAME    "imx-bl"
+#define DRIVER_VERSION "0.2"
+
+static int imxbl_intensity;
+static DEFINE_MUTEX(bl_mutex);
+static struct backlight_properties imxbl_data;
+static struct backlight_device *imx_backlight_device;
+static struct imxbl_machinfo *bl_machinfo;
+
+static unsigned long imxbl_flags;
+#define IMXBL_SUSPENDED     0x01
+#define IMXBL_BATTLOW       0x02
+
+static int imxbl_send_intensity(struct backlight_device *bd)
+{
+	int intensity = bd->props.brightness;
+	unsigned long shadow = 0;
+
+	if (bd->props.power != FB_BLANK_UNBLANK)
+		intensity = 0;
+	if (bd->props.fb_blank != FB_BLANK_UNBLANK)
+		intensity = 0;
+	if (imxbl_flags & IMXBL_SUSPENDED)
+		intensity = 0;
+	if (imxbl_flags & IMXBL_BATTLOW)
+		intensity &= bl_machinfo->limit_mask;
+
+	/* If a method was given in machine info then use it */
+	if( bl_machinfo->set_bl_intensity ) {
+		bl_machinfo->set_bl_intensity(intensity);
+	} else { /* Otherwise use this default one: */
+		shadow = readl(MXC_IO_ADDRESS(LCDC_BASE_ADDR) + 0x2c); /* PWMR / LPCCR */
+		shadow &= ~PWMR_PW(0xff);
+		shadow |= PWMR_PW(intensity);
+		writel(shadow, MXC_IO_ADDRESS(LCDC_BASE_ADDR) + 0x2c);
+		pr_debug("Setting backlight intensity to %d\n", intensity);
+	}
+
+	imxbl_intensity = intensity;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int imxbl_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct backlight_device *bd = platform_get_drvdata(dev);
+
+	imxbl_flags |= IMXBL_SUSPENDED;
+	backlight_update_status(bd);
+	return 0;
+}
+
+static int imxbl_resume(struct platform_device *dev)
+{
+	struct backlight_device *bd = platform_get_drvdata(dev);
+
+	imxbl_flags &= ~IMXBL_SUSPENDED;
+	backlight_update_status(bd);
+	return 0;
+}
+#else
+#define imxbl_suspend	NULL
+#define imxbl_resume	NULL
+#endif
+
+static int imxbl_get_intensity(struct backlight_device *bd)
+{
+	return imxbl_intensity;
+}
+
+/*
+ * Called when the battery is low to limit the backlight intensity.
+ * If limit==0 clear any limit, otherwise limit the intensity
+ */
+void imxbl_limit_intensity(int limit)
+{
+	if (limit)
+		imxbl_flags |= IMXBL_BATTLOW;
+	else
+		imxbl_flags &= ~IMXBL_BATTLOW;
+	backlight_update_status(imx_backlight_device);
+}
+EXPORT_SYMBOL(imxbl_limit_intensity);
+
+
+static struct backlight_ops imxbl_ops = {
+	.get_brightness = imxbl_get_intensity,
+	.update_status  = imxbl_send_intensity,
+};
+
+static int imxbl_probe(struct platform_device *pdev)
+{
+	struct imxbl_machinfo *machinfo = pdev->dev.platform_data;
+
+	bl_machinfo = machinfo;
+	imxbl_data.max_brightness = machinfo->max_intensity;
+	if (!machinfo->limit_mask)
+		machinfo->limit_mask = -1;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+	struct backlight_properties props;
+
+	memset(&props, 0, sizeof(struct backlight_properties));
+	props.max_brightness = machinfo->max_intensity;
+	props.power = FB_BLANK_UNBLANK;
+	props.brightness = machinfo->default_intensity;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	imx_backlight_device = backlight_device_register(DRIVER_NAME,
+								&pdev->dev, NULL, &imxbl_ops);
+#else
+	imx_backlight_device = backlight_device_register(DRIVER_NAME,
+								&pdev->dev, NULL, &imxbl_ops, &props);
+#endif
+
+	if (IS_ERR (imx_backlight_device)) {
+		printk("can't register backlight device\n");
+		return PTR_ERR (imx_backlight_device);
+	}
+
+	platform_set_drvdata(pdev, imx_backlight_device);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	imx_backlight_device->props.max_brightness = machinfo->max_intensity;
+	imx_backlight_device->props.power = FB_BLANK_UNBLANK;
+	imx_backlight_device->props.brightness = machinfo->default_intensity;
+#endif
+
+	backlight_update_status(imx_backlight_device);
+
+	printk("i.MX Backlight driver v" DRIVER_VERSION " initialized.\n");
+	return 0;
+}
+
+static int imxbl_remove(struct platform_device *pdev)
+{
+	struct backlight_device *bd = platform_get_drvdata(pdev);
+
+	imxbl_data.power = 0;
+	imxbl_data.brightness = 0;
+	backlight_update_status(bd);
+
+	backlight_device_unregister(bd);
+
+	printk("i.MX Backlight driver unloaded\n");
+	return 0;
+}
+
+static struct platform_driver imxbl_driver = {
+	.probe		= imxbl_probe,
+	.remove		= imxbl_remove,
+	.suspend	= imxbl_suspend,
+	.resume		= imxbl_resume,
+	.driver		= {
+		.name	= DRIVER_NAME,
+	},
+};
+
+static int __init imxbl_init(void)
+{
+	return platform_driver_register(&imxbl_driver);
+}
+
+static void __exit imxbl_exit(void)
+{
+	platform_driver_unregister(&imxbl_driver);
+}
+
+module_init(imxbl_init);
+module_exit(imxbl_exit);
+
+MODULE_AUTHOR("Julien Boibessot <julien.boibessot@armadeus.com>");
+MODULE_DESCRIPTION("i.MX Backlight Driver");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/backlight/test/test_backlight.sh linux-3.13/drivers/armadeus/backlight/test/test_backlight.sh
--- linux-3.13/drivers/armadeus/backlight/test/test_backlight.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/backlight/test/test_backlight.sh	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,33 @@
+#!/bin/sh
+
+failed()
+{
+    echo "Test FAILED !"
+    exit 1
+}
+
+BL_SYS_DIR="/sys/class/backlight/imx-bl/"
+if [ ! -d "$BL_SYS_DIR" ]; then
+	echo "/sys interface not found:"
+	echo "  driver not loaded or wrong version !"
+	failed
+fi
+
+# Save actual brightness
+ACTUAL=`cat "$BL_SYS_DIR/actual_brightness"`
+for INTENSITY in 300 255 200 150 100 50 25 0; do
+    echo "Setting brightness to: $INTENSITY"
+    echo "$INTENSITY" > "$BL_SYS_DIR/brightness"
+    SET=`cat "$BL_SYS_DIR/actual_brightness"`
+    if [ "$SET" != "$INTENSITY" ]; then
+        echo "Values differ, written: $INTENSITY read: $SET"
+        if [ "$INTENSITY" != "300" ]; then
+            failed
+        fi
+    fi
+    sleep 1
+done
+# Restore brightness
+echo "$ACTUAL" > "$BL_SYS_DIR/brightness"
+
+exit 0
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/display/Kconfig linux-3.13/drivers/armadeus/display/Kconfig
--- linux-3.13/drivers/armadeus/display/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/display/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,12 @@
+#
+#
+
+config HX5116_DISPLAY
+        tristate "HX5116 AMOLED display driver"
+        default n
+        depends on ARMADEUS_DRIVERS
+        select DISPLAY_SUPPORT
+        ---help---
+        This driver allows you to control the contrast of 
+        HX5116 based AMOLED screen.
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/display/Makefile linux-3.13/drivers/armadeus/display/Makefile
--- linux-3.13/drivers/armadeus/display/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/display/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,24 @@
+#
+# Makefile for the hx5116_display driver
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_HX5116_DISPLAY) += hx5116_display.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/display/hx5116_display.c linux-3.13/drivers/armadeus/display/hx5116_display.c
--- linux-3.13/drivers/armadeus/display/hx5116_display.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/display/hx5116_display.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,256 @@
+/*
+ *  Display Driver for hx5116 controler for AMOLED 
+ *
+ *  Copyright (c) 2009 Fabien Marteau - ARMadeus Systems
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+
+#include <linux/display.h>
+#include <linux/spi/spi.h>
+
+#include <linux/version.h>
+#include <mach/imxfb.h>        /* Backlight machinfo struct is defined here */
+#include <mach/hardware.h>
+
+#include <video/hx5116.h>
+
+#define DRIVER_NAME    "hx5116-display"
+#define DRIVER_VERSION "0.3"
+
+/* write value hx5116 display register via SPI */
+void hx5116_write(struct hx5116_display *hx5116_dev, u8 address, u16 data)
+{
+	u8 command[2];
+	int ret;
+
+	/* Address */
+	command[0] = (address << 1) | HX5116_SPI_WRITE;
+	command[1] = data;
+	ret = spi_write(hx5116_dev->spi, command, 2);
+	if (ret < 0)
+		printk("ERROR: can't write on hx5116\n");
+}
+
+/* XXX: not functionnal, need half duplex capability under spi_gpio driver */
+u8 hx5116_read(struct hx5116_display *hx5116_dev, u8 address)
+{
+	u8 command;
+	ssize_t ret;
+
+	/* Address */
+	command = (address << 1) | HX5116_SPI_READ;
+	ret = spi_w8r8(hx5116_dev->spi, command);
+	if (ret < 0)
+		printk("ERROR: can't read on hx5116\n");
+
+	return (u8)ret;
+}
+
+static int hx5116_display_get_contrast(struct display_device *dev)
+{
+	struct hx5116_display *hx5116_dev = dev->priv_data;
+
+	/* TODO: read register value with spi_w8r8 */
+
+	return hx5116_dev->gcontrast_value;
+}
+
+static int hx5116_display_set_contrast(struct display_device *dev, unsigned int value)
+{
+	struct hx5116_display *hx5116_dev = dev->priv_data;
+	
+	hx5116_write(hx5116_dev, HX5116_RGB_CONTRAST, value);
+	hx5116_dev->gcontrast_value = value;
+
+	return value;
+}
+
+static int hx5116_display_probe(struct display_device *dev, void *data)
+{
+	return 1;
+}
+
+static int  hx5116_display_remove(struct display_device *dev)
+{
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static void hx5116_display_suspend(struct display_device *dev, pm_message_t state)
+{
+	struct hx5116_display *hx5116_dev = dev->priv_data;
+}
+
+static void hx5116_display_resume(struct display_device *dev)
+{
+	struct hx5116_display *hx5116_dev = dev->priv_data;
+}
+#else
+#define hx5116_display_suspend	NULL
+#define hx5116_display_resume	NULL
+#endif /* CONFIG_PM */
+
+static struct display_driver hx5116_ops = {
+	.get_contrast 	= hx5116_display_get_contrast,
+	.set_contrast 	= hx5116_display_set_contrast,
+	.probe       	= hx5116_display_probe,
+	.suspend	= hx5116_display_suspend,
+	.resume		= hx5116_display_resume,
+	.remove		= hx5116_display_remove,
+	.max_contrast	= 63,
+};
+
+
+static void hx5116_init_sequence(struct hx5116_display *hx5116_dev)
+{
+	hx5116_dev->reset_on(0); /* reset off */
+
+	/* initial procedure for 24-bit parallel RGB (DE) */
+	hx5116_write (hx5116_dev, 0x04, 0x23); /*set display mode 24-bit parallel RGB (DE)*/
+	hx5116_write (hx5116_dev, 0x05, 0x82); /*set display mode*/
+	hx5116_write (hx5116_dev, 0x07, 0x0F); /*set driver capability*/
+	hx5116_write (hx5116_dev, 0x34, 0x18); /*set display timing*/
+	hx5116_write (hx5116_dev, 0x35, 0x28); /*set display timing*/
+	hx5116_write (hx5116_dev, 0x36, 0x16); /*set display timing*/
+	hx5116_write (hx5116_dev, 0x37, 0x01); /*set display timing*/
+	hx5116_write (hx5116_dev, 0x02, 0x02); /*OTP On*/
+	hx5116_write (hx5116_dev, 0x0A, 0x79); /*VGHVGL=+/-6V*/
+	hx5116_write (hx5116_dev, 0x09, 0x20); /*VGAM1OUT=4.85V*/
+	hx5116_write (hx5116_dev, 0x10, 0x6A); /*set R slop*/
+	hx5116_write (hx5116_dev, 0x11, 0x6A); /*set G slop*/
+	hx5116_write (hx5116_dev, 0x12, 0x68); /*set B slop*/
+	hx5116_write (hx5116_dev, 0x13, 0x00); /*set R_0*/
+	hx5116_write (hx5116_dev, 0x14, 0x04); /*set R_10*/
+	hx5116_write (hx5116_dev, 0x15, 0x05); /*set R_36*/
+	hx5116_write (hx5116_dev, 0x16, 0x05); /*set R_80*/
+	hx5116_write (hx5116_dev, 0x17, 0x04); /*set R_124*/
+	hx5116_write (hx5116_dev, 0x18, 0x03); /*set R_168*/
+	hx5116_write (hx5116_dev, 0x19, 0x02); /*set R_212*/
+	hx5116_write (hx5116_dev, 0x1A, 0x02); /*set R_255*/
+	hx5116_write (hx5116_dev, 0x1B, 0x00); /*set G_0*/
+	hx5116_write (hx5116_dev, 0x1C, 0x06); /*set G_10*/
+	hx5116_write (hx5116_dev, 0x1D, 0x05); /*set G_36*/
+	hx5116_write (hx5116_dev, 0x1E, 0x06); /*set G_80*/
+	hx5116_write (hx5116_dev, 0x1F, 0x06); /*set G_124*/
+	hx5116_write (hx5116_dev, 0x20, 0x05); /*set G_168*/
+	hx5116_write (hx5116_dev, 0x21, 0x05); /*set G_212*/
+	hx5116_write (hx5116_dev, 0x22, 0x07); /*set G_255*/
+	hx5116_write (hx5116_dev, 0x23, 0x00); /*set G_0*/
+	hx5116_write (hx5116_dev, 0x24, 0x07); /*set B_10*/
+	hx5116_write (hx5116_dev, 0x25, 0x06); /*set B_36*/
+	hx5116_write (hx5116_dev, 0x26, 0x07); /*set B_80*/
+	hx5116_write (hx5116_dev, 0x27, 0x07); /*set B_124*/
+	hx5116_write (hx5116_dev, 0x28, 0x06); /*set B_168*/
+	hx5116_write (hx5116_dev, 0x29, 0x04); /*set B_212*/
+	hx5116_write (hx5116_dev, 0x2A, 0x07); /*set B_255*/
+	hx5116_write (hx5116_dev, 0x06, 0x03); /*set display on*/
+}
+
+static int hx5116_spi_probe(struct spi_device *pdev)
+{
+	int err = -EINVAL;
+	struct display_device *disp_dev;
+	struct hx5116_display *hx5116_dev = pdev->dev.platform_data;
+
+	/* fill hx5116 display structure */
+	disp_dev = display_device_register(&hx5116_ops,
+					&pdev->dev,
+					hx5116_dev);
+	if (disp_dev == NULL)
+		goto display_device_error;
+	disp_dev->priv_data = hx5116_dev;
+	hx5116_dev->display_dev = disp_dev;
+	hx5116_dev->spi = pdev;
+
+	/* configure spi */
+	hx5116_dev->spi->mode = SPI_MODE_0;
+	hx5116_dev->spi->bits_per_word = 8;
+	hx5116_dev->spi->dev.power.power_state = PMSG_ON;
+	err = spi_setup(hx5116_dev->spi);
+	if (err < 0) {
+		goto spi_error;
+	}
+
+	hx5116_init_sequence(hx5116_dev);
+
+	return 0;
+
+spi_error:
+	printk("ERROR: can't setup spi for hx5116\n");
+	display_device_unregister(hx5116_dev->display_dev);
+display_device_error:
+	printk("ERROR: can't register display device\n");
+	return err;
+}
+
+static int hx5116_spi_remove(struct spi_device *pdev)
+{
+	struct hx5116_display *hx5116_dev = pdev->dev.platform_data;
+
+	hx5116_dev->reset_on(1); /* let hx5116 in reset */
+	display_device_unregister(hx5116_dev->display_dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int hx5116_spi_suspend(struct spi_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+static int hx5116_spi_resume(struct spi_device *dev)
+{
+	return 0;
+}
+#else
+#define hx5116_suspend	NULL
+#define hx5116_resume	NULL
+#endif
+
+static void hx5116_spi_shutdown(struct spi_device *spi)
+{
+
+}
+
+static struct spi_driver hx5116_driver = {
+	.probe		= hx5116_spi_probe,
+	.remove		= hx5116_spi_remove,
+	.shutdown	= hx5116_spi_shutdown,
+	.suspend	= hx5116_spi_suspend,
+	.resume		= hx5116_spi_resume,
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init hx5116_init(void)
+{
+	return spi_register_driver(&hx5116_driver);
+}
+
+static void __exit hx5116_exit(void)
+{
+	spi_unregister_driver(&hx5116_driver);
+}
+
+module_init(hx5116_init);
+module_exit(hx5116_exit);
+
+MODULE_AUTHOR("Fabien Marteau <fabien.marteau@armadeus.com");
+MODULE_DESCRIPTION("HX5116 AMOLED Driver");
+MODULE_LICENSE("GPL");
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/dma_test/Makefile linux-3.13/drivers/armadeus/dma_test/Makefile
--- linux-3.13/drivers/armadeus/dma_test/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/dma_test/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,24 @@
+#
+# Makefile for the DMA throughput test driver
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-m	+= dma.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets:
+include ../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/dma_test/dma.c linux-3.13/drivers/armadeus/dma_test/dma.c
--- linux-3.13/drivers/armadeus/dma_test/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/dma_test/dma.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,283 @@
+/*
+ * Driver to test DMA throughput
+ *
+ * Copyright (C) 2008 Armadeus Systems <julien.boibessot@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <asm/types.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>        /* get_user,copy_to_user */
+#include <linux/jiffies.h>
+
+#ifdef CONFIG_ARCH_MX2
+#include <mach/dma-mx1-mx2.h>
+#define DMA_DIMR    0x08		/* Interrupt mask Register */
+#define DMA_CCR(x)  (0x8c + ((x) << 6))	/* Control Registers */
+#define CCR_FRC            (1<<1)
+#define CCR_CEN            (1<<0)
+#else
+#include <mach/imx-dma.h>
+#endif
+
+
+#define DRIVER_NAME "dma-test"
+
+
+struct dma_buffer {
+	u32* cpu_mem;
+	dma_addr_t dma_mem;
+};
+
+struct dma_buffer dma_source_buffer, dma_dest_buffer;
+
+static unsigned int nb_todo = 0;
+static unsigned int nb_done = 0;
+
+static int channel;
+
+unsigned int buffer_size = 512 * 1024;
+
+static unsigned int start_time = 0;
+static unsigned int stop_time = 0;
+
+
+static void inline dma_test_trig_transfer(void)
+{
+	/* Activate interrupts for channel */
+	__raw_writel(__raw_readl(DMA_BASE + DMA_DIMR) & ~(1<<channel),
+			DMA_BASE + DMA_DIMR);
+	/* Manually trigger DMA transfer */
+	__raw_writel(__raw_readl(DMA_BASE + DMA_CCR(channel)) | CCR_FRC | CCR_CEN,
+			DMA_BASE + DMA_CCR(channel));
+}
+
+/* Called by the DMA framework when a period has elapsed (scatter-gather */
+/*static void dma_test_progression(int channel, void *data,
+					struct scatterlist *sg)
+{
+	if (sg) {
+		;
+	}
+}*/
+
+/* called when the DMA unit has finished the buffer (single mode) */
+static void dma_test_callback(int channel, void *data)
+{
+	if (nb_done > nb_todo) {
+		stop_time = (unsigned int)jiffies;
+		printk("%s: done (%d) at time 0x%08x\n", __func__, nb_done, stop_time);
+		printk("0x%08x 0x%08x\n", dma_dest_buffer.cpu_mem[0], dma_dest_buffer.cpu_mem[4096]);
+		printk("Tranferred %d Bytes in %d msecs\n", (buffer_size * nb_done), (stop_time - start_time)*10);
+		printk(" --> %d Bytes/secs\n", ((buffer_size * nb_done) / ((stop_time - start_time)*10)) * 1000);
+		nb_done = 0;
+	} else {
+		dma_source_buffer.cpu_mem[0] &= 0xffff0000;
+		dma_source_buffer.cpu_mem[0] |= nb_done;
+		nb_done++;
+		dma_test_trig_transfer();
+	}
+}
+
+/* Called by the DMA framework when an error has occured */
+static void dma_test_err_handler(int channel, void *data, int err)
+{
+	printk("%s %d %d\n", __func__, channel, err);
+
+	printk("DMA timeout on channel %d -%s%s%s%s%s\n",
+		 channel,
+		 err & IMX_DMA_ERR_BURST ?    " burst":"",
+		 err & IMX_DMA_ERR_REQUEST ?  " request":"",
+		 err & IMX_DMA_ERR_TRANSFER ? " transfer":"",
+		 err & IMX_DMA_ERR_BUFFER ?   " buffer":"",
+		 err & IMX_DMA_ERR_TIMEOUT ?  " hw_chain_watchdog":"");
+
+	imx_dma_disable(channel);
+}
+
+/* configure DMA channel of a given substream */
+static int dma_request(void)
+{
+	int err=0, chan=0;
+
+	chan = imx_dma_request_by_prio(DRIVER_NAME, DMA_PRIO_HIGH);
+	if (chan < 0) {
+		printk(KERN_ERR "Unable to grab a DMA channel\n");
+		err = chan;
+		goto on_error_1;
+	}
+
+	err = imx_dma_setup_handlers(chan,
+					dma_test_callback,
+					dma_test_err_handler, NULL /* private data comes here */);
+	if (err < 0) {
+		printk(KERN_ERR "Unable to setup DMA handler for channel %d\n", chan);
+		err = -EIO;
+		goto on_error_2;
+	}
+
+/*	err = imx_dma_setup_progression_handler(chan,
+						dma_test_progression);
+	if (err != 0) {
+		pr_err("Failed to setup the DMA progression handler\n");
+		err = -EIO;
+		goto on_error_2;
+	} */
+
+	printk("DMA channel %d setup\n", chan);
+	imx_dma_disable(chan);
+
+	return chan;
+
+on_error_2:
+	imx_dma_free(chan);
+on_error_1:
+	return err;
+}
+
+
+static int dma_test_proc_write( __attribute__ ((unused)) struct file *file, const char *buf, unsigned long count, void *data)
+{
+	int len;
+	char given_param[16];
+	int loops;
+
+	if (count <= 0) {
+		printk("Empty string transmitted !\n");
+		return 0;
+	}
+	if (count > 4) {
+		len = 4;
+		printk("Only 4x[0-9] decimal values supported !\n");
+	} else {
+		len = count;
+	}
+
+	if (copy_from_user(given_param, buf, len)) {
+		return -EFAULT;
+	}
+
+	loops = simple_strtol(given_param, 0, 10);
+	/* start transfer */
+	printk("Launching %d DMA transfers (mem to mem) at time 0x%08x\n", loops, (unsigned int)jiffies);
+	nb_todo = loops;
+	start_time = (unsigned int)jiffies;
+	dma_test_trig_transfer();
+
+	return len;
+}
+
+
+
+int __init dma_test_init(void)
+{
+	int err, dma_req;
+	unsigned int burstlen, i;
+	static struct proc_dir_entry *proc_active;
+
+	/* Allocate memory buffers */
+	dma_source_buffer.cpu_mem = dma_alloc_coherent(0,
+					buffer_size,
+					&(dma_source_buffer.dma_mem),
+					GFP_DMA | GFP_KERNEL);
+	dma_dest_buffer.cpu_mem = dma_alloc_coherent(0,
+					buffer_size,
+					&(dma_dest_buffer.dma_mem),
+					GFP_DMA | GFP_KERNEL);
+
+	if ((!dma_source_buffer.cpu_mem) || (!dma_dest_buffer.cpu_mem)) {
+		printk("Failed to allocate buffers !\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i <  (buffer_size/sizeof(u32)); i++) {
+		dma_source_buffer.cpu_mem[i] = i;
+	}
+	printk("DMA source virt: 0x%p  phys: 0x%08x\n", dma_source_buffer.cpu_mem, dma_source_buffer.dma_mem);
+	memset(dma_dest_buffer.cpu_mem, 0, buffer_size);
+	printk("DMA dest virt: 0x%p  phys: 0x%08x\n", dma_dest_buffer.cpu_mem, dma_dest_buffer.dma_mem);
+
+	burstlen = 64;
+	dma_req = 0; /* no hw req for mem to mem DMA */
+
+	/* request DMA channel */
+	channel = dma_request();
+	if (channel < 0)
+		return channel;
+
+	/* configure i.MX DMA control register for given channel */
+	err = imx_dma_config_channel(channel,
+					IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR,
+					IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR,
+					dma_req, 1);
+	if (err < 0) {
+		printk("Cannot configure DMA for channel %d\n", channel);
+	}
+
+	/* configure DMA burst length for channel */
+	imx_dma_config_burstlen(channel, burstlen);
+
+	err = imx_dma_setup_single(channel, dma_source_buffer.dma_mem,
+		     buffer_size, dma_dest_buffer.dma_mem,
+		     DMA_MODE_WRITE);
+	if (err < 0) {
+		printk("Cannot setup DMA for channel %d\n", channel);
+	}
+
+	/* create proc files */
+	proc_active = create_proc_entry( "driver/dma_test", S_IWUSR | S_IRGRP | S_IROTH, NULL);
+	if ((proc_active == NULL)) {
+		printk(KERN_ERR DRIVER_NAME ": Could not register one /proc file. Terminating\n");
+		return -ENOMEM;
+	} else {
+		proc_active->write_proc = dma_test_proc_write;
+	}
+
+	return 0;
+}
+
+void __exit dma_test_exit(void)
+{
+	imx_dma_disable(channel);
+	imx_dma_free(channel);
+
+	remove_proc_entry("driver/dma_test", NULL);
+
+	dma_free_coherent(0, buffer_size, dma_source_buffer.cpu_mem,
+			  dma_source_buffer.dma_mem);
+	dma_free_coherent(0, buffer_size, dma_dest_buffer.cpu_mem,
+			  dma_dest_buffer.dma_mem);
+}
+
+
+module_init(dma_test_init);
+module_exit(dma_test_exit);
+
+MODULE_AUTHOR("Julien Boibessot");
+MODULE_DESCRIPTION("APF27 DMA test");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/Kconfig linux-3.13/drivers/armadeus/fpga/Kconfig
--- linux-3.13/drivers/armadeus/fpga/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,20 @@
+#
+# Armadeus FPGA linux-3.13/drivers configuration
+#
+
+menuconfig ARMADEUS_FPGA_DRIVERS
+	bool "FPGA specific linux-3.13/drivers and tools"
+	---help---
+	  All linux-3.13/drivers and tools related to FPGA.
+
+if ARMADEUS_FPGA_DRIVERS
+
+source "drivers/armadeus/fpga/dev_tools/Kconfig"
+source "drivers/armadeus/fpga/others/Kconfig"
+
+comment "Specific designs"
+source "drivers/armadeus/fpga/virtual_components/Kconfig"
+source "drivers/armadeus/fpga/POD/Kconfig"
+source "drivers/armadeus/fpga/board_designs/Kconfig"
+
+endif # ARMADEUS_FPGA_DRIVERS
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/Makefile linux-3.13/drivers/armadeus/fpga/Makefile
--- linux-3.13/drivers/armadeus/fpga/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,31 @@
+#
+# Main Makefile for the Armadeus FPGA related linux-3.13/drivers
+#
+# Add your subdirectories to obj- target
+#
+
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+# Part executed when called from kernel build system:
+
+obj-$(CONFIG_ARMADEUS_FPGA_DRIVERS) += dev_tools/ board_designs/ virtual_components/
+obj-$(CONFIG_POD_DRIVERS) += POD/
+obj-$(CONFIG_ARMADEUS_I2C_OCORE_IRQMNG) += others/i2ctest/
+obj-$(CONFIG_ARMADEUS_PS2KBD_DRIVER) += others/ps2keyboard/
+
+else
+# Part executed when called from standard make in this directory:
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+ifeq ($(LINUX_DIR),)
+LINUX_DIR:=$(ARMADEUS_LINUX_DIR)
+endif
+KDIR	:= $(LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/POD/Kconfig linux-3.13/drivers/armadeus/fpga/POD/Kconfig
--- linux-3.13/drivers/armadeus/fpga/POD/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/POD/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,11 @@
+#
+# Armadeus POD generated linux-3.13/drivers configuration
+#
+
+config POD_DRIVERS
+	boolean "Board linux-3.13/drivers generated by POD"
+	depends on ARMADEUS_FPGA_DRIVERS
+	---help---
+	  Makes all POD generated linux-3.13/drivers selectable.
+
+source "drivers/armadeus/fpga/POD/*/Kconfig"
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/POD/Makefile linux-3.13/drivers/armadeus/fpga/POD/Makefile
--- linux-3.13/drivers/armadeus/fpga/POD/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/POD/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,29 @@
+#
+# Main Makefile for the Armadeus FPGA related linux-3.13/drivers (generated by POD)
+#
+# Sub-directories are automatically added to obj- target
+#
+
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+# Part executed when called from kernel build system:
+
+obj-$(CONFIG_POD_DRIVERS)	+=  $(shell ls -F linux-3.13/drivers/armadeus/fpga/POD/ | grep \/$)
+
+else
+# Part executed when called from standard make in this directory:
+
+ARMADEUS_BASE_DIR=../../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR := $(ARMADEUS_LINUX_DIR)
+PWD  := $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../../Makefile.in
+
+install:
+	echo "Installing Armadeus linux-3.13/drivers..."
+	$(MAKE) -C $(LINUX_DIR) SUBDIRS=$(PWD) INSTALL_MOD_PATH=$(TARGET_DIR) linux-3.13/drivers/armadeus_install
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/Kconfig linux-3.13/drivers/armadeus/fpga/board_designs/Kconfig
--- linux-3.13/drivers/armadeus/fpga/board_designs/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,12 @@
+#
+# Armadeus FPGA platform linux-3.13/drivers configuration
+#
+
+config ARMADEUS_FPGA_BOARD_DESIGNS
+	boolean "Board designs"
+	depends on ARMADEUS_FPGA_DRIVERS
+	---help---
+	  Board support for FPGA designs
+
+source "drivers/armadeus/fpga/board_designs/*/Kconfig"
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/Makefile linux-3.13/drivers/armadeus/fpga/board_designs/Makefile
--- linux-3.13/drivers/armadeus/fpga/board_designs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,3 @@
+
+obj-$(CONFIG_ARMADEUS_FPGA_BOARD_DESIGNS)   += twin_uart/ wishbone_example/ spvision_loader/ 
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/spvision_loader/Kconfig linux-3.13/drivers/armadeus/fpga/board_designs/spvision_loader/Kconfig
--- linux-3.13/drivers/armadeus/fpga/board_designs/spvision_loader/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/spvision_loader/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,11 @@
+
+config ARMADEUS_FPGA_BOARD_DESIGNS_SPVISION_PROBER
+	tristate "board driver for sp_vision fpga loader"
+	default n
+	depends on ARMADEUS_FPGA_BOARD_DESIGNS
+	select ARMADEUS_FPGA_VIRTUAL_SPVISION_LOADER
+	select ARMADEUS_FPGA_VIRTUAL_COMPONENTS
+	---help---
+	  With this driver you will be able to load the configuration
+	  of your sp_vision FPGA directly from Linux userspace.
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/spvision_loader/Makefile linux-3.13/drivers/armadeus/fpga/board_designs/spvision_loader/Makefile
--- linux-3.13/drivers/armadeus/fpga/board_designs/spvision_loader/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/spvision_loader/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for the Armadeus FPGA loader driver
+#
+
+obj-$(CONFIG_ARMADEUS_FPGA_BOARD_DESIGNS_SPVISION_PROBER)	+= sploader_prober.o
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/spvision_loader/sploader_prober.c linux-3.13/drivers/armadeus/fpga/board_designs/spvision_loader/sploader_prober.c
--- linux-3.13/drivers/armadeus/fpga/board_designs/spvision_loader/sploader_prober.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/spvision_loader/sploader_prober.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,91 @@
+/*
+ ***********************************************************************
+ *
+ * (c) Copyright 2011	Armadeus project
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ * Gwenhael Goavec-Merou <gwenhael.goavec-merou@armadeus.com>
+ * loader driver for generic sploader driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ **********************************************************************
+ */
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+# include <mach/fpga.h>
+
+#include "../../virtual_components/sploader/spartan_loadsecond.h"
+
+static struct resource sploader0_resources[] = {
+	[0] = {
+		.start	= ARMADEUS_FPGA_BASE_ADDR, + 0x0,
+		.end	= ARMADEUS_FPGA_BASE_ADDR + 0x0 + 3,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static Xilinx_desc plat_sploader0_data = {
+	.family = Xilinx_Spartan6,
+	.iface = slave_parallel,
+	.size = (11875104l / 8),    //XILINX_XC6SLX45_SIZE,
+	.fpga_offset = ARMADEUS_FPGA_BASE_ADDR,
+	.cookie = 1,
+	.name		= "SP_VISION_CONFIGURE00",
+	.num		= 0,
+	.idnum		= 1,
+	.idoffset	=  0x0 * (16 /8)
+};
+
+
+void plat_sploader_release(struct device *dev)
+{
+	dev_dbg(dev, "released\n");
+}
+
+static struct platform_device plat_sploader_devices[] = {
+    {
+	    .name	= "sploader",
+	    .id	= 0,
+	    .dev	= {
+	    	.release	= plat_sploader_release,
+	    	.platform_data	= &plat_sploader0_data
+	    },
+	    .num_resources	= ARRAY_SIZE(sploader0_resources),
+	    .resource	= sploader0_resources,
+    }
+
+};
+
+static int __init sploader_init(void)
+{
+	return platform_device_register(plat_sploader_devices);
+}
+
+static void __exit sploader_exit(void)
+{
+	platform_device_unregister(plat_sploader_devices);
+}
+
+module_init(sploader_init);
+module_exit(sploader_exit);
+
+MODULE_AUTHOR("Fabien Marteau <fabien.marteau@armadeus.com>");
+MODULE_AUTHOR("Gwenhael Goavec-Merou <gwenhael.goavec-merou@armadeus.com>");
+MODULE_DESCRIPTION("Driver to load spvision fpga");
+MODULE_LICENSE("GPL");
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/Kconfig linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/Kconfig
--- linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,12 @@
+
+config ARMADEUS_FPGA_BOARD_DESIGNS_TWIN_UARTS
+	boolean "board linux-3.13/drivers for twin uarts design"
+	default n
+	depends on ARMADEUS_FPGA_BOARD_DESIGNS && MACH_APF51
+	select ARMADEUS_FPGA_VIRTUAL_COMPONENTS
+	---help---
+	  Board support for fpga designs twin uarts used
+	  for gsm/gps on apf51Dev board.
+
+source "drivers/armadeus/fpga/board_designs/twin_uart/uarts/Kconfig"
+source "drivers/armadeus/fpga/board_designs/twin_uart/irq_mngr/Kconfig"
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/Makefile linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/Makefile
--- linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,3 @@
+
+obj-$(CONFIG_ARMADEUS_FPGA_BOARD_DESIGNS_TWIN_UARTS) += irq_mngr/ uarts/
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/irq_mngr/Kconfig linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/irq_mngr/Kconfig
--- linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/irq_mngr/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/irq_mngr/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,8 @@
+
+config ARMADEUS_FPGA_BOARD_DESIGNS_TWIN_UARTS_IRQ_MNGR
+	tristate "board irq manager"
+	default n
+	depends on ARMADEUS_FPGA_BOARD_DESIGNS_TWIN_UARTS
+	select ARMADEUS_FPGA_VIRTUAL_COMPONENTS_IRQ_MNGR
+	---help---
+	  irq manager board 
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/irq_mngr/Makefile linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/irq_mngr/Makefile
--- linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/irq_mngr/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/irq_mngr/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,2 @@
+
+obj-$(CONFIG_ARMADEUS_FPGA_BOARD_DESIGNS_TWIN_UARTS_IRQ_MNGR) += twin_uarts_irq_mng.o
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/irq_mngr/twin_uarts_irq_mng.c linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/irq_mngr/twin_uarts_irq_mng.c
--- linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/irq_mngr/twin_uarts_irq_mng.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/irq_mngr/twin_uarts_irq_mng.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,107 @@
+/*
+ * Platform data for IRQ manager generic driver
+ *
+ * (c) Copyright 2011    The Armadeus Project - ARMadeus Systems
+ * Author: Julien Boibessot <julien.boibessot@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <mach/hardware.h>
+#ifdef CONFIG_MACH_APF9328 /* To remove when MX1 platform is merged */
+# include "../arch/arm/plat-mxc/include/mach/fpga.h"
+# include <mach/irqs.h>
+#else
+# include <mach/fpga.h>
+#endif
+
+#include "../../../virtual_components/irq_mngr/irq_mng.h"
+
+static struct resource irq_mng0_resources[] = {
+	[0] = {
+		.start	= ARMADEUS_FPGA_BASE_ADDR + 0x0,
+		.end	= ARMADEUS_FPGA_BASE_ADDR + 0x0 + (8 - 1),
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= ARMADEUS_FPGA_IRQ,
+		.end	= ARMADEUS_FPGA_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static struct ocore_irq_mng_pdata irq_mng0_data = {
+	.num		= 0,
+	.idnum		= 0x01,
+	.idoffset	= 0x06,
+};
+
+static void irq_mng0_release(struct device *dev)
+{
+	dev_dbg(dev, "released\n");
+}
+
+static struct platform_device irq_mng0_device = {
+	.name		= "ocore_irq_mng",
+	.id		= 0,
+	.dev		= {
+		.release	= irq_mng0_release,
+		.platform_data	= &irq_mng0_data
+	},
+	.num_resources	= ARRAY_SIZE(irq_mng0_resources),
+	.resource	= irq_mng0_resources,
+};
+
+#ifdef CONFIG_MACH_APF27
+static int fpga_pins[] = {
+	(APF27_FPGA_INT_PIN | GPIO_IN | GPIO_GPIO),
+};
+#endif
+
+static int __init board_irq_mng_init(void)
+{
+#ifdef CONFIG_MACH_APF27
+	int ret;
+
+	ret = mxc_gpio_setup_multiple_pins(fpga_pins, ARRAY_SIZE(fpga_pins), "FPGA");
+	if (ret)
+		return -EINVAL;
+#endif
+	set_irq_type(ARMADEUS_FPGA_IRQ, IRQ_TYPE_EDGE_RISING);
+
+	return platform_device_register(&irq_mng0_device);
+}
+
+static void __exit board_irq_mng_exit(void)
+{
+	platform_device_unregister(&irq_mng0_device);
+#ifdef CONFIG_MACH_APF27
+	mxc_gpio_release_multiple_pins(fpga_pins, ARRAY_SIZE(fpga_pins));
+#endif
+}
+
+module_init(board_irq_mng_init);
+module_exit(board_irq_mng_exit);
+
+MODULE_AUTHOR("Julien Boibessot <julien.boibessot@armadeus.com>");
+MODULE_DESCRIPTION("Platform data for IRQ manager IP driver");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/uarts/16750.c linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/uarts/16750.c
--- linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/uarts/16750.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/uarts/16750.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,139 @@
+/*
+ * Platform data for OpenCore 16750 2x serial IP
+ * loaded in FPGA of the Armadeus boards.
+ *
+ * (C) Copyright 2008-2011 ARMadeus Systems
+ * Author: Julien Boibessot <julien.boibessot@armadeus.com>
+ *
+ * Inspired from Au1x00 Init from Pantelis Antoniou
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/serial_8250.h>
+
+#include <asm/io.h>
+#ifndef CONFIG_MACH_APF9328 /* To remove when MX1 platform is merged */
+#include <mach/fpga.h>
+#endif
+
+#define GSM_UART_INPUT_CLOCK   96000000
+#define GSM_UART_BASE  0x20
+#define GSM_UART_IRQ   IRQ_FPGA(0)
+
+#define GPS_UART_INPUT_CLOCK   96000000
+#define GPS_UART_BASE  0x40
+#define GPS_UART_IRQ   IRQ_FPGA(1)
+
+
+void plat_uart_release(struct device *dev)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30) 
+	pr_debug("device %s released\n", dev->bus_id);
+#else
+	pr_debug("device %s released\n", dev->init_name);
+#endif
+}
+
+static struct plat_serial8250_port ocore_16750_uart0_data[] = {
+	{
+		.mapbase  = ARMADEUS_FPGA_BASE_ADDR + GSM_UART_BASE,
+		.irq      = IRQ_FPGA(0),
+		.uartclk  = 96000000,
+		.regshift = 1,
+		.iotype   = UPIO_MEM,
+		.flags    = UPF_BOOT_AUTOCONF
+	},
+	{ }
+};
+
+static struct plat_serial8250_port ocore_16750_uart1_data[] = {
+	{
+		.mapbase  = ARMADEUS_FPGA_BASE_ADDR + GPS_UART_BASE,
+		.irq      = IRQ_FPGA(1),
+		.uartclk  = 96000000,
+		.regshift = 1,
+		.iotype   = UPIO_MEM,
+		.flags    = UPF_BOOT_AUTOCONF
+	},
+	{ }
+};
+
+static struct platform_device ocore_16750_uart0_device = {
+	.name	= "serial8250",
+	.id	= 0,
+	.dev	= {
+		.release	= plat_uart_release,
+		.platform_data	= ocore_16750_uart0_data,
+	},
+};
+
+static struct platform_device ocore_16750_uart1_device = {
+	.name	= "serial8250",
+	.id	= 1,
+	.dev	= {
+		.release	= plat_uart_release,
+		.platform_data	= ocore_16750_uart1_data,
+	},
+};
+
+static struct platform_device *ocore_16750_uart_devices[] = {
+	&ocore_16750_uart0_device,
+	&ocore_16750_uart1_device,
+};
+
+static int __init ocore_16750_init(void)
+{
+	int ret = -ENODEV;
+	u16 id;
+
+	ocore_16750_uart0_data[0].membase = ioremap(ocore_16750_uart0_data[0].mapbase, 0x20);
+	if (!ocore_16750_uart0_data[0].membase) {
+		printk(KERN_ERR "%s: ioremap failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	/* check if ID is correct for GSM_UART */
+	id = readw(ocore_16750_uart0_data[0].membase + 0x08*2);
+	if (id != 2) {
+		printk(KERN_WARNING "For GSM_UART id:2 doesn't match with "
+			   "id read %d,\n is device present ?\n", id);
+		return -ENODEV;
+	}
+
+	ocore_16750_uart1_data[0].membase = ioremap(ocore_16750_uart1_data[0].mapbase, 0x20);
+	if (!ocore_16750_uart1_data[0].membase) {
+		printk(KERN_ERR "%s: ioremap failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	/* check if ID is correct for GPS_UART */
+	id = readw(ocore_16750_uart1_data[0].membase + 0x08*2);
+	if (id != 3) {
+		printk(KERN_WARNING "For GPS_UART id:3 doesn't match with "
+			   "id read %d,\n is device present ?\n", id);
+		return -ENODEV;
+	}
+
+	ret = platform_add_devices(ocore_16750_uart_devices, ARRAY_SIZE(ocore_16750_uart_devices));
+
+	return ret;
+}
+
+static void __exit ocore_16750_exit(void)
+{
+	platform_device_unregister(&ocore_16750_uart0_device);
+	platform_device_unregister(&ocore_16750_uart1_device);
+}
+
+module_init(ocore_16750_init);
+module_exit(ocore_16750_exit);
+
+MODULE_AUTHOR("Julien Boibessot, <julien.boibessot@armadeus.com>");
+MODULE_DESCRIPTION("Platform data for 16750 OpenCore IP in Armadeus FPGA");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/uarts/Kconfig linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/uarts/Kconfig
--- linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/uarts/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/uarts/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,11 @@
+
+config ARMADEUS_FPGA_BOARD_DESIGNS_TWIN_UARTS_UARTS
+	tristate "board twin uarts"
+	default n
+	depends on ARMADEUS_FPGA_BOARD_DESIGNS_TWIN_UARTS
+	select SERIAL_8250
+	---help---
+	  Board support for fpga designs twin uarts used
+	  for gsm/gps on apf51Dev board.
+		If selected as module, it will be named :
+		twin_uarts_16750
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/uarts/Makefile linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/uarts/Makefile
--- linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/uarts/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/twin_uart/uarts/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,4 @@
+
+obj-$(CONFIG_ARMADEUS_FPGA_BOARD_DESIGNS_TWIN_UARTS_UARTS) += twin_uarts_16750.o
+twin_uarts_16750-objs := 16750.o
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/Kconfig linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/Kconfig
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,18 @@
+
+#
+# Armadeus custom linux-3.13/drivers configuration
+                     
+#
+config ARMADEUS_FPGA_BOARD_DESIGNS_WISHBONE_EXAMPLE
+	boolean "board linux-3.13/drivers for wishbone example"
+	default n
+	depends on ARMADEUS_FPGA_BOARD_DESIGNS
+	select ARMADEUS_FPGA_VIRTUAL_COMPONENTS
+	---help---
+	  Drivers used for wishbone example design that can be
+	  found in firmware/wishbone_example/
+
+source "drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/Kconfig"
+source "drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/Kconfig"
+source "drivers/armadeus/fpga/board_designs/wishbone_example/wb_irq_mngr/Kconfig"
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/Makefile linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/Makefile
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,25 @@
+#
+# Main Makefile for the Armadeus FPGA related linux-3.13/drivers
+#
+# Add your subdirectories to obj- target
+#
+
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+# Part executed when called from kernel build system:
+obj-$(CONFIG_ARMADEUS_FPGA_BOARD_DESIGNS_WISHBONE_EXAMPLE) +=  wb_button/ wb_irq_mngr/ wb_led/
+
+else
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+ARMADEUS_BASE_DIR=../../../../../../
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+install:
+	echo "Installing Armadeus linux-3.13/drivers..."
+	$(MAKE) -C $(LINUX_DIR) SUBDIRS=$(PWD) INSTALL_MOD_PATH=$(TARGET_DIR) linux-3.13/drivers/armadeus_install
+
+test:
+	$(ARMADEUS_TOOLCHAIN_PATH)/arm-linux-gcc push-led.c -o push-led 
+
+endif
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/push-led.c linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/push-led.c
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/push-led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/push-led.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,98 @@
+/* Enable or disable led when button is pressed
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ * 9 mars 2009
+ * fpgaaccess.h
+ *
+ * (c) Copyright 2008    Armadeus project
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ *
+ * A simple driver for reading and writing on
+ * fpga throught a character file /dev/fpgaaccess
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ **********************************************************************
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* file management */
+#include <sys/stat.h>
+#include <fcntl.h>
+
+/* as name said */
+#include <signal.h>
+
+/* sleep */
+#include <unistd.h>
+
+int fbutton;
+int fled;
+
+void quit(int pouet){
+  close(fbutton);
+  close(fled);
+  exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+  unsigned short i,j;
+
+  /* quit when Ctrl-C pressed */
+  signal(SIGINT, quit);
+
+  j=0;
+
+  printf( "Blink a led pushing button\n" );
+
+  if(argc < 3){
+    perror("invalid arguments number\npush-led <button_filename> <led_filename>\n");
+    exit(EXIT_FAILURE);
+  }
+
+
+  while(1){
+
+    fbutton=open(argv[1],O_RDWR);
+    if(fbutton<0){
+      perror("can't open button file\n");
+      exit(EXIT_FAILURE);
+    }
+
+    /* read button value */
+    if(read(fbutton,&j,1)<0){
+      perror("read error\n");
+      exit(EXIT_FAILURE);
+    }
+
+    /* write led value */
+    fled=open(argv[2],O_RDWR);
+    if(fbutton<0){
+      perror("can't open led file\n");
+      exit(EXIT_FAILURE);
+    }
+    
+    if(write(fled,&j,2)<=0){
+    	perror("LED write error\n");
+    	exit(EXIT_FAILURE);
+    }
+    close(fled);
+    close(fbutton);
+  }
+
+  exit(0);
+}
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/.gitignore linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/.gitignore
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/.gitignore	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/.gitignore	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1 @@
+testbutton
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/Kconfig linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/Kconfig
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,9 @@
+#
+#
+
+config ARMADEUS_FPGA_BOARD_DESIGNS_WISHBONE_EXAMPLE_BUTTON_DRIVER
+	tristate "board Button"
+	default n
+	depends on ARMADEUS_FPGA_BOARD_DESIGNS_WISHBONE_EXAMPLE
+	select ARMADEUS_FPGA_VIRTUAL_COMPONENTS_BUTTON
+	---help---
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/Makefile linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/Makefile
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,21 @@
+#
+# Makefile for the Armadeus Wb_button linux-3.13/drivers
+#
+
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_ARMADEUS_FPGA_BOARD_DESIGNS_WISHBONE_EXAMPLE_BUTTON_DRIVER) += wb_example_buttons.o
+wb_example_buttons-objs := board_buttons.o
+else
+
+ARMADEUS_BASE_DIR=../../../../../../../
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR := $(ARMADEUS_LINUX_DIR)
+PWD  := $(shell pwd)
+
+test:
+	$(ARMADEUS_TOOLCHAIN_PATH)/arm-linux-gcc testbutton.c -o testbutton
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/board_buttons.c linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/board_buttons.c
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/board_buttons.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/board_buttons.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,90 @@
+/*
+ * Platform data for generic button IP driver
+ *
+ * (c) Copyright 2008-2011    The Armadeus Project - ARMadeus Systems
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+#ifdef CONFIG_MACH_APF9328 /* To remove when MX1 platform is merged */
+# include "../arch/arm/plat-mxc/include/mach/fpga.h"
+# include <mach/irqs.h>
+#else
+# include <mach/fpga.h>
+#endif
+
+#include "../../../virtual_components/button/button.h"
+
+#define BUTTON0_IRQ   IRQ_FPGA(0)
+
+static struct resource button0_resources[] = {
+	[0] = {
+		.start	= ARMADEUS_FPGA_BASE_ADDR + 0xc,
+		.end	= ARMADEUS_FPGA_BASE_ADDR + 0xc + (4 -1),
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= BUTTON0_IRQ,
+		.end	= BUTTON0_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static struct plat_button_port plat_button0_data = {
+	.name		= "BUTTON0",
+	.num		= 0,
+	.idnum		= 3,
+	.idoffset	= 0x00 * (16 / 8)
+};
+
+void plat_button_release(struct device *dev)
+{
+	dev_dbg(dev, "released\n");
+}
+
+static struct platform_device plat_button0_device = {
+	.name		= "button",
+	.id		= 0,
+	.dev		= {
+		.release	= plat_button_release,
+		.platform_data	= &plat_button0_data
+	},
+	.num_resources	= ARRAY_SIZE(button0_resources),
+	.resource	= button0_resources,
+};
+
+static int __init board_button_init(void)
+{
+	return platform_device_register(&plat_button0_device);
+}
+
+static void __exit board_button_exit(void)
+{
+	platform_device_unregister(&plat_button0_device);
+}
+
+module_init(board_button_init);
+module_exit(board_button_exit);
+
+MODULE_AUTHOR("Fabien Marteau <fabien.marteau@armadeus.com>");
+MODULE_DESCRIPTION("Board specific button driver");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/testbutton.c linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/testbutton.c
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/testbutton.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_button/testbutton.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,85 @@
+/* 
+ * A simple program to test Wishbone button driver
+ *
+ * (c) Copyright 2008    Armadeus project
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ **********************************************************************
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* file management */
+#include <sys/stat.h>
+#include <fcntl.h>
+
+/* as name said */
+#include <signal.h>
+
+/* sleep */
+#include <unistd.h>
+
+int fbutton;
+
+void quit(int pouet) {
+  close(fbutton);
+  exit(0);
+}
+
+void usage(char *exe) {
+  if (exe) {
+    printf("\nUsage:\n");
+    printf("%s <button_device>\n", exe);
+  }
+}
+
+int main(int argc, char *argv[])
+{
+  unsigned short i, j=0;
+
+  /* quit when Ctrl-C pressed */
+  signal(SIGINT, quit);
+
+  printf( "Testing button driver\n" );
+
+  if (argc < 2) {
+    printf("invalid arguments number\n");
+    usage(argv[0]);
+    exit(EXIT_FAILURE);
+  }
+
+  while (1) {
+    fbutton = open(argv[1], O_RDWR);
+    if (fbutton < 0) {
+      perror("can't open file");
+      exit(EXIT_FAILURE);
+    }
+
+    /* read value */
+    if (read(fbutton, &j, 1) < 0) {
+      perror("read error");
+      exit(EXIT_FAILURE);
+    }
+    printf("Read %d\n",j);
+
+    close(fbutton);
+  }
+
+  exit(0);
+}
+
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_irq_mngr/Kconfig linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_irq_mngr/Kconfig
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_irq_mngr/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_irq_mngr/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,14 @@
+
+#
+# Armadeus custom linux-3.13/drivers configuration
+#
+#
+
+#
+config ARMADEUS_FPGA_BOARD_DESIGNS_WISHBONE_EXAMPLE_IRQ_MNGR_DRIVER
+	tristate "board irq"
+	default n
+	depends on ARMADEUS_FPGA_BOARD_DESIGNS_WISHBONE_EXAMPLE
+	select ARMADEUS_FPGA_VIRTUAL_COMPONENTS_IRQ_MNGR
+	---help---
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_irq_mngr/Makefile linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_irq_mngr/Makefile
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_irq_mngr/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_irq_mngr/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,24 @@
+#
+# Makefile for the Armadeus FPGA OpenCore IRQ manager IP
+#
+
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+# Part executed when called from kernel build system:
+
+obj-$(CONFIG_ARMADEUS_FPGA_BOARD_DESIGNS_WISHBONE_EXAMPLE_IRQ_MNGR_DRIVER) += wb_example_irq_mngr.o
+wb_example_irq_mngr-objs := board_irq_mng.o
+
+else
+
+ARMADEUS_BASE_DIR=../../../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR := $(ARMADEUS_LINUX_DIR)
+PWD  := $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../../../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_irq_mngr/board_irq_mng.c linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_irq_mngr/board_irq_mng.c
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_irq_mngr/board_irq_mng.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_irq_mngr/board_irq_mng.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,116 @@
+/*
+ * Platform data for IRQ manager generic driver
+ *
+ * (c) Copyright 2011    The Armadeus Project - ARMadeus Systems
+ * Author: Julien Boibessot <julien.boibessot@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <mach/hardware.h>
+#ifdef CONFIG_MACH_APF9328 /* To remove when MX1 platform is merged */
+# include "../arch/arm/plat-mxc/include/mach/fpga.h"
+# include <mach/irqs.h>
+#else
+# include <mach/fpga.h>
+#endif
+
+#include "../../../virtual_components/irq_mngr/irq_mng.h"
+
+static struct resource irq_mng0_resources[] = {
+	[0] = {
+		.start	= ARMADEUS_FPGA_BASE_ADDR + 0x0,
+		.end	= ARMADEUS_FPGA_BASE_ADDR + 0x0 + (8 - 1),
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 0,	/* Filled later in */
+		.end	= 0,	/* Filled later in */
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static struct ocore_irq_mng_pdata irq_mng0_data = {
+	.num		= 0,
+	.idnum		= 0x01,
+	.idoffset	= 0x06,
+};
+
+void irq_mng0_release(struct device *dev)
+{
+	dev_dbg(dev, "released\n");
+}
+
+static struct platform_device irq_mng0_device = {
+	.name		= "ocore_irq_mng",
+	.id		= 0,
+	.dev		= {
+		.release	= irq_mng0_release,
+		.platform_data	= &irq_mng0_data
+	},
+	.num_resources	= ARRAY_SIZE(irq_mng0_resources),
+	.resource	= irq_mng0_resources,
+};
+
+#ifdef CONFIG_MACH_APF27
+static int fpga_pins[] = {
+	(APF27_FPGA_INT_PIN | GPIO_IN | GPIO_GPIO),
+};
+#endif
+
+static int __init board_irq_mng_init(void)
+{
+#ifdef CONFIG_MACH_APF27
+	int ret;
+
+	ret = mxc_gpio_setup_multiple_pins(fpga_pins, ARRAY_SIZE(fpga_pins), "FPGA");
+	if (ret)
+		return -EINVAL;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+	set_irq_type(ARMADEUS_FPGA_IRQ, IRQ_TYPE_EDGE_RISING);
+#else
+	irq_set_irq_type(ARMADEUS_FPGA_IRQ, IRQ_TYPE_EDGE_RISING);
+#endif
+	irq_mng0_device.resource[1].start = ARMADEUS_FPGA_IRQ;
+	irq_mng0_device.resource[1].end = ARMADEUS_FPGA_IRQ;
+
+	return platform_device_register(&irq_mng0_device);
+}
+
+static void __exit board_irq_mng_exit(void)
+{
+	platform_device_unregister(&irq_mng0_device);
+#ifdef CONFIG_MACH_APF27
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+	mxc_gpio_release_multiple_pins(fpga_pins, ARRAY_SIZE(fpga_pins));
+        /* see https://github.com/torvalds/linux/commit/581f84e24b45ab871ae5f15f9290261c7226ffa9 */
+# endif
+#endif
+}
+
+module_init(board_irq_mng_init);
+module_exit(board_irq_mng_exit);
+
+MODULE_AUTHOR("Julien Boibessot <julien.boibessot@armadeus.com>");
+MODULE_DESCRIPTION("Platform data for IRQ manager IP driver");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/Kconfig linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/Kconfig
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,8 @@
+
+config ARMADEUS_FPGA_BOARD_DESIGNS_WISHBONE_EXAMPLE_LED_DRIVER
+	tristate "board Led"
+	default n
+	depends on ARMADEUS_FPGA_BOARD_DESIGNS_WISHBONE_EXAMPLE
+	select ARMADEUS_FPGA_VIRTUAL_COMPONENTS_LED
+	---help---
+	  blink a led
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/Makefile linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/Makefile
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,23 @@
+#
+# Makefile for the Armadeus FPGA led driver
+#
+
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_ARMADEUS_FPGA_BOARD_DESIGNS_WISHBONE_EXAMPLE_LED_DRIVER) += wb_example_led.o
+wb_example_led-objs := board_leds.o
+
+else
+
+ARMADEUS_BASE_DIR=../../../../../../../
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR := $(ARMADEUS_LINUX_DIR)
+PWD  := $(shell pwd)
+
+test:
+	$(ARMADEUS_TOOLCHAIN_PATH)/arm-linux-gcc -Wall testled.c -o testled
+	chmod 755 testled
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/board_leds.c linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/board_leds.c
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/board_leds.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/board_leds.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,82 @@
+/*
+ * Platform data for generic LED IP driver
+ *
+ * (c) Copyright 2008-2011 The Armadeus Project - ARMadeus Systems
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#ifdef CONFIG_MACH_APF9328 /* To remove when MX1 platform is merged */
+# include "../arch/arm/plat-mxc/include/mach/fpga.h"
+# include <mach/irqs.h>
+#else
+# include <mach/fpga.h>
+#endif
+
+#include "../../../virtual_components/led/led.h"
+
+static struct resource led0_resources[] = {
+	[0] = {
+		.start	= ARMADEUS_FPGA_BASE_ADDR + 0x8,
+		.end	= ARMADEUS_FPGA_BASE_ADDR + 0x8 + (4 - 1),
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct plat_led_port plat_led0_data = {
+	.name		= "LED0",
+	.num		= 0,
+	.idnum		= 2,
+	.idoffset	= 0x01 * (16 / 8),
+};
+
+void plat_led_release(struct device *dev)
+{
+	dev_dbg(dev, "released\n");
+}
+
+static struct platform_device plat_led0_device = {
+	.name	= "led",
+	.id	= 0,
+	.dev	= {
+		.release	= plat_led_release,
+		.platform_data	= &plat_led0_data
+	},
+	.num_resources	= ARRAY_SIZE(led0_resources),
+	.resource	= led0_resources,
+};
+
+static int __init sled_init(void)
+{
+	return platform_device_register(&plat_led0_device);
+}
+
+static void __exit sled_exit(void)
+{
+	platform_device_unregister(&plat_led0_device);
+}
+
+module_init(sled_init);
+module_exit(sled_exit);
+
+MODULE_AUTHOR("Fabien Marteau <fabien.marteau@armadeus.com>");
+MODULE_DESCRIPTION("Driver to blink some LEDs on FPGA");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/testled.c linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/testled.c
--- linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/testled.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/board_designs/wishbone_example/wb_led/testled.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,133 @@
+/* a program to test led driver
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ * 7 april 2008
+ * fpgaaccess.h
+ *
+ * (c) Copyright 2008    Armadeus project
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ *
+ * A simple driver for reading and writing on
+ * fpga throught a character file /dev/fpgaaccess
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ **********************************************************************
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* file management */
+#include <sys/stat.h>
+#include <fcntl.h>
+
+/* as name said */
+#include <signal.h>
+
+/* sleep */
+#include <unistd.h>
+
+int fled;
+
+void quit(int pouet){
+    close(fled);
+    exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+    unsigned short i,j;
+
+    /* quit when Ctrl-C pressed */
+    signal(SIGINT, quit);
+
+    j=0;
+
+    printf( "Testing led driver\n" );
+
+    if(argc < 2){
+        perror("invalid arguments number\ntestled <led_filename>\n");
+        exit(EXIT_FAILURE);
+    }
+
+    while(1){
+        i = (i==0)?1:0;
+        fflush(stdout);
+
+        fled=open(argv[1],O_RDWR);
+        if(fled<0){
+            perror("can't open file \n");
+            exit(EXIT_FAILURE);
+        }
+
+        /* read value */
+        if(read(fled,&j,2)<0){
+            perror("read error\n");
+            exit(EXIT_FAILURE);
+        }
+        printf("Read %d\n",j);
+        close(fled);
+        sleep(1);
+
+        fled=open(argv[1],O_RDWR);
+        if(fled<0){
+            perror("can't open file \n");
+            exit(EXIT_FAILURE);
+        }
+
+        /* write value */
+        j = 0;
+        if(write(fled,&j,2)<=0){
+            perror("write error\n");
+            exit(EXIT_FAILURE);
+        }
+        close(fled);
+        printf("Write 0\n");
+        sleep(1);
+
+        fled=open(argv[1],O_RDWR);
+        if(fled<0){
+            perror("can't open file \n");
+            exit(EXIT_FAILURE);
+        }
+        /* read value */
+        if(read(fled,&j,2)<0){
+            perror("read error\n");
+            exit(EXIT_FAILURE);
+        }
+        close(fled);
+        printf("Read %d\n",j);
+        sleep(1);
+
+        fled=open(argv[1],O_RDWR);
+        if(fled<0){
+            perror("can't open file \n");
+            exit(EXIT_FAILURE);
+        }
+        /* write value */
+        j = 1;
+        if(write(fled,&j,2)<=0){
+            perror("write error\n");
+            exit(EXIT_FAILURE);
+        }
+        close(fled);
+        printf("Write 1\n");
+        sleep(1);
+
+    }
+
+    close(fled);
+    exit(0);
+}
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/Kconfig linux-3.13/drivers/armadeus/fpga/dev_tools/Kconfig
--- linux-3.13/drivers/armadeus/fpga/dev_tools/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,8 @@
+#
+# FPGA devt linux-3.13/drivers configuration
+#
+
+comment "Drivers for configuring and testing the FPGA"
+	depends on ARMADEUS_FPGA_DRIVERS
+	
+source "drivers/armadeus/fpga/dev_tools/loader/Kconfig"
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/Makefile linux-3.13/drivers/armadeus/fpga/dev_tools/Makefile
--- linux-3.13/drivers/armadeus/fpga/dev_tools/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,33 @@
+#
+# Main Makefile for the Armadeus FPGA related linux-3.13/drivers
+#
+# Add your subdirectories to obj- target
+#
+
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+# Part executed when called from kernel build system:
+
+obj-$(CONFIG_ARMADEUS_FPGA_DRIVERS) += loader/
+
+else
+
+# Part executed when called from standard make in this directory:
+
+ARMADEUS_BASE_DIR=../../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+ifeq ($(LINUX_DIR),)
+LINUX_DIR:=$(ARMADEUS_LINUX_DIR)
+endif
+PWD:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../../Makefile.in
+
+install:
+	echo "Installing Armadeus linux-3.13/drivers..."
+	 $(MAKE) -C $(LINUX_DIR) SUBDIRS=$(PWD) INSTALL_MOD_PATH=$(TARGET_DIR) linux-3.13/drivers/armadeus_install
+    
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/loader/Kconfig linux-3.13/drivers/armadeus/fpga/dev_tools/loader/Kconfig
--- linux-3.13/drivers/armadeus/fpga/dev_tools/loader/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/loader/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,11 @@
+#
+
+#
+config ARMADEUS_FPGA_LOADER_DRIVER
+        tristate "Armadeus FPGA configuration driver (= loader)"
+        default n
+        depends on ARMADEUS_FPGA_DRIVERS
+        ---help---
+	  With this driver you will be able to (re)load the configuration
+	  of your FPGA directly from Linux userspace.
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/loader/Makefile linux-3.13/drivers/armadeus/fpga/dev_tools/loader/Makefile
--- linux-3.13/drivers/armadeus/fpga/dev_tools/loader/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/loader/Makefile	2013-11-24 11:31:17.000000000 +0100
@@ -0,0 +1,40 @@
+#
+# Makefile for the Armadeus FPGA loader driver
+#
+
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_ARMADEUS_FPGA_LOADER_DRIVER)	+= fpgaloader.o
+fpgaloader-objs := xilinx-fpga-loader.o fpga-loader.o
+ifneq ($(CONFIG_DTC),)
+ifneq ($(CONFIG_MACH_MX27),)
+obj-y += apf27-fpga-loader.o
+endif
+ifneq ($(CONFIG_MACH_IMX51_DT),)
+obj-y += apf51-fpga-loader.o
+endif
+else
+ifneq ($(CONFIG_MACH_APF51),)
+obj-y += apf51-fpga-loader.o
+endif
+ifneq ($(CONFIG_MACH_APF27),)
+obj-y += apf27-fpga-loader.o
+endif
+ifneq ($(CONFIG_MACH_APF9328),)
+obj-y += apf9328-fpga-loader.o
+endif
+endif # 
+
+else
+
+ARMADEUS_BASE_DIR=../../../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../../../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/loader/apf27-fpga-loader.c linux-3.13/drivers/armadeus/fpga/dev_tools/loader/apf27-fpga-loader.c
--- linux-3.13/drivers/armadeus/fpga/dev_tools/loader/apf27-fpga-loader.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/loader/apf27-fpga-loader.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,258 @@
+/*
+ * APF27 Xilinx FPGA download support
+ * Copyright (C) 2009 Nicolas Colombain <nicolas.colombain@armadeus.com>
+ *                    Armadeus Project / Armadeus systems
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+#include <mach/iomux-mx1-mx2.h>
+#else
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,20)
+#include <mach/iomux-mx27.h>
+#else
+#include <linux/../../arch/arm/mach-imx/iomux-mx27.h>
+#endif
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+#include <mach/gpio.h>
+#else
+#include <linux/gpio.h>
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,7,20)
+#include <linux/../../arch/arm/mach-imx/fpga.h>
+#else
+#include <mach/fpga.h>
+#endif
+
+#include "xilinx-fpga-loader.h"
+
+#define CFG_FPGA_PWR		(GPIO_PORTF | 19)	/* FPGA prog pin  */
+#define CFG_FPGA_PRG		(GPIO_PORTF | 11)	/* FPGA prog pin  */
+#define CFG_FPGA_CLK		(GPIO_PORTF | 15)	/* FPGA clk pin   */
+#define CFG_FPGA_INIT		(GPIO_PORTF | 12)	/* FPGA init pin  */
+#define CFG_FPGA_DONE		(GPIO_PORTF |  9)	/* FPGA done pin  */
+#define CFG_FPGA_RW		(GPIO_PORTF | 21)	/* FPGA done pin  */
+#define CFG_FPGA_CS		(GPIO_PORTF | 22)	/* FPGA done pin  */
+#define CFG_FPGA_SUSPEND	(GPIO_PORTF | 10)	/* FPGA done pin  */
+#define CFG_FPGA_RESET		(GPIO_PORTF |  7)	/* FPGA done pin  */
+
+void *fpga_membase;
+
+static int fpga_shared_pins[] = {
+	(CFG_FPGA_INIT | GPIO_IN | GPIO_PUEN | GPIO_GPIO),
+};
+
+/* Initialize GPIO port before download */
+int apf27_fpga_pre(void)
+{
+	int res = 0;
+
+	fpga_membase = ioremap(ARMADEUS_FPGA_BASE_ADDR, 16);
+	if (!fpga_membase) {
+		printk(KERN_ERR "ioremap failed\n");
+		return -ENOMEM;
+	}
+
+	/* initialize common gpio "shared" with other apps */
+	res =
+	    mxc_gpio_setup_multiple_pins(fpga_shared_pins,
+					 ARRAY_SIZE(fpga_shared_pins),
+					 "FPGA_LOADER");
+	if (res) {
+		printk(KERN_ERR "FPGA prog pins already reserved !!\n");
+		iounmap(fpga_membase);
+		return res;
+	}
+
+	mxc_gpio_mode(CFG_FPGA_CLK | GPIO_OUT | GPIO_PUEN | GPIO_GPIO);
+	mxc_gpio_mode(CFG_FPGA_RW | GPIO_OUT | GPIO_PUEN | GPIO_GPIO);
+	mxc_gpio_mode(CFG_FPGA_CS | GPIO_OUT | GPIO_PUEN | GPIO_GPIO);
+
+	/* power off fpga */
+	gpio_set_value(CFG_FPGA_PWR, 1);
+	mxc_gpio_mode(CFG_FPGA_PWR | GPIO_OUT | GPIO_PUEN | GPIO_GPIO);
+	mdelay(10);
+
+	gpio_set_value(CFG_FPGA_PRG, 1);
+	gpio_set_value(CFG_FPGA_CLK, 1);
+	gpio_set_value(CFG_FPGA_RW, 1);
+	gpio_set_value(CFG_FPGA_CS, 1);
+	gpio_set_value(CFG_FPGA_SUSPEND, 0);
+	gpio_set_value(CFG_FPGA_RESET, 0);
+
+	/* Initialize specific GPIO pins */
+	mxc_gpio_mode(CFG_FPGA_DONE | GPIO_IN | GPIO_PUEN | GPIO_GPIO);
+	mxc_gpio_mode(CFG_FPGA_PRG | GPIO_OUT | GPIO_PUEN | GPIO_GPIO);
+	mxc_gpio_mode(CFG_FPGA_SUSPEND | GPIO_OUT | GPIO_PUEN | GPIO_GPIO);
+
+	/* make sure the reset pin is active due to DLL start up */
+	mxc_gpio_mode(CFG_FPGA_RESET | GPIO_OUT | GPIO_PUEN | GPIO_GPIO);
+	gpio_set_value(CFG_FPGA_RESET, 1);
+
+	/* make sure the fpga is powered */
+	gpio_set_value(CFG_FPGA_PWR, 0);
+
+	return res;
+}
+
+/*
+ * Set the FPGA's active-low program line to the specified level
+ */
+int apf27_fpga_pgm(int assert)
+{
+	gpio_set_value(CFG_FPGA_PRG, !assert);
+
+	return assert;
+}
+
+/*
+ * Set the FPGA's active-high clock line to the specified level
+ */
+int apf27_fpga_clk(int assert_clk)
+{
+	gpio_set_value(CFG_FPGA_CLK, !assert_clk);
+
+	return assert_clk;
+}
+
+/*
+ * Test the state of the active-low FPGA INIT line.  Return 1 on INIT
+ * asserted (low).
+ */
+int apf27_fpga_init(void)
+{
+	int value;
+
+	value = gpio_get_value(CFG_FPGA_INIT);
+
+	return !value;
+}
+
+/*
+ * Test the state of the active-high FPGA DONE pin
+ */
+int apf27_fpga_done(void)
+{
+	return gpio_get_value(CFG_FPGA_DONE);
+}
+
+/*
+ * Set the FPGA's wr line to the specified level
+ */
+int apf27_fpga_wr(int assert_write)
+{
+	gpio_set_value(CFG_FPGA_RW, !assert_write);
+
+	return assert_write;
+}
+
+int apf27_fpga_cs(int assert_cs)
+{
+	gpio_set_value(CFG_FPGA_CS, !assert_cs);
+
+	return assert_cs;
+}
+
+int apf27_fpga_wdata(unsigned char data)
+{
+	__raw_writew(data, fpga_membase);
+
+	return data;
+}
+
+int apf27_fpga_busy(void)
+{
+	return 0;
+}
+
+int apf27_fpga_post(void)
+{
+	iounmap(fpga_membase);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+	mxc_gpio_release_multiple_pins(fpga_shared_pins,
+				       ARRAY_SIZE(fpga_shared_pins));
+	/* see https://github.com/torvalds/linux/commit/581f84e24b45ab871ae5f15f9290261c7226ffa9 */
+#endif
+	/* reconfigure bus ctrl signals */
+	mxc_gpio_mode(CFG_FPGA_RW | GPIO_PF | GPIO_PUEN);
+	mxc_gpio_mode(CFG_FPGA_CS | GPIO_PF | GPIO_PUEN);
+	mxc_gpio_mode(CFG_FPGA_CLK | GPIO_PF | GPIO_PUEN);
+	/* end of prog */
+	gpio_set_value(CFG_FPGA_PRG, 1);
+	/* reset off */
+	gpio_set_value(CFG_FPGA_RESET, 0);
+	mxc_gpio_mode(CFG_FPGA_RESET | GPIO_OUT | GPIO_PUEN | GPIO_GPIO);
+
+	return 0;
+}
+
+int apf27_fpga_abort(void)
+{
+	apf27_fpga_post();
+	gpio_set_value(CFG_FPGA_PWR, 1);
+
+	return 1;
+}
+
+/* Spartan2 code is used to download our Spartan 3: code is compatible.
+ * Just take care about the file size
+ */
+Xilinx_Spartan3_Slave_Parallel_fns fpga_fns = {
+	.pre = apf27_fpga_pre,
+	.pgm = apf27_fpga_pgm,
+	.clk = apf27_fpga_clk,
+	.init = apf27_fpga_init,
+	.done = apf27_fpga_done,
+	.wr = apf27_fpga_wr,
+	.cs = apf27_fpga_cs,
+	.wdata = apf27_fpga_wdata,
+	.busy = apf27_fpga_busy,
+	.abort = apf27_fpga_abort,
+	.post = apf27_fpga_post,
+};
+
+struct fpga_desc apf27_fpga_desc = {
+	.family = Xilinx_Spartan,
+	.iface = slave_parallel,
+	.iface_fns = (void *)&fpga_fns
+};
+
+static struct platform_device fpga_device = {
+	.name = "fpgaloader",
+	.id = 0,
+	.dev = {
+		.platform_data = &apf27_fpga_desc,
+	},
+};
+
+static struct platform_device *devices[] __initdata = {
+	&fpga_device,
+};
+
+static int __init apf27_fpga_initialize(void)
+{
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+
+	return 0;
+}
+
+device_initcall(apf27_fpga_initialize);
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/loader/apf51-fpga-loader.c linux-3.13/drivers/armadeus/fpga/dev_tools/loader/apf51-fpga-loader.c
--- linux-3.13/drivers/armadeus/fpga/dev_tools/loader/apf51-fpga-loader.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/loader/apf51-fpga-loader.c	2013-11-24 13:07:26.000000000 +0100
@@ -0,0 +1,250 @@
+/*
+ * APF51 Xilinx FPGA download support
+ * Copyright (C) 2011 Nicolas Colombain <nicolas.colombain@armadeus.com>
+ *                    Armadeus Project / Armadeus systems
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <asm/io.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,20)
+#include <mach/iomux-mx51.h>
+#include <mach/fpga.h>
+#include <mach/hardware.h>
+#else
+#include <linux/../../arch/arm/mach-imx/iomux-mx51.h>
+#include <linux/../../arch/arm/mach-imx/fpga.h>
+#include <linux/../../arch/arm/mach-imx/mx51.h>
+#include <linux/../../arch/arm/mach-imx/hardware.h>
+#endif
+
+#include "xilinx-fpga-loader.h"
+
+#define MXC_CCM_CBCDR		0x14
+#define MXC_CS1RCR1_ADDR	0x20
+#define MXC_CS1WCR1_ADDR	0x28
+
+#define	CONFIG_SYS_FPGA_PWR	(2*32 + 3)	/*MX51_PAD_DI1_D0_CS__GPIO3_3 */
+#define	CONFIG_SYS_FPGA_PRG	(3*32 + 9)	/*MX51_PAD_CSI2_D12__GPIO4_9 */
+#define	CONFIG_SYS_FPGA_INIT	(3*32 + 11)	/*MX51_PAD_CSI2_D18__GPIO4_11 */
+#define	CONFIG_SYS_FPGA_DONE	(3*32 + 10)	/*MX51_PAD_CSI2_D13__GPIO4_10 */
+#define	CONFIG_SYS_FPGA_SUSPEND	(2*32 + 6)	/*MX51_PAD_DISPB2_SER_DIO__GPIO3_6 */
+
+u32 temp_clk;			/* use to restore the emi_clk_sel after donwload */
+u32 temp_rcr1;
+u32 temp_wcr1;
+void __iomem *cs1_base;
+
+/* Initialize GPIO port before download */
+int apf51_fpga_pre(void)
+{
+#define EMI_CLK_SEL		1<<26
+
+	temp_rcr1 =
+	    __raw_readl(MX51_IO_ADDRESS(MX51_WEIM_BASE_ADDR) +
+			MXC_CS1RCR1_ADDR);
+	__raw_writel(0x01000010,
+		     MX51_IO_ADDRESS(MX51_WEIM_BASE_ADDR) + MXC_CS1RCR1_ADDR);
+
+	temp_wcr1 =
+	    __raw_readl(MX51_IO_ADDRESS(MX51_WEIM_BASE_ADDR) +
+			MXC_CS1WCR1_ADDR);
+	__raw_writel(0x01000008,
+		     MX51_IO_ADDRESS(MX51_WEIM_BASE_ADDR) + MXC_CS1WCR1_ADDR);
+
+	/* change emi_clk_sel to ensure blck smaller than 50MHz */
+	temp_clk =
+	    __raw_readl(MX51_IO_ADDRESS(MX51_CCM_BASE_ADDR) + MXC_CCM_CBCDR);
+	__raw_writel(temp_clk | EMI_CLK_SEL,
+		     MX51_IO_ADDRESS(MX51_CCM_BASE_ADDR) + MXC_CCM_CBCDR);
+
+	/* FPGA PROG */
+	gpio_direction_output(CONFIG_SYS_FPGA_PRG, 1);
+
+	/* FPGA SUSPEND */
+	gpio_direction_output(CONFIG_SYS_FPGA_SUSPEND, 1);
+
+	/* FPGA DONE */
+	gpio_direction_input(CONFIG_SYS_FPGA_DONE);
+
+	/* FPGA INIT# */
+	gpio_direction_input(CONFIG_SYS_FPGA_INIT);
+
+	/* FPGA PWR */
+	gpio_direction_output(CONFIG_SYS_FPGA_PWR, 1);
+
+	cs1_base = ioremap(MX51_CS1_BASE_ADDR, SZ_4K);
+
+	return 0;
+}
+
+/*
+ * Set the FPGA's active-low program line to the specified level
+ */
+int apf51_fpga_pgm(int assert)
+{
+	gpio_direction_output(CONFIG_SYS_FPGA_PRG, !assert);
+	return assert;
+}
+
+/*
+ * Set the FPGA's active-high clock line to the specified level
+ */
+int apf51_fpga_clk(int assert_clk)
+{
+	return assert_clk;
+}
+
+/*
+ * Test the state of the active-low FPGA INIT line.  Return 1 on INIT
+ * asserted (low).
+ */
+int apf51_fpga_init(void)
+{
+	if (gpio_get_value(CONFIG_SYS_FPGA_INIT))
+		return 0;
+	return 1;
+}
+
+/*
+ * Test the state of the active-high FPGA DONE pin
+ */
+int apf51_fpga_done(void)
+{
+	return gpio_get_value(CONFIG_SYS_FPGA_DONE);
+}
+
+/*
+ * Set the FPGA's wr line to the specified level
+ */
+int apf51_fpga_wr(int assert_write)
+{
+	return assert_write;
+}
+
+int apf51_fpga_cs(int assert_cs)
+{
+	return assert_cs;
+}
+
+int apf51_fpga_wdata(unsigned char data)
+{
+	static u32 temp;
+	static u32 index = 0;
+
+	switch (index++) {
+	case 0:
+		temp = data << 8;
+		break;
+	case 1:
+		temp = temp + data;
+		break;
+	case 2:
+		temp = temp + (data << 24);
+		break;
+	default:
+		__raw_writel(temp + (data << 16), cs1_base);
+		index = 0;
+		break;
+	}
+
+	return data;
+}
+
+int apf51_fpga_busy(void)
+{
+	return 0;
+}
+
+int apf51_fpga_post(void)
+{
+	/* restore emi_clk_sel */
+	__raw_writel(temp_clk,
+		     MX51_IO_ADDRESS(MX51_CCM_BASE_ADDR) + MXC_CCM_CBCDR);
+	udelay(10);
+	__raw_writel(temp_rcr1,
+		     MX51_IO_ADDRESS(MX51_WEIM_BASE_ADDR) + MXC_CS1RCR1_ADDR);
+	__raw_writel(temp_wcr1,
+		     MX51_IO_ADDRESS(MX51_WEIM_BASE_ADDR) + MXC_CS1WCR1_ADDR);
+
+	iounmap(cs1_base);
+
+	return 0;
+}
+
+int apf51_fpga_abort(void)
+{
+	__raw_writel(temp_clk,
+		     MX51_IO_ADDRESS(MX51_CCM_BASE_ADDR) + MXC_CCM_CBCDR);
+	udelay(10);
+	__raw_writel(temp_rcr1,
+		     MX51_IO_ADDRESS(MX51_WEIM_BASE_ADDR) + MXC_CS1RCR1_ADDR);
+	__raw_writel(temp_wcr1,
+		     MX51_IO_ADDRESS(MX51_WEIM_BASE_ADDR) + MXC_CS1WCR1_ADDR);
+
+	iounmap(cs1_base);
+
+	return 1;
+}
+
+/* Spartan2 code is used to download our Spartan 3: code is compatible.
+ * Just take care about the file size
+ */
+Xilinx_Spartan3_Slave_Parallel_fns fpga_fns = {
+	.pre = apf51_fpga_pre,
+	.pgm = apf51_fpga_pgm,
+	.clk = apf51_fpga_clk,
+	.init = apf51_fpga_init,
+	.done = apf51_fpga_done,
+	.wr = apf51_fpga_wr,
+	.cs = apf51_fpga_cs,
+	.wdata = apf51_fpga_wdata,
+	.busy = apf51_fpga_busy,
+	.abort = apf51_fpga_abort,
+	.post = apf51_fpga_post,
+};
+
+struct fpga_desc apf51_fpga_desc = {
+	.family = Xilinx_Spartan,
+	.iface = slave_parallel,
+	.iface_fns = (void *)&fpga_fns
+};
+
+static struct platform_device fpga_device = {
+	.name = "fpgaloader",
+	.id = 0,
+	.dev = {
+		.platform_data = &apf51_fpga_desc,
+	},
+};
+
+static struct platform_device *devices[] __initdata = {
+	&fpga_device,
+};
+
+static int __init apf51_fpga_initialize(void)
+{
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+
+	return 0;
+}
+
+device_initcall(apf51_fpga_initialize);
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/loader/apf9328-fpga-loader.c linux-3.13/drivers/armadeus/fpga/dev_tools/loader/apf9328-fpga-loader.c
--- linux-3.13/drivers/armadeus/fpga/dev_tools/loader/apf9328-fpga-loader.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/loader/apf9328-fpga-loader.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,126 @@
+/*
+ * APF9328 Xilinx FPGA download support
+ * Copyright (C) 2006-2009 Nicolas Colombain <nicolas.colombain@armadeus.com>
+ * Copyright (C) 2006-2009 Eric Jarrige <eric.jarrige@armadeus.com>
+ *                         Armadeus Project / Armadeus systems
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <asm/io.h>
+#include <linux/platform_device.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+
+#include "xilinx-fpga-loader.h"
+
+#define FPGA_INIT	(GPIO_PORTB | 15)	/* FPGA init pin (SSI input)  */
+#define FPGA_DONE	(GPIO_PORTB | 16)	/* FPGA done pin (SSI input)  */
+#define FPGA_DIN	(GPIO_PORTB | 17)	/* FPGA data pin (SSI output) */
+#define FPGA_PROGRAM	(GPIO_PORTB | 18)	/* FPGA prog pin (SSI output) */
+#define FPGA_CLOCK	(GPIO_PORTB | 19)	/* FPGA clk pin  (SSI output) */
+
+
+/*
+ * Set the FPGA's active-low program line to the specified level
+ */
+static int apf9328_fpga_pgm( int assert )
+{
+	gpio_set_value(FPGA_PROGRAM, !assert);
+	return assert;
+}
+
+/*
+ * Set the FPGA's active-high clock line to the specified level
+ */
+static int apf9328_fpga_clk( int assert_clk )
+{
+	gpio_set_value(FPGA_CLOCK, assert_clk);
+	return assert_clk;
+}
+
+/*
+ * Test the state of the active-low FPGA INIT line.  Return 1 on INIT
+ * asserted (low).
+ */
+static int apf9328_fpga_init( void )
+{
+	return(!gpio_get_value(FPGA_INIT));
+}
+
+/*
+ * Test the state of the active-high FPGA DONE pin
+ */
+static int apf9328_fpga_done( void )
+{
+	return(gpio_get_value(FPGA_DONE));
+}
+
+/*
+ * Set the FPGA's data line to the specified level
+ */
+static int apf9328_fpga_wr( int assert_write )
+{
+	gpio_set_value(FPGA_DIN, assert_write);
+	return assert_write;
+}
+
+static int apf9328_fpga_pre( void )
+{
+	/* Initialize GPIO pins */
+	imx_gpio_mode(FPGA_INIT | GPIO_GIUS | GPIO_DR | GPIO_IN);
+	imx_gpio_mode(FPGA_DONE | GPIO_GIUS | GPIO_DR | GPIO_IN);
+	imx_gpio_mode(FPGA_DIN  | GPIO_GIUS | GPIO_DR | GPIO_OUT);
+	imx_gpio_mode(FPGA_PROGRAM | GPIO_GIUS | GPIO_DR | GPIO_OUT);
+	imx_gpio_mode(FPGA_CLOCK | GPIO_GIUS | GPIO_DR | GPIO_OUT);
+	return 1;
+}
+
+
+Xilinx_Spartan_Slave_Serial_fns fpga_fns = {
+	.pre = apf9328_fpga_pre,
+	.pgm = apf9328_fpga_pgm,
+	.clk = apf9328_fpga_clk,
+	.init = apf9328_fpga_init,
+	.done = apf9328_fpga_done,
+	.wr = apf9328_fpga_wr,
+};
+
+struct fpga_desc apf9328_fpga_desc = {
+	.family = Xilinx_Spartan,
+	.iface = slave_serial,
+	.iface_fns = (void *) &fpga_fns
+};
+
+static struct platform_device fpga_device = {
+	.name		= "fpgaloader",
+	.id		= 0,
+	.dev = {
+		.platform_data	= &apf9328_fpga_desc,
+	},
+};
+
+static struct platform_device *devices[] __initdata = {
+	&fpga_device,
+};
+
+static int __init apf9328_fpga_initialize(void)
+{
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+	return 0;
+}
+
+device_initcall(apf9328_fpga_initialize);
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpga-loader.c linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpga-loader.c
--- linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpga-loader.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpga-loader.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,324 @@
+/*
+ * Generic Xilinx FPGA loader
+ *
+ * Copyright (C) 2006-2009 Julien Boibessot <julien.boibessot@armadeus.com>
+ *                         Nicolas Colombain <nicolas.colombain@armadeus.com>
+ *                         Armadeus Project / Armadeus systems
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* #define DEBUG */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+
+#include "xilinx-fpga-loader.h"
+
+
+#define DRIVER_VERSION		"0.92"
+#define DRIVER_NAME		"fpgaloader"
+#define FPGA_PROC_DIRNAME	"driver/fpga"
+#define FPGA_PROC_FILENAME	FPGA_PROC_DIRNAME "/loader"
+#define FPGA_IOCTL 0x10000000   /* !! TO BE BETTER DEFINED !! */
+
+/* global variables */
+struct fpga_desc *g_current_desc = NULL;
+struct semaphore fpga_sema;
+
+static unsigned char fpga_descriptor = 0; /* use default target_fpga_desc */
+module_param(fpga_descriptor, byte, 0);
+
+#define FPGA_BUFFER_SIZE 4096
+static unsigned char g_buffer[FPGA_BUFFER_SIZE];
+static unsigned char g_nb_users = 0;
+
+
+/* Handles write() done on /dev/fpga/loader */
+static ssize_t armadeus_fpga_write(struct file *file, const char* pData, size_t count, loff_t *f_pos)
+{
+	ssize_t ret = 0;
+
+	/* Get exclusive access */
+	if (down_interruptible(&fpga_sema))
+		return -ERESTARTSYS;
+
+	if (count > FPGA_BUFFER_SIZE) {
+		count = FPGA_BUFFER_SIZE;
+	}
+
+	/* Get value to write from user space */
+	ret = __copy_from_user(g_buffer, pData, count);
+	if (ret != 0) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	ret = fpga_load(g_current_desc, g_buffer, count);
+
+out:
+	/* Release exclusive access */
+	up(&fpga_sema);
+
+	return ret;
+}
+
+static int armadeus_fpga_open(struct inode *inode, struct file *file)
+{
+	int ret;
+
+	/* Get exclusive access */
+	if (down_interruptible(&fpga_sema))
+		return -ERESTARTSYS;
+
+	/* Only one access at a time is permitted */
+	if (g_nb_users > 0) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ret = fpga_init_load(g_current_desc);
+	if (!ret) {
+		printk("Starting FPGA download\n");
+		g_nb_users++;
+	}
+
+	pr_debug("Opening /dev/fpga/loader, %d %d\n", fpga_descriptor, ret);
+
+out:
+	/* Release exclusive access */
+	up(&fpga_sema);
+
+	return ret;
+}
+
+static int armadeus_fpga_release(struct inode *inode, struct file *file)
+{
+	if (fpga_finish_load(g_current_desc))
+		printk("Failed to load FPGA !\n");
+
+	pr_debug("Closing access to /dev/fpgaloader\n");
+
+	if (g_nb_users > 0)
+		g_nb_users--;
+
+	return 0;
+}
+
+
+/* PROC file */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+static int procfile_fpga_read(char *buffer, __attribute__ ((unused)) char **start,
+			      off_t offset, int buffer_length, 
+			      int *eof, 
+			      __attribute__ ((unused)) void* data) 
+#else
+static int procfile_fpga_read(struct file *file, char __user *buffer, size_t count,
+			      loff_t *offset)
+#endif
+{
+	int ret;
+
+	/* We give all of our information in one go, so if the user asks us if
+	   we have more information the answer should always be no.
+	   This is important because the standard read function from the
+	   library would continue to issue the read system call until the
+	   the kernel replies that it has no more information, or until 
+	   its buffer is filled */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+	if (offset > 0) {
+#else
+	if (*offset > 0) {
+#endif
+		/* we have finished to read, return 0 */
+		ret  = 0;
+	} else {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+		ret = fpga_get_infos(g_current_desc, buffer);
+#else
+		char buf[64];
+		ret = fpga_get_infos(g_current_desc, buf);
+		if (copy_to_user(buffer, buf, ret))
+			ret = -EFAULT;
+		*offset = ret;
+#endif
+	}
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+static int procfile_fpga_write( __attribute__ ((unused)) struct file *file,
+			        const char *buf, unsigned long count, void *data)
+#else
+static ssize_t procfile_fpga_write( __attribute__ ((unused)) struct file *file,
+			        const char __user *buf, size_t count, loff_t *f_pos)
+#endif
+{
+	return count;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+#else
+struct file_operations fpga_proc_fops = {
+	.read = procfile_fpga_read,
+	.write = procfile_fpga_write
+};
+#endif
+
+/* Create /proc entries for direct access to FPGA config */
+static int create_proc_entries( void )
+{
+	static struct proc_dir_entry *fpga_Proc_File;
+
+	/* Create main directory */
+	proc_mkdir(FPGA_PROC_DIRNAME, NULL);
+
+	/* Create proc file */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+	fpga_Proc_File = create_proc_entry(FPGA_PROC_FILENAME, S_IWUSR |S_IRUSR | S_IRGRP | S_IROTH, NULL);
+#else
+	fpga_Proc_File = proc_create(FPGA_PROC_FILENAME, S_IWUSR |S_IRUSR | S_IRGRP | S_IROTH, NULL, &fpga_proc_fops);
+#endif
+	if (fpga_Proc_File == NULL) {
+		printk(DRIVER_NAME ": Could not register a" FPGA_PROC_FILENAME  ". Terminating\n");
+		goto error;
+	} else {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+		fpga_Proc_File->read_proc = procfile_fpga_read;
+		fpga_Proc_File->write_proc = procfile_fpga_write;
+#else
+#endif
+	}
+
+	return 0;
+error:
+	remove_proc_entry(FPGA_PROC_DIRNAME, NULL);
+	return -ENOMEM;
+}
+
+static struct file_operations fpga_fops = {
+	.owner   = THIS_MODULE,
+	.write   = armadeus_fpga_write,
+	/*    .read    = armadeus_fpga_read, Configuration saving not supported yet */
+	.open    = armadeus_fpga_open,
+	.release = armadeus_fpga_release,
+};
+
+#ifdef CONFIG_PM
+static int armadeus_fpga_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int armadeus_fpga_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define armadeus_fpga_suspend	NULL
+#define armadeus_fpga_resume	NULL
+#endif
+
+static struct miscdevice fpgaloader_misc = {
+	.minor  = MISC_DYNAMIC_MINOR,
+	.name   = DRIVER_NAME,
+	.fops   = &fpga_fops,
+};
+
+
+static int armadeus_fpga_probe(struct platform_device *pdev)
+{
+	int result;
+	struct device *dev = &pdev->dev;
+	struct fpga_desc *platform_info;
+
+	platform_info = dev->platform_data;
+	if (platform_info == NULL) {
+		dev_err(&pdev->dev, "probe - no platform data supplied\n");
+		result = -ENODEV;
+		goto err_no_pdata;
+	}
+
+	/* Register the driver through misc layer to get MAJOR/MINOR */
+	result = misc_register(&fpgaloader_misc);
+	if (result) {
+		printk(KERN_ERR "%s:%u: misc_register failed %d\n",
+				__func__, __LINE__, result);
+		goto err_no_pdata;
+	}
+
+	dev_dbg(&pdev->dev, "%s:%u: registered misc device %d\n",
+			__func__, __LINE__, fpgaloader_misc.minor);
+
+	result = create_proc_entries();
+	if (result < 0)
+		goto err_misc;
+
+	sema_init(&fpga_sema, 1);
+
+	/* initialize the current fpga descriptor with the one by default */
+	g_current_desc = platform_info;
+	
+	printk(DRIVER_NAME " v" DRIVER_VERSION " ready\n");
+
+	return 0;
+
+err_misc:
+	misc_deregister(&fpgaloader_misc);
+err_no_pdata:
+	return result;
+}
+
+static int armadeus_fpga_remove(struct platform_device *pdev)
+{
+	remove_proc_entry(FPGA_PROC_FILENAME, NULL);
+	remove_proc_entry(FPGA_PROC_DIRNAME, NULL);
+	misc_deregister(&fpgaloader_misc);
+
+	return 0;
+}
+
+static struct platform_driver armadeus_fpga_driver = {
+	.probe		= armadeus_fpga_probe,
+	.remove		= armadeus_fpga_remove,
+	.suspend	= armadeus_fpga_suspend,
+	.resume		= armadeus_fpga_resume,
+	.driver		= {
+		.name	= DRIVER_NAME,
+	},
+};
+
+static int __init armadeus_fpga_init(void)
+{
+	return platform_driver_register(&armadeus_fpga_driver);
+}
+
+static void __exit armadeus_fpga_exit(void)
+{
+	platform_driver_unregister(&armadeus_fpga_driver);
+}
+
+module_init(armadeus_fpga_init);
+module_exit(armadeus_fpga_exit);
+
+MODULE_AUTHOR("Julien Boibessot / Nicolas Colombain");
+MODULE_DESCRIPTION("Armadeus FPGA loading driver");
+MODULE_LICENSE("GPL");
Binary files linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpgaloader.ko and linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpgaloader.ko differ
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpgaloader.mod.c linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpgaloader.mod.c
--- linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpgaloader.mod.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpgaloader.mod.c	2013-11-24 13:08:47.000000000 +0100
@@ -0,0 +1,23 @@
+#include <linux/module.h>
+#include <linux/vermagic.h>
+#include <linux/compiler.h>
+
+MODULE_INFO(vermagic, VERMAGIC_STRING);
+
+__visible struct module __this_module
+__attribute__((section(".gnu.linkonce.this_module"))) = {
+	.name = KBUILD_MODNAME,
+	.init = init_module,
+#ifdef CONFIG_MODULE_UNLOAD
+	.exit = cleanup_module,
+#endif
+	.arch = MODULE_ARCH_INIT,
+};
+
+MODULE_INFO(intree, "Y");
+
+static const char __module_depends[]
+__used
+__attribute__((section(".modinfo"))) =
+"depends=";
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/loader/load_fpga linux-3.13/drivers/armadeus/fpga/dev_tools/loader/load_fpga
--- linux-3.13/drivers/armadeus/fpga/dev_tools/loader/load_fpga	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/loader/load_fpga	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,67 @@
+#!/bin/sh
+#
+# Loads APFxx's FPGA by using fpgaloader driver
+#
+PLATFORM=`cat /etc/machine`
+
+if [ "$1" == "" ]; then
+	echo "Usage: `basename $0` <filename>"
+	echo "    filename: bitfile to load in FPGA"
+	exit 1
+fi
+
+if [ ! -f "$1" ]; then
+	echo "can't find $1"
+	exit 1
+fi
+
+if [ "$PLATFORM" == "APF51" ]; then
+	filename="$1"
+	ext=${filename/*./}
+	if [ "$ext" != "bin" ]; then
+		echo "Wrong bitstream format, binary file in *.bin format must be used."
+		exit 1
+	fi
+fi
+
+if [ ! -c /dev/fpgaloader ]; then
+	modprobe fpgaloader
+	if [ "$?" != 0 ]; then
+		echo "Failed to modprobe FPGA loader driver. Please check your config !"
+		exit 1
+	fi
+fi
+
+timeout=0
+while [ ! -c /dev/fpgaloader ]; do
+	usleep 1000
+	let timeout=timeout+1
+	if [ $timeout -gt 100 ]; then
+		echo "Timeout while waiting for FPGA loader driver readiness !"
+		exit 1
+	fi
+done
+
+if [ "$PLATFORM" == "APF51" ]; then
+	# On APF51 FPGA loading shares NAND bus so it's safer to load
+	# firmware from RAM
+	BITFILE=/tmp/tmp_bitfile
+	cp $1 $BITFILE
+	if [ "$?" != 0 ]; then
+		echo "Error while making bitfile copy in RAM !"
+		exit 1
+	fi
+	sync
+else
+	BITFILE=$1
+fi
+
+dd if=$BITFILE of=/dev/fpgaloader
+RES=$?
+
+if [ "$PLATFORM" == "APF51" ]; then
+	rm $BITFILE	# delete copy in RAM
+fi
+
+exit $RES
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/loader/linux-3.13/drivers/armadeus.order linux-3.13/drivers/armadeus/fpga/dev_tools/loader/linux-3.13/drivers/armadeus.order
--- linux-3.13/drivers/armadeus/fpga/dev_tools/loader/linux-3.13/drivers/armadeus.order	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/loader/linux-3.13/drivers/armadeus.order	2013-12-20 12:21:06.000000000 +0100
@@ -0,0 +1 @@
+kernel/linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpgaloader.ko
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/loader/xilinx-fpga-loader.c linux-3.13/drivers/armadeus/fpga/dev_tools/loader/xilinx-fpga-loader.c
--- linux-3.13/drivers/armadeus/fpga/dev_tools/loader/xilinx-fpga-loader.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/loader/xilinx-fpga-loader.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,423 @@
+/*
+ * Xilinx FPGAs download support
+ * Copyright (C) 2006-2009 Nicolas Colombain <nicolas.colombain@armadeus.com>
+ *                         Armadeus Project / Armadeus systems
+ *
+ * Based on the (U-Boot) implementation of:
+ * Rich Ireland, Enterasys Networks, rireland@enterasys.com.
+ * Keith Outwater, keith_outwater@mvis.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <asm/io.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+
+#include "xilinx-fpga-loader.h"
+
+
+#define CONFIG_FPGA_DELAY()
+#define CFG_FPGA_WAIT   20000  /* uS */
+
+size_t bytecount = 0; /* total bytes received */
+
+
+/* Timeout function */
+static unsigned long get_timer(unsigned long initTime)
+{
+	struct timeval tv;
+	do_gettimeofday(&tv);
+	if( tv.tv_usec > initTime )  /* avoid overflow pb */
+		return tv.tv_usec - initTime;
+	else
+		return initTime - tv.tv_usec;
+}
+
+/* dump the given descriptor infos */
+static int xilinx_dump_descriptor_info( struct fpga_desc *desc, char* buffer )
+{
+	int len;
+	len  = sprintf( buffer, "%s %s\n",
+			(desc->family == Xilinx_Spartan) ? "spartan":"unknown",
+			(desc->iface == slave_serial) ? "slave serial":"slave parallel"
+			);
+	return len;
+}
+
+/**
+ *  program the FPGA (serial mode).
+ *  return 0 if success, >0 while programming, <0 if error detected
+ */
+static size_t spartan_serial_load(struct fpga_desc *desc, const char* buf, size_t bsize)
+{
+	Xilinx_Spartan_Slave_Serial_fns *fn = desc->iface_fns;
+
+	if (fn) {
+		int i;
+		unsigned char   val;
+		size_t nbbyte = 0; /* init local counter */
+
+		while (nbbyte < bsize) {
+			/* Spartan signals an error if INIT goes low (active)
+			   while DONE is low (inactive) */
+			if ((*fn->done)() == 0 && (*fn->init)()) {
+				printk("** CRC error during FPGA load.\n");
+				return -ETIMEDOUT;
+			}
+			val = buf[nbbyte ++];
+			bytecount++;
+			i = 8;
+			do {
+				/* Deassert the clock */
+				(*fn->clk)(0);
+				CONFIG_FPGA_DELAY();
+				/* Write data */
+				(*fn->wr)(val & 0x80);
+				CONFIG_FPGA_DELAY();
+				/* Assert the clock */
+				(*fn->clk)(1);
+				CONFIG_FPGA_DELAY();
+				val <<= 1;
+				i --;
+			} while (i > 0);
+		}
+
+		if (bytecount % 4096 == 0)
+			printk(".");
+
+		return bsize;
+	}
+	return -EINVAL;
+}
+
+/**
+ *  initialize the FPGA programming interface (serial).
+ *  return 0 if success, <0 if error detected
+ */
+static int spartan_serial_init(struct fpga_desc *desc)
+{
+	Xilinx_Spartan_Slave_Serial_fns *fn = desc->iface_fns;
+	if (fn) {
+		unsigned long timestamp;
+
+		if (*fn->pre){
+			(*fn->pre)(); /* Run the pre configuration function if there is one. */
+		}
+
+		/* Establish the initial state */
+		(*fn->pgm)(1);	/* Assert the program, commit */
+
+		/* Wait for INIT state (init low) */
+		timestamp = get_timer(0);		/* get current time */
+		do {
+			CONFIG_FPGA_DELAY ();
+			if (get_timer(timestamp) > CFG_FPGA_WAIT) {
+				pr_debug("** Timeout waiting for INIT to start.\n");
+				return -ETIMEDOUT;
+			}
+		} while (!(*fn->init)());
+
+		/* Get ready for the burn */
+		CONFIG_FPGA_DELAY ();
+		(*fn->pgm)(0);	/* Deassert the program, commit */
+
+		timestamp = get_timer(0);		/* get current time */
+		/* Now wait for INIT to go high */
+		do {
+			CONFIG_FPGA_DELAY ();
+			if (get_timer(timestamp) > CFG_FPGA_WAIT) {
+				pr_debug("** Timeout waiting for INIT to clear.\n");
+				return -ETIMEDOUT;
+			}
+		} while ((*fn->init)());
+
+		bytecount = 0; /* reset byte count */
+		return 0; /* success */
+	}
+	return -EINVAL;
+}
+
+/* terminate the FPGA load (serial mode) */
+static int spartan_serial_finish(struct fpga_desc *desc)
+{
+	unsigned long timestamp;
+	Xilinx_Spartan_Slave_Serial_fns *fn = desc->iface_fns;
+
+	if (fn) {
+		CONFIG_FPGA_DELAY ();
+
+		/* now check for done signal */
+		timestamp = get_timer(0);	/* get current time */
+		(*fn->wr)(1);
+
+		while (! (*fn->done)()) {
+			CONFIG_FPGA_DELAY ();
+			(*fn->clk)(0);	/* Deassert the clock pin */
+			CONFIG_FPGA_DELAY ();
+			(*fn->clk)(1);	/* Assert the clock pin */
+
+			if (get_timer(timestamp) > CFG_FPGA_WAIT) {
+				pr_debug("** Timeout waiting for DONE.\n");
+				return -ETIMEDOUT;
+			}
+		}
+	}
+	return 0;
+}
+
+
+/**
+ *  initialize the FPGA programming interface (parallel).
+ *  return 0 if success, <0 if error detected
+ */
+static int spartan_parallel_init(struct fpga_desc *desc)
+{
+	int res = 0;
+	Xilinx_Spartan3_Slave_Parallel_fns *fn = desc->iface_fns;
+
+	if (fn) {
+		unsigned long timestamp;
+		/*
+		 * Run the pre configuration function if there is one.
+		 */
+		if (*fn->pre) {
+			if( (res = (*fn->pre) ()) ) return res;
+		}
+		mdelay(100);
+
+		/* Establish the initial state */
+		(*fn->pgm) (1);	/* Assert the program, commit */
+		timestamp = get_timer(0);		/* get current time */
+		/* Now wait for INIT to go down */
+		do {
+			CONFIG_FPGA_DELAY ();
+			if (get_timer(timestamp) > CFG_FPGA_WAIT) {
+				pr_debug("** Timeout waiting for INIT to set.\n");
+				(*fn->abort) ();	/* abort the burn */
+				return -ETIMEDOUT;
+			}
+		} while (!(*fn->init) () );
+
+
+		/* Get ready for the burn */
+		CONFIG_FPGA_DELAY ();
+		(*fn->pgm) (0);	/* Deassert the program, commit */
+
+		timestamp = get_timer (0);		/* get current time */
+		/* Now wait for INIT and BUSY to go high */
+		do {
+			CONFIG_FPGA_DELAY ();
+			if (get_timer(timestamp) > CFG_FPGA_WAIT) {
+				pr_debug("** Timeout waiting for INIT to clear.\n");
+				(*fn->abort) ();	/* abort the burn */
+				return -ETIMEDOUT;
+			}
+		} while ((*fn->init) ());
+		(*fn->wr) (1); /* Assert write, commit */
+		(*fn->cs) (1); /* Assert chip select, commit */
+		(*fn->clk) (1);	/* Assert the clock pin */
+		bytecount = 0; // reset byte count
+	}
+	return 0;
+}
+
+/**
+ *  program the FPGA (parallel mode).
+ *  return 0 if success, >0 while programming, <0 if error detected
+ */
+static size_t spartan_parallel_load(struct fpga_desc *desc, const char* buf, size_t bsize)
+{
+	unsigned long flags;
+	Xilinx_Spartan3_Slave_Parallel_fns *fn = desc->iface_fns;
+
+	if (fn) {
+		/* Load the data */
+		size_t nbbyte = 0;
+
+		raw_local_irq_save(flags);
+		 while (nbbyte < bsize) {
+			(*fn->clk) (1);	/* Assert the clock pin */
+			CONFIG_FPGA_DELAY ();
+ 			(*fn->wdata) (buf[nbbyte++]); /* write the data */
+			CONFIG_FPGA_DELAY ();
+			(*fn->clk) (0);	/* Deassert the clock pin */
+			bytecount++;
+		}
+		raw_local_irq_restore(flags);
+
+		return bsize;
+	}
+	return -EINVAL;
+}
+
+/* terminate the FPGA load (parallel mode) */
+static int spartan_parallel_finish(struct fpga_desc *desc)
+{
+	Xilinx_Spartan3_Slave_Parallel_fns *fn = desc->iface_fns;
+	unsigned long timestamp;
+
+	if (fn) {
+		/* now check for done signal */
+		timestamp = get_timer(0);	/* get current time */
+		while (!(*fn->done) ()) {
+			CONFIG_FPGA_DELAY ();
+			(*fn->clk) (0);	/* Deassert the clock pin */
+			CONFIG_FPGA_DELAY ();
+			(*fn->clk) (1);	/* Assert the clock pin */
+
+			if (get_timer(timestamp) > CFG_FPGA_WAIT) {
+				printk("** Timeout waiting for DONE to clear. %d bytes\n", bytecount);
+				(*fn->abort) ();	/* abort the burn */
+				return -ETIMEDOUT;
+			}
+		}
+		(*fn->cs) (0);	/* Deassert the chip select */
+		(*fn->wr) (0);	/* Deassert the write pin */
+		(*fn->post) (); /* release resources */
+	}
+
+	return 0;
+}
+
+
+size_t fpga_load( struct fpga_desc *desc, const char *buf, size_t bsize )
+{
+	int ret = 0;
+
+	if (desc) {
+		switch (desc->family) /* check family */
+		{
+			case Xilinx_Spartan:
+			{
+				switch (desc->iface) /* check download hardware interface */
+				{
+					case slave_serial:
+						ret = spartan_serial_load(desc, buf, bsize);
+					break;
+					case slave_parallel:
+						ret = spartan_parallel_load (desc, buf, bsize);
+					break;
+					default:
+						PRINTF("interface not supported!\n");
+						ret = -ENOSYS;
+					break;
+				}
+			}
+			break;
+
+			default:
+				PRINTF("family not supported!\n");
+				ret = -ENOSYS;
+			break;
+		}
+	}
+	else {
+		PRINTF("invalid FPGA descriptor!\n");
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+int fpga_init_load( struct fpga_desc *desc )
+{
+	int ret = 0;
+
+	if (desc) {
+		switch (desc->family)
+		{
+			case Xilinx_Spartan:
+			{
+				switch (desc->iface) /* check donwload hardware interface */
+				{
+					case slave_serial:
+						ret = spartan_serial_init( desc );
+					break;
+					case slave_parallel:
+						ret = spartan_parallel_init( desc );
+					break;
+					default:
+						pr_debug("interface not supported!\n");
+						ret = -ENOSYS;
+					break;
+				}
+			}
+			break;
+			default:
+				pr_debug("family not supported!\n");
+				ret = -ENOSYS;
+			break;
+		}
+	}
+	else {
+		pr_debug("invalid FPGA descriptor!\n");
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+int fpga_finish_load(struct fpga_desc *desc)
+{
+	int ret = 0;
+
+	if (desc) {
+		switch (desc->family)
+		{
+		case Xilinx_Spartan:
+		{
+			switch (desc->iface) /* check hardware download interface */
+			{
+				case slave_serial:
+					ret = spartan_serial_finish(desc);
+				break;
+				case slave_parallel: 
+					ret = spartan_parallel_finish(desc);
+				break;
+				default:
+					pr_debug("interface not supported!\n");
+					ret = -ENOSYS;
+				break;
+			}
+		}
+		break;
+		default:
+			pr_debug("family not supported!\n");
+			ret = -ENOSYS;
+		break;
+		}
+	} else {
+		pr_debug("invalid FPGA descriptor!\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+int fpga_get_infos( struct fpga_desc *desc, char* buffer )
+{
+	int len = 0;
+
+	if (desc) {
+		len  = xilinx_dump_descriptor_info( desc, buffer );
+	}
+
+	return len;
+}
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/loader/xilinx-fpga-loader.h linux-3.13/drivers/armadeus/fpga/dev_tools/loader/xilinx-fpga-loader.h
--- linux-3.13/drivers/armadeus/fpga/dev_tools/loader/xilinx-fpga-loader.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/loader/xilinx-fpga-loader.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,137 @@
+/*
+ * Xilinx FPGAs download support
+ * Copyright (C) 2006-2009 Nicolas Colombain <nicolas.colombain@armadeus.com>
+ *                         Armadeus Project / Armadeus systems
+ *
+ * Based on the implementation (U-Boot) of:
+ * Rich Ireland, Enterasys Networks, rireland@enterasys.com.
+ * Keith Outwater, keith_outwater@mvis.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+#ifndef __XILINX_FPGA_H__
+#define __XILINX_FPGA_H__
+
+#include <linux/types.h>
+
+
+#define FPGA_DEBUG
+//#undef FPGA_DEBUG
+
+#ifdef FPGA_DEBUG
+#define PRINTF(fmt,args...)	printk (fmt ,##args)
+#else
+#define PRINTF(fmt,args...)
+#endif
+
+/* Spartan-III */
+#define XILINX_XC3S50_SIZE  	439264/8
+#define XILINX_XC3S200_SIZE  	1047616/8
+#define XILINX_XC3S400_SIZE  	1699136/8
+#define XILINX_XC3S1000_SIZE 	3223488/8
+#define XILINX_XC3S1500_SIZE 	5214784/8
+#define XILINX_XC3S2000_SIZE 	7673024/8
+#define XILINX_XC3S4000_SIZE 	11316864/8
+#define XILINX_XC3S5000_SIZE 	13271936/8
+
+
+typedef enum {
+	min_xilinx_iface_type,		/* low range check value */
+	slave_serial,			/* serial data and external clock */
+	slave_parallel,			/* parallel data and external clock */
+	max_xilinx_iface_type		/* insert all new types before this */
+} Xilinx_iface;
+
+typedef enum {
+	min_xilinx_type,		/* low range check value */
+	Xilinx_Spartan, 		/* Spartan-II Family */
+	max_xilinx_type			/* insert all new types before this */
+} Xilinx_Family;
+
+struct fpga_desc {
+	Xilinx_Family    family;	/* part type */
+	Xilinx_iface     iface;		/* interface type */
+	size_t           size;		/* bytes of data part can accept */
+	void *           iface_fns;	/* interface function table */
+};
+
+
+/** pointer to target specific low level function */
+typedef int (*Xilinx_pgm_fn)( int assert_pgm );
+typedef int (*Xilinx_init_fn)(void);
+typedef int (*Xilinx_done_fn)(void);
+typedef int (*Xilinx_clk_fn)( int assert_clk );
+typedef int (*Xilinx_wr_fn)( int assert_write );
+typedef int (*Xilinx_pre_fn)(void);
+
+typedef int (*Xilinx_cs_fn)( int assert_cs);
+typedef int (*Xilinx_wdata_fn)( unsigned char data );
+typedef int (*Xilinx_busy_fn)(void);
+typedef int (*Xilinx_abort_fn)(void);
+typedef int (*Xilinx_post_fn)(void);
+
+/** struct of target specific low level functions */
+typedef struct {
+	Xilinx_pre_fn	pre;
+	Xilinx_pgm_fn	pgm;
+	Xilinx_clk_fn	clk;
+	Xilinx_init_fn	init;
+	Xilinx_done_fn	done;
+	Xilinx_wr_fn	wr;
+} Xilinx_Spartan_Slave_Serial_fns;
+
+/* Slave Parallel Implementation function table */
+typedef struct {
+	Xilinx_pre_fn	pre;
+	Xilinx_pgm_fn	pgm;
+	Xilinx_clk_fn	clk;
+	Xilinx_init_fn	init;
+	Xilinx_done_fn	done;
+	Xilinx_wr_fn	wr;
+	Xilinx_cs_fn	cs;
+	Xilinx_wdata_fn	wdata;
+	Xilinx_busy_fn	busy;
+	Xilinx_abort_fn	abort;
+	Xilinx_post_fn	post;
+} Xilinx_Spartan3_Slave_Parallel_fns;
+
+
+/**
+ *  program the FPGA.
+ *  return 0 if success, >0 while programming, <0 if error detected
+ */
+size_t fpga_load(struct fpga_desc *desc, const char *buf, size_t bsize);
+
+/**
+ *  initialize the FPGA programming interface
+ *  return 0 if success, <0 if error detected
+ */
+int fpga_init_load(struct fpga_desc *desc);
+
+/* terminate FPGA loading */
+int fpga_finish_load(struct fpga_desc *desc);
+
+/**
+ *  get some infos about FPGA download.
+ *  return the number of char placed in the buffer
+ */
+int fpga_get_infos(struct fpga_desc *desc, char* buffer);
+
+#endif // __XILINX_FPGA_H__
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/dev_tools/linux-3.13/drivers/armadeus.order linux-3.13/drivers/armadeus/fpga/dev_tools/linux-3.13/drivers/armadeus.order
--- linux-3.13/drivers/armadeus/fpga/dev_tools/linux-3.13/drivers/armadeus.order	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/dev_tools/linux-3.13/drivers/armadeus.order	2013-12-20 12:21:07.000000000 +0100
@@ -0,0 +1 @@
+kernel/linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpgaloader.ko
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/linux-3.13/drivers/armadeus.order linux-3.13/drivers/armadeus/fpga/linux-3.13/drivers/armadeus.order
--- linux-3.13/drivers/armadeus/fpga/linux-3.13/drivers/armadeus.order	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/linux-3.13/drivers/armadeus.order	2013-12-20 12:21:07.000000000 +0100
@@ -0,0 +1 @@
+kernel/linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpgaloader.ko
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/others/Kconfig linux-3.13/drivers/armadeus/fpga/others/Kconfig
--- linux-3.13/drivers/armadeus/fpga/others/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/others/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,10 @@
+#
+# Armadeus custom linux-3.13/drivers configuration
+#
+#
+
+comment "Others linux-3.13/drivers for the FPGA"
+	depends on ARMADEUS_FPGA_DRIVERS
+	
+source "drivers/armadeus/fpga/others/i2ctest/Kconfig"
+source "drivers/armadeus/fpga/others/ps2keyboard/Kconfig"
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/others/i2ctest/Kconfig linux-3.13/drivers/armadeus/fpga/others/i2ctest/Kconfig
--- linux-3.13/drivers/armadeus/fpga/others/i2ctest/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/others/i2ctest/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,8 @@
+#
+#
+
+config ARMADEUS_I2C_OCORE_IRQMNG
+        tristate "Driver for testing wishbone i2c-ocore-irq_mng"
+        default n
+        depends on ARMADEUS_FPGA_DRIVERS
+        ---help---
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/others/i2ctest/Makefile linux-3.13/drivers/armadeus/fpga/others/i2ctest/Makefile
--- linux-3.13/drivers/armadeus/fpga/others/i2ctest/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/others/i2ctest/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,31 @@
+#
+# Makefile for the Armadeus bus_i2ctest linux-3.13/drivers
+#
+
+# Part executed when cali2ctest from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-m	+= i2ctest.o
+
+i2ctest	:= i2ctest.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../../../Makefile.in
+
+test:
+	$(ARMADEUS_TOOLCHAIN_PATH)/arm-linux-gcc testi2ctest.c -o testi2ctest
+	chmod 755 testi2ctest
+	cp testi2ctest /tftpboot/
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/others/i2ctest/README linux-3.13/drivers/armadeus/fpga/others/i2ctest/README
--- linux-3.13/drivers/armadeus/fpga/others/i2ctest/README	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/others/i2ctest/README	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,16 @@
+This is a really simple driver to test reading and writing
+a value on i2c memory component throught ocore-irq_mng FPGA IP.
+
+Frames are like :
+START+ADDR+ACK+SUBADDR+ACK+REPSTART+ADDR+ACK+VALUE+ACK+STOP
+
+To use it load i2ctest.ko module with insmod
+>insmod i2ctest.ko
+
+Then read /proc/i2c_test with cat
+> cat /proc/i2c_test
+
+This will send write command on component
+
+To read the value you wrote, read /proc/i2c_test2
+> cat /proc/i2c_test2
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/others/i2ctest/i2ctest.c linux-3.13/drivers/armadeus/fpga/others/i2ctest/i2ctest.c
--- linux-3.13/drivers/armadeus/fpga/others/i2ctest/i2ctest.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/others/i2ctest/i2ctest.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,336 @@
+/* i2ctest.c 
+ ***********************************************************************
+ *
+ * (c) Copyright 2008    Armadeus project
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ * Driver for testing i2c IP ocore with irq_mngr
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ **********************************************************************
+ */
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/ioport.h>	/* request_mem_region */
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+
+#include <asm/io.h>	/* readw() writew() */
+#include <mach/hardware.h>
+#include <asm/irq.h>
+
+/* Addresses */
+#define FPGA_IRQ_MASK   (0x0)
+#define FPGA_IRQ_PEND   (0x2)
+#define FPGA_IRQ_ACK    (0x2)
+
+#define FPGA_BASE_ADDR		(0x20)
+#define FPGA_I2C_PRESCLo	(FPGA_BASE_ADDR+0x0)
+#define FPGA_I2C_PRESCHi	(FPGA_BASE_ADDR+0x2)
+#define FPGA_I2C_CTR		(FPGA_BASE_ADDR+0x4)
+#define FPGA_I2C_TXR		(FPGA_BASE_ADDR+0xA)
+#define FPGA_I2C_RXR		(FPGA_BASE_ADDR+0xE)
+#define FPGA_I2C_CR		(FPGA_BASE_ADDR+0x8)
+#define FPGA_I2C_SR		(FPGA_BASE_ADDR+0xC)
+
+/* Values */
+#define PRELo	(0xBF)
+#define PREHi   (0x00)
+
+/* read/write (accelerometer)*/
+#define ADDR	(0x1D) /* lis3lv02dl */
+#define SUBADDR (0x16) /* OFFSET_X   */
+#define VALUE	(0xBB)
+
+/* irq position in irqmngr */
+#define IRQ (0x01)
+
+
+/* CTR register */
+#define I2C_EN    (0x80)
+#define I2C_IEN   (0x40)
+
+/* CR register */
+#define I2C_STA   (0x80)
+#define I2C_STO   (0x40)
+#define I2C_RD    (0x20)
+#define I2C_WR    (0x10)
+#define I2C_ACK   (0x08)
+#define I2C_IACK  (0x01)
+
+/* read/write bit */
+#define I2C_ADD_READ  (0x01)
+#define I2C_ADD_WRITE (0x00)
+
+//#define LED_DEBUG
+#undef PDEBUG
+#ifdef LED_DEBUG
+# ifdef __KERNEL__
+    /* for kernel spage */
+#   define PDEBUG(fmt,args...) printk(KERN_DEBUG "i2ctest : " fmt, ##args)
+# else
+    /* for user space */
+#   define PDEBUG(fmt,args...) printk(stderr, fmt, ##args)
+# endif
+#else
+# define PDEBUG(fmt,args...) /* no debbuging message */
+#endif
+
+#define DRIVER_NAME "i2ctest"
+
+struct i2ctest_dev {
+	struct semaphore sem;
+	void * fpga_virtual_base_address;
+};
+
+struct i2ctest_dev *i2cdev;
+
+struct resource *mem; /* pointer to fpga led */
+
+static void free_all(void);
+
+/***************************
+ * interrupt management
+ * *************************/
+static irqreturn_t fpga_interrupt(int irq,void *stuff,struct pt_regs *reg){
+	static int count = 0;
+	u16 data;
+
+	/***************/
+	/* write VALUE */
+	/***************/
+	if (count == 0) {
+		/*read RxACK bit from Status Register, should be 0 */
+		ioread16(i2cdev->fpga_virtual_base_address + FPGA_I2C_SR);
+		/* write to Transmit sub address, set WR bit acknowledge interrupt*/
+		iowrite16(SUBADDR,i2cdev->fpga_virtual_base_address + FPGA_I2C_TXR);
+		iowrite16(I2C_WR|I2C_IACK,
+				  i2cdev->fpga_virtual_base_address + FPGA_I2C_CR);
+
+		/* acknowledge irq in irq manager*/
+		iowrite16(IRQ,i2cdev->fpga_virtual_base_address + FPGA_IRQ_ACK);
+		count++;
+	} else if (count == 1) {
+		/*read RxACK bit from Status Register, should be 0 */
+		ioread16(i2cdev->fpga_virtual_base_address + FPGA_I2C_SR);
+
+		/* write to Transmit sub address, set WR bit acknowledge interrupt*/
+		iowrite16(ADDR<<1|I2C_ADD_WRITE,i2cdev->fpga_virtual_base_address+FPGA_I2C_TXR);
+		iowrite16(I2C_STA|I2C_WR|I2C_IACK,
+				  i2cdev->fpga_virtual_base_address + FPGA_I2C_CR);
+
+		/* acknowledge irq in irq manager*/
+		iowrite16(IRQ,i2cdev->fpga_virtual_base_address + FPGA_IRQ_ACK);
+		count ++;
+	} else if (count == 2) {
+		/*read RxACK bit from Status Register, should be 0 */
+		ioread16(i2cdev->fpga_virtual_base_address + FPGA_I2C_SR);
+		/* write VALUE, set WR bit acknowledge interrupt*/
+		iowrite16(VALUE,i2cdev->fpga_virtual_base_address+FPGA_I2C_TXR);
+		iowrite16(I2C_IACK|I2C_WR|I2C_STO,
+				  i2cdev->fpga_virtual_base_address + FPGA_I2C_CR);
+
+		/* acknowledge irq in irq manager*/
+		iowrite16(IRQ,i2cdev->fpga_virtual_base_address + FPGA_IRQ_ACK);
+		count++;
+	} else if (count == 3) {
+		/*read RxACK bit from Status Register, should be 0 */
+		ioread16(i2cdev->fpga_virtual_base_address + FPGA_I2C_SR);
+		/* acknowledge interruption */
+		iowrite16(I2C_IACK,
+				  i2cdev->fpga_virtual_base_address + FPGA_I2C_CR);
+		/* acknowledge irq in irq manager*/
+		iowrite16(IRQ,i2cdev->fpga_virtual_base_address + FPGA_IRQ_ACK);
+		count++;
+
+	} else if (count == 4) {/**************READ THE VALUE ****************/
+		/*read RxACK bit from Status Register, should be 0 */
+		ioread16(i2cdev->fpga_virtual_base_address + FPGA_I2C_SR);
+
+		/* write 0x2C to Transmit sub address, set WR bit acknowledge interrupt*/
+		iowrite16(SUBADDR,i2cdev->fpga_virtual_base_address+FPGA_I2C_TXR);
+		iowrite16(I2C_WR|I2C_IACK,
+				  i2cdev->fpga_virtual_base_address + FPGA_I2C_CR);
+
+		/* acknowledge irq in irq manager*/
+		iowrite16(IRQ,i2cdev->fpga_virtual_base_address + FPGA_IRQ_ACK);
+		count++;
+	} else if (count == 5) {
+		/*read RxACK bit from Status Register, should be 0 */
+		ioread16(i2cdev->fpga_virtual_base_address + FPGA_I2C_SR);
+		/* write adress on TXR and CTR register repeated start, acknowledge interrupt*/
+		iowrite16(ADDR<<1|I2C_ADD_READ,i2cdev->fpga_virtual_base_address+FPGA_I2C_TXR);
+		iowrite16(I2C_STA|I2C_WR|I2C_IACK,
+				  i2cdev->fpga_virtual_base_address + FPGA_I2C_CR);
+
+		/* acknowledge irq in irq manager*/
+		iowrite16(IRQ,i2cdev->fpga_virtual_base_address + FPGA_IRQ_ACK);
+		count++;
+	} else if (count == 6) {
+		/* write on TXR and CTR register, set read bit,acknowledge interrupt*/
+		iowrite16(I2C_RD|I2C_ACK|I2C_IACK|I2C_STO,
+				  i2cdev->fpga_virtual_base_address + FPGA_I2C_CR);
+
+		/* acknowledge irq in irq manager*/
+		iowrite16(IRQ,i2cdev->fpga_virtual_base_address + FPGA_IRQ_ACK);
+		count++;
+	} else if (count == 7) {
+		/*read RxACK bit from Status Register, should be 0 */
+		data = ioread16(i2cdev->fpga_virtual_base_address + FPGA_I2C_SR);
+		/* read the value */
+		data = ioread16(i2cdev->fpga_virtual_base_address + FPGA_I2C_RXR);
+		/* write on TXR and CTR register, set read bit,acknowledge interrupt*/
+		iowrite16(I2C_IACK,
+				  i2cdev->fpga_virtual_base_address + FPGA_I2C_CR);
+
+		/* acknowledge irq in irq manager*/
+		iowrite16(IRQ,i2cdev->fpga_virtual_base_address + FPGA_IRQ_ACK);
+
+		printk(KERN_INFO "read %04x\n",data);
+		count++;
+	}
+	return IRQ_HANDLED;
+}
+
+/****************************
+ * read proc
+ * **************************/
+
+static int read_proc(char *page,char **start,off_t offset,
+					 int count,int *eof,void *data)
+{
+	PDEBUG("Trying to write %04x on i2c slave\n",VALUE);
+
+	/* unmask interrupt for i2c in interrupt manager*/
+	iowrite16(IRQ, i2cdev->fpga_virtual_base_address + FPGA_IRQ_MASK);
+
+	/* set prescale */
+	iowrite16(PRELo, i2cdev->fpga_virtual_base_address + FPGA_I2C_PRESCLo);
+	PDEBUG("Write %04x at %04x\n", PRELo,FPGA_I2C_PRESCLo);
+	iowrite16(PREHi, i2cdev->fpga_virtual_base_address + FPGA_I2C_PRESCHi);
+	PDEBUG("Write %04x at %04x\n", PRELo,FPGA_I2C_PRESCHi);
+
+	/* set core enable and interrupt enable*/
+	iowrite16(I2C_EN|I2C_IEN,
+			  i2cdev->fpga_virtual_base_address + FPGA_I2C_CTR);
+	PDEBUG("Write %04x at %04x\n", I2C_EN|I2C_IEN,FPGA_I2C_CTR);
+
+	/* write slave adresse on TXR */
+	iowrite16(ADDR<<1|I2C_ADD_WRITE, i2cdev->fpga_virtual_base_address + FPGA_I2C_TXR);
+	/* and CTR register*/
+	iowrite16(I2C_STA|I2C_WR|I2C_IACK,
+			  i2cdev->fpga_virtual_base_address+FPGA_I2C_CR);
+	PDEBUG("Write %04x at %04x\n", I2C_STA|I2C_WR,FPGA_I2C_TXR);
+
+	return 0;
+}
+
+static int read_proc2(char *page,char **start,off_t offset,int count,
+					  int *eof,void *data)
+{
+	PDEBUG("Trying to read on i2c slave\n");
+
+	/* write slave adresse on TXR*/
+	iowrite16(ADDR<<1|I2C_ADD_WRITE, i2cdev->fpga_virtual_base_address + FPGA_I2C_TXR);
+	/* write ctr register*/
+	iowrite16(I2C_ADD_WRITE|I2C_STA|I2C_WR|I2C_IACK,
+			  i2cdev->fpga_virtual_base_address + FPGA_I2C_CR);
+	return 0;
+}
+
+/****************************
+ * Module management 
+ * **************************/
+
+static int __init i2ctest_init(void){
+	int result;
+	u16 data;
+	result = 0;
+
+	mem = NULL;
+
+	/* Allocate a private structure and reference it as driver's data */
+	PDEBUG("Allocate a private structure and reference it as driver s data\n"); 
+	i2cdev = (struct i2ctest_dev *)kmalloc(sizeof(struct i2ctest_dev),GFP_KERNEL);
+	if (i2cdev == NULL) {
+		printk(KERN_WARNING "I2CDEV: unable to allocate private structure\n");
+		return -ENOMEM;
+	}
+
+	/* Requested I/O memory */
+	if ((i2cdev->fpga_virtual_base_address = ioremap(IMX_CS1_PHYS, IMX_CS1_SIZE)) == NULL) {
+		printk(KERN_ERR "ioremap error\n");
+		goto error;
+	}
+
+	/* irq registering */
+	if (request_irq(IRQ_GPIOA(1), (irq_handler_t)fpga_interrupt, IRQF_SHARED,"fpga", i2cdev) < 0) {
+		printk(KERN_ERR "Can't request fpga irq\n");
+		goto error;
+	}
+	//ioread16(i2cdev->fpga_virtual_base_address + FPGA_IRQ_ACK);
+	/* irq ack */
+	data = IRQ;
+	iowrite16(data, i2cdev->fpga_virtual_base_address + FPGA_IRQ_ACK);
+
+	/* create proc entry */
+	create_proc_read_entry("i2c_test",0 /* default mode */,
+						   NULL /* parent dir */, read_proc, 
+						   NULL /* client data */);
+
+	/* create proc entry */
+	create_proc_read_entry("i2c_test2",0 /* default mode */,
+						   NULL /* parent dir */, read_proc2, 
+						   NULL /* client data */);
+
+	/* OK module inserted ! */
+	printk(KERN_INFO "i2ctest module insered\n");
+	return 0;
+
+error:
+	printk(KERN_ERR "%s: not inserted\n",DRIVER_NAME);
+	free_all();
+	return result;
+
+
+}
+
+static void __exit i2ctest_exit(void){
+	free_all();
+}
+
+static void free_all(void){
+
+	/* free irq*/
+	free_irq(IRQ_GPIOA(1),i2cdev);
+
+	/* Free the allocated memory */
+	kfree(i2cdev);
+
+	/* remove proc entry */
+	remove_proc_entry("i2c_test",0);
+
+	printk(KERN_INFO "i2ctest module deleted\n");
+}
+
+module_init(i2ctest_init);
+module_exit(i2ctest_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Fabien Marteau <fabien.marteau@armadeus.com> - ARMadeus Systems");
+MODULE_DESCRIPTION("I2C tester");
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/Kconfig linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/Kconfig
--- linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,12 @@
+#
+#
+
+config ARMADEUS_PS2KBD_DRIVER
+        tristate "Armadeus PS/2 driver"
+        default n
+        depends on ARMADEUS_FPGA_DRIVERS
+        ---help---
+	  If you have the corresponding IP loaded in the FPGA then this
+	  driver will allow you to use PS/2 keyboard with your Armadeus
+	  board.
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/Makefile linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/Makefile
--- linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,25 @@
+#
+# Makefile for the Armadeus FPGA "PS/2" driver
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_ARMADEUS_PS2KBD_DRIVER)	+= apf9328ps2.o
+apf9328ps2-objs	:= core.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../../../Makefile.in
+    
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/README linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/README
--- linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/README	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/README	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,8 @@
+To compile this driver (example):
+---------------------------------
+    make ARCH=arm CROSS_COMPILE=/local/julien/Armadeus/Armadeus_SVN_test/armadeus/software/buildroot/build_arm_nofpu/staging_dir/bin/arm-linux-
+
+To install this driver:
+-----------------------
+Copy resulting *.ko files on your target rootfs
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/core.c linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/core.c
--- linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/others/ps2keyboard/core.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,204 @@
+/*
+ *  PS/2 keyboard controller driver for Armadeus APF9328 board with Spartan3 FPGA
+ *
+ *  Copyright (c) 2006 Armadeus Team
+ *
+ *  Based on the work of Vojtech Pavlik
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+/*#define DEBUG 1*/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/kernel.h>	/* pr_debug */
+
+#include <mach/imx-regs.h>
+
+/* Linux Kernel uses virtual addresses linearly mapped to physical one, ex for CS1:
+#define IMX_CS1_PHYS        0x12000000
+#define IMX_CS1_SIZE        0x01000000
+#define IMX_CS1_VIRT        0xea000000*/
+
+/* Following defines will have to be put in a .h file somewhere when driver will be finished */
+#define FPGA_PS2_STATUS_REGISTER (*((volatile unsigned short*)(IMX_CS1_VIRT + 0x00)))
+#define FPGA_PS2_FIFO_FULL	(0x08)
+#define FPGA_PS2_FIFO_EMPTY	(0x02)
+#define FPGA_PS2_DATA_REGISTER	(*((volatile unsigned short*)(IMX_CS1_VIRT + 0x02)))
+#define FPGA_PS2_ID_REGISTER	(*((volatile unsigned short*)(IMX_CS1_VIRT + 0x08)))
+#define FPGA_PS2_ID_VALUE	(0x1234)
+
+#define FPGA_PS2_DEFAULT_ADDRESS 0x12000000
+/* Base address in i.MX memory map to access PS/2 interface on FPGA   NOT HANDLED YET, cf previous defines */
+static unsigned int base_address = FPGA_PS2_DEFAULT_ADDRESS;
+module_param_named(base, base_address, uint, 0);
+MODULE_PARM_DESC(base, "Base address in i.MX memory map to access PS/2 interface on FPGA (default is 0x12000000)");
+
+/* Compatibility mode for keyboard, I'm not sure we should support XT... */
+static unsigned int apf9328keyboard_mode = SERIO_8042;
+module_param_named(mode, apf9328keyboard_mode, uint, 0);
+MODULE_PARM_DESC(mode, "Mode of operation: XT = 0/AT = 1 (default)");
+
+/* Global variables */
+static int gBuffer;
+static struct serio *apf9328keyboard_port;
+static struct timer_list read_timer;
+#define DRIVER_NAME "Armadeus PS/2"
+#define DRIVER_VERSION "0.2"
+
+
+/* Read one entry in FPGA FIFO */
+static int apf9328keyboard_read(void)
+{
+	volatile unsigned short value;
+
+	value = FPGA_PS2_DATA_REGISTER;
+	pr_debug(DRIVER_NAME ": value read 0x%x\n", value);
+
+	return value;
+}
+
+/* Flush receive FIFO in FPGA */
+static int apf9328keyboard_flush(void)
+{
+	volatile unsigned short shadow;
+	unsigned int timeout = 0;
+
+	while (((shadow & FPGA_PS2_FIFO_EMPTY) == 0) && (timeout <= 50))
+	{
+		shadow = FPGA_PS2_DATA_REGISTER;
+		shadow = FPGA_PS2_STATUS_REGISTER;
+		timeout++;
+	}
+
+	return 0;
+}
+
+#if 0
+static int apf9328keyboard_write(struct serio *port, unsigned char c)
+{
+	/* Not implemented yet in hardware... */
+	return 0;
+}
+#endif
+
+/* Simulated by a software interrupt (timer) at that time... */
+#ifdef HARDWARE_INTERRUPT_ACTIVATED
+static int apf9328keyboard_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+#else
+static void apf9328keyboard_interrupt(unsigned long arg)
+#endif // HARDWARE_INTERRUPT_ACTIVATED
+{
+	volatile unsigned short status = 0;
+	/*printk("RD IT: "); */
+
+	status = FPGA_PS2_STATUS_REGISTER;
+	/* Get data from FPGA (if there is some) */
+	while ((status & FPGA_PS2_FIFO_EMPTY) == 0 )
+	{
+		gBuffer = apf9328keyboard_read();
+		/* Apply it some processing */
+		/* ...??? */
+		/* Forward it to upper layer */
+#ifdef HARDWARE_INTERRUPT_ACTIVATED
+		serio_interrupt(apf9328keyboard_port, gBuffer, 0, regs);
+		status = FPGA_PS2_STATUS_REGISTER;
+	}
+
+	return(IRQ_HANDLED);
+#else 
+		serio_interrupt(apf9328keyboard_port, gBuffer, 0);
+		status = FPGA_PS2_STATUS_REGISTER;
+		pr_debug(DRIVER_NAME ": status read 0x%x\n", status);
+	}
+	/* Trigger timer again */
+	read_timer.expires = jiffies + HZ/20; /* Schedule next interrupt in 50 msec */
+	add_timer(&read_timer);
+#endif /* HARDWARE_INTERRUPT_ACTIVATED */
+}
+
+/* Check if FPGA was loaded with PS/2 IP */
+static int apf9328keyboard_checkinterface(void)
+{
+	int status = 0;
+
+	/* Try to access test register */
+	if (FPGA_PS2_ID_REGISTER != FPGA_PS2_ID_VALUE) {
+		status = -ENOMEM;
+	} else {
+		/* Flush Fifo */
+		apf9328keyboard_flush();
+	}
+
+	return status;
+}
+
+/* Initialize structure to communicate with upper layer: input/serio */
+static struct serio * __init apf9328keyboard_allocate_serio(void)
+{
+	struct serio *serio;
+	
+	serio = kmalloc(sizeof(struct serio), GFP_KERNEL);
+	if (serio) {
+		memset(serio, 0, sizeof(struct serio));
+		serio->id.type = apf9328keyboard_mode;
+	/*        serio->write = apf9328keyboard_write, UNCOMMENT THIS ONLY IF YOU WANT TO HAVE HOST->KEYBOARD COMM (YOU WILL HAVE TO IMPLEMENTE WRITE) */
+		strlcpy(serio->name, "APF9328 AT/XT keyboard adapter", sizeof(serio->name));
+		strlcpy(serio->phys, "Spartan3 PS/2", sizeof(serio->phys));
+	}
+	
+	return serio;
+}
+
+static int __init apf9328keyboard_init( void )
+{
+	int err;
+
+	/* Check if FPGA was correctly loaded */
+	err = apf9328keyboard_checkinterface();
+	if (err) {
+		printk(KERN_ERR DRIVER_NAME ": Unable to find PS/2 controller. This driver requires a board with a FPGA loaded with the right IP!\n" );
+		return(err);
+	}
+
+	/* Register our driver to upper layer (input/serio) */
+	apf9328keyboard_port = apf9328keyboard_allocate_serio();
+	if (!apf9328keyboard_port) {
+		return(-ENOMEM);
+	}
+	serio_register_port(apf9328keyboard_port);
+
+	/* Initialize and trigger read timer (when no hardware interrupt is available on controller) */
+	init_timer(&read_timer);
+	read_timer.expires = jiffies + HZ; /* Schedule next interrupt in 1 sec */
+	read_timer.data = 0;
+	read_timer.function = apf9328keyboard_interrupt;
+	add_timer(&read_timer);
+
+	printk(KERN_INFO DRIVER_NAME " v" DRIVER_VERSION ": APF9328KBD %s adapter OK!\n", apf9328keyboard_mode ? "AT" : "XT");
+
+	return 0;
+}
+
+static void __exit apf9328keyboard_exit( void )
+{
+	del_timer(&read_timer);
+	serio_unregister_port(apf9328keyboard_port);
+	/*kfree( apf9328keyboard_port ); ?? */
+	printk( KERN_INFO DRIVER_NAME ": successfully unloaded\n" );
+}
+
+
+module_init(apf9328keyboard_init);
+module_exit(apf9328keyboard_exit);
+
+MODULE_AUTHOR("Julien Boibessot, Michael Lerjen");
+MODULE_DESCRIPTION("Armadeus APF9328 PS/2 keyboard controller driver");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/Kconfig linux-3.13/drivers/armadeus/fpga/virtual_components/Kconfig
--- linux-3.13/drivers/armadeus/fpga/virtual_components/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,15 @@
+config ARMADEUS_FPGA_VIRTUAL_COMPONENTS
+	boolean "virtual components"
+	default y
+	depends on ARMADEUS_FPGA_DRIVERS
+	---help---
+	  Armadeus driver specific for virtual components
+	  under FPGA.
+
+source "drivers/armadeus/fpga/virtual_components/irq_mngr/Kconfig"
+source "drivers/armadeus/fpga/virtual_components/button/Kconfig"
+source "drivers/armadeus/fpga/virtual_components/led/Kconfig"
+source "drivers/armadeus/fpga/virtual_components/pod_gpio/Kconfig"
+source "drivers/armadeus/fpga/virtual_components/pod_pwm/Kconfig"
+source "drivers/armadeus/fpga/virtual_components/pod_servo/Kconfig"
+source "drivers/armadeus/fpga/virtual_components/sploader/Kconfig"
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/Makefile linux-3.13/drivers/armadeus/fpga/virtual_components/Makefile
--- linux-3.13/drivers/armadeus/fpga/virtual_components/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,3 @@
+
+obj-$(CONFIG_ARMADEUS_FPGA_VIRTUAL_COMPONENTS) += button/ irq_mngr/ led/ pod_gpio/ sploader/ pod_pwm/ pod_servo/
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/button/Kconfig linux-3.13/drivers/armadeus/fpga/virtual_components/button/Kconfig
--- linux-3.13/drivers/armadeus/fpga/virtual_components/button/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/button/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,8 @@
+
+config ARMADEUS_FPGA_VIRTUAL_COMPONENTS_BUTTON
+	tristate "button"
+	default n
+	depends on ARMADEUS_FPGA_VIRTUAL_COMPONENTS
+	---help---
+	  Armadeus driver for virtual button component.
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/button/Makefile linux-3.13/drivers/armadeus/fpga/virtual_components/button/Makefile
--- linux-3.13/drivers/armadeus/fpga/virtual_components/button/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/button/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,26 @@
+#
+# Makefile for the Armadeus FPGA button driver
+#
+
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+# Part executed when called from kernel build system:
+
+obj-$(CONFIG_ARMADEUS_FPGA_VIRTUAL_COMPONENTS_BUTTON)	+= button_ocore.o
+button_ocore-objs := gbutton.o
+
+else
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+
+ARMADEUS_BASE_DIR=../../../../../..
+-include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+CC = $(ARMADEUS_TOOLCHAIN_PATH)/arm-linux-gcc
+KDIR := $(ARMADEUS_LINUX_DIR)
+PWD  := $(shell pwd)
+
+test:
+	$(CC) -Wall testbutton.c -o testbutton
+	chmod 755 testbutton
+
+endif
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/button/button.h linux-3.13/drivers/armadeus/fpga/virtual_components/button/button.h
--- linux-3.13/drivers/armadeus/fpga/virtual_components/button/button.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/button/button.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,38 @@
+/*
+ * Platform data for generic button IP driver
+ *
+ * (c) Copyright 2007-2011    The Armadeus Project - ARMadeus Systems
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __BUTTON_H__
+#define __BUTTON_H__
+
+#define BUTTON_NUMBER 1
+#define BUTTON_REG_OFFSET (0x02)
+#define BUTTON_ID_OFFSET  (0x00)
+
+/* platform device */
+struct plat_button_port {
+	const char *name;	/* instance name */
+	int num;		/* instance number */
+	int idnum;		/* identity number */
+	int idoffset;		/* identity relative address */
+	struct button_dev *sdev;/* struct for main device structure */
+};
+
+#endif /* __BUTTON_H__ */
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/button/gbutton.c linux-3.13/drivers/armadeus/fpga/virtual_components/button/gbutton.c
--- linux-3.13/drivers/armadeus/fpga/virtual_components/button/gbutton.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/button/gbutton.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,333 @@
+/*
+ * Generic driver for Wishbone button IP
+ *
+ * (c) Copyright 2008-2011    The Armadeus Project - ARMadeus Systems
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fs.h>		/* for file  operations */
+#include <linux/cdev.h>
+#include <linux/ioport.h>	/* request_mem_region */
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)
+#include <linux/slab.h>		/* kmalloc */
+#endif
+
+#include <asm/uaccess.h>	/* copy_to_user function */
+#include <asm/io.h>		/* readw() writew() */
+
+#include "button.h"
+
+struct button_dev {
+	char *name;		/* name of the instance */
+	struct cdev cdev;	/* char device structure */
+	struct semaphore sem;	/* mutex */
+	void *membase;		/* base address for instance  */
+	dev_t devno;		/* to store Major and minor numbers */
+	u8 read_in_wait;	/* user is waiting for value to read */
+	struct resource *mem_res;
+	struct resource *irq_res;
+};
+
+ssize_t button_read(struct file *fildes, char __user * buff,
+		    size_t count, loff_t * offp)
+{
+	struct button_dev *ldev = fildes->private_data;
+	u16 data = 0;
+	ssize_t retval = 0;
+
+	ldev->read_in_wait = 1;
+
+	if (*offp + count >= 1)	/* Only one word can be read */
+		count = 1 - *offp;
+
+	if ((retval = down_interruptible(&ldev->sem)) < 0) {
+		goto out;
+	}
+
+	data = readw(ldev->membase + BUTTON_REG_OFFSET);
+	pr_debug("Read %d at 0x%x\n", data,
+		 (unsigned int)ldev->membase + BUTTON_REG_OFFSET);
+
+	/* return data for user */
+	if (copy_to_user(buff, &data, 2)) {
+		printk(KERN_WARNING "read : copy to user data error\n");
+		retval = -EFAULT;
+		goto out;
+	}
+
+	*offp = *offp + count;
+	retval = 1;
+
+out:
+	ldev->read_in_wait = 0;
+	return retval;
+}
+
+int button_open(struct inode *inode, struct file *filp)
+{
+	/* Allocate and fill any data structure to be put in filp->private_data */
+	filp->private_data =
+	    container_of(inode->i_cdev, struct button_dev, cdev);
+
+	return 0;
+}
+
+int button_release(struct inode *inode, struct file *filp)
+{
+	struct button_dev *dev;
+
+	dev = container_of(inode->i_cdev, struct button_dev, cdev);
+	filp->private_data = NULL;
+
+	return 0;
+}
+
+static struct file_operations button_fops = {
+	.owner = THIS_MODULE,
+	.read = button_read,
+	.open = button_open,
+	.release = button_release,
+};
+
+static irqreturn_t button_interrupt(int irq, void *dev_id)
+{
+	struct button_dev *ldev = dev_id;
+
+	/* wake up reading process */
+	if (ldev->read_in_wait)
+		up(&ldev->sem);
+
+	return IRQ_HANDLED;
+}
+
+static int button_probe(struct platform_device *pdev)
+{
+	struct plat_button_port *pdata = pdev->dev.platform_data;
+	int ret = 0;
+	int button_major, button_minor;
+	u16 ip_id;
+	struct button_dev *sdev;
+	struct resource *mem_res;
+	struct resource *irq_res;
+
+	pr_debug("Button probing\n");
+	pr_debug("Register %s num %d\n", pdata->name, pdata->num);
+
+	if (!pdata) {
+		dev_err(&pdev->dev, "Platform data required !\n");
+		return -ENODEV;
+	}
+
+	/* get resources */
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "can't find mem resource\n");
+		return -EINVAL;
+	}
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!irq_res) {
+		dev_err(&pdev->dev, "can't find irq resource\n");
+		return -EINVAL;
+	}
+
+	mem_res =
+	    request_mem_region(mem_res->start, resource_size(mem_res),
+			       pdev->name);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "iomem already in use\n");
+		return -EBUSY;
+	}
+
+	/* allocate memory for private structure */
+	sdev = kmalloc(sizeof(struct button_dev), GFP_KERNEL);
+	if (!sdev) {
+		ret = -ENOMEM;
+		goto out_release_mem;
+	}
+
+	sdev->membase = ioremap(mem_res->start, resource_size(mem_res));
+	if (!sdev->membase) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto out_dev_free;
+	}
+	sdev->mem_res = mem_res;
+	sdev->irq_res = irq_res;
+
+	/* check if ID is correct */
+	ip_id = readw(sdev->membase + BUTTON_ID_OFFSET);
+	if (ip_id != pdata->idnum) {
+		ret = -ENODEV;
+		dev_warn(&pdev->dev, "For %s id:%d doesn't match "
+			 "with id read %d,\n is device present ?\n",
+			 pdata->name, pdata->idnum, ip_id);
+		goto out_iounmap;
+	}
+
+	pdata->sdev = sdev;
+
+	sdev->name = (char *)kmalloc((1 + strlen(pdata->name)) * sizeof(char),
+				     GFP_KERNEL);
+	if (sdev->name == NULL) {
+		dev_err(&pdev->dev, "Kmalloc name space error\n");
+		goto out_iounmap;
+	}
+	if (strncpy(sdev->name, pdata->name, 1 + strlen(pdata->name)) < 0) {
+		printk("copy error");
+		goto out_name_free;
+	}
+
+	/* Get the major and minor device numbers */
+	button_major = 251;
+	button_minor = pdata->num;
+
+	sdev->devno = MKDEV(button_major, button_minor);
+	ret = alloc_chrdev_region(&(sdev->devno), button_minor, 1, pdata->name);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "%s: can't get major %d\n",
+			 pdata->name, button_major);
+		goto out_name_free;
+	}
+	dev_info(&pdev->dev, "%s: MAJOR: %d MINOR: %d\n",
+		 pdata->name, MAJOR(sdev->devno), MINOR(sdev->devno));
+
+	/* initiate mutex locked */
+	sdev->read_in_wait = 0;
+	sema_init(&sdev->sem, 0);
+
+	/* Init the cdev structure  */
+	cdev_init(&sdev->cdev, &button_fops);
+	sdev->cdev.owner = THIS_MODULE;
+	sdev->cdev.ops = &button_fops;
+
+	pr_debug("%s: Add the device to the kernel, "
+		 "connecting cdev to major/minor number \n", pdata->name);
+	ret = cdev_add(&sdev->cdev, sdev->devno, 1);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "%s: can't add cdev\n", pdata->name);
+		goto out_cdev_free;
+	}
+
+	/* irq registering */
+	ret = request_irq(sdev->irq_res->start,
+			  button_interrupt,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+			  IRQF_SAMPLE_RANDOM,
+#else
+			  0,
+#endif
+			  sdev->name, sdev);
+	if (ret < 0) {
+		printk(KERN_ERR "Can't register irq %d\n",
+		       sdev->irq_res->start);
+		goto request_irq_error;
+	}
+
+	/* OK driver ready ! */
+	printk(KERN_INFO "%s loaded\n", pdata->name);
+	return 0;
+
+	free_irq(sdev->irq_res->start, sdev);
+request_irq_error:
+	cdev_del(&sdev->cdev);
+	pr_debug("%s:cdev deleted\n", pdata->name);
+out_cdev_free:
+	unregister_chrdev_region(sdev->devno, 1);
+	printk(KERN_INFO "%s: button deleted\n", pdata->name);
+out_name_free:
+	kfree(sdev->name);
+out_iounmap:
+	iounmap(sdev->membase);
+out_dev_free:
+	kfree(sdev);
+out_release_mem:
+	release_mem_region(mem_res->start, resource_size(mem_res));
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,8,0)
+/* __dev* stuff is removed from Linux since 30/11/2012 */
+#define __devexit
+#if defined(MODULE) || defined(CONFIG_HOTPLUG)
+# define __devexit_p(x) x
+# else
+# define __devexit_p(x) NULL
+# endif
+#endif
+
+static int __devexit button_remove(struct platform_device *pdev)
+{
+	struct plat_button_port *pdata = pdev->dev.platform_data;
+	struct button_dev *sdev = (*pdata).sdev;
+
+	free_irq(sdev->irq_res->start, sdev);
+
+	cdev_del(&sdev->cdev);
+	pr_debug("%s:cdev deleted\n", pdata->name);
+
+	unregister_chrdev_region(sdev->devno, 1);
+	printk(KERN_INFO "%s: button deleted\n", pdata->name);
+
+	kfree(sdev->name);
+	iounmap(sdev->membase);
+	kfree(sdev);
+	release_mem_region(sdev->mem_res->start, resource_size(sdev->mem_res));
+	printk(KERN_INFO "%s: deleted with success\n", pdata->name);
+
+	return 0;
+}
+
+static struct platform_driver plat_button_driver = {
+	.probe = button_probe,
+	.remove = __devexit_p(button_remove),
+	.driver = {
+		.name = "button",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init button_init(void)
+{
+	int ret;
+
+	pr_debug("Platform driver name %s", plat_button_driver.driver.name);
+	ret = platform_driver_register(&plat_button_driver);
+	if (ret) {
+		printk(KERN_ERR "Platform driver register error\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit button_exit(void)
+{
+	platform_driver_unregister(&plat_button_driver);
+}
+
+module_init(button_init);
+module_exit(button_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Fabien Marteau <fabien.marteau@armadeus.com>");
+MODULE_DESCRIPTION("Wishbone button IP generic driver");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/button/testbutton.c linux-3.13/drivers/armadeus/fpga/virtual_components/button/testbutton.c
--- linux-3.13/drivers/armadeus/fpga/virtual_components/button/testbutton.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/button/testbutton.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,93 @@
+/* 
+ * A simple program to test Wishbone button driver
+ *
+ * (c) Copyright 2008    Armadeus project
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ **********************************************************************
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <signal.h>
+
+int fd_button;
+
+void quit(int signal)
+{
+    close(fd_button);
+    exit(0);
+}
+
+void usage(char *prog_name)
+{
+    if (prog_name) {
+        printf("\nUsage:\n");
+        printf("%s <button_device> [count]\n", prog_name);
+    }
+}
+
+int main(int argc, char *argv[])
+{
+    unsigned short value=0;
+    int count=0, max_count=0;
+
+    /* quit when Ctrl-C is pressed */
+    signal(SIGINT, quit);
+
+    if (argc < 2) {
+        printf("invalid arguments number\n");
+        usage(argv[0]);
+        exit(EXIT_FAILURE);
+    }
+
+    fd_button = open(argv[1], O_RDWR);
+    if (fd_button < 0) {
+        perror("can't open file");
+        exit(EXIT_FAILURE);
+    }
+
+    if (argc == 3)
+        max_count = atoi(argv[2]);
+
+    printf("Press button\n");
+
+    while (1) {
+        /* read value (blocking) */
+        if (read(fd_button, &value, 1) < 0) {
+            perror("read error");
+            exit(EXIT_FAILURE);
+        }
+        printf("Read %d\n", value);
+        count++;
+        if (max_count && (count >= max_count))
+            break;
+
+/* needed ?
+        if (lseek(fd_button, 0, SEEK_SET) < 0) {
+            perror("lseek error");
+            exit(EXIT_FAILURE);
+        }
+*/
+    }
+
+    close(fd_button);
+    exit(0);
+}
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/Kconfig linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/Kconfig
--- linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,8 @@
+
+config ARMADEUS_FPGA_VIRTUAL_COMPONENTS_IRQ_MNGR
+	tristate "irq manager"
+	default n
+	depends on ARMADEUS_FPGA_VIRTUAL_COMPONENTS
+	---help---
+	  Armadeus driver for virtual irq_mngr component
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/Makefile linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/Makefile
--- linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,4 @@
+
+obj-$(CONFIG_ARMADEUS_FPGA_VIRTUAL_COMPONENTS_IRQ_MNGR) += irq_ocore.o
+irq_ocore-objs := main.o
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/irq_mng.h linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/irq_mng.h
--- linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/irq_mng.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/irq_mng.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,32 @@
+/*
+ * Platform data for IRQ manager generic driver
+ *
+ * (c) Copyright 2011    The Armadeus Project - ARMadeus Systems
+ * Author: Julien Bibessot <julien.boibessot@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __IRQ_MNG_H__
+#define __IRQ_MNG_H__
+
+struct ocore_irq_mng_pdata {
+	int num;		/* instance number */
+	int idnum;		/* identity number */
+	int idoffset;		/* identity register relative address */
+	struct irq_mng *mng;
+};
+
+#endif /* __IRQ_MNG_H__ */
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/main.c linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/main.c
--- linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/main.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,381 @@
+/*
+ * Driver for the IRQ manager (OpenCore/Wishbone based) IP
+ *
+ * (C) Copyright 2008-2013 Armadeus Systems
+ * Author: Julien Boibessot <julien.boibessot@armadeus.com>
+ *
+ * Inspired of linux/arch/arm/mach-imx/irq.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*#define DEBUG*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)
+#include <linux/slab.h>		/* kmalloc */
+#endif
+#include <linux/irq.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0)
+# include <mach/hardware.h>
+# include <mach/irqs.h>
+#endif
+#include <asm/irq.h>
+#include <asm/io.h> /* readb() & Co */
+#include <asm/mach/irq.h>
+
+#include "irq_mng.h"
+
+#ifndef CONFIG_MACH_APF9328
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0)
+# include <mach/fpga.h> /* To remove when MX1 platform is merged */
+#else
+# include <linux/../../arch/arm/mach-imx/fpga.h>
+#endif
+#endif
+
+#define ID_OFFSET	(0x02 *(16/8))
+#define NB_IT		16
+#define FPGA_IMR	0x00 /* Interrupt Mask Register relative @ */
+#define FPGA_ISR	0x02 /* Interrupt Status Register relative @ */
+
+#define DRIVER_NAME	"ocore_irq_mng"
+
+struct irq_mng {
+	void *membase;
+	struct resource *mem_res;
+	struct resource *irq_res;
+};
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,36)
+struct irq_mng global_mng;
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,39)
+static int imx_fpga_irq_type(struct irq_data *data, unsigned int flow_type)
+{
+	return 0;
+}
+#else
+static int imx_fpga_irq_type(unsigned int _irq, unsigned int type)
+{
+	return 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,36)
+static void imx_fpga_ack_irq(struct irq_data *data)
+{
+	struct irq_mng *mng = irq_data_get_irq_chip_data(data);
+	unsigned int irq = data->irq;
+#else
+static void imx_fpga_ack_irq(unsigned int irq)
+{
+	struct irq_mng *mng = &global_mng;
+#endif
+	int shadow;
+
+	shadow = 1 << ((irq - IRQ_FPGA_START) % NB_IT);
+	pr_debug("%s: irq %d ack:0x%x\n", __FUNCTION__, irq, shadow);
+	writew(shadow, mng->membase + FPGA_ISR);
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,36)
+static void imx_fpga_mask_irq(struct irq_data *data)
+{
+	struct irq_mng *mng = irq_data_get_irq_chip_data(data);
+	unsigned int irq = data->irq;
+#else
+static void imx_fpga_mask_irq(unsigned int irq)
+{
+	struct irq_mng *mng = &global_mng;
+#endif
+	int shadow;
+
+	shadow = readw(mng->membase + FPGA_IMR);
+	shadow &= ~( 1 << ((irq - IRQ_FPGA_START) % NB_IT));
+	pr_debug("%s: irq %d mask:0x%x\n", __FUNCTION__, irq, shadow);
+	writew(shadow, mng->membase + FPGA_IMR);
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,36)
+static void imx_fpga_unmask_irq(struct irq_data *data)
+{
+	struct irq_mng *mng = irq_data_get_irq_chip_data(data);
+	unsigned int irq = data->irq;
+#else
+static void imx_fpga_unmask_irq(unsigned int irq)
+{
+	struct irq_mng *mng = &global_mng;
+#endif
+	int shadow;
+
+	shadow = readw(mng->membase + FPGA_IMR);
+	shadow |= 1 << ((irq - IRQ_FPGA_START) % NB_IT);
+	pr_debug("%s: irq %d mask:0x%x\n", __FUNCTION__, irq, shadow);
+	writew(shadow, mng->membase + FPGA_IMR);
+}
+
+static irqreturn_t ocore_irq_mng_interrupt(int irq, void *data)
+{
+	struct irq_mng *mng = data;
+	struct irq_desc *desc;
+	unsigned int mask;
+
+	mask = readw(mng->membase + FPGA_ISR);
+	pr_debug("%s: mask:0x%04x\n", __FUNCTION__, mask);
+	do {
+		irq = IRQ_FPGA_START;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)
+		desc = irq_to_desc(irq);
+#else
+		desc = irq_desc + irq;
+#endif
+
+		/* handle irqs */
+		while (mask) {
+			if (mask & 1) {
+				pr_debug("handling irq %d 0x%08x\n", irq,
+						(unsigned int)desc);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,39)
+				desc->handle_irq(irq, desc);
+#else
+				desc_handle_irq(irq, desc);
+#endif
+			}
+			irq++;
+			desc++;
+			mask >>= 1;
+		}
+		mask = readw(mng->membase + FPGA_ISR);
+	} while (mask != 0);
+
+	return IRQ_HANDLED;
+}
+
+static struct irq_chip imx_fpga_chip = {
+	.name		= "FPGA",
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,36)
+	.irq_ack	= imx_fpga_ack_irq,
+	.irq_mask	= imx_fpga_mask_irq,
+	.irq_unmask	= imx_fpga_unmask_irq,
+#else
+	.ack		= imx_fpga_ack_irq,
+	.mask		= imx_fpga_mask_irq,
+	.unmask		= imx_fpga_unmask_irq,
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,39)
+	.irq_set_type	= imx_fpga_irq_type,
+#else
+	.set_type	= imx_fpga_irq_type,
+#endif
+};
+
+#ifdef CONFIG_PM
+static int ocore_irq_mng_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	dev_dbg(&pdev->dev, "suspended\n");
+
+	return 0;
+}
+
+static int ocore_irq_mng_resume(struct platform_device *pdev)
+{
+	dev_dbg(&pdev->dev, "resumed\n");
+
+	return 0;
+}
+#else
+# define ocore_irq_mng_suspend NULL
+# define ocore_irq_mng_resume NULL
+#endif /* CONFIG_PM */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,8,0)
+/* __dev* stuff is removed from Linux since 30/11/2012 */
+#define __devinit
+#define __devexit
+#endif
+
+static int __devinit ocore_irq_mng_probe(struct platform_device *pdev)
+{
+	struct ocore_irq_mng_pdata *pdata = pdev->dev.platform_data;
+	unsigned int irq;
+	u16 id;
+	int ret = 0;
+	struct resource *mem_res;
+	struct resource *irq_res;
+	struct irq_mng *mng;
+
+	if (!pdata) {
+		dev_err(&pdev->dev, "Platform data required !\n");
+		return -ENODEV;
+	}
+
+	/* get resources */
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "can't find mem resource\n");
+		return -EINVAL;
+	}
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!irq_res) {
+		dev_err(&pdev->dev, "can't find irq resource\n");
+		return -EINVAL;
+	}
+
+	mem_res = request_mem_region(mem_res->start, resource_size(mem_res), pdev->name);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "iomem already in use\n");
+		return -EBUSY;
+	}
+
+	/* allocate memory for private structure */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,36)
+	mng = kmalloc(sizeof(struct irq_mng), GFP_KERNEL);
+#else
+	mng = &global_mng;
+#endif
+	if (!mng) {
+		ret = -ENOMEM;
+		goto out_release_mem;
+	}
+	pdata->mng = mng;
+
+	mng->membase = ioremap(mem_res->start, resource_size(mem_res));
+	if (!mng->membase) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto out_dev_free;
+	}
+	mng->mem_res = mem_res;
+	mng->irq_res = irq_res;
+
+	/* check if ID is correct */
+	id = readw(mng->membase + ID_OFFSET);
+	if (id != pdata->idnum) {
+		printk(KERN_WARNING "For irq_mngr id:%d doesn't match with id"
+			"read %d,\n is device present ?\n", pdata->idnum, id);
+		ret = -ENODEV;
+		goto out_iounmap;
+	}
+
+	/* Mask all interrupts initially */
+	writew(0, mng->membase + FPGA_IMR);
+
+	for (irq = IRQ_FPGA(0); irq < IRQ_FPGA(NB_IT); irq++) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,39)
+		irq_set_chip_data(irq, mng);
+		irq_set_chip_and_handler_name(irq, &imx_fpga_chip,
+						handle_edge_irq, NULL);
+#else
+		set_irq_chip_data(irq, mng);
+		set_irq_chip_and_handler(irq, &imx_fpga_chip, handle_edge_irq);
+#endif
+		set_irq_flags(irq, IRQF_VALID);
+	}
+	/* clear pending interrupts */
+	writew(0xffff, mng->membase + FPGA_ISR);
+
+	ret = request_irq(mng->irq_res->start, ocore_irq_mng_interrupt,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+				IRQF_SAMPLE_RANDOM,
+#else
+				0,
+#endif
+				"ocore_irq_mng", mng);
+
+	if (ret < 0) {
+		printk(KERN_ERR "Can't register irq %d\n",
+			   mng->irq_res->start);
+		goto request_irq_error;
+	}
+
+	pr_debug("FPGA IRQs initialized (Parent=%d)\n", mng->irq_res->start);
+
+	return 0;
+
+request_irq_error:
+out_iounmap:
+	iounmap(mng->membase);
+out_dev_free:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,36)
+	kfree(mng);
+#endif
+out_release_mem:
+	release_mem_region(mem_res->start, resource_size(mem_res));
+
+	return ret;
+}
+
+static int __devexit ocore_irq_mng_remove(struct platform_device *pdev)
+{
+	struct ocore_irq_mng_pdata *pdata = pdev->dev.platform_data;
+	struct irq_mng *mng = pdata->mng;
+	unsigned int irq;
+
+	for (irq = IRQ_FPGA(0); irq < IRQ_FPGA(NB_IT); irq++) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,39)
+		irq_set_chip(irq, NULL);
+		irq_set_handler(irq, NULL);
+#else
+		set_irq_chip(irq, NULL);
+		set_irq_handler(irq, NULL);
+#endif
+		set_irq_flags(irq, 0);
+	}
+	free_irq(mng->irq_res->start, mng);
+	release_mem_region(mng->mem_res->start, resource_size(mng->mem_res));
+	iounmap(mng->membase);
+	kfree(mng);
+
+	return 0;
+}
+
+static struct platform_driver ocore_irq_mng_driver = {
+	.probe      = ocore_irq_mng_probe,
+	.remove     = ocore_irq_mng_remove,
+	.suspend    = ocore_irq_mng_suspend,
+	.resume     = ocore_irq_mng_resume,
+	.driver     = {
+		.name   = DRIVER_NAME,
+	},
+};
+
+static int __init ocore_irq_mng_init(void)
+{
+	return platform_driver_register(&ocore_irq_mng_driver);
+}
+
+static void __exit ocore_irq_mng_exit(void)
+{
+	platform_driver_unregister(&ocore_irq_mng_driver);
+}
+
+module_init(ocore_irq_mng_init);
+module_exit(ocore_irq_mng_exit);
+
+MODULE_AUTHOR("Julien Boibessot, <julien.boibessot@armadeus.com>");
+MODULE_DESCRIPTION("Armadeus OpenCore IRQ manager");
+MODULE_LICENSE("GPL");
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/linux-3.13/drivers/armadeus.order linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/linux-3.13/drivers/armadeus.order
--- linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/linux-3.13/drivers/armadeus.order	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/linux-3.13/drivers/armadeus.order	2013-12-07 13:42:48.000000000 +0100
@@ -0,0 +1 @@
+kernel/linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/irq_ocore.ko
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/test.c linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/test.c
--- linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/test.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/irq_mngr/test.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,82 @@
+/*
+ * Driver to test OpenCore IRQ manager driver
+ *
+ * Copyright (C) 2008-2011 ARMadeus Systems
+ * Author: Julien Boibessot <julien.boibessot@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+
+#include <asm/irq.h>
+#ifndef CONFIG_MACH_APF9328
+#include <mach/fpga.h> /* To remove when MX1 platform is merged*/
+#endif
+
+
+/* Module's parameters: */
+static int interrupt = IRQ_FPGA(3);
+module_param(interrupt, int, 0000);
+MODULE_PARM_DESC(interrupt, "IT to request");
+
+#define DRIVER_NAME "IRQ test module"
+
+
+static irqreturn_t fpga_interrupt(int irq,void *dev_id,struct pt_regs *reg)
+{
+	printk(KERN_ERR "FPGA IT n%d\n", irq);
+
+	return IRQ_HANDLED;
+}
+
+unsigned int data;
+
+static int __init irq_mng_test_init(void)
+{
+	int result;
+	
+	/* IRQ registering */
+	if ((result = request_irq(interrupt, (irq_handler_t)fpga_interrupt,
+				/*IRQF_SHARED*/0, "ocore_irq_test", &data)) < 0) {
+		printk(KERN_ERR "Can't request IRQ n%d\n", interrupt);
+		goto error;
+	}
+	
+	printk(KERN_INFO DRIVER_NAME " inserted (IRQ %d reserved), be sure to "
+		"have correspondig IP loaded in the FPGA !\n", interrupt);
+	return 0;
+	
+error:
+	return result;
+}
+
+static void __exit irq_mng_test_exit(void)
+{
+	printk(DRIVER_NAME " unloaded\n");
+	free_irq(interrupt, 0); /* still a bug here ! */
+}
+
+module_init(irq_mng_test_init);
+module_exit(irq_mng_test_exit);
+
+MODULE_AUTHOR("Julien Boibessot, <julien.boibessot@armadeus.com>");
+MODULE_DESCRIPTION("OpenCore IRQ manager IP's test driver");
+MODULE_LICENSE("GPL");
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/led/Kconfig linux-3.13/drivers/armadeus/fpga/virtual_components/led/Kconfig
--- linux-3.13/drivers/armadeus/fpga/virtual_components/led/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/led/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,7 @@
+
+config ARMADEUS_FPGA_VIRTUAL_COMPONENTS_LED
+	tristate "led"
+	default n
+	depends on ARMADEUS_FPGA_VIRTUAL_COMPONENTS
+	---help---
+	  Armadeus driver for virtual led component.
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/led/Makefile linux-3.13/drivers/armadeus/fpga/virtual_components/led/Makefile
--- linux-3.13/drivers/armadeus/fpga/virtual_components/led/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/led/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,18 @@
+#
+# Makefile for the Armadeus FPGA led driver
+#
+
+obj-$(CONFIG_ARMADEUS_FPGA_VIRTUAL_COMPONENTS_LED) := led_ocore.o
+led_ocore-objs := g_led.o
+
+ARMADEUS_BASE_DIR=../../../../../..
+-include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR := $(ARMADEUS_LINUX_DIR)
+PWD  := $(shell pwd)
+
+test:
+	$(ARMADEUS_TOOLCHAIN_PATH)/arm-linux-gcc -Wall testled.c -o testled
+	chmod 755 testled
+
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/led/g_led.c linux-3.13/drivers/armadeus/fpga/virtual_components/led/g_led.c
--- linux-3.13/drivers/armadeus/fpga/virtual_components/led/g_led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/led/g_led.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,328 @@
+/*
+ * Generic driver for Wishbone LED IP
+ *
+ * (c) Copyright 2008	Armadeus project
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/ioport.h>	/* request_mem_region */
+#include <linux/platform_device.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)
+#include <linux/slab.h>		/* kmalloc */
+#endif
+
+#include <asm/uaccess.h>	/* copy_to_user function */
+#include <asm/io.h>		/* readw() writew() */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,9)
+#include <mach/hardware.h>
+#endif
+
+#include "led.h"
+
+/* main device structure */
+struct led_dev {
+	char *name;		/* the name of the instance */
+	int  loaded_led_num;/* number of the led, depends on load order*/
+	struct cdev cdev;/* Char device structure */
+	void * membase;  /* base address for instance  */
+	dev_t devno;	 /* to store Major and minor numbers */
+	struct resource *mem_res;
+};
+
+ssize_t led_read(struct file *fildes, char __user *buff,
+				 size_t count, loff_t *offp);
+
+ssize_t led_write(struct file *fildes, const char __user *
+				  buff,size_t count, loff_t *offp);
+int led_open(struct inode *inode, struct file *filp);
+
+int led_release(struct inode *, struct file *filp);
+
+struct file_operations led_fops = {
+	.owner = THIS_MODULE,
+	.read  = led_read,
+	.write = led_write,
+	.open  = led_open,
+	.release = led_release,
+};
+
+/***********************************
+ * characters file /dev operations
+ * *********************************/
+ssize_t led_read(struct file *fildes, char __user *buff,
+				 size_t count, loff_t *offp)
+{
+	struct led_dev *sdev = fildes->private_data;
+	u16 data=0;
+
+	pr_debug("Read value\n");
+	if (*offp != 0) { /* offset must be 0 */
+		pr_debug("offset %d\n", (int)*offp);
+		return 0;
+	}
+
+	pr_debug("count %d\n", count);
+	if (count > 2) { /* 16bits max*/
+		count = 2; 
+	}
+
+	data = readw(sdev->membase + LED_REG_OFFSET);
+	pr_debug("Read %d at %x\n", data, (int)(sdev->membase + LED_REG_OFFSET));
+
+	/* return data for user */
+	if (copy_to_user(buff, &data, count)) {
+		printk(KERN_WARNING "read : copy to user data error\n");
+		return -EFAULT;
+	}
+	return count;
+}
+
+ssize_t led_write(struct file *fildes, const char __user *
+				  buff,size_t count, loff_t *offp)
+{
+	struct led_dev *sdev = fildes->private_data;
+	u16 data = 0;
+
+	if (*offp != 0) { /* offset must be 0 */
+		pr_debug("offset %d\n", (int)*offp);
+		return 0;
+	}
+
+	pr_debug("count %d\n", count);
+	if (count > 2) { /* 16 bits max)*/
+		count = 2;
+	}
+
+	if (copy_from_user(&data, buff, count)) {
+		printk(KERN_WARNING "write : copy from user error\n");
+		return -EFAULT;
+	}
+
+	pr_debug("Write %d at %x\n",
+		   data,
+		   (int)(sdev->membase + LED_REG_OFFSET));
+	writew(data, sdev->membase + LED_REG_OFFSET);
+
+	return count;
+}
+
+int led_open(struct inode *inode, struct file *filp)
+{
+	/* Allocate and fill any data structure to be put in filp->private_data */
+	filp->private_data = container_of(inode->i_cdev, struct led_dev, cdev);
+	pr_debug("LED opened\n");
+	return 0;
+}
+
+int led_release(struct inode *inode, struct file *filp)
+{
+	struct led_dev *dev;
+
+	dev = container_of(inode->i_cdev, struct led_dev, cdev);
+	pr_debug("%s: released\n", dev->name);
+	filp->private_data=NULL;
+
+	return 0;
+}
+
+static int led_probe(struct platform_device *pdev)
+{
+	struct plat_led_port *pdata = pdev->dev.platform_data;
+	int ret = 0;
+	int led_major, led_minor;
+	u16 ip_id;
+	struct led_dev *sdev;
+	struct resource *mem_res;
+
+	pr_debug("LED probing\n");
+	pr_debug("Register %s num %d\n", pdata->name, pdata->num);
+
+	if (!pdata) {
+		dev_err(&pdev->dev, "Platform data required !\n");
+		return -ENODEV;
+	}
+
+	/* get resources */
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "can't find mem resource\n");
+		return -EINVAL;
+	}
+
+	mem_res =
+	    request_mem_region(mem_res->start, resource_size(mem_res),
+			       pdev->name);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "iomem already in use\n");
+		return -EBUSY;
+	}
+
+	/* allocate memory for private structure */
+	sdev = kmalloc(sizeof(struct led_dev), GFP_KERNEL);
+	if (!sdev) {
+		ret = -ENOMEM;
+		goto out_release_mem;
+	}
+
+	sdev->membase = ioremap(mem_res->start, resource_size(mem_res));
+	if (!sdev->membase) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto out_dev_free;
+	}
+	sdev->mem_res = mem_res;
+
+	/* check if ID is correct */
+	ip_id = readw(sdev->membase + pdata->idoffset);
+	if (ip_id != pdata->idnum) {
+		ret = -ENODEV;
+		printk(KERN_WARNING "For %s id:%d doesn't match with "
+			   "id read %d,\n is device present ?\n",
+			   pdata->name, pdata->idnum, ip_id);
+		goto out_iounmap;
+	}
+
+	pdata->sdev = sdev;
+	sdev->name = (char *)kmalloc((1+strlen(pdata->name))*sizeof(char), 
+								 GFP_KERNEL);
+	if (sdev->name == NULL) {
+		printk("Kmalloc name space error\n");
+		goto out_iounmap;
+	}
+	if (strncpy(sdev->name, pdata->name, 1+strlen(pdata->name)) < 0) {
+		printk("copy error");
+		goto out_name_free;
+	}
+
+	/* Get the major and minor device numbers */
+	led_major = 252;
+	led_minor = pdata->num;
+
+	sdev->devno = MKDEV(led_major, led_minor);
+	ret = alloc_chrdev_region(&(sdev->devno), led_minor, 1, pdata->name);
+	if (ret < 0) {
+		printk(KERN_WARNING "%s: can't get major %d\n", pdata->name, led_major);
+		goto out_name_free;
+	}
+	printk(KERN_INFO "%s: MAJOR: %d MINOR: %d\n",
+		   pdata->name,
+		   MAJOR(sdev->devno),
+		   MINOR(sdev->devno));
+
+	/* Init the cdev structure  */
+	pr_debug("Init the cdev structure\n");
+	cdev_init(&sdev->cdev, &led_fops);
+	sdev->cdev.owner = THIS_MODULE;
+	sdev->cdev.ops   = &led_fops;
+
+	/* Add the device to the kernel, connecting cdev to major/minor number */
+	pr_debug("%s:Add the device to the kernel, "
+		   "connecting cdev to major/minor number \n", pdata->name);
+	ret = cdev_add(&sdev->cdev, sdev->devno, 1);
+	if (ret) {
+		printk(KERN_WARNING "%s: can't add cdev\n", pdata->name);
+		goto out_cdev_free;
+	}
+
+	/* initialize LED value */
+	writew(1, sdev->membase);
+
+	/* OK module inserted ! */
+	printk(KERN_INFO "LED module %s inserted\n", pdata->name);
+	return 0;
+
+	cdev_del(&sdev->cdev);
+out_cdev_free:
+	unregister_chrdev_region(sdev->devno, 1);
+	printk(KERN_INFO "%s: LED deleted\n", pdata->name);
+out_name_free:
+	kfree(sdev->name);
+out_iounmap:
+	iounmap(sdev->membase);
+out_dev_free:
+	kfree(sdev);
+out_release_mem:
+	release_mem_region(mem_res->start, resource_size(mem_res));
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,8,0)
+/* __dev* stuff is removed from Linux since 30/11/2012 */
+#define __devexit
+#if defined(MODULE) || defined(CONFIG_HOTPLUG)
+# define __devexit_p(x) x
+# else
+# define __devexit_p(x) NULL
+# endif
+#endif
+
+static int __devexit led_remove(struct platform_device *pdev)
+{
+	struct plat_led_port *dev = pdev->dev.platform_data;
+	struct led_dev *sdev = (*dev).sdev;
+
+	pr_debug("Unregister %s, number %d\n", dev->name, dev->num);
+	pr_debug("cdev name : %s\n", sdev->name);
+	cdev_del(&sdev->cdev);
+	pr_debug("%s:cdev deleted\n", dev->name);
+	unregister_chrdev_region(sdev->devno, 1);
+	kfree(sdev->name);
+	iounmap(sdev->membase);
+	kfree(sdev);
+	release_mem_region(sdev->mem_res->start, resource_size(sdev->mem_res));
+	printk(KERN_INFO "%s: deleted with success\n", dev->name);
+
+	return 0;
+}
+
+static struct platform_driver plat_led_driver = {
+	.probe = led_probe,
+	.remove = __devexit_p(led_remove),
+	.driver	= {
+		.name	= "led",
+		.owner   = THIS_MODULE,
+	},
+};
+
+static int __init led_init(void)
+{
+	int ret;
+
+	pr_debug("Platform driver name %s\n", plat_led_driver.driver.name);
+	ret = platform_driver_register(&plat_led_driver);
+	return ret;
+}
+
+static void led_exit(void)
+{
+	platform_driver_unregister(&plat_led_driver);
+	pr_debug("driver unregistered\n");
+}
+
+module_init(led_init);
+module_exit(led_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Fabien Marteau <fabien.marteau@armadeus.com>");
+MODULE_DESCRIPTION("Wishbone IP LED device driver");
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/led/led.h linux-3.13/drivers/armadeus/fpga/virtual_components/led/led.h
--- linux-3.13/drivers/armadeus/fpga/virtual_components/led/led.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/led/led.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,35 @@
+/*
+ * Platform data for Wishbone LED IP driver
+ *
+ * (c) Copyright 2007-2011 The Armadeus Project - ARMadeus Systems
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef __LED_H__
+#define __LED_H__
+
+#define LED_REG_OFFSET (0x00)
+
+/* platform device */
+struct plat_led_port {
+	const char *name;	/* instance name  */
+	int num;		/* instance number */
+	int idnum;		/* identity number */
+	int idoffset;		/* identity relative address */
+	struct led_dev *sdev;	/* struct for main device structure*/
+};
+
+#endif /* __LED_H__ */
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/led/testled.c linux-3.13/drivers/armadeus/fpga/virtual_components/led/testled.c
--- linux-3.13/drivers/armadeus/fpga/virtual_components/led/testled.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/led/testled.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,132 @@
+/* a program to test led driver
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ * 7 april 2008
+ * fpgaaccess.h
+ *
+ * (c) Copyright 2008    Armadeus project
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ *
+ * A simple driver for reading and writing on
+ * fpga throught a character file /dev/fpgaaccess
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ **********************************************************************
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* file management */
+#include <sys/stat.h>
+#include <fcntl.h>
+
+/* as name said */
+#include <signal.h>
+
+/* sleep */
+#include <unistd.h>
+
+int fled;
+
+void quit(int pouet){
+    close(fled);
+    exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+    unsigned short i,j;
+
+    /* quit when Ctrl-C pressed */
+    signal(SIGINT, quit);
+
+    j=0;
+
+    printf( "Testing led driver\n" );
+
+    if(argc < 2){
+        perror("invalid arguments number\ntestled <led_filename>\n");
+        exit(EXIT_FAILURE);
+    }
+
+    while(1){
+        i = (i==0)?1:0;
+        fflush(stdout);
+
+        fled=open(argv[1],O_RDWR);
+        if(fled<0){
+            perror("can't open file \n");
+            exit(EXIT_FAILURE);
+        }
+
+        /* read value */
+        if(read(fled,&j,2)<0){
+            perror("read error\n");
+            exit(EXIT_FAILURE);
+        }
+        printf("Read %d\n",j);
+        close(fled);
+        sleep(1);
+
+        fled=open(argv[1],O_RDWR);
+        if(fled<0){
+            perror("can't open file \n");
+            exit(EXIT_FAILURE);
+        }
+
+        /* write value */
+        j = 0;
+        if(write(fled,&j,2)<=0){
+            perror("write error\n");
+            exit(EXIT_FAILURE);
+        }
+        close(fled);
+        printf("Write 0\n");
+        sleep(1);
+
+        fled=open(argv[1],O_RDWR);
+        if(fled<0){
+            perror("can't open file \n");
+            exit(EXIT_FAILURE);
+        }
+        /* read value */
+        if(read(fled,&j,2)<0){
+            perror("read error\n");
+            exit(EXIT_FAILURE);
+        }
+        close(fled);
+        printf("Read %d\n",j);
+        sleep(1);
+
+        fled=open(argv[1],O_RDWR);
+        if(fled<0){
+            perror("can't open file \n");
+            exit(EXIT_FAILURE);
+        }
+        /* write value */
+        j = 1;
+        if(write(fled,&j,2)<=0){
+            perror("write error\n");
+            exit(EXIT_FAILURE);
+        }
+        close(fled);
+        printf("Write 1\n");
+        sleep(1);
+
+    }
+
+    close(fled);
+    exit(0);
+}
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/Kconfig linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/Kconfig
--- linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,8 @@
+
+config ARMADEUS_FPGA_VIRTUAL_COMPONENTS_GPIO
+	tristate "pod_gpio"
+	default n
+	depends on ARMADEUS_FPGA_VIRTUAL_COMPONENTS
+	---help---
+	  Armadeus driver for virtual pod_gpio component.
+	  kernel >= 2.6.38 is required
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/Makefile linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/Makefile
--- linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for the Armadeus FPGA led driver
+#
+
+obj-$(CONFIG_ARMADEUS_FPGA_VIRTUAL_COMPONENTS_GPIO) := pod_gpio.o
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/pod_gpio.c linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/pod_gpio.c
--- linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/pod_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/pod_gpio.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,395 @@
+/*
+ * ARMadeus driver for the POD component pod_gpio
+ *
+ * (C) Copyright 2011 - Armadeus Systems <support@armadeus.com>
+ * Author: Kevin JOLY joly.kevin25@gmail.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <asm/irq.h>
+#include <asm/io.h> /* readb() & Co */
+#include <asm/mach/irq.h>
+
+
+#include "pod_gpio.h"
+
+#define GPIO_ID				0x00
+#define GPIO_CONFIG			0x02
+#define GPIO_VALUE			0x04
+#define GPIO_ENABLE_INTERRUPT		0x06
+#define GPIO_INTERRUPT_STATUS		0x08
+#define GPIO_INTERRUPT_EDGE_TYPE	0x0A
+
+struct pod_gpio_chip {
+	struct gpio_chip chip;
+	struct irq_chip interrupt_chip;
+	struct platform_device *pdev;
+	void __iomem *reg_base;
+	int irq_base;
+};
+
+static u16 cg_read_reg(const struct pod_gpio_chip *cg_chip, int reg)
+{
+	return ioread16(cg_chip->reg_base + reg);
+}
+
+static void cg_write_reg(const struct pod_gpio_chip *cg_chip, int reg,
+			 u16 val)
+{
+	iowrite16(val, cg_chip->reg_base + reg);
+}
+
+static void pod_gpio_ack_irq(struct irq_data *data)
+{
+	struct irq_chip *chip = get_irq_chip(data->irq);
+	struct pod_gpio_chip *cg_chip =
+		container_of(chip, struct pod_gpio_chip, interrupt_chip);
+
+	cg_write_reg(cg_chip , GPIO_INTERRUPT_STATUS,
+					(1 << (data->irq - IRQ_GPIO_POD(0))));
+}
+
+static void pod_gpio_mask_irq(struct irq_data *data)
+{
+	struct irq_chip *chip = get_irq_chip(data->irq);
+	struct pod_gpio_chip *cg_chip =
+		container_of(chip, struct pod_gpio_chip, interrupt_chip);
+
+	u16 enable_interrupt_config;
+	enable_interrupt_config = cg_read_reg(cg_chip, GPIO_ENABLE_INTERRUPT);
+
+
+	cg_write_reg(cg_chip , GPIO_ENABLE_INTERRUPT, enable_interrupt_config &
+					~(1 << (data->irq - IRQ_GPIO_POD(0))));
+}
+
+static void pod_gpio_unmask_irq(struct irq_data *data)
+{
+	struct irq_chip *chip = get_irq_chip(data->irq);
+	struct pod_gpio_chip *cg_chip =
+		container_of(chip, struct pod_gpio_chip, interrupt_chip);
+
+	u16 enable_interrupt_config;
+
+
+	enable_interrupt_config = cg_read_reg(cg_chip, GPIO_ENABLE_INTERRUPT);
+
+	cg_write_reg(cg_chip, GPIO_ENABLE_INTERRUPT, enable_interrupt_config |
+					(1 << (data->irq - IRQ_GPIO_POD(0))));
+}
+
+static int pod_gpio_irq_type(unsigned int _irq, unsigned int type)
+{
+	struct irq_chip *chip = get_irq_chip(_irq);
+	struct pod_gpio_chip *cg_chip =
+			container_of(chip, struct pod_gpio_chip,
+							interrupt_chip);
+	u16 edge_config;
+
+
+	edge_config = cg_read_reg(cg_chip, GPIO_INTERRUPT_EDGE_TYPE);
+
+	/* Only falling and rising edge are supporter by pod_gpio */
+	if (type == IRQ_TYPE_EDGE_RISING) {
+		cg_write_reg(cg_chip, GPIO_INTERRUPT_EDGE_TYPE, edge_config |
+					(1 << (_irq - IRQ_GPIO_POD(0))));
+	} else if (type == IRQ_TYPE_EDGE_FALLING) {
+		cg_write_reg(cg_chip, GPIO_INTERRUPT_EDGE_TYPE, edge_config &
+					~(1 << (_irq - IRQ_GPIO_POD(0))));
+	} else {
+		dev_err(&cg_chip->pdev->dev,
+		"The selected edge type is not supported by the driver.\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static irqreturn_t pod_gpio_interrupt(int irq, void *data)
+{
+	struct pod_gpio_chip *cg_chip = data;
+	struct irq_desc *desc;
+	u16 pending_interrupts;
+
+	irq = IRQ_GPIO_POD(0);
+	desc = irq_to_desc(irq);
+
+	pending_interrupts = cg_read_reg(cg_chip, GPIO_INTERRUPT_STATUS);
+
+	while (pending_interrupts) {
+		if (pending_interrupts & 1) {
+			/* Get irq handle */
+			desc_handle_irq(irq, desc);
+		}
+		irq++;
+		desc++;
+		pending_interrupts >>= 1;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int pod_gpio_get(struct gpio_chip *chip, unsigned gpio_num)
+{
+	struct pod_gpio_chip *cg_chip =
+			container_of(chip, struct pod_gpio_chip, chip);
+		u16 io_config;
+
+	io_config = cg_read_reg(cg_chip, GPIO_CONFIG) | (1 << gpio_num);
+
+	if (cg_read_reg(cg_chip, GPIO_VALUE) & (1 << gpio_num))
+		return 1;
+	else
+		return 0;
+}
+
+static int pod_gpio_direction_in(struct gpio_chip *chip,
+						unsigned gpio_num)
+{
+	struct pod_gpio_chip *cg_chip =
+			container_of(chip, struct pod_gpio_chip, chip);
+	u16 io_config;
+
+	io_config = cg_read_reg(cg_chip, GPIO_CONFIG) | (1 << gpio_num);
+	cg_write_reg(cg_chip, GPIO_CONFIG, io_config);
+
+	return 0;
+}
+
+static void pod_gpio_set(struct gpio_chip *chip, unsigned gpio_num,
+					int val)
+{
+	struct pod_gpio_chip *cg_chip =
+			container_of(chip, struct pod_gpio_chip, chip);
+	u16 io_value;
+
+	if (val == 1)
+		io_value = cg_read_reg(cg_chip, GPIO_VALUE) | (1 << gpio_num);
+	else
+		io_value = cg_read_reg(cg_chip, GPIO_VALUE) & ~(1 << gpio_num);
+
+	cg_write_reg(cg_chip, GPIO_VALUE, io_value);
+}
+
+static int pod_gpio_direction_out(struct gpio_chip *chip,
+						unsigned gpio_num, int val)
+{
+	struct pod_gpio_chip *cg_chip =
+			container_of(chip, struct pod_gpio_chip, chip);
+	u16 io_config;
+
+	io_config = cg_read_reg(cg_chip, GPIO_CONFIG) & ~(1 << gpio_num);
+	cg_write_reg(cg_chip, GPIO_CONFIG, io_config);
+
+	return 0;
+}
+
+static int pod_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+
+	struct pod_gpio_chip *cg_chip =
+			container_of(chip, struct pod_gpio_chip, chip);
+
+	return cg_chip->irq_base + offset;
+}
+
+static int pod_gpio_probe(struct platform_device *pdev)
+{
+	int err;
+	struct pod_gpio_chip *cg_chip;
+	struct resource *resource_memory, *resource_irq;
+	unsigned int irq;
+	u16 id;
+
+	resource_memory = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	resource_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+
+	if (!resource_memory || !resource_irq) {
+		err = -ENODEV;
+		dev_err(&pdev->dev, "Device pod_gpio not found\n");
+		goto exit;
+	}
+
+	if (!request_mem_region(resource_memory->start,
+	resource_size(resource_memory), pod_gpio_DRIVER_NAME)) {
+		dev_err(&pdev->dev, "Can't request memory region %x to %x\n",
+		resource_memory->start, resource_memory->start +
+			resource_memory->end);
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	/*Allocate memory for pod_gpio chip*/
+	cg_chip = kzalloc(sizeof(struct pod_gpio_chip), GFP_KERNEL);
+	if (!cg_chip) {
+		err = -ENOMEM;
+		dev_err(&pdev->dev,
+			"Can't allocate memory for pod_gpio_chip\n");
+		goto release_region;
+	}
+
+	dev_set_drvdata(&pdev->dev, cg_chip);
+
+	/*Chip configuration*/
+	cg_chip->chip.label		= pod_gpio_DRIVER_NAME;
+	cg_chip->chip.owner		= THIS_MODULE;
+	cg_chip->chip.ngpio		= 16;
+	cg_chip->chip.base		= -1;
+	cg_chip->chip.get		= pod_gpio_get;
+	cg_chip->chip.direction_input	= pod_gpio_direction_in;
+	cg_chip->chip.set		= pod_gpio_set;
+	cg_chip->chip.direction_output	= pod_gpio_direction_out;
+	cg_chip->chip.to_irq		= pod_gpio_to_irq;
+	cg_chip->irq_base		= IRQ_GPIO_POD(0);
+	cg_chip->pdev			= pdev;
+
+	/*Interrupt chip configuration*/
+	cg_chip->interrupt_chip.name = pod_gpio_DRIVER_NAME;
+	cg_chip->interrupt_chip.irq_ack = pod_gpio_ack_irq;
+	cg_chip->interrupt_chip.irq_mask = pod_gpio_mask_irq;
+	cg_chip->interrupt_chip.irq_unmask = pod_gpio_unmask_irq;
+	cg_chip->interrupt_chip.set_type = pod_gpio_irq_type;
+
+	/* Add virtual interrupts from GPIO*/
+	for (irq = IRQ_GPIO_POD(0) ; irq < IRQ_GPIO_POD(16) ; irq++) {
+		set_irq_chip_data(irq, cg_chip);
+		set_irq_chip_and_handler(irq, &cg_chip->interrupt_chip,
+							handle_edge_irq);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	cg_chip->reg_base = ioremap_nocache(resource_memory->start,
+					resource_size(resource_memory));
+
+	if (!cg_chip->reg_base) {
+		err = -EIO;
+		goto free_chip;
+	}
+
+	/*Check if ID is correct*/
+	id = cg_read_reg(cg_chip, GPIO_ID);
+	if (pdev->id != id) {
+		dev_err(&pdev->dev,
+			"Driver id %d doesn't match with the device id %d\n",
+			pdev->id, id);
+		err = -ENODEV;
+		goto exit_iounmap;
+	}
+
+	/* Clear all pending interrupts */
+	cg_write_reg(cg_chip, GPIO_INTERRUPT_STATUS, 0xFF);
+
+	/* Disable all interrupts */
+	cg_write_reg(cg_chip, GPIO_ENABLE_INTERRUPT, 0x00);
+
+	/* Add the GPIO chip*/
+	err = gpiochip_add(&cg_chip->chip);
+	if (err) {
+		dev_err(&pdev->dev, "Can't add the gpio chip\n");
+		goto exit_iounmap;
+	}
+
+	/* Request irq pin */
+	err = request_irq(resource_irq->start, pod_gpio_interrupt,
+			0 , "pod_gpio", cg_chip);
+
+	if (err) {
+		dev_err(&pdev->dev, "Can't request irq %d\n",
+					resource_irq->start);
+		goto exit_iounmap;
+	}
+
+	dev_info(&pdev->dev, "pod_gpio probed. GPIO used: %d..%d, IRQ used: %d..%d\n",
+	cg_chip->chip.base, cg_chip->chip.base + cg_chip->chip.ngpio-1, IRQ_GPIO_POD(0), IRQ_GPIO_POD(16));
+
+	return 0;
+
+ exit_iounmap:
+	iounmap(cg_chip->reg_base);
+free_chip:
+	kfree(cg_chip);
+release_region:
+	release_mem_region(resource_memory->start,
+				resource_size(resource_memory));
+exit:
+return err;
+}
+
+static int pod_gpio_remove(struct platform_device *pdev)
+{
+	struct resource *resource_memory, *resource_irq;
+	struct pod_gpio_chip *cg_chip = dev_get_drvdata(&pdev->dev);
+	unsigned int irq;
+
+	/* Remove the GPIO chip */
+	if (gpiochip_remove(&cg_chip->chip))
+		dev_err(&pdev->dev, "gpio_chip remove failed\n");
+
+	if (cg_chip->reg_base)
+		iounmap(cg_chip->reg_base);
+
+	kfree(cg_chip);
+
+	resource_memory = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	resource_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+
+	release_mem_region(resource_memory->start,
+		resource_size(resource_memory));
+
+	for (irq = IRQ_GPIO_POD(0) ; irq < IRQ_GPIO_POD(16) ; irq++) {
+		set_irq_chip(irq, NULL);
+		set_irq_handler(irq, NULL);
+		set_irq_flags(irq, 0);
+	}
+
+	free_irq(resource_irq->start, cg_chip);
+
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver pod_gpio_drv = {
+	.driver = {
+		.name = pod_gpio_DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = pod_gpio_probe,
+	.remove = pod_gpio_remove,
+};
+
+static int __init pod_gpio_init(void)
+{
+	return platform_driver_register(&pod_gpio_drv);
+}
+module_init(pod_gpio_init);
+
+static void __exit pod_gpio_exit(void)
+{
+	platform_driver_unregister(&pod_gpio_drv);
+}
+module_exit(pod_gpio_exit);
+
+MODULE_AUTHOR("Kevin Joly <joly.kevin25@gmail.com>");
+MODULE_DESCRIPTION("GPIO driver for pod_gpio component of POD");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/pod_gpio.h linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/pod_gpio.h
--- linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/pod_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/pod_gpio/pod_gpio.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,33 @@
+/*
+ * ARMadeus definitions for the POD component pod_gpio
+ *
+ * (C) Copyright 2011 - Armadeus Systems <support@armadeus.com>
+ * Author: Kevin JOLY joly.kevin25@gmail.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef LINUX_pod_gpio
+#define LINUX_pod_gpio
+
+#ifndef CONFIG_MACH_APF9328
+# include <mach/fpga.h> /* To remove when MX1 platform is merged */
+#endif
+
+#define IRQ_GPIO_POD(x) IRQ_FPGA(x+16)
+
+#define pod_gpio_DRIVER_NAME "pod_gpio"
+
+#endif
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/Kconfig linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/Kconfig
--- linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,8 @@
+
+config ARMADEUS_FPGA_VIRTUAL_COMPONENTS_PWM
+	tristate "pod_pwm"
+	default n
+	depends on ARMADEUS_FPGA_VIRTUAL_COMPONENTS
+	---help---
+	  Armadeus driver for virtual pod_pwm component.
+	  kernel >= 2.6.38 is required
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/Makefile linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/Makefile
--- linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,3 @@
+# Makefile for pod_pwm driver
+
+obj-$(CONFIG_ARMADEUS_FPGA_VIRTUAL_COMPONENTS_PWM) += pod_pwm.o
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/pod_pwm.c linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/pod_pwm.c
--- linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/pod_pwm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/pod_pwm.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,368 @@
+/*
+ * Linux kernel driver for the POD component pod_pwm
+ *
+ * (C) Copyright 2012 - EIRBOT <eirbot.enseirb.fr>
+ * Author: Kevin JOLY joly.kevin25@gmail.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include "pod_pwm.h"
+
+/* POD_PWM Registers*/
+#define REG_PWM_ID 0x00
+#define REG_T_ON 0x02
+#define REG_DIV 0x04
+
+#define DEFAULT_CLOCK_SOURCE_FREQUENCY 100000000
+
+struct class *class_pwm;
+
+struct pod_pwm_device {
+	int angle;
+	void __iomem *membase;
+	struct device *dev;
+	int gMajor;
+	unsigned long clock_source;
+};
+
+const struct file_operations pwm_fops = {
+	/* TODO */
+};
+
+/* Low level access */
+static u16 read_reg(const struct pod_pwm_device *pwm, u16 reg)
+{
+	return ioread16(pwm->membase + reg);
+}
+
+void write_reg(const struct pod_pwm_device *pwm, u16 reg, u16 value)
+{
+	iowrite16(value, pwm->membase + reg);
+}
+
+unsigned int get_duty(const struct pod_pwm_device *pwm)
+{
+	u16 t_on;
+	u16 div;
+
+	t_on = read_reg(pwm, REG_T_ON);
+	div = read_reg(pwm, REG_DIV);
+
+	if (div < 1)
+		return 0;
+
+	return (t_on*1000)/div;
+}
+
+/* Attributes */
+
+static ssize_t pwm_show_duty(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pod_pwm_device *pwm =
+		(struct pod_pwm_device *)(dev_get_drvdata(dev));
+
+	return sprintf(buf, "%d\n", get_duty(pwm));
+}
+
+static ssize_t pwm_store_duty(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	int err;
+	u16 div;
+	u16 duty;
+	struct pod_pwm_device *pwm =
+		(struct pod_pwm_device *)(dev_get_drvdata(dev));
+
+	err = kstrtouint(buf, 10, (unsigned int *)(&duty));
+
+	if (err) {
+		dev_err(dev, "kstrtol failed with error code %d.\n", err);
+		return size;
+	}
+
+	if (duty < 0)
+		duty = 0;
+	if (duty > 1000)
+		duty = 1000;
+
+	div = read_reg(pwm, REG_DIV);
+	write_reg(pwm, REG_T_ON, (div * duty)/1000);
+
+	return size;
+}
+
+static ssize_t pwm_show_frequency(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u16 div;
+	struct pod_pwm_device *pwm =
+		(struct pod_pwm_device *)(dev_get_drvdata(dev));
+
+	div = read_reg(pwm, REG_DIV);
+	if (div <= 0)
+		return pwm->clock_source;
+
+	return sprintf(buf, "%ld\n", pwm->clock_source/div);
+}
+
+static ssize_t pwm_store_frequency(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	u16 div;
+	int err;
+	unsigned int duty;
+	unsigned long freq;
+	struct pod_pwm_device *pwm =
+		(struct pod_pwm_device *)(dev_get_drvdata(dev));
+
+	err = kstrtol(buf, 10, &freq);
+
+	if (err) {
+		dev_err(dev, "kstrtol failed with error code %d.\n", err);
+		return size;
+	}
+
+	if ((freq > pwm->clock_source) || (freq < pwm->clock_source/65635)) {
+		dev_err(dev, "Invalid pwm frequency %ld.\n", freq);
+		return size;
+	}
+
+	duty = get_duty(pwm);
+	div = pwm->clock_source / freq;
+
+	write_reg(pwm, REG_DIV, div);
+	write_reg(pwm, REG_T_ON, (div * duty)/1000);
+
+	return size;
+}
+
+static ssize_t pwm_show_clock_source(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct pod_pwm_device *pwm =
+		(struct pod_pwm_device *)(dev_get_drvdata(dev));
+
+	return sprintf(buf, "%ld\n", pwm->clock_source);
+}
+
+static ssize_t pwm_store_clock_source(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err;
+	long freq;
+	struct pod_pwm_device *pwm =
+		(struct pod_pwm_device *)(dev_get_drvdata(dev));
+
+	err = kstrtol(buf, 10, &freq);
+
+	if (err) {
+		dev_err(dev, "kstrtol failed with error code %d.\n", err);
+		return size;
+	}
+
+	if (freq < 1)
+		return 0;
+
+	pwm->clock_source = freq;
+
+	return size;
+}
+
+/* dev_attr_duty  /class/pwm/pwmX/duty */
+static DEVICE_ATTR(duty, S_IWUSR | S_IRUGO, pwm_show_duty, pwm_store_duty);
+/* dev_attr_frequency  /sys/class/pwm/pwmX/frequency */
+static DEVICE_ATTR(frequency, S_IWUSR | S_IRUGO, pwm_show_frequency,
+	pwm_store_frequency);
+/* dev_attr_clock_source  /sys/class/pwm/pwmX/clock_source */
+static DEVICE_ATTR(clock_source, S_IWUSR | S_IRUGO, pwm_show_clock_source,
+	pwm_store_clock_source);
+
+void init_pwm(struct pod_pwm_device *pwm)
+{
+	pwm->clock_source = DEFAULT_CLOCK_SOURCE_FREQUENCY;
+	pwm->gMajor = 0;
+}
+
+static int pod_pwm_drv_probe(struct platform_device *pdev)
+{
+	struct resource *resource_memory;
+	struct pod_pwm_device *pwm;
+	int err;
+	u16 id;
+
+	resource_memory = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (!resource_memory) {
+		err = -ENODEV;
+		dev_err(&pdev->dev, "Device pod_pwm not found\n");
+		goto exit_error;
+	}
+
+	if (!request_mem_region(resource_memory->start,
+		resource_size(resource_memory), DRIVER_NAME)) {
+		dev_err(&pdev->dev, "Can't request memory region %x to %x\n",
+			resource_memory->start,
+			resource_memory->start + resource_memory->end);
+		err = -ENOMEM;
+		goto exit_error;
+	}
+
+	pwm = kmalloc(sizeof(struct pod_pwm_device), GFP_KERNEL);
+
+	if (!pwm) {
+		err = -ENOMEM;
+		goto exit_release_mem;
+	}
+	pwm->membase = ioremap(resource_memory->start,
+			resource_memory->end - resource_memory->start + 1);
+	if (!pwm) {
+		err = -ENOMEM;
+		goto exit_kfree;
+	}
+
+	id = read_reg(pwm, REG_PWM_ID);
+
+	if (pdev->id != id) {
+		dev_err(&pdev->dev,
+			"Driver id %d doesn't match with the device id %d\n",
+			pdev->id, id);
+		err = -ENODEV;
+		goto exit_iounmap;
+	}
+
+	init_pwm(pwm);
+
+	err = register_chrdev(pwm->gMajor, DRIVER_NAME, &pwm_fops);
+	if (err < 0) {
+		dev_err(&pdev->dev, "unable to register char driver.\n");
+		goto exit_iounmap;
+	}
+
+	if (!pwm->gMajor)
+		pwm->gMajor = err;
+
+	pwm->dev = device_create(class_pwm, NULL, MKDEV(pwm->gMajor, pdev->id),
+			NULL, "pwm%i", pdev->id);
+
+	if (IS_ERR(pwm->dev)) {
+		err = PTR_ERR(pwm->dev);
+		dev_err(&pdev->dev, "can't create device\n");
+		goto error_device_destroy;
+	}
+
+	err = device_create_file(pwm->dev, &dev_attr_duty);
+	if (err) {
+		dev_err(&pdev->dev,
+			"can't create device attribute  \"duty\".\n");
+		goto error_device_destroy;
+	}
+
+	err = device_create_file(pwm->dev, &dev_attr_frequency);
+	if (err) {
+		dev_err(&pdev->dev,
+			"can't create device attribute \"frequency\".\n");
+		goto error_device_destroy;
+	}
+
+	err = device_create_file(pwm->dev, &dev_attr_clock_source);
+
+	if (err) {
+		dev_err(&pdev->dev,
+			"can't create device attribute \"clock_source\".\n");
+		goto error_device_destroy;
+	}
+
+	dev_set_drvdata(&pdev->dev, pwm);
+	dev_set_drvdata(pwm->dev, pwm);
+
+	dev_info(&pdev->dev, "pod_pwm:%d Succesfully probed", id);
+
+	return 0;
+
+error_device_destroy:
+	device_destroy(class_pwm, MKDEV(pwm->gMajor, pdev->id));
+	unregister_chrdev(pwm->gMajor, DRIVER_NAME);
+exit_iounmap:
+	iounmap(pwm->membase);
+exit_kfree:
+	kfree(pwm);
+exit_release_mem:
+	release_mem_region(resource_memory->start,
+		resource_size(resource_memory));
+exit_error:
+	return err;
+}
+
+static int pod_pwm_drv_remove(struct platform_device *pdev)
+{
+	struct pod_pwm_device *pwm =
+		(struct pod_pwm_device *)(dev_get_drvdata(&pdev->dev));
+	struct resource *resource_memory =
+		platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	device_remove_file(pwm->dev, &dev_attr_duty);
+	device_remove_file(pwm->dev, &dev_attr_frequency);
+	device_remove_file(pwm->dev, &dev_attr_clock_source);
+
+	device_destroy(class_pwm, MKDEV(pwm->gMajor, pdev->id));
+	unregister_chrdev(pwm->gMajor, DRIVER_NAME);
+
+	if (pwm->membase > 0)
+		iounmap(pwm->membase);
+
+	kfree(pwm);
+	release_mem_region(resource_memory->start,
+		resource_size(resource_memory));
+
+		return 0;
+}
+
+static struct platform_driver pod_pwm_driver = {
+	.probe = pod_pwm_drv_probe,
+	.remove = pod_pwm_drv_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+},
+};
+
+static int __init pod_pwm_init(void)
+{
+	class_pwm = class_create(THIS_MODULE, "pod_pwm");
+	if (IS_ERR(class_pwm))
+		return PTR_ERR(class_pwm);
+
+	return platform_driver_register(&pod_pwm_driver);
+}
+
+static void __exit pod_pwm_exit(void)
+{
+	platform_driver_unregister(&pod_pwm_driver);
+	class_destroy(class_pwm);
+}
+
+module_init(pod_pwm_init);
+module_exit(pod_pwm_exit);
+
+MODULE_AUTHOR("Kevin JOLY, inspired by i.MX PWM driver");
+MODULE_DESCRIPTION("POD pwm driver");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/pod_pwm.h linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/pod_pwm.h
--- linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/pod_pwm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/pod_pwm/pod_pwm.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,26 @@
+/*
+ * Linux kernel driver for the POD component pod_pwm
+ *
+ * (C) Copyright 2012 - EIRBOT <eirbot.enseirb.fr>
+ * Author: Kevin JOLY joly.kevin25@gmail.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef LINUX_POD_PWM
+#define LINUX_POD_PWM
+
+#define DRIVER_NAME "pod_pwm"
+
+#endif
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/Kconfig linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/Kconfig
--- linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,8 @@
+
+config ARMADEUS_FPGA_VIRTUAL_COMPONENTS_SERVO
+	tristate "pod_servo"
+	default n
+	depends on ARMADEUS_FPGA_VIRTUAL_COMPONENTS
+	---help---
+	  Armadeus driver for virtual pod_servo component.
+	  kernel >= 2.6.38 is required
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/Makefile linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/Makefile
--- linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,3 @@
+# Makefile for pod_pwm driver
+
+obj-$(CONFIG_ARMADEUS_FPGA_VIRTUAL_COMPONENTS_PWM) += pod_servo.o
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/pod_servo.c linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/pod_servo.c
--- linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/pod_servo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/pod_servo.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,305 @@
+/*
+ * Linux kernel driver for the POD component pod_servo
+ *
+ * (C) Copyright 2012 - EIRBOT <eirbot.enseirb.fr>
+ * Author: Kevin JOLY joly.kevin25@gmail.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include "pod_servo.h"
+
+/* POD_SERVO Registers*/
+#define REG_SERVO_ID 0x00
+#define REG_ANGLE 0x02
+
+#define DEFAULT_CLOCK_SOURCE_FREQUENCY 100000000
+
+struct class *class_servo;
+
+struct pod_servo_device {
+	int angle;
+	void __iomem *membase;
+	struct device *dev;
+	int gMajor;
+	unsigned long clock_source;
+};
+
+const struct file_operations servo_fops = {
+	/* TODO */
+};
+
+/* Low level access */
+static u16 read_reg(const struct pod_servo_device *servo, u16 reg)
+{
+	return ioread16(servo->membase + reg);
+}
+
+void write_reg(const struct pod_servo_device *servo, u16 reg, u16 value)
+{
+	iowrite16(value, servo->membase + reg);
+}
+
+unsigned int get_angle(const struct pod_servo_device *servo)
+{
+	u16 angle;
+
+	angle = read_reg(servo, REG_ANGLE);
+
+	return (angle*180)/1000;
+}
+
+/* Attributes */
+
+static ssize_t servo_show_angle(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pod_servo_device *servo =
+		(struct pod_servo_device *)(dev_get_drvdata(dev));
+
+	return sprintf(buf, "%d\n", get_angle(servo));
+}
+
+static ssize_t servo_store_angle(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	int err;
+	u16 angle;
+	struct pod_servo_device *servo =
+		(struct pod_servo_device *)(dev_get_drvdata(dev));
+
+	err = kstrtouint(buf, 10, (unsigned int *)(&angle));
+
+	if (err) {
+		dev_err(dev, "kstrtol failed with error code %d.\n", err);
+		return size;
+	}
+
+	if (angle < 0)
+		angle = 0;
+	if (angle > 180)
+		angle = 1000;
+
+	write_reg(servo, REG_ANGLE, (angle*1000)/180);
+
+	return size;
+}
+
+static ssize_t servo_show_clock_source(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct pod_servo_device *servo =
+		(struct pod_servo_device *)(dev_get_drvdata(dev));
+
+	return sprintf(buf, "%ld\n", servo->clock_source);
+}
+
+static ssize_t servo_store_clock_source(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err;
+	long freq;
+	struct pod_servo_device *servo =
+		(struct pod_servo_device *)(dev_get_drvdata(dev));
+
+	err = kstrtol(buf, 10, &freq);
+
+	if (err) {
+		dev_err(dev, "kstrtol failed with error code %d.\n", err);
+		return size;
+	}
+
+	if (freq < 1)
+		return 0;
+
+	servo->clock_source = freq;
+
+	return size;
+}
+
+/* dev_attr_angle  /class/servo/servoX/angle */
+static DEVICE_ATTR(angle, S_IWUSR | S_IRUGO, servo_show_angle,
+	servo_store_angle);
+/* dev_attr_clock_source  /sys/class/servo/servoX/clock_source */
+static DEVICE_ATTR(clock_source, S_IWUSR | S_IRUGO, servo_show_clock_source,
+	servo_store_clock_source);
+
+void init_servo(struct pod_servo_device *servo)
+{
+	servo->clock_source = DEFAULT_CLOCK_SOURCE_FREQUENCY;
+	servo->gMajor = 0;
+}
+
+static int pod_servo_drv_probe(struct platform_device *pdev)
+{
+	struct resource *resource_memory;
+	struct pod_servo_device *servo;
+	int err;
+	u16 id;
+
+	resource_memory = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (!resource_memory) {
+		err = -ENODEV;
+		dev_err(&pdev->dev, "Device pod_servo not found\n");
+		goto exit_error;
+	}
+
+	if (!request_mem_region(resource_memory->start,
+		resource_size(resource_memory), DRIVER_NAME)) {
+		dev_err(&pdev->dev, "Can't request memory region %x to %x\n",
+			resource_memory->start,
+			resource_memory->start + resource_memory->end);
+		err = -ENOMEM;
+		goto exit_error;
+	}
+
+	servo = kmalloc(sizeof(struct pod_servo_device), GFP_KERNEL);
+
+	if (!servo) {
+		err = -ENOMEM;
+		goto exit_release_mem;
+	}
+	servo->membase = ioremap(resource_memory->start,
+			resource_memory->end - resource_memory->start + 1);
+	if (!servo) {
+		err = -ENOMEM;
+		goto exit_kfree;
+	}
+
+	id = read_reg(servo, REG_SERVO_ID);
+
+	if (pdev->id != id) {
+		dev_err(&pdev->dev,
+			"Driver id %d doesn't match with the device id %d\n",
+			pdev->id, id);
+		err = -ENODEV;
+		goto exit_iounmap;
+	}
+
+	init_servo(servo);
+
+	err = register_chrdev(servo->gMajor, DRIVER_NAME, &servo_fops);
+	if (err < 0) {
+		dev_err(&pdev->dev, "unable to register char driver.\n");
+		goto exit_iounmap;
+	}
+
+	if (!servo->gMajor)
+		servo->gMajor = err;
+
+	servo->dev = device_create(class_servo, NULL, MKDEV(servo->gMajor, pdev->id),
+			NULL, "servo%i", pdev->id);
+
+	if (IS_ERR(servo->dev)) {
+		err = PTR_ERR(servo->dev);
+		dev_err(&pdev->dev, "can't create device\n");
+		goto error_device_destroy;
+	}
+
+	err = device_create_file(servo->dev, &dev_attr_angle);
+	if (err) {
+		dev_err(&pdev->dev,
+			"can't create device attribute  \"angle\".\n");
+		goto error_device_destroy;
+	}
+
+	err = device_create_file(servo->dev, &dev_attr_clock_source);
+
+	if (err) {
+		dev_err(&pdev->dev,
+			"can't create device attribute \"clock_source\".\n");
+		goto error_device_destroy;
+	}
+
+	dev_set_drvdata(&pdev->dev, servo);
+	dev_set_drvdata(servo->dev, servo);
+
+	dev_info(&pdev->dev, "pod_servo:%d Succesfully probed", id);
+
+	return 0;
+
+error_device_destroy:
+	device_destroy(class_servo, MKDEV(servo->gMajor, pdev->id));
+	unregister_chrdev(servo->gMajor, DRIVER_NAME);
+exit_iounmap:
+	iounmap(servo->membase);
+exit_kfree:
+	kfree(servo);
+exit_release_mem:
+	release_mem_region(resource_memory->start,
+		resource_size(resource_memory));
+exit_error:
+	return err;
+}
+
+static int pod_servo_drv_remove(struct platform_device *pdev)
+{
+	struct pod_servo_device *servo =
+		(struct pod_servo_device *)(dev_get_drvdata(&pdev->dev));
+	struct resource *resource_memory =
+		platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	device_remove_file(servo->dev, &dev_attr_angle);
+	device_remove_file(servo->dev, &dev_attr_clock_source);
+
+	device_destroy(class_servo, MKDEV(servo->gMajor, pdev->id));
+	unregister_chrdev(servo->gMajor, DRIVER_NAME);
+
+	if (servo->membase > 0)
+		iounmap(servo->membase);
+
+	kfree(servo);
+	release_mem_region(resource_memory->start,
+		resource_size(resource_memory));
+
+		return 0;
+}
+
+static struct platform_driver pod_servo_driver = {
+	.probe = pod_servo_drv_probe,
+	.remove = pod_servo_drv_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+},
+};
+
+static int __init pod_servo_init(void)
+{
+	class_servo = class_create(THIS_MODULE, "pod_servo");
+	if (IS_ERR(class_servo))
+		return PTR_ERR(class_servo);
+
+	return platform_driver_register(&pod_servo_driver);
+}
+
+static void __exit pod_servo_exit(void)
+{
+	platform_driver_unregister(&pod_servo_driver);
+	class_destroy(class_servo);
+}
+
+module_init(pod_servo_init);
+module_exit(pod_servo_exit);
+
+MODULE_AUTHOR("Kevin JOLY, inspired by i.MX PWM driver");
+MODULE_DESCRIPTION("POD servo driver");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/pod_servo.h linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/pod_servo.h
--- linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/pod_servo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/pod_servo/pod_servo.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,26 @@
+/*
+ * Linux kernel driver for the POD component pod_servo
+ *
+ * (C) Copyright 2012 - EIRBOT <eirbot.enseirb.fr>
+ * Author: Kevin JOLY joly.kevin25@gmail.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef LINUX_POD_SERVO
+#define LINUX_POD_SERVO
+
+#define DRIVER_NAME "pod_servo"
+
+#endif
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/Kconfig linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/Kconfig
--- linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,9 @@
+
+config ARMADEUS_FPGA_VIRTUAL_SPVISION_LOADER
+	tristate "sploader"
+	default n
+	depends on ARMADEUS_FPGA_VIRTUAL_COMPONENTS
+	---help---
+	  With this driver you will be able to (re)load the
+	  configuration of your SP_VISION FPGA directly from
+	  Linux userspace
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/Makefile linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/Makefile
--- linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,6 @@
+#
+# Makefile for the Armadeus FPGA SP_VISION loader
+#
+
+obj-$(CONFIG_ARMADEUS_FPGA_VIRTUAL_SPVISION_LOADER) := sploader.o
+sploader-objs := spartan_loadsecond.o sp-loader.o
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/sp-loader.c linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/sp-loader.c
--- linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/sp-loader.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/sp-loader.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,380 @@
+/*
+ * Generic Xilinx FPGA loader
+ *
+ * Copyright (C) 2006-2009 Julien Boibessot <julien.boibessot@armadeus.com>
+ *                         Nicolas Colombain <nicolas.colombain@armadeus.com>
+ *                         Armadeus Project / Armadeus systems
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* #define DEBUG */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+
+#include "spartan_loadsecond.h"
+
+/* request_mem_region */
+#include <linux/ioport.h>
+
+#include <mach/fpga.h>
+#include <asm/io.h>
+#include "sploader.h"
+
+#define ARMADEUS_FPGA_BASE_ADDR_VIRT 0xF4300000
+#define DRIVER_VERSION		"0.91"
+#define DRIVER_NAME		"sp_loader"
+#define FPGA_PROC_DIRNAME	"driver/sp"
+#define FPGA_PROC_FILENAME	FPGA_PROC_DIRNAME "/sploader"
+#define FPGA_IOCTL 0x10000000	/* !! TO BE BETTER DEFINED !! */
+
+struct sploader_dev {
+	char *name;
+	void *membase;
+	struct resource *mem_res;
+};
+
+/* global variables */
+Xilinx_desc *g_current_desc = NULL;
+struct semaphore fpga_sema;
+
+static unsigned char fpga_descriptor = 0;	/* use default target_fpga_desc */
+module_param(fpga_descriptor, byte, 0);
+
+#define FPGA_BUFFER_SIZE 4096
+static unsigned char g_buffer[FPGA_BUFFER_SIZE];
+static unsigned char g_nb_users = 0;
+
+/* Handles write() done on /dev/fpga/loader */
+static ssize_t armadeus_fpga_write(struct file *file, const char *pData,
+				   size_t count, loff_t * f_pos)
+{
+	ssize_t ret = 0;
+
+	/* Get exclusive access */
+	if (down_interruptible(&fpga_sema))
+		return -ERESTARTSYS;
+
+	if (count > FPGA_BUFFER_SIZE) {
+		count = FPGA_BUFFER_SIZE;
+	}
+
+	/* Get value to write from user space */
+	ret = __copy_from_user(g_buffer, pData, count);
+	if (ret != 0) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	ret = write_content(g_current_desc, g_buffer, count);
+
+ out:
+	/* Release exclusive access */
+	up(&fpga_sema);
+
+	return ret;
+}
+
+static int armadeus_fpga_open(struct inode *inode, struct file *file)
+{
+	int ret;
+	u16 ip_id;
+
+	/* Get exclusive access */
+	if (down_interruptible(&fpga_sema))
+		return -ERESTARTSYS;
+
+	/* Only one access at a time is permitted */
+	if (g_nb_users > 0) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	/* check if ID is correct */
+	ip_id = readw(g_current_desc->ip_addr + g_current_desc->idoffset);
+	if (ip_id != g_current_desc->idnum) {
+		ret = -ENODEV;
+		printk(KERN_WARNING "For %s id:%d doesn't match with "
+						"id read %d,\n is device present ?\n",
+						g_current_desc->name, g_current_desc->idnum, ip_id);
+		goto out;
+	}
+
+	ret = loadsecond(g_current_desc);
+	if (!ret) {
+		printk("Starting FPGA download\n");
+		g_nb_users++;
+	}
+	pr_debug("Opening /dev/sp_loader, %d %d\n", fpga_descriptor, ret);
+
+ out:
+	/* Release exclusive access */
+	up(&fpga_sema);
+
+	return ret;
+}
+
+static int armadeus_fpga_release(struct inode *inode, struct file *file)
+{
+	if (end_load(g_current_desc)) {
+		printk("Failed to load FPGA !\n");
+	}
+
+	pr_debug("Closing access to /dev/fpgaloader\n");
+
+	if (g_nb_users > 0)
+		g_nb_users--;
+
+	return 0;
+}
+
+/* PROC file */
+static int procfile_fpga_read(char *buffer, __attribute__ ((unused))
+			      char **start, off_t offset, int buffer_length,
+			      int *eof, __attribute__ ((unused))
+			      void *data)
+{
+	int ret;
+
+	/* We give all of our information in one go, so if the user asks us if
+	   we have more information the answer should always be no.
+	   This is important because the standard read function from the
+	   library would continue to issue the read system call until the
+	   the kernel replies that it has no more information, or until 
+	   its buffer is filled */
+	if (offset > 0) {
+		/* we have finished to read, return 0 */
+		ret = 0;
+	} else {
+		//ret = fpga_get_infos(g_current_desc, buffer);
+	}
+
+	return ret;
+}
+
+static int procfile_fpga_write( __attribute__ ((unused))
+			       struct file *file,
+			       const char *buf, unsigned long count, void *data)
+{
+	return count;
+}
+
+/* Create /proc entries for direct access to FPGA config */
+static int create_proc_entries(void)
+{
+	static struct proc_dir_entry *fpga_Proc_File;
+
+	/* Create main directory */
+	proc_mkdir(FPGA_PROC_DIRNAME, NULL);
+
+	/* Create proc file */
+	fpga_Proc_File =
+	    create_proc_entry(FPGA_PROC_FILENAME,
+			      S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH, NULL);
+	if (fpga_Proc_File == NULL) {
+		printk(DRIVER_NAME ": Could not register a" FPGA_PROC_FILENAME
+		       ". Terminating\n");
+		goto error;
+	} else {
+		fpga_Proc_File->read_proc = procfile_fpga_read;
+		fpga_Proc_File->write_proc = procfile_fpga_write;
+	}
+
+	return 0;
+ error:
+	remove_proc_entry(FPGA_PROC_DIRNAME, NULL);
+	return -ENOMEM;
+}
+
+static struct file_operations fpga_fops = {
+	.owner = THIS_MODULE,
+	.write = armadeus_fpga_write,
+	/*    .read    = armadeus_fpga_read, Configuration saving not supported yet */
+	.open = armadeus_fpga_open,
+	.release = armadeus_fpga_release,
+};
+
+static struct miscdevice fpgaloader_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DRIVER_NAME,
+	.fops = &fpga_fops,
+};
+
+Xilinx_Spartan6_Slave_SelectMap_fns fpga_fns = {
+	.pre = fpga_spartan6_pre_fn,
+	.pgm = fpga_spartan6_pgm_fn,
+	.init = fpga_spartan6_init_fn,
+	.err = NULL,
+	.done = fpga_spartan6_done_fn,
+	.clk = fpga_spartan6_clk_fn,
+	.cs = fpga_spartan6_cs_fn,
+	.wr = fpga_spartan6_wr_fn,
+	.rdata = fpga_spartan6_rdata_fn,
+	.wdata = fpga_spartan6_wdata_fn,
+	.busy = fpga_spartan6_busy_fn,
+	.abort = fpga_spartan6_abort_fn,
+	.post = fpga_spartan6_post_fn,
+};
+
+#ifdef CONFIG_PM
+static int armadeus_sploader_suspend(struct platform_device *pdev,
+				     pm_message_t state)
+{
+	return 0;
+}
+
+static int armadeus_sploader_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define armadeus_fpga_suspend   NULL
+#define armadeus_fpga_resume    NULL
+#endif
+
+static int armadeus_sploader_probe(struct platform_device *pdev)
+{
+	Xilinx_desc *pdata = pdev->dev.platform_data;
+	int ret = 0;
+	int result;
+	struct device *dev = &pdev->dev;
+	Xilinx_desc *platform_info;
+	struct resource *mem_res;
+	struct sploader_dev *sdev;
+
+	platform_info = dev->platform_data;
+	if (platform_info == NULL) {
+		dev_err(&pdev->dev, "probe - no platform data supplied\n");
+		result = -ENODEV;
+		goto err_no_pdata;
+	}
+	pdata->iface_fns = (void *)&fpga_fns;
+	/* Register the driver through misc layer to get MAJOR/MINOR */
+	result = misc_register(&fpgaloader_misc);
+	if (result) {
+		printk(KERN_ERR "%s:%u: misc_register failed %d\n",
+		       __func__, __LINE__, result);
+		goto err_no_pdata;
+	}
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "can't find mem resource\n");
+		return -EINVAL;
+	}
+
+	mem_res = request_mem_region(mem_res->start, resource_size(mem_res),
+				     "sploader");
+	if (!mem_res) {
+		dev_err(&pdev->dev, "iomem already in use\n");
+		return -EBUSY;
+	}
+
+	sdev = kmalloc(sizeof(struct sploader_dev), GFP_KERNEL);
+	if (!sdev) {
+		ret = -ENOMEM;
+		goto out_release_mem;
+	}
+
+	platform_info->ip_addr =
+	    ioremap(mem_res->start, resource_size(mem_res));
+	if (!sdev->membase) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto out_dev_free;
+	}
+
+	sdev->mem_res = mem_res;
+
+	pdata->sdev = sdev;
+
+	result = create_proc_entries();
+	if (result < 0)
+		goto out_iounmap;
+
+	sema_init(&fpga_sema, 1);
+
+	/* initialize the current fpga descriptor with the one by default */
+	g_current_desc = platform_info;
+
+	printk(DRIVER_NAME " v" DRIVER_VERSION " ready\n");
+
+	return 0;
+
+ out_iounmap:
+	iounmap(platform_info->ip_addr);
+ out_dev_free:
+	kfree(sdev);
+ out_release_mem:
+	release_mem_region(mem_res->start, resource_size(mem_res));
+ err_no_pdata:
+
+	return ret;
+}
+
+static int armadeus_sploader_remove(struct platform_device *pdev)
+{
+	Xilinx_desc *dev = pdev->dev.platform_data;
+	struct sploader_dev *sdev = (*dev).sdev;
+
+	remove_proc_entry(FPGA_PROC_FILENAME, NULL);
+	remove_proc_entry(FPGA_PROC_DIRNAME, NULL);
+	misc_deregister(&fpgaloader_misc);
+	iounmap(g_current_desc->ip_addr);
+	kfree(sdev);
+	release_mem_region(sdev->mem_res->start, resource_size(sdev->mem_res));
+	printk(KERN_INFO "%s: deleted with success\n", dev->name);
+
+	return 0;
+}
+
+static struct platform_driver plat_sploader_driver = {
+	.probe = armadeus_sploader_probe,
+	.remove = armadeus_sploader_remove,
+	.suspend = armadeus_sploader_suspend,
+	.resume = armadeus_sploader_resume,
+	.driver = {
+		   .name = "sploader",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init armadeus_spartan6_init(void)
+{
+	int ret;
+
+	printk("platform driver name %s\n", plat_sploader_driver.driver.name);
+	ret = platform_driver_register(&plat_sploader_driver);
+	return ret;
+}
+
+static void __exit armadeus_spartan6_exit(void)
+{
+	platform_driver_unregister(&plat_sploader_driver);
+}
+
+module_init(armadeus_spartan6_init);
+module_exit(armadeus_spartan6_exit);
+
+MODULE_AUTHOR("Julien Boibessot / Nicolas Colombain");
+MODULE_AUTHOR("Gwenhael Goavec-Merou");
+MODULE_DESCRIPTION("Armadeus SPVISION loading driver");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/spartan_loadsecond.c linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/spartan_loadsecond.c
--- linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/spartan_loadsecond.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/spartan_loadsecond.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,303 @@
+#include <linux/types.h>
+#include "spartan_loadsecond.h"
+#include <asm/io.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+
+#define FPGA_FAIL -1
+#define FPGA_SUCCESS 0
+#define FALSE                    (0)
+#define TRUE                     (!FALSE)
+
+#define CONFIG_SYS_FPGA_WAIT        20000	/* 20 ms */
+#define CONFIG_FPGA_DELAY()
+
+#define SELECTMAP_CONFIG_RDWR_N     0
+#define SELECTMAP_CONFIG_PROGRAM_N  1
+#define SELECTMAP_CONFIG_CSI_N      2
+#define SELECTMAP_CONFIG_OS         3
+#define SELECTMAP_CONFIG_CLK        4
+#define SELECTMAP_CONFIG_REG        (desc->ip_addr+2)
+
+#define SELECTMAP_STATUS_DONE       0
+#define SELECTMAP_STATUS_BUSY       1
+#define SELECTMAP_STATUS_INIT_N     2
+#define SELECTMAP_STATUS_REG        (desc->ip_addr+4)
+#define SELECTMAP_DATA_REG          (desc->ip_addr+6)
+
+Xilinx_desc *xil_desc;
+
+static unsigned long get_timer(unsigned long initTime)
+{
+	struct timeval tv;
+	do_gettimeofday(&tv);
+	if (tv.tv_usec > initTime)	/* avoid overflow pb */
+		return tv.tv_usec - initTime;
+	else
+		return initTime - tv.tv_usec;
+}
+
+int fpga_spartan6_abort_fn(Xilinx_desc *desc, int cookie)
+{
+	int config;
+
+	config = readw(SELECTMAP_CONFIG_REG);	/* read config */
+	config |= (1 << SELECTMAP_CONFIG_CLK);	/* IP in clock mode */
+	writew(config, SELECTMAP_CONFIG_REG);	/* write config */
+
+	return cookie;
+}
+
+int fpga_spartan6_busy_fn(Xilinx_desc *desc, int cookie)
+{
+	u16 status;
+
+	status = readw(SELECTMAP_STATUS_REG);	/* read config */
+
+	return (((status & (1 << SELECTMAP_STATUS_BUSY)) != 0) ? 0 : 1);
+}
+
+int fpga_spartan6_post_fn(Xilinx_desc *desc, int cookie)
+{
+	int config;
+
+	config = readw(SELECTMAP_CONFIG_REG);	/* read config */
+	config |= (1 << SELECTMAP_CONFIG_CLK);	/* IP in clock mode */
+	config &= ~(1 << SELECTMAP_CONFIG_OS);	/* OS High */
+	writew(config, SELECTMAP_CONFIG_REG);	/* write config */
+
+	return cookie;
+}
+
+int loadsecond(Xilinx_desc * desc)
+{
+	int ret_val;		// = FPGA_FAIL;     /* assume the worst */
+	Xilinx_Spartan6_Slave_SelectMap_fns *fn;
+	xil_desc = desc;
+	fn = desc->iface_fns;
+	ret_val = FPGA_FAIL;	/* assume the worst */
+
+	if (fn) {
+		int ret;
+		int cookie = desc->cookie;	/* make a local copy */
+		unsigned long ts;	/* timestamp */
+
+		/*
+		 * This code is designed to emulate the "Express Style"
+		 * Continuous Data Loading in Slave Parallel Mode for
+		 * the Spartan-VI Family.
+		 *
+		 * Run the pre configuration function if there is one.
+		 */
+		if (*fn->pre) {
+			ret = (*fn->pre) (desc, cookie);
+			if (ret < 0)
+				return FPGA_FAIL;
+		}
+
+		/* PROG_N low */
+		(*fn->pgm) (desc, TRUE, TRUE, cookie);	/* Assert the program, commit */
+
+		CONFIG_FPGA_DELAY();
+
+		/* PROG_N high */
+		(*fn->pgm) (desc, FALSE, TRUE, cookie);	/* deAssert the program, commit */
+
+		/* Wait for INIT_N low */
+		ts = get_timer(0);	/* get current time */
+		do {
+			CONFIG_FPGA_DELAY();
+
+			if (get_timer(ts) > CONFIG_SYS_FPGA_WAIT) {	/* check the time */
+				printk ("** Timeout waiting for INIT to clear.\n");
+				(*fn->abort) (desc, cookie);	/* abort the burn */
+				return FPGA_FAIL;
+			}
+		} while ((*fn->init) (desc, cookie) == FPGA_SUCCESS);
+
+		(*fn->wr) (desc, TRUE, TRUE, cookie);	/* Assert write, commit */
+		(*fn->cs) (desc, TRUE, TRUE, cookie);	/* Assert chip select, commit */
+	}
+	return 0;
+}
+
+int write_content(Xilinx_desc * desc, void *buf, size_t bsize)
+{
+	unsigned long flags;
+	Xilinx_Spartan6_Slave_SelectMap_fns *fn = desc->iface_fns;
+
+	if (fn) {
+		int cookie = desc->cookie;	/* make a local copy */
+		size_t bytecount = 0;
+		unsigned char *data = (unsigned char *)buf;
+		/* Load the data */
+		raw_local_irq_save(flags);
+		while (bytecount < bsize) {
+			(*fn->wdata) (desc, data[bytecount], TRUE, cookie);	/* write the data */
+			bytecount++;
+		}
+		raw_local_irq_restore(flags);
+		return bsize;
+	}
+	return -EINVAL;
+}
+
+int end_load(Xilinx_desc * desc)
+{
+	int ret_val = FPGA_FAIL;	/* assume the worst */
+	Xilinx_Spartan6_Slave_SelectMap_fns *fn;
+	fn = desc->iface_fns;
+	ret_val = FPGA_FAIL;	/* assume the worst */
+
+	if (fn) {
+		int cookie = desc->cookie;	/* make a local copy */
+		unsigned long ts;	/* timestamp */
+
+		/* now check for done signal */
+		ts = get_timer(0);	/* get current time */
+		ret_val = FPGA_SUCCESS;
+		while ((*fn->done) (desc, cookie) == FPGA_FAIL) {
+			/* XXX - we should have a check in here somewhere to
+			 * make sure we aren't busy forever... */
+
+			if (get_timer(ts) > 20000 ) {	/* check the time */
+				printk("** Timeout waiting for DONE to clear.\n");
+				(*fn->abort) (desc, cookie);	/* abort the burn */
+				ret_val = FPGA_FAIL;
+				break;
+			}
+		}
+
+		CONFIG_FPGA_DELAY();
+		(*fn->cs) (desc, FALSE, TRUE, cookie);	/* Deassert the chip select */
+		(*fn->wr) (desc, FALSE, TRUE, cookie);	/* Deassert the write pin */
+
+		printk("\n");	/* terminate the dotted line */
+
+		if (ret_val == FPGA_SUCCESS) {
+			printk("Done.\n");
+		}
+		/*
+		 * Run the post configuration function if there is one.
+		 */
+		if (*fn->post) {
+			(*fn->post) (desc, cookie);
+		} else {
+			printk("Fail.\n");
+		}
+	} else {
+		printk("%s: NULL Interface function table!\n", __FUNCTION__);
+	}
+	return ret_val;
+}
+
+int fpga_spartan6_init_fn(Xilinx_desc *desc, int cookie)
+{
+	uint16_t status;
+
+	status = readw(SELECTMAP_STATUS_REG);
+
+	return (((status & (1 << SELECTMAP_STATUS_INIT_N)) ==
+		 0) ? FPGA_SUCCESS : FPGA_FAIL);
+}
+
+/* Set the FPGA's active-high clock line to the specified level */
+int fpga_spartan6_clk_fn(Xilinx_desc *desc, int assert_clk, int flush, int cookie)
+{
+	/* clock pulse is generated when a data is wrote */
+	return assert_clk;
+}
+
+/* Test the state of the active-high FPGA DONE pin */
+int fpga_spartan6_done_fn(Xilinx_desc *desc, int cookie)
+{
+	uint16_t status;
+
+	status = readw(SELECTMAP_STATUS_REG);
+	return (((status & (1 << SELECTMAP_STATUS_DONE)) ==
+		 0) ? FPGA_FAIL : FPGA_SUCCESS);
+}
+
+/* TODO: read/write in 16bits mode */
+int fpga_spartan6_rdata_fn(Xilinx_desc *desc, unsigned char *data, int cookie)
+{
+	*data = (readw(SELECTMAP_DATA_REG) & 0xff);
+	printk(".");
+
+	return *data;
+}
+
+int fpga_spartan6_wdata_fn(Xilinx_desc *desc, unsigned char data, 
+							int flush, int cookie)
+{
+	uint16_t val = data & 0x00ff;
+
+	writew(val, SELECTMAP_DATA_REG);
+
+	return data;
+}
+
+/* Set the FPGA's wr line to the specified level */
+int fpga_spartan6_wr_fn(Xilinx_desc *desc, int assert_write, int flush, int cookie)
+{
+	unsigned short config;
+
+	config = readw(SELECTMAP_CONFIG_REG);
+	if (assert_write)
+		config &= ~(1 << SELECTMAP_CONFIG_RDWR_N);
+	else
+		config |= (1 << SELECTMAP_CONFIG_RDWR_N);
+	writew(config, SELECTMAP_CONFIG_REG);
+
+	return assert_write;
+}
+
+int fpga_spartan6_cs_fn(Xilinx_desc *desc, int assert_cs, int flush, int cookie)
+{
+	int config;
+	config = readw(SELECTMAP_CONFIG_REG);
+	if (assert_cs)
+		config &= ~(1 << SELECTMAP_CONFIG_CSI_N);
+	else
+		config |= (1 << SELECTMAP_CONFIG_CSI_N);
+	writew(config, SELECTMAP_CONFIG_REG);
+
+	return assert_cs;
+}
+
+/* Initialize FPGA before download */
+int fpga_spartan6_pre_fn(Xilinx_desc *desc, int cookie)
+{
+	int config;
+
+	config = readw(SELECTMAP_CONFIG_REG);
+	config &= ~(1 << SELECTMAP_CONFIG_CLK);	/* IP in selectmap mode */
+	config |= (1 << SELECTMAP_CONFIG_OS);	/* OS High */
+	config |= (1 << SELECTMAP_CONFIG_CSI_N);	/* CSI_n High */
+	config |= (1 << SELECTMAP_CONFIG_PROGRAM_N);	/* PROGRAM_n High */
+	config |= (1 << SELECTMAP_CONFIG_RDWR_N);	/* rdwr_n High */
+
+	writew(config, SELECTMAP_CONFIG_REG);
+	udelay(1);		/*wait until supply started */
+	config = readw(SELECTMAP_CONFIG_REG);
+
+	return cookie;
+}
+
+/* Set the FPGA's active-low program line to the specified level */
+int fpga_spartan6_pgm_fn(Xilinx_desc *desc, int assert, int flush, int cookie)
+{
+	unsigned short config;
+
+	config = readw(SELECTMAP_CONFIG_REG);
+
+	if (assert)
+		config &= ~(1 << SELECTMAP_CONFIG_PROGRAM_N);
+	else
+		config |= (1 << SELECTMAP_CONFIG_PROGRAM_N);
+
+	writew(config, SELECTMAP_CONFIG_REG);
+
+	return assert;
+}
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/spartan_loadsecond.h linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/spartan_loadsecond.h
--- linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/spartan_loadsecond.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/spartan_loadsecond.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,119 @@
+#ifndef SPARTAN_LOADSECOND_H
+#define SPARTAN_LOADSECOND_H
+
+/* Xilinx types
+ *  *********************************************************************/
+struct sp_vision_struct {
+	uint32_t fpga_offset;
+	int ip_addr;
+	int ip_id;
+};
+
+typedef enum {			/* typedef Xilinx_iface */
+	min_xilinx_iface_type,	/* low range check value */
+	slave_serial,		/* serial data and external clock */
+	master_serial,		/* serial data w/ internal clock (not used) */
+	slave_parallel,		/* parallel data w/ external latch */
+	jtag_mode,		/* jtag/tap serial (not used ) */
+	master_selectmap,	/* master SelectMap (virtex2)           */
+	slave_selectmap,	/* slave SelectMap (virtex2)            */
+	max_xilinx_iface_type	/* insert all new types before this */
+} Xilinx_iface;			/* end, typedef Xilinx_iface */
+
+typedef enum {			/* typedef Xilinx_Family */
+	min_xilinx_type,	/* low range check value */
+	Xilinx_Spartan2,	/* Spartan-II Family */
+	Xilinx_VirtexE,		/* Virtex-E Family */
+	Xilinx_Virtex2,		/* Virtex2 Family */
+	Xilinx_Spartan3,	/* Spartan-III Family */
+	Xilinx_Spartan6,	/* Spartan-VI Family */
+	max_xilinx_type		/* insert all new types before this */
+} Xilinx_Family;		/* end, typedef Xilinx_Family */
+
+typedef struct {		/* typedef Xilinx_desc */
+	Xilinx_Family family;	/* part type */
+	Xilinx_iface iface;	/* interface type */
+	size_t size;		/* bytes of data part can accept */
+	void *iface_fns;	/* interface function table */
+	/* XXX:for second fpga configuration (throught first fpga) */
+	uint32_t fpga_offset;	/* first fpga offset */
+	void *ip_addr;		/* Address of spartan_selectmap IP */
+	int ip_id;		/* Idendifiant of spartan_selectmap IP */
+	/* end of XXX */
+	int cookie;		/* implementation specific cookie */
+	// ggm //
+	const char *name;             /* instance name  */
+	int num;                      /* instance number */
+	int idnum;                    /* identity number */
+	int idoffset;                 /* identity relative address */
+	struct sploader_dev *sdev;    /* struct for main device structure */
+
+} Xilinx_desc;			/* end, typedef Xilinx_desc */
+
+typedef int (*Xilinx_pgm_fn) (Xilinx_desc *desc, int assert_pgm, int flush, int cookie);
+typedef int (*Xilinx_init_fn) (Xilinx_desc *desc, int cookie);
+typedef int (*Xilinx_err_fn) (Xilinx_desc *desc, int cookie);
+typedef int (*Xilinx_done_fn) (Xilinx_desc *desc, int cookie);
+typedef int (*Xilinx_clk_fn) (Xilinx_desc *desc, int assert_clk, int flush, int cookie);
+typedef int (*Xilinx_cs_fn) (Xilinx_desc *desc, int assert_cs, int flush, int cookie);
+typedef int (*Xilinx_wr_fn) (Xilinx_desc *desc, int assert_write, int flush, int cookie);
+typedef int (*Xilinx_rdata_fn) (Xilinx_desc *desc, unsigned char *data, int cookie);
+typedef int (*Xilinx_wdata_fn) (Xilinx_desc *desc, unsigned char data, int flush, int cookie);
+typedef int (*Xilinx_busy_fn) (Xilinx_desc *desc, int cookie);
+typedef int (*Xilinx_abort_fn) (Xilinx_desc *desc, int cookie);
+typedef int (*Xilinx_pre_fn) (Xilinx_desc *desc, int cookie);
+typedef int (*Xilinx_post_fn) (Xilinx_desc *desc, int cookie);
+
+typedef struct {
+	Xilinx_pre_fn pre;
+	Xilinx_pgm_fn pgm;
+	Xilinx_init_fn init;
+	Xilinx_err_fn err;
+	Xilinx_done_fn done;
+	Xilinx_clk_fn clk;
+	Xilinx_cs_fn cs;
+	Xilinx_wr_fn wr;
+	Xilinx_rdata_fn rdata;
+	Xilinx_wdata_fn wdata;
+	Xilinx_busy_fn busy;
+	Xilinx_abort_fn abort;
+	Xilinx_post_fn post;
+	int relocated;
+} Xilinx_Spartan6_Slave_SelectMap_fns;
+
+#define FPGA_FAIL -1
+#define FPGA_SUCCESS 0
+#define FALSE                    (0)
+#define TRUE                     (!FALSE)
+#define SELECTMAP_CONFIG_REG        (desc->ip_addr+2)
+#define SELECTMAP_STATUS_REG        (desc->ip_addr+4)
+#define SELECTMAP_STATUS_BUSY       1
+
+#define SELECTMAP_CONFIG_CLK                4
+#define CONFIG_SYS_FPGA_WAIT            20000	/* 20 ms */
+#define CONFIG_FPGA_DELAY()
+#define SELECTMAP_STATUS_INIT_N     2
+#define SELECTMAP_STATUS_DONE       0
+#define SELECTMAP_DATA_REG  (desc->ip_addr+6)
+#define SELECTMAP_CONFIG_RDWR_N             0
+#define SELECTMAP_CONFIG_CSI_N              2
+#define SELECTMAP_CONFIG_PROGRAM_N  1
+
+int loadsecond(Xilinx_desc * desc/*, void *ip_addr, int ip_id*/);
+int write_content(Xilinx_desc * desc, void *buf, size_t bsize);
+int end_load(Xilinx_desc * desc);
+
+int fpga_spartan6_pre_fn(Xilinx_desc *desc, int cookie);
+int fpga_spartan6_pgm_fn(Xilinx_desc *desc, int assert_pgm, int flush, int cookie);
+int fpga_spartan6_cs_fn(Xilinx_desc *desc, int assert_cs, int flush, int cookie);
+int fpga_spartan6_init_fn(Xilinx_desc *desc, int cookie);
+int fpga_spartan6_done_fn(Xilinx_desc *desc, int cookie);
+int fpga_spartan6_clk_fn(Xilinx_desc *desc, int assert_clk, int flush, int cookie);
+int fpga_spartan6_wr_fn(Xilinx_desc *desc, int assert_write, int flush, int cookie);
+int fpga_spartan6_rdata_fn(Xilinx_desc *desc, unsigned char *data, int cookie);
+int fpga_spartan6_wdata_fn(Xilinx_desc *desc, unsigned char data, int flush, int cookie);
+int fpga_spartan6_abort_fn(Xilinx_desc *desc, int cookie);
+int fpga_spartan6_busy_fn(Xilinx_desc *desc, int cookie);
+int fpga_spartan6_post_fn(Xilinx_desc *desc, int cookie);
+
+#endif				/*SPARTAN_LOADSECOND_H */
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/sploader.h linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/sploader.h
--- linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/sploader.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/fpga/virtual_components/sploader/sploader.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,37 @@
+/*
+ * Platform data for Wishbone SPLOADER IP driver
+ *
+ * (c) Copyright 2007-2011 The Armadeus Project - ARMadeus Systems
+ * Fabien Marteau <fabien.marteau@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __SPLOADER_H__
+#define __SPLOADER_H__
+
+#define SPLOADER_REG_OFFSET (0x00)
+
+/* platform device */
+struct plat_sploader_port
+{
+  const char *name;				/* instance name  */
+  int num;						/* instance number */
+  int idnum;					/* identity number */
+  int idoffset;					/* identity relative address */
+  struct sploader_dev *sdev;	/* struct for main device structure */
+};
+
+#endif /* __SPLOADER_H__ */
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/generic/Kconfig linux-3.13/drivers/armadeus/generic/Kconfig
--- linux-3.13/drivers/armadeus/generic/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/generic/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,10 @@
+#
+#
+
+config ARMADEUS_GENERIC_DRIVER
+        tristate "Generic Armadeus driver (for test)"
+        default n
+        depends on ARMADEUS_DRIVERS
+        ---help---
+		  Could be useful as startpoint for your own linux-3.13/drivers
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/generic/Makefile linux-3.13/drivers/armadeus/generic/Makefile
--- linux-3.13/drivers/armadeus/generic/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/generic/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,25 @@
+#
+# Makefile for a generic Armadeus linux-3.13/drivers
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_ARMADEUS_GENERIC_DRIVER)	+= genmod.o
+generic-objs	:= generic.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/generic/generic.c linux-3.13/drivers/armadeus/generic/generic.c
--- linux-3.13/drivers/armadeus/generic/generic.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/generic/generic.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,458 @@
+/*
+ **********************************************************************
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ **********************************************************************
+ */
+
+#define GPIO_PROC_FILE 1
+#define SETTINGS_PROC_FILE 4
+
+#include "generic.h"
+#include <asm/arch/imx-regs.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#define PORT_A      0
+#define PORT_B      1
+#define PORT_C      2
+#define PORT_D      3
+#define NB_PORTS    4
+#define PORT_MAX_ID 4
+
+enum {
+    DDIR_I = 0,
+    OCR1_I,
+    OCR2_I,
+    ICONFA1_I,
+    ICONFA2_I,
+    ICONFB1_I,
+    ICONFB2_I,
+    DR_I,
+    GIUS_I,
+    SSR_I,
+    ICR1_I,
+    ICR2_I,
+    IMR_I,
+    GPR_I,
+    SWR_I,
+    PUEN_I,
+};
+
+#define PORTB27_21MASK    ((unsigned long)0x0FF00000)
+#define PORTB27_21SHIFT   20
+#define PORT_D_31_10_MASK 0xFFFFFC00
+
+// Global variables
+struct gpio_operations *driver_ops;
+static int gpio_major =  GPIO_MAJOR;
+
+static int number_of_pins[4] = {32, 32, 32, 32};
+
+static unsigned long init_map;
+struct semaphore gpio_sema;
+
+static unsigned int gPortAIndex = PORT_A;
+static unsigned int gPortBIndex = PORT_B;
+static unsigned int gPortCIndex = PORT_C;
+static unsigned int gPortDIndex = PORT_D;
+// Module parameters
+
+static void __exit armadeus_generic_cleanup(void);
+
+
+//------------------------------------------------
+//
+// Low level functions
+//
+#define DEFAULT_VALUE 0x12345678
+static unsigned long MASK[]= { 0x0003FFFE, 0xF00FFF00, 0x0003E1F8, 0xFFFFFFFF };
+#define PORT_A_MASK    0x0003FFFE
+#define PORT_B_MASK    0xF00FFF00
+#define PORT_C_MASK    0x0003E1F8
+#define PORT_D_MASK    0xFFFFFFFF
+
+
+//------------------------------------------------
+//
+// Handles write() done on /dev/gpioxx
+//
+static ssize_t armadeus_gpio_write(struct file *file, const char *data, size_t count, loff_t *ppos)
+{
+    unsigned int minor;
+    size_t        i;
+    /*char*/unsigned int          port_value=0;
+    ssize_t       ret = 0;
+    unsigned int  value=0;
+    
+    minor = MINOR(file->f_dentry->d_inode->i_rdev);
+    printk("armadeus_gpio_write() on minor %d\n", minor);
+    
+    if (ppos != &file->f_pos)
+        return -ESPIPE;
+    
+    if (down_interruptible(&gpio_sema))
+        return -ERESTARTSYS;
+
+    value = 0;
+    for (i = 0; i < count; ++i) 
+    {
+        port_value = 0;
+        // Get value to write from user space
+        ret = __get_user(port_value, (unsigned int*)/*(char *)*/data);
+        if (ret != 0) {
+            //ret = -EFAULT;
+            goto out;
+        }
+
+        //writeOnPort( minor, port_value );
+        
+        data++;
+        *ppos = *ppos+1;
+    }
+    ret = count;
+
+out:
+    up(&gpio_sema);
+    return ret;
+}
+
+//
+// Handles read() done on /dev/gpioxx
+//
+static ssize_t armadeus_gpio_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+    unsigned minor = MINOR(file->f_dentry->d_inode->i_rdev);
+    unsigned long value=0;
+    size_t bytes_read=0;
+    ssize_t ret = 0;
+    char port_status;
+    
+    if (count == 0)
+        return bytes_read;
+    
+    if (ppos != &file->f_pos)
+        return -ESPIPE;
+    
+    if (down_interruptible(&gpio_sema))
+        return -ERESTARTSYS;
+        
+    printk("armadeus_gpio_read on minor %d\n", minor);
+            
+    //value = readFromPort( minor );
+    port_status = (char)(value & 0xFF);
+    
+    if (copy_to_user(buf, &port_status, sizeof(unsigned int))) {
+        ret = -EFAULT;
+        goto out;
+    }
+    bytes_read += sizeof(unsigned int);
+    buf += sizeof(unsigned int);
+    *ppos = *ppos+4;
+    ret = bytes_read;
+
+out:
+    up(&gpio_sema);
+    return ret;
+}
+
+static int armadeus_gpio_open(struct inode *inode, struct file *file)
+{
+    unsigned minor = MINOR(inode->i_rdev);
+    
+    if( minor >= PORT_MAX_ID ) {
+        printk("unsupported minor\n");
+        return -EINVAL;
+    }
+
+    printk("Opening /dev/gpio%d file\n", minor);
+    return 0;
+}
+
+static int armadeus_gpio_release(struct inode *inode, struct file *file)
+{
+    unsigned minor = MINOR(inode->i_rdev);
+    
+    printk("Closing access to /dev/gpio%d\n", minor);
+    return 0;
+}
+
+
+//------------------------------------------------
+// PROC file functions
+//
+static int procfile_gpio_read( char *buffer, __attribute__ ((unused)) char **start, off_t offset, int buffer_length, int *eof, void* data) 
+{
+    int len; /* The number of bytes actually used */
+    unsigned int port_status=0x53;
+    unsigned int port_ID = 0;
+    
+    if( data != NULL )
+    {   
+        port_ID = *((unsigned int*)data);
+        //printk("procfile_gpio_read %d \n", port_ID);
+    }
+    
+    // We give all of our information in one go, so if the user asks us if we have more information the answer should always be no.
+    // This is important because the standard read function from the library would continue to issue the read system call until 
+    // the kernel replies that it has no more information, or until its buffer is filled.
+    
+    if( (offset > 0) || (buffer_length < number_of_pins[port_ID]+2) ) 
+    {
+        return 0;
+    }
+    
+    len = buffer_length;
+    if( len > MAX_NUMBER_OF_PINS + 1 ) 
+    {
+        len = MAX_NUMBER_OF_PINS + 1;
+    }
+    
+    if (down_interruptible(&gpio_sema))
+        return -ERESTARTSYS;
+    
+    // Get the status of the gpio ports
+    //port_status = readFromPort( port_ID );
+    // Put status to given chr buffer
+    //len = toString(port_status, buffer, number_of_pins[/*PORT_B*/port_ID]);
+    
+    //*start = buffer;
+    *eof = 1;
+    up(&gpio_sema);
+    
+    // Return the length    
+    return len;
+}
+
+
+static int procfile_gpio_write( __attribute__ ((unused)) struct file *file, const char *buf, unsigned long count, void *data)
+{
+    int len;
+    char new_gpio_state[MAX_NUMBER_OF_PINS+1];
+    unsigned int gpio_state = 0;
+    unsigned int port_ID = 0;
+    
+    if( data != NULL )
+    {   
+        port_ID = *((unsigned int*)data);
+    }
+
+    // Do some checks on parameters    
+    if( count <= 0 ){
+        printk("Empty string transmitted !\n");
+        return 0;
+    }    
+    if( count > (MAX_NUMBER_OF_PINS + 1) ) {
+        len = MAX_NUMBER_OF_PINS;
+       printk("Gpio port is only 32bits !\n");
+    } else {
+        len = count;
+    }
+
+    // Get exclusive access to port    
+    if( down_interruptible(&gpio_sema) )
+        return -ERESTARTSYS;
+    
+    // Get datas to write from user space
+    if( copy_from_user(new_gpio_state, buf, len) ) {
+        up(&gpio_sema);
+        return -EFAULT;
+    }
+    
+    // Convert it from String to Int
+    //gpio_state = fromString(new_gpio_state, number_of_pins[port_ID] /*__number_of_pins*/);
+    printk("/proc asking me to write %d bits (0x%x) on GPIO%d\n", len, gpio_state, port_ID);
+
+    // Put value in GPIO registers    
+    //writeOnPort( port_ID, gpio_state );
+    
+    up(&gpio_sema);
+    
+    return len;
+}
+
+
+//------------------------------------------------
+//  Handling of IOCTL calls 
+//
+int armadeus_generic_ioctl( struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg )
+{
+    int err = 0; int ret = 0;
+    int value=0;
+    unsigned int minor;
+    
+    printk(" ## IOCTL received: (0x%x) ##\n", cmd);
+    
+    // Extract the type and number bitfields, and don't decode wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()
+    if (_IOC_TYPE(cmd) != PP_IOCTL) return -ENOTTY;
+
+    // The direction is a bitmask, and VERIFY_WRITE catches R/W transfers. `Type' is user-oriented, while access_ok is kernel-oriented, 
+    // so the concept of "read" and "write" is reversed
+    if (_IOC_DIR(cmd) & _IOC_READ)
+        err = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
+    else if (_IOC_DIR(cmd) & _IOC_WRITE)
+        err =  !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
+
+    if (err) return -EFAULT;
+
+    // Obtain exclusive access
+    if (down_interruptible(&gpio_sema))
+        return -ERESTARTSYS;
+    // Extract and test minor
+    minor = MINOR(inode->i_rdev);
+    if( minor > GPIO_MAX_MINOR ) {
+        printk("Minor outside range: %d !\n", minor);
+        return -EFAULT;
+    }
+    
+    switch(cmd) 
+    {
+        case GPIORDDIRECTION:
+            //value = getPortDir( minor );
+            //    value = (getPortDir( PORT_B ) & PORTB27_21MASK) >> PORTB27_21SHIFT;
+            ret = __put_user(value, (unsigned int *)arg);
+        break;
+
+        case GPIOWRDIRECTION:
+            ret = __get_user(value, (unsigned int *)arg);
+
+            if( ret==0 ) {
+                //setPortDir( minor, value );
+            }
+        break;
+
+        case GPIORDDATA:
+            //value = readFromPort( minor );
+            ret = __put_user(value, (unsigned int *)arg);
+        break;
+
+        case GPIOWRDATA:
+            ret = __get_user(value, (unsigned int *)arg);
+            if( ret == 0 ) {
+                //writeOnPort( minor, value );
+            }
+        break;
+
+        default:
+            return -ENOTTY;
+        break;
+    }
+    // Release exclusive access
+    up(&gpio_sema);
+
+    return ret;
+}
+
+//
+// Create /proc entries for direct access (with echo/cat) to GPIOs config
+//
+static int create_proc_entries( void )
+{
+    static struct proc_dir_entry *Proc_PortA;
+    
+    //
+    printk("Creating /proc entries: ");
+    // Create main directory
+    proc_mkdir(GPIO_PROC_DIRNAME, NULL);
+    // Create proc file to handle GPIO values
+    Proc_PortA = create_proc_entry( GENERIC_PROC_FILENAME, S_IWUSR |S_IRUSR | S_IRGRP | S_IROTH, NULL);
+    
+    if( Proc_PortA == NULL ) 
+    {
+        printk(KERN_ERR DRIVER_NAME ": Could not register a " GENERIC_PROC_FILENAME  ". Terminating\n");
+        armadeus_generic_cleanup();
+        return -ENOMEM;
+    } 
+    else 
+    {
+        Proc_PortA->read_proc  = procfile_gpio_read;   Proc_PortA->write_proc = procfile_gpio_write; Proc_PortA->data  = (void*)&gPortAIndex;
+        init_map |= GPIO_PROC_FILE;
+    }
+    
+    printk("OK!\n");
+    return(0);
+}
+
+static struct file_operations gpio_fops = {
+    .owner   = THIS_MODULE,
+    .write   = armadeus_gpio_write,
+    .read    = armadeus_gpio_read,
+    .open    = armadeus_gpio_open,
+    .release = armadeus_gpio_release,
+    .ioctl   = armadeus_generic_ioctl,
+};
+
+//
+// Module's initialization function
+//
+static int __init armadeus_generic_init(void)
+{
+    static int result, i;
+
+    printk("Initializing Armadeus generic driver\n");
+    init_map = 0;
+       
+    // Register the driver by getting a major number
+    result = register_chrdev(gpio_major, DRIVER_NAME, &gpio_fops);
+    if (result < 0) 
+    {
+        printk(KERN_WARNING DRIVER_NAME ": can't get major %d\n", gpio_major);
+        return result;
+    }
+    if( gpio_major == 0 ) gpio_major = result; // dynamic Major allocation
+
+    // Creating /proc entries
+    result = create_proc_entries();
+    if( result < 0 ) return( result );
+    
+    // Initialise GPIO port access semaphore
+    sema_init(&gpio_sema, 1);
+
+    // Set GPIOs to initial state
+    //??
+    
+    printk( DRIVER_NAME " " DRIVER_VERSION " successfully loaded !\n");
+
+    return(0);
+}
+
+//
+// Module's cleanup function
+//
+static void __exit armadeus_generic_cleanup(void)
+{
+    printk( DRIVER_NAME " Cleanup: ");
+    
+    // Remove /proc entries
+    remove_proc_entry( GENERIC_PROC_FILENAME, NULL);
+//     remove_proc_entry( GPIO_PROC_PORTB_FILENAME, NULL);
+//     remove_proc_entry( GPIO_PROC_PORTC_FILENAME, NULL);
+//     remove_proc_entry( GPIO_PROC_PORTD_FILENAME, NULL);
+//     remove_proc_entry( GPIO_PROC_PORTADIR_FILENAME, NULL);
+//     remove_proc_entry( GPIO_PROC_PORTBDIR_FILENAME, NULL);
+//     remove_proc_entry( GPIO_PROC_PORTCDIR_FILENAME, NULL);
+//     remove_proc_entry( GPIO_PROC_PORTDDIR_FILENAME, NULL);
+
+    // De-register from /dev interface
+    unregister_chrdev(gpio_major, DRIVER_NAME);
+
+    printk("Ok !\n ");
+}
+
+module_init(armadeus_generic_init);
+module_exit(armadeus_generic_cleanup);
+MODULE_AUTHOR("Julien Boibessot");
+MODULE_DESCRIPTION("Armadeus generic driver");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/generic/generic.h linux-3.13/drivers/armadeus/generic/generic.h
--- linux-3.13/drivers/armadeus/generic/generic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/generic/generic.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,66 @@
+/*
+ **********************************************************************
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ **********************************************************************
+*/
+
+#ifndef __CORE_GPIO_H__
+#define __CORE_GPIO_H__
+
+#include <linux/config.h>
+#include <config/modversions.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/fcntl.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/pci.h>
+
+// Proc filenames:
+#define GPIO_PROC_DIRNAME         "driver/generic"
+//
+#define GENERIC_PROC_FILENAME  GPIO_PROC_DIRNAME "/toto"
+/*#define GPIO_PROC_PORTB_FILENAME  GPIO_PROC_DIRNAME "/portB"
+#define GPIO_PROC_PORTC_FILENAME  GPIO_PROC_DIRNAME "/portC"
+#define GPIO_PROC_PORTD_FILENAME  GPIO_PROC_DIRNAME "/portD"*/
+
+// By default, we use dynamic allocation of major numbers -> MAJOR = 0
+#define GPIO_MAJOR 0
+#define GPIO_MAX_MAJOR 254
+#define GPIO_MAX_MINOR 4 
+
+// IOCTL 
+#define GPIORDDIRECTION _IOR(PP_IOCTL, 0xF0, int)  //Read/write bitmask that determines input/output pins (1 means output, 0 input)
+#define GPIOWRDIRECTION _IOW(PP_IOCTL, 0xF1, int)
+#define GPIORDDATA      _IOR(PP_IOCTL, 0xF2, int)
+#define GPIOWRDATA      _IOW(PP_IOCTL, 0xF3, int)
+
+#define MAX_NUMBER_OF_PINS 32
+//#define OUR_NAME       "Armadeus_gpio"
+#define DRIVER_NAME    "Armadeus GPIOs driver"
+#define DRIVER_VERSION "v0.0.1"
+
+// Pretend we're PPDEV for IOCTL
+#include <linux/ppdev.h>
+
+
+#endif // __CORE_GPIO_H__
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/gpio/Kconfig linux-3.13/drivers/armadeus/gpio/Kconfig
--- linux-3.13/drivers/armadeus/gpio/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/gpio/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,16 @@
+#
+#
+
+config ARMADEUS_GPIO_DRIVER
+        tristate "Armadeus GPIO driver"
+        default n
+        depends on ARMADEUS_DRIVERS
+        ---help---
+
+config ARMADEUS_PPDEV_DRIVER
+        tristate "Armadeus Parallel Port emulation driver (with LCD port)"
+        default n
+        depends on ARMADEUS_GPIO_DRIVER && MACH_APF9328
+        ---help---
+          This driver allows you to emulate a parallel port interface with GPIO.
+          Activate it if you want for example connect a LCD with a // port interface.
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/gpio/Makefile linux-3.13/drivers/armadeus/gpio/Makefile
--- linux-3.13/drivers/armadeus/gpio/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/gpio/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,28 @@
+#
+# Makefile for the Armadeus GPIO linux-3.13/drivers
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_ARMADEUS_GPIO_DRIVER)	+= gpio.o
+obj-$(CONFIG_ARMADEUS_PPDEV_DRIVER)	+= ppdev.o
+
+gpio-objs	:= core.o
+ppdev-objs	:= ppdevemu.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets:
+include ../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/gpio/README linux-3.13/drivers/armadeus/gpio/README
--- linux-3.13/drivers/armadeus/gpio/README	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/gpio/README	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,8 @@
+
+To compile:
+make ARCH=arm CROSS_COMPILE=/local/julien/arm-toolchain/buildroot/build_arm_nofpu/staging_dir/bin/arm-linux-
+
+3 linux-3.13/drivers/armadeus (gpio.ko, ppdev.ko, loadfpga.ko) will be generated, copy them in your rootfs (/lib/linux-3.13/drivers/armadeus).
+copy loadgpio.sh in your /etc/init.d directory on your rootfs and launch it to insert linux-3.13/drivers/armadeus and create devices file in /dev
+
+Juliem
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/gpio/core.c linux-3.13/drivers/armadeus/gpio/core.c
--- linux-3.13/drivers/armadeus/gpio/core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/gpio/core.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,1401 @@
+/*
+ * Armadeus i.MXL/27 GPIO management driver
+ *
+ * Copyright (C) 2006-2010	Julien Boibessot <julien.boibessot@armadeus.com>
+ *				Nicolas Colombain <nicolas.colombain@armadeus.com>
+ *				Fabien Marteau <fabien.marteau@armadeus.com>
+ *				Armadeus Project / Armadeus Systems
+ *
+ * Inspired by a lot of other GPIO management systems...
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/interrupt.h>	/* request_irq */
+#include <linux/irq.h>		/* set_irq_type */
+#include <asm/gpio.h>		/* imx_gpio_... */
+#include <linux/cdev.h>		/* struct cdev */
+#include <mach/hardware.h>
+#include <asm/mach/map.h>
+#include <linux/poll.h>
+#ifdef CONFIG_ARCH_MX2
+#include <mach/iomux-mx1-mx2.h>
+#endif
+#ifdef CONFIG_ARCH_IMX		/* TO BE REMOVED WHEN MX1 PLATFORM EXIST */
+#include "iomux-mx1.h"
+#endif
+
+#include "gpio-dev.h"		/* for ioctl defs */
+
+
+#define DRIVER_NAME	"Armadeus GPIOs driver"
+#define DRIVER_VERSION	"2.6"
+
+/* By default, we use dynamic allocation of major numbers -> MAJOR = 0 */
+#define GPIO_MAJOR 0
+#define GPIO_PROC_DIRNAME	"driver/gpio"
+
+#define GPIO_PROC_FILE_INIT		(1 << 0)
+#define SETTINGS_PROC_FILE_INIT		(1 << 3)
+#define SETTINGS_IRQ_PROC_FILE_INIT	(1 << 4)
+#define SETTINGS_PULLUP_PROC_FILE_INIT	(1 << 5)
+#define SETTINGS_MODE_PROC_FILE_INIT	(1 << 6)
+
+#define MAX_NUMBER_OF_PINS 32
+
+#define PORT_A		0
+#define PORT_B		1
+#define PORT_C		2
+#define PORT_D		3
+#ifdef CONFIG_ARCH_IMX
+#define NB_PORTS	4
+#endif
+#ifdef CONFIG_ARCH_MX2
+#define PORT_E		4
+#define PORT_F		5
+#define NB_PORTS	6
+#endif
+
+#define MAX_MINOR	255	/* Linux limitation */
+
+#define FULL_PORTA_MINOR (MAX_MINOR - PORT_A)
+#define FULL_PORTB_MINOR (MAX_MINOR - PORT_B)
+#define FULL_PORTC_MINOR (MAX_MINOR - PORT_C)
+#define FULL_PORTD_MINOR (MAX_MINOR - PORT_D)
+#ifndef CONFIG_ARCH_IMX
+#define FULL_PORTE_MINOR (MAX_MINOR - PORT_E)
+#define FULL_PORTF_MINOR (MAX_MINOR - PORT_F)
+#endif
+#define FULL_MINOR_TO_PORT(x) (MAX_MINOR - x)
+
+/* Parameters order: */
+enum {
+	DDIR_I = 0,
+	OCR1_I,
+	OCR2_I,
+	ICONFA1_I,
+	ICONFA2_I,
+	ICONFB1_I,
+	ICONFB2_I,
+	DR_I,
+	GIUS_I,
+	SSR_I,
+	ICR1_I,
+	ICR2_I,
+	IMR_I,
+	GPR_I,
+	SWR_I,
+	PUEN_I,
+};
+
+/* Global variables */
+struct gpio_operations *driver_ops;
+static int gpio_major = GPIO_MAJOR;
+
+#ifdef CONFIG_ARCH_IMX
+static int number_of_pins[NB_PORTS] = { 32, 32, 32, 32 };
+#else
+static int number_of_pins[NB_PORTS] = { 32, 32, 32, 32, 32, 32 };
+#endif
+
+static unsigned long init_map;
+struct semaphore gpio_sema;
+
+enum {
+	VALUE = 0,
+	DIRECTION,
+	PULL_UP,
+	INTERRUPT,
+	MODE,
+	NB_SETTINGS,		/* nb of settings in this enum -> should always be the last ! */
+};
+
+struct gpio_settings {
+	unsigned int port;
+	int type;
+};
+
+/* Module parameters */
+#define NB_CONFIG_REGS 16
+static int portA_init[NB_CONFIG_REGS] =
+    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+static int portA_init_nb = 0;
+module_param_array(portA_init, int, &portA_init_nb, 0000);
+static int portB_init[NB_CONFIG_REGS] =
+    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+static int portB_init_nb = 0;
+module_param_array(portB_init, int, &portB_init_nb, 0000);
+static int portC_init[NB_CONFIG_REGS] =
+    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+static int portC_init_nb = 0;
+module_param_array(portC_init, int, &portC_init_nb, 0000);
+static int portD_init[NB_CONFIG_REGS] =
+    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+static int portD_init_nb = 0;
+module_param_array(portD_init, int, &portD_init_nb, 0000);
+#ifndef CONFIG_ARCH_IMX
+static int portE_init[NB_CONFIG_REGS] =
+    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+static int portE_init_nb = 0;
+module_param_array(portE_init, int, &portE_init_nb, 0000);
+static int portF_init[NB_CONFIG_REGS] =
+    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+static int portF_init_nb = 0;
+module_param_array(portF_init, int, &portF_init_nb, 0000);
+#endif
+
+struct gpio_item {
+	spinlock_t lock;
+
+	int enabled;
+	int initialized;
+	int port;
+	int nb_pins;
+	int number;
+	unsigned char irq_value;
+	u32 pin_mask;
+	u32 oe_mask;
+
+	/* Pin state last time we read it (for blocking reads) */
+	u32 pin_state;
+	int changed;
+
+	wait_queue_head_t change_wq;
+	struct fasync_struct *async_queue;
+
+	int id;
+	struct class_device *gpio_dev;
+	struct cdev char_dev;
+	/* struct config_item item; TBDJUJU: Use configfs filesystem ! */
+};
+
+#ifdef CONFIG_ARCH_IMX
+static unsigned int shadows_irq_h[NB_PORTS] = { 0, 0, 0, 0 };
+static unsigned int shadows_irq_l[NB_PORTS] = { 0, 0, 0, 0 };
+#else
+static unsigned int shadows_irq_h[NB_PORTS] = { 0, 0, 0, 0, 0, 0 };
+static unsigned int shadows_irq_l[NB_PORTS] = { 0, 0, 0, 0, 0, 0 };
+#endif
+
+/* Static functions */
+
+static void __exit armadeus_gpio_cleanup(void);
+
+static int toString(unsigned long value, char *buffer, int number_of_bits,
+		    int base)
+{
+	static int i, j;
+	char mask = 0x01 | base;
+
+	/* convert it into a string */
+	for (j = (base * number_of_bits) - (base), i = number_of_bits; i > 0;
+	     i--, j -= base) {
+		buffer[number_of_bits - i] = ((value >> j) & mask) + '0';
+	}
+
+	buffer[number_of_bits] = '\n';
+	buffer[number_of_bits + 1] = 0;
+
+	return number_of_bits + 1;
+}
+
+/* Convert binary string ("010011") to int. Don't care of non '0' / '1' chars */
+static unsigned long fromString(char *buffer, int number_of_bits, int base)
+{
+	int i, j;
+	unsigned long ret_val = 0;
+
+	ret_val = 0;
+	/* Create WORD to write from the string */
+	for (i = 0, j = 1; j <= number_of_bits; i++) {
+		//printk("%x j=%d i=%d\n", buffer[i], j, i);
+		if (buffer[i] == '\0')
+			break;	/* EOC */
+
+		ret_val <<= base;
+		ret_val |= (buffer[i] - '0') & 0xff;
+		j++;
+	}
+
+	return ret_val;
+}
+
+/*
+ * Low level functions
+ */
+/* These masks are for restricting user access to configuration of some
+ * criticals GPIO pins used by Armadeus and not configurable */
+#ifdef CONFIG_ARCH_IMX
+static unsigned long PORT_MASK[] =
+    { 0x0003FFFE, 0xF00FFF00, 0x0003E1F8, 0xFFFFFFFF };
+#else
+static unsigned long PORT_MASK[] =
+    { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFC000, 0xFFFE0000, 0x00FFCCF8, 0x00FFFF80 };
+#endif
+
+static void initialize_port(int port, int *init_params)
+{
+	u32 lTemp;
+
+	/* Initialize PORT with module parameters */
+	if (init_params[DR_I]) {
+		__raw_writel(init_params[DR_I], VA_GPIO_BASE + MXC_DR(port));
+	}
+	if (init_params[SSR_I]) {
+		__raw_writel(init_params[SSR_I], VA_GPIO_BASE + MXC_SSR(port));
+	}
+	if (init_params[OCR1_I]) {
+		__raw_writel(init_params[OCR1_I],
+			     VA_GPIO_BASE + MXC_OCR1(port));
+	}
+	/*else { default value are already set by iMX !! */
+	if (init_params[OCR2_I]) {
+		__raw_writel(init_params[OCR2_I],
+			     VA_GPIO_BASE + MXC_OCR2(port));
+	}
+	if (init_params[ICONFA1_I]) {
+		__raw_writel(init_params[ICONFA1_I],
+			     VA_GPIO_BASE + MXC_ICONFA1(port));
+	}
+	if (init_params[ICONFA2_I]) {
+		__raw_writel(init_params[ICONFA2_I],
+			     VA_GPIO_BASE + MXC_ICONFA2(port));
+	}
+	if (init_params[ICONFB1_I]) {
+		__raw_writel(init_params[ICONFB1_I],
+			     VA_GPIO_BASE + MXC_ICONFB1(port));
+	}
+	if (init_params[ICONFB2_I]) {
+		__raw_writel(init_params[ICONFB2_I],
+			     VA_GPIO_BASE + MXC_ICONFB2(port));
+	}
+	if (init_params[DDIR_I]) {
+		__raw_writel(init_params[DDIR_I],
+			     VA_GPIO_BASE + MXC_DDIR(port));
+	}
+	if (init_params[SWR_I]) {
+		__raw_writel(init_params[SWR_I], VA_GPIO_BASE + MXC_SWR(port));
+	}
+	if (init_params[GPR_I]) {
+		lTemp = __raw_readl(VA_GPIO_BASE +
+				MXC_GPR(port)) & (~PORT_MASK[port]);
+		__raw_writel(lTemp | (init_params[GPR_I] & PORT_MASK[port]),
+			     VA_GPIO_BASE + MXC_GPR(port));
+	}
+	if (init_params[GIUS_I]) {
+		lTemp = __raw_readl(VA_GPIO_BASE +
+				MXC_GIUS(port)) & (~PORT_MASK[port]);
+		__raw_writel(lTemp | (init_params[GIUS_I] & PORT_MASK[port]),
+			     VA_GPIO_BASE + MXC_GIUS(port));
+	}
+	if (init_params[PUEN_I]) {
+		lTemp = __raw_readl(VA_GPIO_BASE +
+				MXC_PUEN(port)) & (~PORT_MASK[port]);
+		__raw_writel(lTemp | (init_params[PUEN_I] & PORT_MASK[port]),
+			     VA_GPIO_BASE + MXC_PUEN(port));
+	}
+	if (init_params[ICR1_I]) {
+		__raw_writel(init_params[ICR1_I],
+			     VA_GPIO_BASE + MXC_ICR1(port));
+	}
+	if (init_params[ICR2_I]) {
+		__raw_writel(init_params[ICR2_I],
+			     VA_GPIO_BASE + MXC_ICR2(port));
+	}
+	if (init_params[IMR_I]) {
+		__raw_writel(init_params[IMR_I], VA_GPIO_BASE + MXC_IMR(port));
+	}
+}
+
+static void initialize_all_ports(void)
+{
+	initialize_port(PORT_A, portA_init);
+	initialize_port(PORT_B, portB_init);
+	initialize_port(PORT_C, portC_init);
+	initialize_port(PORT_D, portD_init);
+#ifndef CONFIG_ARCH_IMX
+	initialize_port(PORT_E, portE_init);
+	initialize_port(PORT_F, portF_init);
+#endif
+}
+
+static void write_on_port(unsigned int aPort, unsigned int aValue)
+{
+	__raw_writel(aValue & 0xFFFFFFFF, VA_GPIO_BASE + MXC_DR(aPort));
+}
+
+static unsigned int read_from_port(unsigned int aPort)
+{
+	unsigned int port_value = 0;
+
+	/* Get the status of the gpio ports */
+	port_value = __raw_readl(VA_GPIO_BASE + MXC_SSR(aPort));
+
+	return port_value;
+}
+
+#define GPIO_TO_PORT(gpio)	(gpio / MAX_NUMBER_OF_PINS)
+#define GPIO_TO_PIN(gpio)	(gpio % MAX_NUMBER_OF_PINS)
+
+/* Return the interrupt config for a pin */
+static unsigned char get_gpio_irq(unsigned int gpio)
+{
+	unsigned int pin_num = GPIO_TO_PIN(gpio);
+	unsigned int port_num = GPIO_TO_PORT(gpio);
+	unsigned long shad;
+	int port_size = number_of_pins[port_num];
+
+	if (pin_num < (port_size / 2)) {
+		shad = shadows_irq_l[port_num];
+	} else {
+		shad = shadows_irq_h[port_num];
+		pin_num -= (port_size / 2);
+	}
+
+	return (shad >> (2 * pin_num)) & 0x03;
+}
+
+static void set_gpio_irq(unsigned int gpio, int value)
+{
+	unsigned int pin_num = GPIO_TO_PIN(gpio);
+	unsigned int port_num = GPIO_TO_PORT(gpio);
+	int port_size = number_of_pins[port_num];
+	int return_value;
+
+	if (pin_num < (port_size / 2)) {
+		return_value = shadows_irq_l[port_num] &
+			(~(0x03 << (pin_num * 2)));
+		shadows_irq_l[port_num] = return_value |
+			((value & 0x03) << (pin_num * 2));
+	} else {
+		return_value = shadows_irq_h[port_num] &
+		    (~(0x03 << (2 * (pin_num - (port_size/2)))));
+		shadows_irq_h[port_num] = return_value |
+		    ((value & 0x03) << (2 * (pin_num - (port_size/2))));
+	}
+}
+
+static void set_port_mode(unsigned int aPort, unsigned int aModeMask)
+{
+	int i;
+	int ocr1, ocr2, gius;
+
+	ocr1 = __raw_readl(VA_GPIO_BASE + MXC_OCR1(aPort));
+	ocr2 = __raw_readl(VA_GPIO_BASE + MXC_OCR2(aPort));
+	gius = __raw_readl(VA_GPIO_BASE + MXC_GIUS(aPort));
+	aModeMask = aModeMask & PORT_MASK[aPort];	/* only sets the allowed pins */
+	for (i = 0; i < number_of_pins[aPort]; i++) {
+		if (i < 16) {
+			if ((aModeMask >> i) & 1)
+				ocr1 = ocr1 | (3 << (i * 2));
+		} else {
+			if ((aModeMask >> i) & 1)
+				ocr2 = ocr2 | (3 << ((i - 16) * 2));
+		}
+	}
+	__raw_writel(ocr1, VA_GPIO_BASE + MXC_OCR1(aPort));
+	__raw_writel(ocr2, VA_GPIO_BASE + MXC_OCR2(aPort));
+	gius = gius | aModeMask;
+	__raw_writel(gius, VA_GPIO_BASE + MXC_GIUS(aPort));
+}
+
+static unsigned int get_port_mode(unsigned int port)
+{
+	int i;
+	int ocr1, ocr2, gius, value = 0;
+
+	ocr1 = __raw_readl(VA_GPIO_BASE + MXC_OCR1(port));
+	ocr2 = __raw_readl(VA_GPIO_BASE + MXC_OCR2(port));
+	gius = __raw_readl(VA_GPIO_BASE + MXC_GIUS(port));
+	/* pin is a GPIO if OCR == 3 AND GIUS == 1 */
+	for (i = 0; i < number_of_pins[port]; i++) {
+		if (i < 16) {
+			if (((ocr1 >> (i * 2)) & 3) == 3)
+				value = value | (1 << i);
+		} else {
+			if (((ocr2 >> ((i - 16) * 2)) & 3) == 3)
+				value = value | (1 << i);
+		}
+	}
+	value = value & gius;
+
+	return value;
+}
+
+static void set_gpio_mode(unsigned int gpio, unsigned int mode)
+{
+	unsigned int port_mode, port_num = GPIO_TO_PORT(gpio),
+			pin_num = GPIO_TO_PIN(gpio);
+
+	port_mode = get_port_mode(port_num);
+
+	if (mode)
+		set_port_mode(port_num, port_mode | (1 << pin_num));
+	else
+		set_port_mode(port_num, port_mode & (~(1 << pin_num)));
+}
+
+static unsigned int get_gpio_mode(unsigned int gpio)
+{
+	unsigned int port_mode = get_port_mode(GPIO_TO_PORT(gpio));
+
+	return (((port_mode & (1 << GPIO_TO_PIN(gpio))) != 0) ? 1 : 0);
+}
+
+static unsigned int get_port_pullup(unsigned int port)
+{
+	return __raw_readl(VA_GPIO_BASE + MXC_PUEN(port));
+}
+
+static void set_port_pullup(unsigned int port, unsigned int pullup_mask)
+{
+	__raw_writel(pullup_mask & 0xffffffff, VA_GPIO_BASE + MXC_PUEN(port));
+}
+
+static unsigned int get_gpio_pullup(unsigned int gpio)
+{
+	unsigned int port_num = GPIO_TO_PORT(gpio);
+	unsigned int pin_num = GPIO_TO_PIN(gpio);
+	unsigned int port_pullup = get_port_pullup(port_num);
+
+	return (((port_pullup & (1 << pin_num)) != 0) ? 1 : 0);
+}
+
+static void set_gpio_pullup(unsigned int gpio, unsigned int value)
+{
+	unsigned int port_num = GPIO_TO_PORT(gpio);
+	unsigned int pin_num = GPIO_TO_PIN(gpio);
+	unsigned int port_pullup = get_port_pullup(port_num);
+
+	if (value != 0)
+		set_port_pullup(port_num, port_pullup | (1 << pin_num));
+	else
+		set_port_pullup(port_num, port_pullup & (~(1 << pin_num)));
+}
+
+static void set_port_dir(unsigned int port, unsigned int dir_mask)
+{
+	__raw_writel(dir_mask & 0xffffffff, VA_GPIO_BASE + MXC_DDIR(port));
+}
+
+static unsigned int get_port_dir(unsigned int aPort)
+{
+	unsigned int port_value = 0;
+
+	/* Get the status of the GPIO direction registers */
+	port_value = __raw_readl(VA_GPIO_BASE + MXC_DDIR(aPort));
+
+	return port_value;
+}
+
+static void set_gpio_dir(unsigned int gpio, unsigned int dir)
+{
+	unsigned int port_dir, port_num = GPIO_TO_PORT(gpio),
+			pin_num = GPIO_TO_PIN(gpio);
+
+	port_dir = get_port_dir(port_num);
+	if (dir != 0)
+		set_port_dir(port_num, port_dir | (1 << pin_num));
+	else
+		set_port_dir(port_num, port_dir & (~(1 << pin_num)));
+}
+
+static unsigned int get_gpio_dir(unsigned int gpio)
+{
+	unsigned int port_dir;
+
+	port_dir = get_port_dir(GPIO_TO_PORT(gpio));
+
+	return (((port_dir & (1 << GPIO_TO_PIN(gpio))) != 0) ? 1 : 0);
+}
+
+
+char *port_name[NB_PORTS] = { "portA", "portB", "portC", "portD",
+#ifdef CONFIG_ARCH_MX2
+	"portE", "portF",
+#endif
+};
+char *port_setting_name[NB_SETTINGS] =
+    { "Value", "Direction", "Pull-up", "Interrupt", "Mode" };
+
+/* Handles write() done on /dev/gpioxx */
+static ssize_t armadeus_gpio_dev_write(struct file *file, const char *data,
+				       size_t count, loff_t * offset)
+{
+	unsigned int minor = 0;
+	u32 value = 0;
+	ssize_t ret = 0;
+	struct gpio_item *gpio = file->private_data;
+
+	minor = MINOR(file->f_dentry->d_inode->i_rdev);
+
+	pr_debug("- %s %d byte(s) on minor %d -> %s pin %d\n", __FUNCTION__,
+		 count, minor, port_name[gpio->port], gpio->number);
+
+	if (down_interruptible(&gpio_sema))	/* Usefull ?? */
+		return -ERESTARTSYS;
+
+	count = min(count, (size_t) 4);
+	if (copy_from_user(&value, data, count)) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	if (gpio->nb_pins != 1) {
+		pr_debug("Full port write: 0x%x\n", value);
+		write_on_port(gpio->port, value);
+	} else {
+		value = value ? 1 : 0;
+		pr_debug("Single pin write: %d\n", value);
+		gpio_set_value(minor, value);
+	}
+	ret = count;
+
+out:
+	up(&gpio_sema);
+	return ret;
+}
+
+/* Handles read() done on /dev/gpioxx */
+static ssize_t armadeus_gpio_dev_read(struct file *file, char *buf,
+				      size_t count, loff_t * ppos)
+{
+	unsigned minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	u32 value = 0;
+	ssize_t ret = 0;
+	struct gpio_item *gpio = file->private_data;
+
+	if (count == 0)
+		return count;
+
+	spin_lock_irq(&gpio->lock);
+
+	pr_debug("- %s %d byte(s) on minor %d -> %s pin %d\n", __FUNCTION__,
+		 count, minor, port_name[gpio->port], gpio->number);
+
+	while (!gpio->changed) {
+		spin_unlock_irq(&gpio->lock);
+
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		if (wait_event_interruptible(gpio->change_wq, gpio->changed))
+			return -ERESTARTSYS;
+
+		spin_lock_irq(&gpio->lock);
+	}
+	gpio->changed = 0;
+
+	if (gpio->nb_pins != 1) {
+		value = read_from_port(gpio->port);
+		pr_debug("Full port read: 0x%x\n", value);
+	} else {
+		value = gpio_get_value(minor);
+		pr_debug("Single pin read: %d\n", value);
+	}
+
+	count = min(count, (size_t) sizeof(u32));
+	if (copy_to_user(buf, &value, count)) {
+		ret = -EFAULT;
+		goto out;
+	}
+	ret = count;
+
+out:
+	spin_unlock_irq(&gpio->lock);
+	return ret;
+}
+
+static irqreturn_t armadeus_gpio_interrupt(int irq, void *dev_id)
+{
+	struct gpio_item *gpio = dev_id;
+	u32 old_state, new_state;
+
+	pr_debug("IT for pin %d %d\n", gpio->port, gpio->number);
+
+	old_state = gpio->pin_state;
+	new_state =
+	    gpio_get_value((gpio->port << GPIO_PORT_SHIFT) | gpio->number);
+	gpio->pin_state = new_state;
+
+	gpio->changed = 1;
+	wake_up_interruptible(&gpio->change_wq);
+
+	if (gpio->async_queue)
+		kill_fasync(&gpio->async_queue, SIGIO, POLL_IN);
+
+	return IRQ_HANDLED;
+}
+
+static int armadeus_gpio_dev_open(struct inode *inode, struct file *file)
+{
+	unsigned minor = MINOR(inode->i_rdev);
+	/*unsigned int major = MAJOR(inode->i_rdev); */
+	unsigned int irq;
+	int ret = 0;
+	struct gpio_item *gpio;	/* = container_of(inode->i_cdev, struct gpio_item,
+				   char_dev); */
+
+	gpio = kzalloc(sizeof(struct gpio_item), GFP_KERNEL);
+	if (!gpio) {
+		ret = -ENOMEM;
+		goto err_kzalloc;
+	}
+
+	file->private_data = gpio;
+	spin_lock_init(&gpio->lock);
+	init_waitqueue_head(&gpio->change_wq);
+
+	/* Access all port pins in one time */
+	switch (minor) {
+	case FULL_PORTA_MINOR:
+	case FULL_PORTB_MINOR:
+	case FULL_PORTC_MINOR:
+	case FULL_PORTD_MINOR:
+#ifndef CONFIG_ARCH_IMX
+	case FULL_PORTE_MINOR:
+	case FULL_PORTF_MINOR:
+#endif
+		gpio->nb_pins = 32;
+		gpio->changed = 0;
+		gpio->port = FULL_MINOR_TO_PORT(minor);
+		pr_debug("Reserving full %s\n", port_name[gpio->port]);
+		goto success;
+		break;
+	}
+
+	/* Pin by pin access */
+	gpio->nb_pins = 1;
+	gpio->changed = 0;
+
+	if ((ret = gpio_request(minor, "gpio-dev"))) {
+		printk(KERN_ERR "gpio: pin %i is already in use\n", minor);
+		goto err_gpio_request;
+	}
+
+	gpio->port = minor >> GPIO_PORT_SHIFT;
+	gpio->number = minor & GPIO_PIN_MASK;
+	gpio->pin_state = 0;
+
+	if (get_gpio_dir(minor)) {
+		gpio_direction_output(minor, gpio_get_value(minor));
+	} else {
+		gpio_direction_input(minor);
+		gpio->pin_state = gpio_get_value(minor);
+	}
+
+	gpio->irq_value = get_gpio_irq(minor);
+	/* Request interrupt if pin was configured for: */
+	if (gpio->irq_value) {
+		irq = IRQ_GPIOA(minor);	/* irq number are continuous */
+		ret = request_irq(irq, armadeus_gpio_interrupt, 0, "gpio",
+					gpio);
+		if (ret) {
+			printk(KERN_ERR "gpio: irq %d already reserved\n", irq);
+			goto err_irq;
+		}
+		switch (gpio->irq_value) {
+		case (IRQ_TYPE_EDGE_BOTH):
+			set_irq_type(irq, IRQ_TYPE_EDGE_BOTH);
+			break;
+		case IRQ_TYPE_EDGE_RISING:
+			set_irq_type(irq, IRQ_TYPE_EDGE_RISING);
+			break;
+		case IRQ_TYPE_EDGE_FALLING:
+			set_irq_type(irq, IRQ_TYPE_EDGE_FALLING);
+			break;
+		case IRQ_TYPE_NONE:
+			break;
+		}
+	}
+
+success:
+	pr_debug("Opening /dev node for %s pin %d\n", port_name[gpio->port],
+		 gpio->number);
+	gpio->initialized = 1;
+	return 0;
+
+	free_irq(irq, gpio);
+err_irq:
+	gpio_free(minor);
+err_gpio_request:
+	kfree(gpio);
+err_kzalloc:
+	/* what about spinlock & wait_queue ?? */
+	return ret;
+}
+
+/* Handles close() done on /dev/gpioxx */
+static int armadeus_gpio_dev_release(struct inode *inode, struct file *file)
+{
+	unsigned minor = MINOR(inode->i_rdev);
+	struct gpio_item *gpio = file->private_data;
+	unsigned int irq;
+
+	if (gpio->initialized) {
+		if (gpio->irq_value) {
+			irq = IRQ_GPIOA(minor);
+			free_irq(irq, gpio);
+		}
+		gpio_free(minor);
+	}
+	kfree(gpio);
+	pr_debug("Closing access to /dev/gpio/ minor %d\n", minor);
+
+	return 0;
+}
+
+/* Handling of IOCTL calls */
+int armadeus_gpio_dev_ioctl(struct inode *inode, struct file *filp,
+			    unsigned int cmd, unsigned long arg)
+{
+	int err = 0, ret = 0, value = 0;
+	unsigned int minor;
+	unsigned int irq;
+	struct gpio_item *gpio = filp->private_data;
+
+	pr_debug(DRIVER_NAME " ## IOCTL received: (0x%x) ##\n", cmd);
+
+	/* Extract the type and number bitfields, and don't decode wrong cmds:
+	 * return ENOTTY (inappropriate ioctl) before access_ok() */
+	if (_IOC_TYPE(cmd) != PP_IOCTL)
+		return -ENOTTY;
+
+	/* The direction is a bitmask, and VERIFY_WRITE catches R/W transfers.
+	 * `Type' is user-oriented, while access_ok is kernel-oriented,
+	 * so the concept of "read" and "write" is reversed */
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		err = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
+
+	if (err)
+		return -EFAULT;
+
+	/* Obtain exclusive access */
+	if (down_interruptible(&gpio_sema))
+		return -ERESTARTSYS;
+
+	/* Extract and test minor */
+	minor = MINOR(inode->i_rdev);
+#ifndef CONFIG_ARCH_IMX
+	if (minor < FULL_PORTF_MINOR) {
+#else
+	if (minor < FULL_PORTD_MINOR) {
+#endif
+		/* ioctl for /dev/gpio/PXn */
+		switch (cmd) {
+		case GPIORDDIRECTION:
+			ret = __put_user(get_gpio_dir(minor), (unsigned int *)arg);
+			break;
+
+		case GPIOWRDIRECTION:
+			ret = __get_user(value, (unsigned int *)arg);
+			set_gpio_dir(minor, value);
+			break;
+
+		case GPIORDDATA:
+			ret = __put_user(gpio_get_value(minor), (unsigned int *)arg);
+			break;
+
+		case GPIOWRDATA:
+			ret = __get_user(value, (unsigned int *)arg);
+			if (value != 0) {
+				gpio_set_value(minor, 1);
+			} else {
+				gpio_set_value(minor, 0);
+			}
+			break;
+
+		case GPIORDMODE:
+			ret = __put_user(get_gpio_mode(minor), (unsigned int *)arg);
+			break;
+
+		case GPIOWRMODE:
+			ret = __get_user(value, (unsigned int *)arg);
+			set_gpio_mode(minor, value);
+			break;
+
+		case GPIORDIRQMODE:
+			ret = __put_user(get_gpio_irq(minor),
+					(unsigned int *)arg);
+			break;
+
+		case GPIOWRIRQMODE:
+			ret = __get_user(value, (unsigned int *)arg);
+			value &= 0x03;
+			if (ret == 0) {
+				set_gpio_irq(minor, value);
+			}
+			irq = IRQ_GPIOA(minor);	/* irq number are continuous */
+			if (value != IRQ_TYPE_NONE) {
+				if (gpio->irq_value == IRQ_TYPE_NONE) {
+					ret = request_irq(irq,
+							armadeus_gpio_interrupt,
+							0, "gpio", gpio);
+					if (ret) {
+						printk(KERN_ERR
+						       "GPIO TODO: manage request_irq error\n");
+					}
+				}
+				gpio->irq_value = value;
+				switch (gpio->irq_value) {
+				case (IRQ_TYPE_EDGE_BOTH):
+					set_irq_type(irq, IRQ_TYPE_EDGE_BOTH);
+					break;
+				case IRQ_TYPE_EDGE_RISING:
+					set_irq_type(irq, IRQ_TYPE_EDGE_RISING);
+					break;
+				case IRQ_TYPE_EDGE_FALLING:
+					set_irq_type(irq, IRQ_TYPE_EDGE_FALLING);
+					break;
+				case IRQ_TYPE_NONE:
+					break;
+				}
+			} else {
+				if (gpio->irq_value != IRQ_TYPE_NONE) {
+					free_irq(irq, gpio);
+				}
+				gpio->irq_value = IRQ_TYPE_NONE;
+			}
+			gpio->changed = 0;
+			break;
+
+		case GPIORDPULLUP:
+			ret = __put_user(get_gpio_pullup(minor), (unsigned int *)arg);
+			break;
+
+		case GPIOWRPULLUP:
+			ret = __get_user(value, (unsigned int *)arg);
+			set_gpio_pullup(minor, value);
+			break;
+
+		default:
+			printk("IOCTL not supported\n");
+			ret = -ENOTTY;
+			break;
+		}
+	} else {
+		/* ioctls on /dev/gpio/portX */
+		switch (cmd) {
+		case GPIORDDATA:
+			value = read_from_port(MAX_MINOR - minor);
+			ret = __put_user(value, (unsigned int *)arg);
+			break;
+
+		case GPIOWRDATA:
+			ret = __get_user(value, (unsigned int *)arg);
+			if (ret == 0) {
+				write_on_port(MAX_MINOR - minor, value);
+			}
+			break;
+
+		default:
+			printk("IOCTL not supported on full port\n");
+			ret = -ENOTTY;
+			break;
+		}
+	}
+	/* Release exclusive access */
+	up(&gpio_sema);
+
+	return ret;
+}
+
+static int armadeus_gpio_dev_fasync(int fd, struct file *filp, int on)
+{
+	struct gpio_item *gpio = filp->private_data;
+
+	return fasync_helper(fd, filp, on, &(gpio->async_queue));
+}
+
+static unsigned int armadeus_gpio_dev_poll(struct file *filp, poll_table * wait)
+{
+	struct gpio_item *gpio = filp->private_data;
+	unsigned int mask = 0;
+
+	spin_lock_irq(&gpio->lock);
+
+	poll_wait(filp, &gpio->change_wq, wait);
+	if (gpio->changed) {
+		mask |= (POLLIN | POLLRDNORM);
+	}
+
+	spin_unlock_irq(&gpio->lock);
+
+	return mask;
+}
+
+static struct file_operations gpio_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.write = armadeus_gpio_dev_write,
+	.read = armadeus_gpio_dev_read,
+	.open = armadeus_gpio_dev_open,
+	.release = armadeus_gpio_dev_release,
+	.ioctl = armadeus_gpio_dev_ioctl,
+	.fasync = armadeus_gpio_dev_fasync,
+	.poll = armadeus_gpio_dev_poll,
+};
+
+/*
+ * PROC file functions
+ */
+
+static int armadeus_gpio_proc_read(char *buffer, char **start, off_t offset,
+				   int buffer_length, int *eof,
+				   __attribute__ ((unused))
+				   void *data)
+{
+	int len = 0;		/* The number of bytes actually used */
+	unsigned int port_status = 0x66, port_status2 = 0x66;
+	unsigned int port_ID = 0;
+	struct gpio_settings *settings = (struct gpio_settings *)data;
+
+	if (settings != NULL) {
+		port_ID = settings->port;
+	}
+
+	/* We give all of our information in one go, so if the user asks us if we
+	 * have more information the answer should always be no. This is important
+	 * because the standard read function from the library would continue to
+	 * issue the read system call until the kernel replies that it has no more
+	 * information, or until its buffer is filled
+	 */
+	if (offset > 0 || buffer_length < (number_of_pins[port_ID] + 2))
+		return 0;
+
+	if (down_interruptible(&gpio_sema))
+		return -ERESTARTSYS;
+
+	switch (settings->type) {
+	case MODE:
+		port_status = get_port_mode(port_ID);
+		break;
+
+	case VALUE:
+		port_status = read_from_port(port_ID);
+		break;
+
+	case DIRECTION:
+		port_status = get_port_dir(port_ID);
+		break;
+
+	case PULL_UP:
+		port_status = __raw_readl(VA_GPIO_BASE + MXC_PUEN(port_ID));
+		break;
+
+	case INTERRUPT:
+		port_status = shadows_irq_h[port_ID];
+		port_status2 = shadows_irq_l[port_ID];
+		break;
+
+	default:
+		printk("%s: unknown setting\n", __FUNCTION__);
+		break;
+	}
+	/* Put result to given chr buffer */
+	if (settings->type != INTERRUPT) {
+		len = toString(port_status, buffer, number_of_pins[port_ID], 1);
+	} else {
+		len = toString(port_status, buffer,
+				number_of_pins[port_ID] / 2,
+				2);
+		len += toString(port_status2, buffer + len - 1,
+				number_of_pins[port_ID] / 2, 2);
+		len -= 1;
+	}
+
+	pr_debug("%s: 0x%08x", __func__, port_status);
+	if (settings->type == INTERRUPT)
+		pr_debug(" 0x%08x", port_status2);
+	pr_debug("\n");
+
+	*eof = 1;
+	up(&gpio_sema);
+
+	return len;
+}
+
+static char new_gpio_state[MAX_NUMBER_OF_PINS * 2];
+
+static int armadeus_gpio_proc_write( __attribute__ ((unused))
+				    struct file *file, const char *buf,
+				    unsigned long count,
+				    __attribute__ ((unused))
+				    void *data)
+{
+	int len;
+	unsigned int gpio_state = 0, gpio_state2 = 0;
+	unsigned int port_ID = 0;
+	struct gpio_settings *settings = (struct gpio_settings *)data;
+
+	if (settings != NULL) {
+		port_ID = settings->port;
+	}
+
+	/* Do some checks on parameters */
+	if (count <= 0) {
+		printk("Empty string transmitted !\n");
+		return 0;
+	}
+	if (count > (MAX_NUMBER_OF_PINS + 1))
+		printk("GPIO port registers are only 32bits !\n");
+	if (count > (sizeof(new_gpio_state))) {
+		len = sizeof(new_gpio_state);
+	} else {
+		len = count;
+	}
+
+	/* Get exclusive access to port */
+	if (down_interruptible(&gpio_sema))
+		return -ERESTARTSYS;
+
+	/* Get datas to write from user space */
+	if (copy_from_user(new_gpio_state, buf, len)) {
+		up(&gpio_sema);
+		return -EFAULT;
+	}
+
+	if (strlen(new_gpio_state) > 0) {
+		/* Convert it from String to Int */
+		if (settings->type != INTERRUPT) {
+			gpio_state = fromString(new_gpio_state,
+						number_of_pins[port_ID],
+						1);
+		} else {
+			gpio_state = fromString(new_gpio_state,
+						number_of_pins[port_ID] / 2,
+						2);
+			gpio_state2 = fromString(new_gpio_state +
+						(number_of_pins[port_ID] / 2),
+						(number_of_pins[port_ID] / 2),
+						2);
+		}
+
+		switch (settings->type) {
+		case MODE:
+			set_port_mode(port_ID, gpio_state);
+			break;
+
+		case VALUE:
+			write_on_port(port_ID, gpio_state);
+			break;
+
+		case DIRECTION:
+			set_port_dir(port_ID, gpio_state);
+			break;
+
+		case PULL_UP:
+			set_port_pullup(port_ID, gpio_state);
+			break;
+
+		case INTERRUPT:
+			shadows_irq_h[port_ID] = gpio_state;
+			shadows_irq_l[port_ID] = gpio_state2;
+			break;
+
+		default:
+			printk("%s: unknown setting\n", __FUNCTION__);
+			break;
+		}
+
+		if (settings->type != INTERRUPT) {
+			pr_debug("/proc wrote 0x%x", gpio_state);
+		} else {
+			pr_debug("/proc wrote 0x%x 0x%x", gpio_state,
+				 gpio_state2);
+		}
+		pr_debug(" on %s %s register\n", port_name[port_ID],
+			 port_setting_name[settings->type]);
+	}
+
+	up(&gpio_sema);
+	/* Makes as if we take all the data sent even if we can't handle more
+	   than register size */
+	return count;
+}
+
+/* /proc registering helpers */
+struct proc_config_entry {
+	struct proc_dir_entry *entry;
+	char name[32];
+	int port;
+	int type;
+};
+
+static int initialize_proc_entry(struct proc_config_entry *config)
+{
+	int i;
+
+	for (i = 0; i < NB_PORTS; i++) {
+		config[i].entry = create_proc_entry(config[i].name,
+					S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH,
+					NULL);
+		if (config[i].entry == NULL) {
+			printk(KERN_ERR DRIVER_NAME
+			       ": Couldn't register %s. Terminating.\n",
+			       config[i].name);
+			return -ENOMEM;
+		}
+		config[i].entry->read_proc = armadeus_gpio_proc_read;
+		config[i].entry->write_proc = armadeus_gpio_proc_write;
+		config[i].entry->data = kmalloc(sizeof(struct gpio_settings),
+						GFP_KERNEL);
+		((struct gpio_settings *)config[i].entry->data)->port = i;
+		((struct gpio_settings *)config[i].entry->data)->type =
+		    config[i].type;
+	}
+
+	return 0;
+}
+
+/*
+ * Create /proc entries for direct access (with echo/cat) to GPIOs config
+ */
+static int create_proc_entries(void)
+{
+	struct proc_config_entry proc_config[NB_PORTS];
+	int ret, i;
+
+	pr_debug("Creating /proc entries: ");
+
+	/* Create main directory */
+	proc_mkdir(GPIO_PROC_DIRNAME, NULL);
+
+	/* Create proc file to handle GPIO values */
+	for (i = 0; i < NB_PORTS; i++) {
+		sprintf(proc_config[i].name, "%s/%s", GPIO_PROC_DIRNAME,
+			port_name[i]);
+		proc_config[i].type = VALUE;
+	}
+
+	if ((ret = initialize_proc_entry(proc_config)))
+		return ret;
+	init_map |= GPIO_PROC_FILE_INIT;
+
+	/* Create proc file to handle GPIO mode */
+	for (i = 0; i < NB_PORTS; i++) {
+		sprintf(proc_config[i].name, "%s/%smode", GPIO_PROC_DIRNAME,
+			port_name[i]);
+		proc_config[i].type = MODE;
+	}
+
+	if ((ret = initialize_proc_entry(proc_config)))
+		return ret;
+	init_map |= SETTINGS_MODE_PROC_FILE_INIT;
+
+	/* Create proc file to handle GPIO direction settings */
+	for (i = 0; i < NB_PORTS; i++) {
+		sprintf(proc_config[i].name, "%s/%sdir", GPIO_PROC_DIRNAME,
+			port_name[i]);
+		proc_config[i].type = DIRECTION;
+	}
+
+	if ((ret = initialize_proc_entry(proc_config)))
+		return ret;
+	init_map |= SETTINGS_PROC_FILE_INIT;
+
+	/* Create proc file to handle GPIO interrupt settings */
+	for (i = 0; i < NB_PORTS; i++) {
+		sprintf(proc_config[i].name, "%s/%sirq", GPIO_PROC_DIRNAME,
+			port_name[i]);
+		proc_config[i].type = INTERRUPT;
+	}
+
+	if ((ret = initialize_proc_entry(proc_config)))
+		return ret;
+	init_map |= SETTINGS_IRQ_PROC_FILE_INIT;
+
+	/* Create proc file to handle GPIO pullup settings */
+	for (i = 0; i < NB_PORTS; i++) {
+		sprintf(proc_config[i].name, "%s/%spullup", GPIO_PROC_DIRNAME,
+			port_name[i]);
+		proc_config[i].type = PULL_UP;
+	}
+
+	if ((ret = initialize_proc_entry(proc_config)))
+		return ret;
+	init_map |= SETTINGS_PULLUP_PROC_FILE_INIT;
+
+	pr_debug("OK!\n");
+
+	return 0;
+}
+
+static void remove_proc_entries(void)
+{
+	char proc_name[32];
+	int i;
+
+	/* Remove /proc entries */
+	if (init_map & GPIO_PROC_FILE_INIT) {
+		printk(DRIVER_NAME " removing /proc/.../portX\n");
+		for (i = 0; i < NB_PORTS; i++) {
+			sprintf(proc_name, "%s/%s", GPIO_PROC_DIRNAME,
+				port_name[i]);
+			remove_proc_entry(proc_name, NULL);
+		}
+	}
+	if (init_map & SETTINGS_MODE_PROC_FILE_INIT) {
+		printk(DRIVER_NAME " removing /proc/.../portXmode\n");
+		for (i = 0; i < NB_PORTS; i++) {
+			sprintf(proc_name, "%s/%smode", GPIO_PROC_DIRNAME,
+				port_name[i]);
+			remove_proc_entry(proc_name, NULL);
+		}
+	}
+	if (init_map & SETTINGS_PROC_FILE_INIT) {
+		printk(DRIVER_NAME " removing /proc/.../portXdir\n");
+		for (i = 0; i < NB_PORTS; i++) {
+			sprintf(proc_name, "%s/%sdir", GPIO_PROC_DIRNAME,
+				port_name[i]);
+			remove_proc_entry(proc_name, NULL);
+		}
+	}
+	if (init_map & SETTINGS_IRQ_PROC_FILE_INIT) {
+		printk(DRIVER_NAME " removing /proc/.../portXirq\n");
+		for (i = 0; i < NB_PORTS; i++) {
+			sprintf(proc_name, "%s/%sirq", GPIO_PROC_DIRNAME,
+				port_name[i]);
+			remove_proc_entry(proc_name, NULL);
+		}
+	}
+	if (init_map & SETTINGS_PULLUP_PROC_FILE_INIT) {
+		printk(DRIVER_NAME " removing /proc/.../portXpullup\n");
+		for (i = 0; i < NB_PORTS; i++) {
+			sprintf(proc_name, "%s/%spullup", GPIO_PROC_DIRNAME,
+				port_name[i]);
+			remove_proc_entry(proc_name, NULL);
+		}
+	}
+
+	remove_proc_entry(GPIO_PROC_DIRNAME, NULL);
+}
+
+static void print_port_params(int port, int nb, int *params)
+{
+	int i;
+
+	printk("	%s Parameters (%i): ", port_name[port], nb);
+	for (i = 0; i < NB_CONFIG_REGS; i++) {
+		printk(" 0x%x", params[i]);
+	}
+	printk("\n");
+}
+
+/* Module's initialization */
+static int __init armadeus_gpio_init(void)
+{
+	static int result;
+
+	printk("Initializing Armadeus GPIOs driver\n");
+	print_port_params(PORT_A, portA_init_nb, portA_init);
+	print_port_params(PORT_B, portB_init_nb, portB_init);
+	print_port_params(PORT_C, portC_init_nb, portC_init);
+	print_port_params(PORT_D, portD_init_nb, portD_init);
+#ifdef CONFIG_ARCH_MX2
+	print_port_params(PORT_E, portE_init_nb, portE_init);
+	print_port_params(PORT_F, portF_init_nb, portF_init);
+#endif
+	init_map = 0;
+
+	/* Configure HW ports/GPIOs with default values or given parameters */
+	initialize_all_ports();
+
+	/* Register the driver as character device by getting a major number */
+	result = register_chrdev(gpio_major, DRIVER_NAME, &gpio_fops);
+	if (result < 0) {
+		printk(KERN_WARNING DRIVER_NAME ": can't get major %d\n",
+		       gpio_major);
+		return result;
+	}
+	if (gpio_major == 0)
+		gpio_major = result;	/* dynamic Major allocation */
+
+	/* Creates /proc entries */
+	if ((result = create_proc_entries())) {
+		remove_proc_entries();
+		return result;
+	}
+
+	/* Initialise GPIO port access semaphore */
+	sema_init(&gpio_sema, 1);
+
+	/* Set GPIOs to initial state: iMX and parameters will do it */
+
+	printk(DRIVER_NAME " v" DRIVER_VERSION " successfully loaded !\n");
+	return 0;
+}
+
+/* Module's cleanup */
+static void __exit armadeus_gpio_cleanup(void)
+{
+	/* TBDJUJU free config[i].entry->data first ?? */
+	remove_proc_entries();
+
+	/* De-register from /dev interface */
+	unregister_chrdev(gpio_major, DRIVER_NAME);
+}
+
+/*
+ * API To be removed ???
+ */
+void gpioWriteOnPort(unsigned int aPort, unsigned int aValue)
+{
+	if (aPort >= NB_PORTS) {
+		printk(DRIVER_NAME "port unknown !\n");
+		return;
+	}
+	write_on_port(aPort, aValue);
+}
+
+unsigned int gpioReadFromPort(unsigned int aPort)
+{
+	if (aPort >= NB_PORTS) {
+		printk(DRIVER_NAME "port unknown !\n");
+		return 0;
+	} else {
+		return read_from_port(aPort);
+	}
+}
+
+void gpioSetPortDir(unsigned int aPort, unsigned int aDirMask)
+{
+	set_port_dir(aPort, aDirMask);
+}
+
+unsigned int gpioGetPortDir(unsigned int aPort)
+{
+	return get_port_dir(aPort);
+}
+
+EXPORT_SYMBOL(gpioWriteOnPort);
+EXPORT_SYMBOL(gpioReadFromPort);
+EXPORT_SYMBOL(gpioSetPortDir);
+EXPORT_SYMBOL(gpioGetPortDir);
+
+module_init(armadeus_gpio_init);
+module_exit(armadeus_gpio_cleanup);
+MODULE_AUTHOR("Julien Boibessot / Nicolas Colombain / Fabien Marteau");
+MODULE_DESCRIPTION("Armadeus GPIOs driver");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/gpio/gpio-dev.h linux-3.13/drivers/armadeus/gpio/gpio-dev.h
--- linux-3.13/drivers/armadeus/gpio/gpio-dev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/gpio/gpio-dev.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,51 @@
+/*
+ * Armadeus i.MXL/i.MX27 GPIO management driver
+ *
+ * Copyright (C) 2006-2010 Julien Boibessot <julien.boibessot@armadeus.com>
+ *                         Nicolas Colombain <nicolas.colombain@armadeus.com>
+ *                         Armadeus Project / Armadeus Systems
+ *
+ * Inspired by a lot of other GPIO management systems...
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __CORE_GPIO_H__
+#define __CORE_GPIO_H__
+
+/* IOCTL */
+/* direction: 1 output, 0 input */
+#define GPIORDDIRECTION	_IOR(PP_IOCTL, 0xF0, int)
+#define GPIOWRDIRECTION	_IOW(PP_IOCTL, 0xF1, int)
+
+#define GPIORDDATA	_IOR(PP_IOCTL, 0xF2, int)
+#define GPIOWRDATA	_IOW(PP_IOCTL, 0xF3, int)
+
+/* mode: 1 GPIO, 0 device function */
+#define GPIORDMODE	_IOR(PP_IOCTL, 0xF4, int)
+#define GPIOWRMODE	_IOW(PP_IOCTL, 0xF5, int)
+
+#define GPIORDPULLUP	_IOR(PP_IOCTL, 0xF6, int)
+#define GPIOWRPULLUP	_IOW(PP_IOCTL, 0xF7, int)
+
+/* IRQ type: 0 none, 1 rising, 2 falling, 3 both */
+#define GPIORDIRQMODE	_IOR(PP_IOCTL, 0xF8, int)
+#define GPIOWRIRQMODE	_IOW(PP_IOCTL, 0xF9, int)
+
+/* Pretend we're PPDEV for IOCTL */
+#include <linux/ppdev.h>
+
+#endif				/* __CORE_GPIO_H__ */
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/gpio/gpio_helpers.sh linux-3.13/drivers/armadeus/gpio/gpio_helpers.sh
--- linux-3.13/drivers/armadeus/gpio/gpio_helpers.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/gpio/gpio_helpers.sh	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,75 @@
+#!/bin/sh
+
+#
+# Functions to ease GPIO settings/usage
+#
+#  Copyright (C) 2010 The Armadeus Project
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+
+GPIO_DEV_DIR=/dev/gpio
+GPIO_PROC_DIR=/proc/driver/gpio
+
+setbit()
+{
+	PORT=$1
+	NB=$2
+	VAL=$3
+	cat $PORT | sed "s/[0-1]\([0-1]\{$NB\}\)$/$VAL\1/" > $PORT
+}
+
+gpio_set_value_old()
+{
+	GPIO=$1
+	VALUE=$2
+	if [ -c "$GPIO_DEV_DIR/$GPIO" ]; then
+		if [ "$VALUE" == "1" ]; then
+			echo -ne "\x01" > $GPIO_DEV_DIR/$GPIO
+		else
+			echo -ne "\x00" > $GPIO_DEV_DIR/$GPIO
+		fi
+	else
+		echo "$GPIO GPIO not usable !"
+	fi
+}
+
+# Sets $1 as GPIO; $2 == 1 -> outpout, 0 -> input
+gpio_mode()
+{
+        GPIO=`echo $1 | cut -c 3-4`
+        VALUE=$2
+        PORT=`echo $1 | cut -c 2`
+        PORT_DIR=$GPIO_PROC_DIR"/port"$PORT"dir"
+        PORT_MODE=$GPIO_PROC_DIR"/port"$PORT"mode"
+
+        setbit $PORT_MODE $GPIO 1
+        setbit $PORT_DIR $GPIO $VALUE
+}
+
+#
+# For gpiolib:
+#
+gpio_direction_output()
+{
+	if [ "$1" != "" ]; then
+		echo $1 > /sys/class/gpio/export
+		echo out > /sys/class/gpio/gpio$1/direction
+		if [ "$2" != "" ]; then
+			echo $2 > /sys/class/gpio/gpio$1/value
+		fi
+	fi
+}
+
+gpio_set_value()
+{
+	BOARD=`cat /etc/machine`
+	if [ "$BOARD" == "APF9328" ]; then
+		gpio_set_value_old $1 $2
+	else
+		echo $2 > /sys/class/gpio/gpio$1/value
+	fi
+}
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/gpio/iomux-mx1.h linux-3.13/drivers/armadeus/gpio/iomux-mx1.h
--- linux-3.13/drivers/armadeus/gpio/iomux-mx1.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/gpio/iomux-mx1.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2006-2008 Julien Boibessot <julien.boibessot@armadeus.com>
+ *                         Armadeus Project / Armadeus Systems
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __IOMUX_MX1_H__
+#define __IOMUX_MX1_H__
+
+#define VA_GPIO_BASE   IO_ADDRESS(IMX_GPIO_BASE)
+#define MXC_DDIR(x)    (0x00 + ((x) << 8))
+#define MXC_OCR1(x)    (0x04 + ((x) << 8))
+#define MXC_OCR2(x)    (0x08 + ((x) << 8))
+#define MXC_ICONFA1(x) (0x0c + ((x) << 8))
+#define MXC_ICONFA2(x) (0x10 + ((x) << 8))
+#define MXC_ICONFB1(x) (0x14 + ((x) << 8))
+#define MXC_ICONFB2(x) (0x18 + ((x) << 8))
+#define MXC_DR(x)      (0x1c + ((x) << 8))
+#define MXC_GIUS(x)    (0x20 + ((x) << 8))
+#define MXC_SSR(x)     (0x24 + ((x) << 8))
+#define MXC_ICR1(x)    (0x28 + ((x) << 8))
+#define MXC_ICR2(x)    (0x2c + ((x) << 8))
+#define MXC_IMR(x)     (0x30 + ((x) << 8))
+#define MXC_ISR(x)     (0x34 + ((x) << 8))
+#define MXC_GPR(x)     (0x38 + ((x) << 8))
+#define MXC_SWR(x)     (0x3c + ((x) << 8))
+#define MXC_PUEN(x)    (0x40 + ((x) << 8))
+
+#endif /* __IOMUX_MX1_H__ */
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/gpio/loadgpio.sh linux-3.13/drivers/armadeus/gpio/loadgpio.sh
--- linux-3.13/drivers/armadeus/gpio/loadgpio.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/gpio/loadgpio.sh	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,87 @@
+#!/bin/ash
+
+#
+# This script will load Armadeus GPIO linux-3.13/drivers/armadeus
+#
+
+GPIO_DEV_DIR=/dev/gpio
+
+# Load GPIO main module
+#modprobe gpio portB_init=0,0,0x00FFFF00,0,0,0,0,0,0xF00FFFFF,0,0,0,0,0,0,0x0FF00000 portD_init=0,0xFFFF0000,0xFFFFFFFF,0,0,0,0,0,0xFFFFFFFF,0,0,0,0,0,0,0xFFFFFC00
+modprobe gpio
+# Load PPDEV emulation module
+if [ "$1" != "" ]; then
+	modprobe ppdev port_mode=4
+fi
+
+GPIO_MAJOR=`cat /proc/devices | grep GPIO | cut -d " " -f 1`
+PPDEV_MAJOR=`cat /proc/devices | grep ppdev | cut -d " " -f 1`
+
+if [ "$GPIO_MAJOR" == "" ]; then
+	echo "GPIO module failed to load, exiting..."
+	exit 1
+fi
+
+if [ -d "$GPIO_DEV_DIR" ]; then
+	echo $GPIO_DEV_DIR"xxx devices already created, skipping..."
+	exit 0
+fi
+
+mkdir -p $GPIO_DEV_DIR
+
+# For PPDEV
+if [ "$PPDEV_MAJOR" != "" ]; then
+	mkdir -p /dev/parports
+	mknod /dev/parports/0 c $PPDEV_MAJOR 0
+fi
+
+BOARD=`cat /etc/machine`
+
+# /dev for "full" port access:
+mknod $GPIO_DEV_DIR/portA c $GPIO_MAJOR 255
+mknod $GPIO_DEV_DIR/portB c $GPIO_MAJOR 254
+mknod $GPIO_DEV_DIR/portC c $GPIO_MAJOR 253
+mknod $GPIO_DEV_DIR/portD c $GPIO_MAJOR 252
+if [ "$BOARD" == "APF27" ]; then
+mknod $GPIO_DEV_DIR/portE c $GPIO_MAJOR 251
+mknod $GPIO_DEV_DIR/portF c $GPIO_MAJOR 250
+fi
+
+# params: $1=port, $2=pin start, $3=pin end, $4=minor start
+create_dev()
+{
+	for pin in `seq $2 $3`; do
+		minor=$(($4+$pin))
+		mknod $GPIO_DEV_DIR/P$1$pin c $GPIO_MAJOR $minor
+	done
+	echo -n "."
+}
+
+echo -n "Creating /dev nodes for individual pin access: "
+if [ "$BOARD" == "APF9328" ]; then
+	# PortA[0-31]
+	create_dev A 0 31 0
+	# PortB[8-31]
+	create_dev B 8 31 32
+	# PortC[3-17]
+	create_dev C 3 17 64
+	# PortD[6-31]
+	create_dev D 6 31 96
+	echo
+fi
+
+if [ "$BOARD" == "APF27" ]; then
+	# PortA[0-31]
+	create_dev A 0 31 0
+	# PortB[0-31]
+	create_dev B 0 31 32
+	# PortC[5-31]
+	create_dev C 5 31 64
+	# PortD[16-31]
+	create_dev D 16 31 96
+	# PortE[3-23]
+	create_dev E 3 23 128
+	# PortF[7-22]
+	create_dev F 7 22 160
+	echo
+fi
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/gpio/ppdevemu.c linux-3.13/drivers/armadeus/gpio/ppdevemu.c
--- linux-3.13/drivers/armadeus/gpio/ppdevemu.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/gpio/ppdevemu.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,316 @@
+/*
+ * Armadeus Parallel port (ppdev) emulation on APF9328 LCD port
+ *
+ * Copyright (C) 2006-2009 Julien Boibessot <julien.boibessot@armadeus.com>
+ *                         Armadeus Project / Armadeus Systems
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <linux/version.h>
+#include <linux/moduleparam.h>
+/* Pretend we're PPDEV for IOCTL */
+#include <linux/ppdev.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#ifdef CONFIG_ARCH_IMX /* TO BE REMOVED WHEN MX1 PLATFORM EXIST */
+#include "iomux-mx1.h"
+#endif
+
+extern void         gpioWriteOnPort( unsigned int, unsigned int );
+extern unsigned int gpioReadFromPort( unsigned int );
+extern void         gpioSetPortDir( unsigned int, unsigned int );
+extern unsigned int gpioGetPortDir( unsigned int );
+
+#define DRIVER_VERSION            "v0.2"
+#define PPDEV_DEVICE_NAME "Armadeus_ppdev"
+
+/* by default, we use dynamic allocation of major numbers */
+#define PPDEV_MAJOR 0
+#define PPDEV_MAX_MAJOR 254
+#define PPDEV_MINOR 0
+#define PPDEV_MAX_MINOR 4
+
+#define PORT_A      0
+#define PORT_B      1
+#define PORT_C      2
+#define PORT_D      3
+#define PORT_MAX_ID 4
+
+/*#define PORTB27_21MASK    0x0FF00000
+#define PORTB27_21SHIFT   20*/
+#define PORT_D_31_10_MASK 0xFFFFFC00
+
+struct ppdev_operations *driver_ops;
+static int ppdev_major = PPDEV_MAJOR;
+/*int __number_of_pins;
+static int number_of_pins[4] = {32, 32, 32, 32};*/
+
+static unsigned long init_map;
+struct semaphore ppdev_sema;
+/* global variables */
+/*static unsigned int gPortAIndex = PORT_A;
+static unsigned int gPortBIndex = PORT_B;
+static unsigned int gPortCIndex = PORT_C;
+static unsigned int gPortDIndex = PORT_D;*/
+
+static unsigned char port_mode = 8; /* 8bits mode by default */
+module_param( port_mode, byte, 0 );
+MODULE_PARM_DESC(port_mode, "Choose between 8 or 4 bits mode");
+
+
+void __exit armadeus_ppdev_cleanup(void);
+
+/*
+ * Low level functions
+ */
+static void initialize_port( void )
+{
+	u32 temp;
+
+	/* If not already done by core module */
+	temp = __raw_readl(VA_GPIO_BASE + MXC_GIUS(PORT_D)) | PORT_D_31_10_MASK; /* set only portD 31..10 */
+	__raw_writel(temp, VA_GPIO_BASE + MXC_GIUS(PORT_D));
+	temp = __raw_readl(VA_GPIO_BASE + MXC_PUEN(PORT_D)) | PORT_D_31_10_MASK; /* set only portD 31..10 */
+	__raw_writel(temp, VA_GPIO_BASE + MXC_PUEN(PORT_D));
+	temp = __raw_readl(VA_GPIO_BASE + MXC_OCR1(PORT_D)) | 0xFFFF0000;
+	__raw_writel(temp, VA_GPIO_BASE + MXC_OCR1(PORT_D));
+	temp = __raw_readl(VA_GPIO_BASE + MXC_OCR2(PORT_D)) | 0xFFFFFFFF;
+	__raw_writel(temp, VA_GPIO_BASE + MXC_OCR2(PORT_D));
+}
+
+/* Handles write() done on /dev/ppdevxx */
+/*static ssize_t armadeus_ppdev_write(struct file *file, const char *data, size_t count, loff_t *ppos)
+{
+}*/
+
+/* Handles read() done on /dev/ppdevxx */
+/*static ssize_t armadeus_ppdev_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+}*/
+
+/* Handles open() system call done on /dev/... */
+static int armadeus_ppdev_open(struct inode *inode, struct file *file)
+{
+	unsigned m = MINOR(inode->i_rdev);
+	if (m != PPDEV_MINOR) {
+		printk("Not the right parport minor\n");
+		return -EINVAL;
+	}
+
+	pr_debug("Opening /dev/ppdev%d file\n", m);
+	return 0;
+}
+
+/* Handles close() system call done on /dev/... */
+static int armadeus_ppdev_release(struct inode *inode, struct file *file)
+{
+	pr_debug("Closing access to /dev/ppdev\n");
+	return 0;
+}
+
+/* Handling of some PPDEV IOCTL calls */
+int armadeus_ppdev_ioctl( struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg )
+{
+	int err = 0; int ret = 0;
+	int value=0;
+	unsigned int minor;
+	unsigned int lShadow = 0;
+	unsigned int PP_DDIR_MASK=0;
+
+	pr_debug(" ## IOCTL received: (0x%x) ##\n", cmd);
+
+	/* Extract the type and number bitfields, and don't decode wrong cmds:
+	   return ENOTTY (inappropriate ioctl) before access_ok() */
+	if (_IOC_TYPE(cmd) != PP_IOCTL) 
+		return -ENOTTY;
+
+	/* The direction is a bitmask, and VERIFY_WRITE catches R/W transfers.
+	 `Type' is user-oriented, while access_ok is kernel-oriented,
+	  so the concept of "read" and "write" is reversed */
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		err = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
+	if (err)
+		return -EFAULT;
+
+	if (down_interruptible(&ppdev_sema))
+		return -ERESTARTSYS;
+
+	minor = MINOR(inode->i_rdev);
+	if (minor > PPDEV_MAX_MINOR ) {
+		printk("Minor outside range: %d !\n", minor);
+		return -EFAULT;
+	}
+
+	switch (cmd)
+	{
+		case PPCLAIM:
+		case PPRELEASE:
+		break;
+
+		case PPFCONTROL: // Normally not used in 4bits mode because in this case control signals are generated with data port
+			ret = __get_user(value, (unsigned char *)arg);
+			/* Write ctrl infos on assigned ctrl ppdevlines how ??? */
+			printk("/FROB 0x%x/ ", value);
+			/* Get value from port and clear bits we will set */
+			lShadow = gpioReadFromPort(PORT_D);
+			/* Control lines are on PortD[14,13,12] */
+			lShadow &= 0xFFFF8FFF;
+			/* Control are written on iMX LCD Port control in GPIO mode, ie PortD[14,13,12] */
+			lShadow |= ((value & 0x0F) << 12);
+			/* Put it on port */
+			gpioWriteOnPort(PORT_D, lShadow);
+			printk(" 0x%x /", lShadow);
+		break;
+
+		/* IOCTL used to write on data register of the simulated
+		 parallel port. We will ask LCD4LINUX to use 4 bits mode
+		 for controlling the LCD and to use the 4 remaining data
+		 line as control lines.
+		 So, 4 lowest bit received as argument are data and
+		 4 highest bits are control
+		 !! Minor number is ignored for all PPDEV IOCTLs !! */
+		case PPWDATA:
+			ret = __get_user(value, (unsigned char *)arg);
+			/*printk("/WD 0x%x ", value);*/
+			if (ret !=0 )
+				break;
+
+			/* Get value from port and clear bits we will set */
+			lShadow = gpioReadFromPort(PORT_D);
+			if (port_mode == 4) {
+				lShadow &= 0xFF000FFF; //0xFFF00FFF;
+				/* Control (4 highest bits) are written on iMX LCD
+				Port control in GPIO mode, ie PortD[14,13,12] */
+				lShadow |= ((value & 0x70) << (12-4));
+				/* Data (4 lowest bits) are written on iMX LCD port
+				data in GPIO mode, ie PortD[18-15] */
+				lShadow |= ((value & 0x0F) << (15+4));
+			} else {
+				lShadow &= 0xFF807FFF;
+				lShadow |= ((value & 0xFF) << 15);
+			}
+			gpioWriteOnPort(PORT_D, lShadow);
+			/*printk(" 0x%x /", lShadow); */
+		break;
+
+		case PPRDATA:
+			if (port_mode == 4) {
+				/* Data (4 lowest bits) are read from iMX LCD port data
+				in GPIO mode, ie PortD[18-15] */
+				value = (gpioReadFromPort(PORT_D) >> (15+4)) & 0x0F;
+			} else {
+				value = (gpioReadFromPort(PORT_D) >> 15) & 0xFF;
+			}
+			
+			ret = __put_user(value, (unsigned char *)arg);
+			printk("/RD 0x%x/ ", value);
+		break;
+
+		case PPDATADIR:
+			ret = __get_user(value, (unsigned char *)arg);
+			printk("/DIR 0x%x/ ", value);
+			
+			if (port_mode == 4) {
+				PP_DDIR_MASK = 0xFF807FFF; /* 1111 1111 1111 1000 0111 1111 1111 1111 ?? */
+			} else {
+				PP_DDIR_MASK = 0xFF807FFF; /* 1111 1111 1000 0000 0111 1111 1111 1111 */
+			}
+			/* linux/ppdev.h define PPDATADIR as "Data line direction: non-zero for input mode."
+			For ppdevs, the logic is reversed - bit=1 == output
+			This is _not_ "generic" at all, but very much hard-wired towards being able to use an HD44780 LCD on the GPIO pins
+			(in 4-bit mode) and being able to do so using generic ppdev instructions
+			So, GPIO4-GPIO7 (=ctrl signals) will _always_ be set to output for this call, only GPIO0-GPIO3 (=datalines) are changed */
+			if (ret == 0) {
+				lShadow = gpioGetPortDir( PORT_D );
+				/* only 4 data lines can be set to ouput/input, control lines are always output...*/
+				if (value==0) {
+					gpioSetPortDir( PORT_D, (lShadow | (!PP_DDIR_MASK)) );
+				} else {
+					gpioSetPortDir( PORT_D, (lShadow & PP_DDIR_MASK) );
+				}
+			} else {
+				printk(PPDEV_DEVICE_NAME ": ret=%x\n", ret);
+			}
+		break;
+
+		default:
+			return -ENOTTY;
+		break;
+	}
+
+	up(&ppdev_sema);
+	
+	return ret;
+}
+
+static struct file_operations ppdev_fops = {
+	.owner   = THIS_MODULE,
+	/*.write   = armadeus_ppdev_write,
+	.read    = armadeus_ppdev_read,*/
+	.open    = armadeus_ppdev_open,
+	.release = armadeus_ppdev_release,
+	.ioctl   = armadeus_ppdev_ioctl,
+};
+
+
+int __init armadeus_ppdev_init(void)
+{
+	static int result;
+
+	printk("Initializing Armadeus Parallel Port emulation driver\n");
+	printk("    Port mode: %d bits\n", port_mode );
+	init_map = 0;
+
+	/* Configure HW ports/GPIOs with default values or given parameters */
+	initialize_port();
+
+	/* Register the driver by getting a major number */
+	result = register_chrdev(ppdev_major, PPDEV_DEVICE_NAME, &ppdev_fops);
+	if (result < 0) {
+		printk(KERN_WARNING PPDEV_DEVICE_NAME ": can't get major %d\n", ppdev_major);
+		return result;
+	}
+	/* Dynamic Major allocation */
+	if (ppdev_major == 0)
+		ppdev_major = result;
+
+	/* Initialise GPIO port access semaphore */
+	sema_init(&ppdev_sema, 1);
+
+	printk(DRIVER_VERSION " successfully loaded !\n");
+
+	return(0);
+}
+
+void __exit armadeus_ppdev_cleanup(void)
+{
+	unregister_chrdev(ppdev_major, PPDEV_DEVICE_NAME);
+}
+
+
+module_init(armadeus_ppdev_init);
+module_exit(armadeus_ppdev_cleanup);
+MODULE_AUTHOR("JB / NC");
+MODULE_DESCRIPTION("Armadeus Parallel Port");
+MODULE_LICENSE("GPL");
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/imx_counter/Kconfig linux-3.13/drivers/armadeus/imx_counter/Kconfig
--- linux-3.13/drivers/armadeus/imx_counter/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/imx_counter/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,7 @@
+#
+#
+
+config MX27_GPT2
+	tristate "Use i.MX27 timer 2 as counter"
+	---help---
+	  TBD.
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/imx_counter/Makefile linux-3.13/drivers/armadeus/imx_counter/Makefile
--- linux-3.13/drivers/armadeus/imx_counter/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/imx_counter/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,24 @@
+#
+# Makefile for the ...
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_APF27_GPT2)	+= gpt2_plat.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/imx_counter/gpt2_plat.c linux-3.13/drivers/armadeus/imx_counter/gpt2_plat.c
--- linux-3.13/drivers/armadeus/imx_counter/gpt2_plat.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/imx_counter/gpt2_plat.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2010 Julien Boibessot <julien.boibessot@armadeus.com>
+ * sponsored by Armadeus Systems.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+
+#include <mach/common.h>
+#include <mach/iomux-mx1-mx2.h>
+#include <mach/gpio.h>
+
+#include <../mach-mx2/devices.h>
+
+
+struct clk *gpt2_clk;
+
+static int apf27_gpt2_pins[] = {
+	 (GPIO_PORTC | GPIO_IN  | GPIO_PF | 15),	/* TIN */
+};
+
+static int __init gpt_plat_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	printk("--- %s\n", __func__);
+
+	/* Activates clock */
+	gpt2_clk = clk_get(&pdev->dev, "gpt_clk");
+	
+	/* Configure TIN */
+	ret = mxc_gpio_setup_multiple_pins(apf27_gpt2_pins,
+			ARRAY_SIZE(apf27_gpt2_pins), "GPT");
+
+	return 0;
+} 
+
+static int __exit gpt_plat_remove(struct platform_device *pdev)
+{
+	printk("--- %s\n", __func__);
+
+	mxc_gpio_release_multiple_pins(apf27_gpt2_pins, ARRAY_SIZE(apf27_gpt2_pins));
+
+	return 0;
+}
+
+
+MODULE_ALIAS("platform:gpt_timer");
+
+static struct platform_driver driver = {
+	.driver = {
+		.name = "imx_gpt",
+		.owner = THIS_MODULE,
+	},
+	.probe = gpt_plat_probe,
+	.remove = gpt_plat_remove,
+};
+
+static struct resource timer1_resources[] = {
+	[0] = {
+		.start  = GPT2_BASE_ADDR,
+		.end    = GPT2_BASE_ADDR + 0x17,
+		.flags  = IORESOURCE_MEM
+	},
+	[1] = {
+		.start   = MXC_INT_GPT2,
+		.end     = MXC_INT_GPT2,
+		.flags   = IORESOURCE_IRQ,
+        }
+};
+
+struct platform_device mxc_gpt1 = {
+        .name = "imx_gpt",
+        .id = 1,
+        .num_resources = ARRAY_SIZE(timer1_resources),
+	.resource = timer1_resources
+};
+
+
+static int __init gpt_plat_init(void)
+{
+	printk("--- %s\n", __func__);
+
+	platform_driver_register(&driver);
+	platform_device_register(&mxc_gpt1);
+	
+	return 0;
+}
+
+static void __exit gpt_plat_exit(void)
+{
+	printk("--- %s\n", __func__);
+	/* To be completed ... */
+}
+
+module_init(gpt_plat_init);
+module_exit(gpt_plat_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Julien Boibessot <julien.boibessot@armadeus.com>");
+MODULE_DESCRIPTION("Platform data for APF27 GPT2");
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/imxlkeypad/Kconfig linux-3.13/drivers/armadeus/imxlkeypad/Kconfig
--- linux-3.13/drivers/armadeus/imxlkeypad/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/imxlkeypad/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,10 @@
+#
+
+#
+config ARMADEUS_KEYPAD_DRIVER
+        tristate "Armadeus keypad driver"
+        default n
+        depends on ARMADEUS_DRIVERS
+        ---help---
+	  GPIO pins can be used to control a matrix keypad with this driver
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/imxlkeypad/Makefile linux-3.13/drivers/armadeus/imxlkeypad/Makefile
--- linux-3.13/drivers/armadeus/imxlkeypad/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/imxlkeypad/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,23 @@
+#
+# Makefile for the imx keypad linux-3.13/drivers
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_ARMADEUS_KEYPAD_DRIVER)	+= imxkeypad.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../Makefile.in
+ 
+endif
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/imxlkeypad/imxkeypad.c linux-3.13/drivers/armadeus/imxlkeypad/imxkeypad.c
--- linux-3.13/drivers/armadeus/imxlkeypad/imxkeypad.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/imxlkeypad/imxkeypad.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,320 @@
+/*
+ * imxkeypad driver for Linux/ARM Armadeus project
+ *
+ *  Copyright (c) 2006-2008 Eric Jarrige
+ *
+ * Based on LoCoMo keyboard driver
+ */
+
+/*
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/autoconf.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/ioport.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <linux/version.h>
+#include <mach/hardware.h>
+
+MODULE_AUTHOR("Eric Jarrige");
+MODULE_DESCRIPTION("i.MXL keypad driver");
+MODULE_LICENSE("GPL");
+
+#define DEBUG
+
+#define KPD_MAX_ROWS		8
+#define KPD_MAX_COLS		8
+
+#define KB_ROWMASK(r)		(1 << (r + kpdPtr->rows_offset))
+#define SCANCODE(c,r)		( (c * kpdPtr->num_rows) + (r) )
+
+#define KB_DELAY		8	/* uS */
+#define SCAN_INTERVAL		(HZ/10)
+
+static unsigned short imxkeypad_keycode[KPD_MAX_ROWS * KPD_MAX_COLS] = {
+	KEY_LEFT, KEY_RIGHT, KEY_ENTER, KEY_ESC,       /* 0 - 3 */
+	KEY_3,    KEY_6,     KEY_9,     KEY_SPACE,     /* 4 - 7 */
+	KEY_2,    KEY_5,     KEY_8,     KEY_0,         /* 8 - 11 */
+	KEY_1,    KEY_4,     KEY_7,     KEY_KPASTERISK /* 12 - 15 */
+};
+
+struct imxkeypad {
+	unsigned short keycode[KPD_MAX_ROWS * KPD_MAX_COLS];
+	struct input_dev *input;
+	char phys[32];
+
+	int num_rows;
+	int rows_offset;
+	int num_cols;
+	int cols_offset;
+	int port;
+	int irqs[KPD_MAX_ROWS];
+	spinlock_t lock;
+	
+	struct timer_list timer;
+	char	irq_disabled;
+	int 	debouncing;
+};
+
+/* module parameters definition */
+static int io_port=0;
+module_param(io_port, int, 0000);
+MODULE_PARM_DESC(io_port, "GPIO port (0..3)");
+
+static long int size[]={4,4};
+module_param_array(size, long, NULL, 0000);
+MODULE_PARM_DESC(size, "matrix size: num rows, num cols");
+
+static long int bit_offset[]={3,7};
+module_param_array(bit_offset, long, NULL, 0000);
+MODULE_PARM_DESC(bit_offset, "rows and cols bits offset in registers");
+
+module_param_array(imxkeypad_keycode, short, NULL, 0000); // imxkeypad_keycode declared line 60
+MODULE_PARM_DESC(imxkeypad_keycode, "rows and cols bits offset in registers");
+
+/* helper functions for reading the keyboard matrix */
+static inline void imxkeypad_charge_all(struct imxkeypad *kpdPtr)
+{
+	DR(kpdPtr->port) |= 
+		(((1<<(kpdPtr->num_cols))-1)<<(kpdPtr->cols_offset));
+}
+
+static inline void imxkeypad_activate_all(struct imxkeypad *kpdPtr)
+{
+	DR(kpdPtr->port) &= ~(((1<<(kpdPtr->num_cols))-1)<<(kpdPtr->cols_offset));
+}
+
+static inline void imxkeypad_activate_col(struct imxkeypad *kpdPtr, int col)
+{
+	DR(kpdPtr->port) &= ~(1 << (col + kpdPtr->cols_offset));
+}
+
+static inline void imxkeypad_reset_col(struct imxkeypad *kpdPtr, int col)
+{
+	DR(kpdPtr->port) |= (1 << (col + kpdPtr->cols_offset));
+}
+
+/*
+ * The i.MX keypad only generates interrupts when a key is pressed.
+ * So when a key is pressed, we enable a timer.  This timer scans the
+ * keyboard, and this is how we detect when the key is released.
+ */
+
+/* Scan the hardware keyboard and push any changes up to the Input layer */
+static void imxkeypad_scankeyboard(struct imxkeypad *kpdPtr) 
+{
+	unsigned int row, col, scancode;
+	unsigned long rowd;
+	unsigned int num_pressed;
+	
+	imxkeypad_charge_all(kpdPtr);
+
+	num_pressed = 0;
+	for (col = 0; col < kpdPtr->num_cols; col++) {
+
+		imxkeypad_activate_col(kpdPtr, col);
+		udelay(KB_DELAY);
+		 
+		rowd = ~(SSR(kpdPtr->port));
+		for (row = 0; row < kpdPtr->num_rows; row++ ) {
+			scancode = SCANCODE(col, row);
+			if (rowd & KB_ROWMASK(row)) {
+				num_pressed++;
+				input_report_key(kpdPtr->input, kpdPtr->keycode[scancode], 1);
+				kpdPtr->debouncing = 1;
+				printk(KERN_DEBUG "key index: %d\n", scancode);
+			} else if (1 >= kpdPtr->debouncing) {
+				input_report_key(kpdPtr->input, kpdPtr->keycode[scancode], 0);
+			}
+		}
+		imxkeypad_reset_col(kpdPtr, col);
+	}
+	imxkeypad_activate_all(kpdPtr);
+
+	input_sync(kpdPtr->input);
+
+	/* on key release, repeat some scan to remove debounce */
+	if ((!num_pressed)&&(0 <= kpdPtr->debouncing)) {
+		kpdPtr->debouncing--;
+	}
+
+	if ((!num_pressed)&&(kpdPtr->irq_disabled)&&(0 >= kpdPtr->debouncing)) {
+		for (row = 0; row < kpdPtr->num_rows; row++) {
+			enable_irq(kpdPtr->irqs[row]);
+		}
+		kpdPtr->irq_disabled = 0;
+	} else {
+		/* if any keys are pressed or still checking debounce, enable the timer */
+		mod_timer(&kpdPtr->timer, jiffies + SCAN_INTERVAL);
+	}
+}
+
+/* 
+ * imxkeypad interrupt handler.
+ */
+static irqreturn_t imxkeypad_interrupt(int irq, void *dev_id/*, struct pt_regs *regs*/)
+{
+	struct imxkeypad *kpdPtr = dev_id;
+	unsigned int row;
+	 
+	if (!kpdPtr->irq_disabled) {
+		for (row = 0; row < kpdPtr->num_rows; row++) {
+			disable_irq(kpdPtr->irqs[row]);
+		}
+		kpdPtr->irq_disabled = 1;
+		kpdPtr->debouncing = 1;
+	}
+
+	printk(KERN_DEBUG "keypad int\n");
+
+	mod_timer(&kpdPtr->timer, jiffies + SCAN_INTERVAL);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * imxkeypad timer checking for released keys
+ */
+static void imxkeypad_timer_callback(unsigned long data)
+{
+	struct imxkeypad *kpdPtr = (struct imxkeypad *) data;
+	imxkeypad_scankeyboard(kpdPtr);
+}
+
+
+
+static struct imxkeypad imxkeypad;
+
+
+static int __init imxkeypad_init(void)
+{
+	int i, ret;
+
+	printk(KERN_INFO "Initializing Armadeus keypad driver\n");
+
+	memset(&imxkeypad, 0, sizeof(struct imxkeypad));
+
+	spin_lock_init(&imxkeypad.lock);
+
+	init_timer(&imxkeypad.timer);
+	imxkeypad.timer.function = imxkeypad_timer_callback;
+	imxkeypad.timer.data = (unsigned long) &imxkeypad;
+	strcpy(imxkeypad.phys, "imxkeypad/input0");
+	
+	imxkeypad.input = input_allocate_device();
+	if (!imxkeypad.input) {
+		printk(KERN_ERR "imxkeypad: Can't allocate device structure\n");
+		goto out;
+	}
+	imxkeypad.input->evbit[0] = BIT(EV_KEY) | BIT(EV_REP);
+	
+	imxkeypad.input->keycode = imxkeypad.keycode;
+	imxkeypad.input->keycodesize = sizeof(unsigned short);
+	imxkeypad.input->keycodemax = ARRAY_SIZE(imxkeypad_keycode);
+	imxkeypad.input->name = "imxkeypad";
+	imxkeypad.input->phys = imxkeypad.phys;
+	imxkeypad.input->id.bustype = BUS_HOST;
+	imxkeypad.input->id.vendor = 0x0001;
+	imxkeypad.input->id.product = 0x0001;
+	imxkeypad.input->id.version = 0x0100;
+
+	printk(KERN_DEBUG "imxkeypad matrix size: %ld rows, %ld cols\n", size[0], size[1]);
+	imxkeypad.num_rows = size[0];
+	imxkeypad.num_cols = size[1];
+
+	printk(KERN_DEBUG "imxkeypad bit_offset : rows %ld bits, cols %ld bits\n", bit_offset[0], bit_offset[1]);
+	imxkeypad.rows_offset = bit_offset[0];
+	imxkeypad.cols_offset = bit_offset[1];
+
+	printk(KERN_DEBUG "imxkeypad GPIO port: %d\n", io_port);
+	imxkeypad.port = io_port;
+
+	/* init keycode table */	
+	memcpy(imxkeypad.keycode, imxkeypad_keycode, sizeof(imxkeypad.keycode));
+	for (i = 0; i < (imxkeypad.num_cols*imxkeypad.num_rows); i++)
+		set_bit(imxkeypad.keycode[i], imxkeypad.input->keybit);
+	clear_bit(0, imxkeypad.input->keybit);
+
+	/* init each gpios row pin as an input with pullup */	
+	for (i = 0; i < imxkeypad.num_rows; i++) {
+		imx_gpio_mode( (imxkeypad.port<<GPIO_PORT_SHIFT) 
+				| GPIO_GIUS | GPIO_IN | GPIO_PUEN
+				| (imxkeypad.rows_offset + i) );
+	}	
+	/* init each gpios column pin as an output */	
+	for (i = 0; i < imxkeypad.num_cols; i++) {
+		imx_gpio_mode( (imxkeypad.port<<GPIO_PORT_SHIFT) 
+				| GPIO_GIUS | GPIO_OUT | GPIO_DR
+				| (imxkeypad.cols_offset + i) );
+		
+	}	
+
+	/* Activate(??) every column to detect any key pressed */
+	imxkeypad_activate_all(&imxkeypad);
+
+	/* register driver to the Linux Input layer */
+	input_register_device(imxkeypad.input); /* TODO: Handle returned value !! */
+
+	/* attempt to reserve the interrupts (on i.MXL each GPIO can generate it's own interrupt) */
+	for (i = 0; i < imxkeypad.num_rows; i++) {
+		imxkeypad.irqs[i] = IMX_IRQS + 32*imxkeypad.port + imxkeypad.rows_offset + i;
+		printk(KERN_DEBUG "imxkeypad: requesting irq %d\n", imxkeypad.irqs[i]);
+		ret = request_irq(imxkeypad.irqs[i], imxkeypad_interrupt, 0, "imxkeypad", &imxkeypad);
+		if (ret) {
+			printk(KERN_ERR "imxkeypad: Can't get irq for keyboard\n");
+			goto free;
+		}
+		else set_irq_type( imxkeypad.irqs[i], IRQF_TRIGGER_FALLING ); /* configure it as falling edge sensitive */
+	}
+	
+	return 0;
+
+free:
+	input_unregister_device(imxkeypad.input);
+out:
+
+	return 0;
+}
+
+static void __exit imxkeypad_exit(void)
+{
+	int i;
+	
+	for (i = 0; i < imxkeypad.num_rows; i++) {
+		free_irq(imxkeypad.irqs[i], &imxkeypad);
+	}
+
+	del_timer_sync(&imxkeypad.timer);
+	
+	input_unregister_device(imxkeypad.input);
+}
+
+module_init(imxkeypad_init);
+module_exit(imxkeypad_exit);
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/Kconfig linux-3.13/drivers/armadeus/isp1761/Kconfig
--- linux-3.13/drivers/armadeus/isp1761/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,10 @@
+#
+#
+
+config ARMADEUS_ISP1761
+        tristate "isp1761 USB 2.0 Host controller"
+        default n
+        depends on ARMADEUS_DRIVERS && USB
+        ---help---
+        This driver allows you to control isp1761 USB 2.0 Host controller of the DevFull board
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/Makefile linux-3.13/drivers/armadeus/isp1761/Makefile
--- linux-3.13/drivers/armadeus/isp1761/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,25 @@
+#
+# Makefile for the ISP1761
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_ARMADEUS_ISP1761)	+= hal/ host/ apf9328-isp1761.o
+
+# Part execute when called from standard make in this directory:
+else
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+ifeq ($(LINUX_DIR),)
+LINUX_DIR    := $(ARMADEUS_LINUX_DIR)
+endif
+KDIR	:= $(LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../Makefile.in
+
+endif
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/README linux-3.13/drivers/armadeus/isp1761/README
--- linux-3.13/drivers/armadeus/isp1761/README	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/README	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,32 @@
+---------------------------------------
+ ISP176x driver (version 2.0.0.0-gum1)
+---------------------------------------
+
+This driver for the ISP1761 on a Gumstix is adapted from version 2.0.0.0 of the
+ISP176x host driver released by Philips at
+  http://sourceforge.net/projects/isp176x-hcd
+
+Changes from the original driver essentially involve:
+ - porting to Linux 2.6.17
+ - writing the HAL module hal_pxa.c
+ - The addition of gumstix-isp1761.c to point the driver at the relevant
+   resources.
+
+The board it has been tested on has the ISP1761 wired up as follows:
+ - 16-bit data bus
+ - 17-bits of address lines straight through
+ - nCS on nCS2
+ - NPWE to nWR (VLIO)
+ - NOE to nRD
+
+The gumstix-isp1761 module must be loaded before pehci, else the pehci module
+will not load.
+
+Porting to your port will involve editing gumstix-isp1761.c to find the correct
+chip select lines, IRQ lines, and memory regions. A 32-bit data bus will also
+require some changes to the mode register setting (set upon reset) in pehci.c
+and hal_pxa.c.
+
+Isochronous support has not been tested.
+
+ - Bernard Blackham <bernard@blackham.com.au>
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/apf9328-isp1761.c linux-3.13/drivers/armadeus/isp1761/apf9328-isp1761.c
--- linux-3.13/drivers/armadeus/isp1761/apf9328-isp1761.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/apf9328-isp1761.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,33 @@
+/*
+ * Deprecated - Now part of apf9328.c kernel file and U-Boot 1.3.4 patch 3.5
+ */
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+
+#include <linux/version.h>
+#include <mach/hardware.h>
+#include <mach/imx-regs.h>
+
+
+int __init devfull_isp1761_init(void)
+{	
+	return 0;
+}
+
+void __exit devfull_isp1761_exit(void)
+{
+}
+
+module_init(devfull_isp1761_init);
+module_exit(devfull_isp1761_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Julien Boibessot / Nicolas Colombain - Armadeus systems");
+MODULE_DESCRIPTION("APF9328 ISP1761 chip initialization driver");
+MODULE_VERSION("0.2");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/hal/Makefile linux-3.13/drivers/armadeus/isp1761/hal/Makefile
--- linux-3.13/drivers/armadeus/isp1761/hal/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/hal/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,3 @@
+#
+#
+obj-$(CONFIG_ARMADEUS_ISP1761) := hal_imx.o
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/hal/hal_imx.c linux-3.13/drivers/armadeus/isp1761/hal/hal_imx.c
--- linux-3.13/drivers/armadeus/isp1761/hal/hal_imx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/hal/hal_imx.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,1015 @@
+/************************************************************
+ * Philips ISP176x Hardware Abstraction Layer code file
+ *
+ * (c) 2002 Koninklijke Philips Electronics N.V. All rights reserved. <usb.linux@philips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * File Name: hal_x86.c
+ *
+ * Refering linux kernel version 2.6.23
+ *
+ * History:
+ *
+ * Date                Author                  Comments
+ * ---------------------------------------------------------------------
+ * Nov 29 2005        Prabhakar Kalasani      Initial Creation     
+ * Nov 04 2007        NC (armadeus)           add 2.6.23 compatibility
+ **********************************************************************
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>  
+#include <linux/usb.h>
+#include <linux/poll.h>
+#include <linux/platform_device.h>
+#include <linux/vmalloc.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <asm/dma.h>
+
+/*--------------------------------------------------------------*
+ *               linux system include files
+ *--------------------------------------------------------------*/
+#include "hal_x86.h" // We can use the x86 headers for now.
+#include "../hal/hal_intf.h"
+#include "../hal/isp1761.h"
+
+/*--------------------------------------------------------------*
+ *               Local variable Definitions
+ *--------------------------------------------------------------*/
+struct isp1761_dev              isp1761_loc_dev[ISP1761_LAST_DEV];
+static  struct isp1761_hal      hal_data;
+static struct platform_device *s_pdev;
+int      iolength = 0;
+static   __u32            isp1761_base = 0;
+
+/*--------------------------------------------------------------*
+ *               Local # Definitions
+ *--------------------------------------------------------------*/
+#define         isp1761_driver_name     "1761-m6"
+#define         ISP1761_IO_EXTENT ((1 << 17)-1) // 17 address bits used.
+#define         ISP1761_REGSET_LEN   0xffff
+
+#undef CONFIG_PM /* PM no workie yet. */
+
+/*--------------------------------------------------------------*
+ *               Local Function 
+ *--------------------------------------------------------------*/
+
+static int __devexit isp1761_remove (struct platform_device *pdev);
+static int __devinit isp1761_probe (struct platform_device *pdev);
+#ifdef CONFIG_PM
+static int isp1761_pci_suspend (struct pci_dev *dev, __u32 state);
+static int isp1761_pci_resume (struct pci_dev *dev);
+#endif
+static irqreturn_t  isp1761_pci_isr (int irq, void *dev_id);
+
+
+/*--------------------------------------------------------------*
+ *              ISP 1761 interrupt locking functions
+ *--------------------------------------------------------------*/
+int             isp1761_hw_lock = 0;
+int             isp1761_hw_isr = 0;
+
+void isp1761_disable_interrupt(int      irq) {
+    /* DUMMY functions
+     * Not used */
+    disable_irq(irq);
+    return;
+}
+void isp1761_enable_interrupt(int       irq) {
+    /* DUMMY functions
+     * Not used */
+    enable_irq(irq);
+    return;
+}
+
+/*--------------------------------------------------------------*
+ *               ISP1761 Interrupt Service Routine
+ *--------------------------------------------------------------*/
+/*Interrupt Service Routine for device controller*/
+irqreturn_t isp1761_pci_dc_isr(int irq, void *data)
+{
+    struct isp1761_dev *dev;
+    dev = &isp1761_loc_dev[ISP1761_DC];
+
+    hal_entry("%s: Entered\n",__FUNCTION__);
+    /*not ready yet*/
+    if(dev->active == 0)
+    {
+        printk("isp1761_pci_dc_isr: dev->active is NULL \n");
+        return IRQ_NONE;
+    }
+
+    /* Get the source of interrupts for Device Controller
+     * Device Controller interrupts are cleared by the driver
+     * during processing
+     */
+
+    /*unblock the device interrupt*/
+
+    isp1761_reg_write32(dev, DEV_UNLOCK_REGISTER, 0xaa37);
+    dev->int_reg = isp1761_reg_read32(dev, DEV_INTERRUPT_REGISTER, dev->int_reg);
+    hal_int("isp1761_pci_dc_isr:INTERRUPT_REGISTER 0x%x\n",dev->int_reg);
+    /*clear the interrupt source*/
+    isp1761_reg_write32(dev, 0x218, dev->int_reg);
+    dev->int_reg &= 0x03fffdb9;
+    if(dev->int_reg)
+        dev->handler(dev, dev->isr_data);
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return IRQ_HANDLED;
+}
+
+/* Interrupt Service Routine of isp1761                                   
+ * Reads the source of interrupt and calls the corresponding driver's ISR.
+ * Before calling the driver's ISR clears the source of interrupt.
+ * The linux-3.13/drivers can get the source of interrupt from the dev->int_reg field
+ */
+irqreturn_t isp1761_pci_isr(int irq, void *__data) 
+{
+    __u32               irq_mask = 0;
+    struct isp1761_dev  *dev;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+    /* Process the Host Controller Driver */
+    dev = &isp1761_loc_dev[ISP1761_HC];
+    /* Get the source of interrupts for Host Controller*/
+    dev->int_reg = isp1761_reg_read32(dev, HC_INTERRUPT_REG,dev->int_reg);
+    isp1761_reg_write32(dev,HC_INTERRUPT_REG,dev->int_reg);
+    irq_mask = isp1761_reg_read32(dev, HC_INTENABLE_REG,irq_mask);
+
+    dev->int_reg &= irq_mask; /*shared irq ??*/
+    /*call the Host Isr if any valid(minus otg)interrupt is present*/
+    if(dev->int_reg & ~HC_OTG_INTERRUPT)                
+        dev->handler(dev,dev->isr_data);
+#ifdef OTG
+#ifndef MSEC_INT_BASED
+    mdelay(1);
+#endif
+    /*process otg interrupt if there is any*/
+    if(dev->int_reg & HC_OTG_INTERRUPT){
+        u32     otg_int;        
+#ifndef MSEC_INT_BASED
+        mdelay(1);
+#endif
+        otg_int = (dev->int_reg & HC_OTG_INTERRUPT);
+        /* Process OTG controller Driver 
+         * Since OTG is part of  HC interrupt register, 
+         * the interrupt source will be HC interrupt Register
+         * */
+        dev = &isp1761_loc_dev[ISP1761_OTG];
+        /* Read the source of  OTG_INT and clear the
+           interrupt source */
+        dev->int_reg = otg_int; 
+        dev->handler(dev, dev->isr_data);
+    }   
+#endif
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return IRQ_HANDLED;
+} /* End of isp1362_pci_isr */
+
+/*--------------------------------------------------------------*
+ *               PCI Driver Interface Functions
+ *--------------------------------------------------------------*/
+
+/* Pci driver interface functions */
+static struct platform_driver isp1761_platform_driver = {
+probe:         isp1761_probe,
+remove:        isp1761_remove,
+driver:        { .name = "isp1761" }
+};
+
+
+/*--------------------------------------------------------------*
+ *               ISP1761 Read write routine 
+ *--------------------------------------------------------------*/
+
+/* Write a 32 bit Register of isp1761 */
+void isp1761_reg_write32(struct isp1761_dev *dev,__u16 reg,__u32 data)
+{ 
+    /* Write the 32bit to the register address given to us*/
+    writel(data,dev->baseaddress+reg);
+    //printk("Wrote to 0x%08x value 0x%08x\n", isp1761_base + reg, data);
+}
+
+
+/* Read a 32 bit Register of isp1761 */
+__u32 isp1761_reg_read32(struct isp1761_dev *dev,__u16 reg,__u32 data)
+{ 
+
+    data = readl(dev->baseaddress + reg);
+    //printk("Read from 0x%08x is 0x%08x\n", isp1761_base + reg, data);
+    return data;
+}
+
+
+/* Read a 16 bit Register of isp1761 */
+__u16 isp1761_reg_read16(struct isp1761_dev *dev,__u16 reg,__u16 data)
+{ 
+    data = readw(dev->baseaddress+reg);
+    return data;
+}
+
+/* Write a 16 bit Register of isp1761 */
+void isp1761_reg_write16(struct isp1761_dev *dev,__u16 reg,__u16 data)
+{ 
+    //printk("Wrote to 0x%08x value 0x%04x\n", isp1761_base + reg, data);
+    writew(data,dev->baseaddress+reg);
+
+}
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_mem_read
+ *
+ * Memory read using PIO method.
+ *
+ *  Input: struct isp1761_driver *drv  -->  Driver structure.
+ *                      __u32 start_add     --> Starting address of memory 
+ *              __u32 end_add     ---> End address 
+ *              
+ *              __u32 * buffer      --> Buffer pointer.
+ *              __u32 length       ---> Length 
+ *              __u16 dir          ---> Direction ( Inc or Dec)
+ *                      
+ *  Output     int Length  ----> Number of bytes read 
+ *
+ *  Called by: system function 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+/* Memory read function PIO */
+
+int     
+isp1761_mem_read(struct isp1761_dev *dev, __u32 start_add, 
+        __u32 end_add, __u32 * buffer, __u32 length, __u16 dir)
+{
+    u8 *temp_base_mem = 0;      
+    u8 *one = (u8 *) buffer;
+    u16 *two = (u16 *) buffer;
+    int a = (int)length;
+    u32 w;
+    temp_base_mem= (dev->baseaddress + start_add);
+    /*initialize the Register 0x33C-used to manage Multiple threads */
+    writel(start_add,dev->baseaddress+0x33c);
+
+last:
+    w = readl(temp_base_mem);
+    if(a == 1){
+        *one=(u8)w;
+        return 0;
+    }
+    if(a == 2){
+        *two=(u16)w;
+        return 0;
+    }   
+
+
+    if(a == 3){
+        *two=(u16)w;
+        two += 1;
+        w >>= 16;
+        *two = (u8)(w);
+        return 0;
+
+    }
+
+
+    while(a>0){
+        *buffer = w;
+        temp_base_mem = temp_base_mem+4;
+        start_add +=4;
+        a -= 4;
+        if(a == 0)
+            break;
+        if(a < 4){
+            buffer += 1;
+            one = (u8 *)buffer;
+            two = (u16 *)buffer;
+            goto last;
+        }
+        buffer += 1;
+        w = readl(temp_base_mem); 
+    }
+    return ((a < 0) || (a == 0))?0:(-1);
+
+}
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_mem_write
+ *
+ * Memory write using PIO method.
+ *
+ *  Input: struct isp1761_driver *drv  -->  Driver structure.
+ *                      __u32 start_add     --> Starting address of memory 
+ *              __u32 end_add     ---> End address 
+ *              
+ *              __u32 * buffer      --> Buffer pointer.
+ *              __u32 length       ---> Length 
+ *              __u16 dir          ---> Direction ( Inc or Dec)
+ *                      
+ *  Output     int Length  ----> Number of bytes read 
+ *
+ *  Called by: system function 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+/* Memory read function IO */
+int     
+isp1761_mem_write(struct isp1761_dev *dev, 
+        __u32 start_add, __u32 end_add, 
+        __u32 * buffer, __u32 length,
+        __u16 dir)
+{
+    u8 *temp_base_mem = 0;
+    int a = length;
+    //u8 *temp = (u8*)buffer;
+    u8 one      =(u8 )(*buffer);
+    u16 two     =(u16 )(*buffer);       
+    temp_base_mem = (dev->baseaddress + start_add);
+
+    if(a == 1){
+        writeb(one,temp_base_mem);
+        return 0;
+    }
+    if(a == 2){
+        writew(two,temp_base_mem);
+        return 0;
+    }
+
+    while(a>0){         
+        writel(*buffer, temp_base_mem);
+        temp_base_mem = temp_base_mem+4;
+        start_add +=4;
+        a -=4;
+        if(a <= 0)
+            break;
+        buffer += 1;
+
+    }
+    return ((a < 0) || (a == 0))?0:(-1);
+
+}
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_check_mem_region
+ *
+ *  Check the memory region for Memory Mapping 
+ *  Check with the system about the availability of the region,
+ *  and returns success, if available.
+ *
+ *  Input: struct isp1761_driver *drv  --> Driver structure.
+ *  
+ *  Output result  
+ *         
+ *
+ *  Called by: system function 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+int isp1761_check_mem_region(struct isp1761_dev *dev)
+{
+    int ret;
+    ret=check_mem_region(dev->start, dev->length);
+    return ret;
+}/* End of isp1761_check_mem_region */
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_request_mem_region
+ isp1761_release_mem_region
+ isp1761_get_mem_params
+
+ *
+ *  If the check returns Success, we can request the region for 
+ *  Memory mapping of our chip memory
+ *
+ *  Input: struct isp1761_driver *drv  --> Driver structure.
+ *  
+ *  Output result  
+ *         
+ *
+ *  Called by: system function 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+struct resource* isp1761_request_mem_region(struct isp1761_dev *dev)
+{
+    dev->mem_res = request_mem_region(dev->start, dev->length, "Isp1761_device");
+    return dev->mem_res;
+}/* End of isp1761_request_mem_region */
+
+/* Release an already acquired memory region.
+   It should be done at the rmmod of the module */
+void isp1761_release_mem_region(struct isp1761_dev* dev)
+{
+    release_mem_region (dev->start, dev->length);
+}
+
+/* Get the start address and length of Mapped Memory */ 
+void isp1761_get_mem_params(struct isp1761_dev *dev,struct isp1761_driver *drv)
+{
+    dev->start  =isp1761_loc_dev[drv->index].start;
+    dev->length =isp1761_loc_dev[drv->index].length;
+}/* End of isp1761_get_mem_params*/
+
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_request_irq
+ *
+ * This function registers the ISR of driver with this driver.
+ * Since there is only one interrupt line, when the first driver
+ * is registerd, will call the system function request_irq. The PLX
+ * bridge needs enabling of interrupt in the interrupt control register to 
+ * pass the local interrupts to the PCI (cpu).
+ * For later registrations will just update the variables. On ISR, this driver
+ * will look for registered handlers and calls the corresponding driver's
+ * ISR "handler" function with "isr_data" as parameter.
+ *
+ *  Input: struct 
+ *              (void (*handler)(struct isp1761_dev *, void *)-->handler.
+ *               isp1761_driver *drv  --> Driver structure.
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+int isp1761_request_irq(void (*handler)(struct isp1761_dev *, void *),
+        struct isp1761_dev *dev, void *isr_data) 
+{
+    int result = 0;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+    hal_int("isp1761_request_irq: dev->index %x\n",dev->index);
+    if(dev->index == ISP1761_DC){
+        result = request_irq(dev->irq, isp1761_pci_dc_isr,
+                IRQF_SHARED,
+                dev->name,
+                isr_data);
+    }else {
+        result= request_irq(dev->irq,isp1761_pci_isr,
+                IRQF_SHARED,
+                dev->name,
+                isr_data);
+    }
+
+    /*Interrupt handler routine*/
+    dev->handler = handler;
+    dev->isr_data = isr_data;
+    hal_int("isp1761_request_irq: dev->handler %s\n",dev->handler);
+    hal_int("isp1761_request_irq: dev->isr_data %x\n",dev->isr_data);
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return result;
+} /* End of isp1761_request_irq */
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_free_irq
+ *
+ * This function de-registers the ISR of driver with this driver.
+ * Since there is only one interrupt line, when the last driver
+ * is de-registerd, will call the system function free_irq. The PLX
+ * bridge needs disabling of interrupt in the interrupt control register to 
+ * block the local interrupts to the PCI (cpu).
+ *
+ *  Input: struct 
+ *              (void (*handler)(struct isp1761_dev *, void *)-->handler.
+ *               isp1761_driver *drv  --> Driver structure.
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+void isp1761_free_irq(struct isp1761_dev *dev, void *isr_data)
+{
+    hal_int(("isp1761_free_irq(dev=%p,isr_data=%p)\n",dev,isr_data));
+    free_irq(dev->irq,isr_data);
+} /* isp1761_free_irq */
+
+
+
+/* Allocate Fragmented kernel Memory */
+void* isp_1761_kmalloc(size_t size,int flags)
+{
+    void* ret;
+    ret =kmalloc(size,flags);
+    return ret;
+}
+
+/* Free the memory allocated by kmalloc */
+void isp_1761_kfree(const void* objp)
+{
+    kfree(objp);
+}
+
+/* Allocate Contiguous kernel Memory */
+void* isp_1761_vmalloc(__u32 size, __u16 flags, pgprot_t prot)
+{
+    void* ret;
+    ret = __vmalloc(size, flags, prot);
+    return ret;
+}
+
+/* Free the memory allocated by vmalloc */
+void isp_1761_vfree(const void* objp)
+{
+    kfree(objp);
+}
+
+
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_register_driver
+ *
+ * This function is used by top driver (OTG, HCD, DCD) to register
+ * their communication functions (probe, remove, suspend, resume) using
+ * the drv data structure.
+ * This function will call the probe function of the driver if the ISP1761
+ * corresponding to the driver is enabled
+ *
+ *  Input: struct isp1761_driver *drv  --> Driver structure.
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+int     isp1761_register_driver(struct isp1761_driver *drv) 
+{
+    struct isp1761_dev  *dev;
+    int result;
+    isp1761_id *id;
+
+    hal_entry("%s: Entered\n",__FUNCTION__);
+    info("isp1761_register_driver(drv=%p) \n",drv);
+
+    if(!drv) return -EINVAL;
+    dev = &isp1761_loc_dev[drv->index];
+    if(drv->index == ISP1761_DC){/*FIX for device*/
+        result = drv->probe(dev,drv->id);
+    }else{              
+        id = drv->id;
+        if(dev->active) result = drv->probe(dev,id);
+        else    result = -ENODEV;
+    }
+
+    if(result >= 0 ) {
+        printk(KERN_INFO __FILE__ ": Registered Driver %s\n",
+                drv->name);
+        dev->driver = drv;
+    }
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return result;
+} /* End of isp1761_register_driver */
+
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_unregister_driver
+ *
+ * This function is used by top driver (OTG, HCD, DCD) to de-register
+ * their communication functions (probe, remove, suspend, resume) using
+ * the drv data structure.
+ * This function will check whether the driver is registered or not and
+ * call the remove function of the driver if registered
+ *
+ *  Input: struct isp1761_driver *drv  --> Driver structure.
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+
+void    isp1761_unregister_driver(struct isp1761_driver *drv)
+{
+    struct isp1761_dev  *dev;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+
+    info("isp1761_unregister_driver(drv=%p)\n",drv);
+    dev = &isp1761_loc_dev[drv->index];
+    if(dev->driver == drv) {
+        /* driver registered is same as the requestig driver */
+        drv->remove(dev);
+        dev->driver = NULL;
+        info(": De-registered Driver %s\n",
+                drv->name);
+        return;
+    }
+    hal_entry("%s: Exit\n",__FUNCTION__);
+} /* End of isp1761_unregister_driver */
+
+
+/*--------------------------------------------------------------*
+ *               ISP1761 PCI driver interface routine.
+ *--------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_module_init
+ *
+ *  This  is the module initialization function. It registers to 
+ *  PCI driver for a PLX PCI bridge device. And also resets the
+ *  internal data structures before registering to PCI driver.
+ *
+ *  Input: void 
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ * 
+ -------------------------------------------------------------------*/
+static int __init isp1761_module_init (void) 
+{
+    int result = 0;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+
+    memset(isp1761_loc_dev,0,sizeof(isp1761_loc_dev));
+
+    result = platform_driver_register(&isp1761_platform_driver);
+
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return result;
+}
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_module_cleanup
+ *
+ * This  is the module cleanup function. It de-registers from 
+ * PCI driver and resets the internal data structures.
+ *
+ *  Input: void 
+ *  Output void
+ *
+ *  Called by: system function module_cleanup 
+ * 
+ * 
+ * 
+ --------------------------------------------------------------*/
+
+static void __exit isp1761_module_cleanup (void) 
+{
+    printk("Hal Module Cleanup\n");
+    platform_driver_unregister(&isp1761_platform_driver);
+    memset(isp1761_loc_dev,0,sizeof(isp1761_loc_dev));
+} 
+
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_probe
+ *
+ * PCI probe function of ISP1761
+ * This function is called from PCI Driver as an initialization function
+ * when it founds the PCI device. This functions initializes the information
+ * for the 3 Controllers with the assigned resources and tests the register
+ * access to these controllers and do a software reset and makes them ready
+ * for the linux-3.13/drivers to play with them.
+ *
+ *  Input: 
+ *              struct pci_dev *dev                     ----> PCI Devie data structure 
+ *      const struct pci_device_id *id  ----> PCI Device ID 
+ *  Output void
+ *
+ *  Called by: system function module_cleanup 
+ * 
+ * 
+ * 
+ --------------------------------------------------------------**/
+
+    static int __devinit
+isp1761_probe (struct platform_device *pdev)
+{
+    __u32       reg_data = 0;
+    struct isp1761_dev  *loc_dev;
+    struct resource *res;
+    void *address = 0;
+    int length = ISP1761_IO_EXTENT;
+    int status = 0;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+
+    res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "isp1761-regs");
+    if (!res)
+	    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res)
+	    return -ENODEV;
+
+    isp1761_base = res->start;
+    hal_init(("isp1761 pci base address = %x\n", isp1761_base));
+
+    /* Get the Host Controller IO and INT resources
+     */
+    loc_dev = &(isp1761_loc_dev[ISP1761_HC]);
+    loc_dev->dev = &pdev->dev;
+    loc_dev->irq = platform_get_irq(pdev, 0);
+    loc_dev->io_base = isp1761_base;
+    loc_dev->start   =  isp1761_base;
+    loc_dev->length  = ISP1761_REGSET_LEN;
+    loc_dev->io_len = ISP1761_REGSET_LEN; /*64K*/
+    loc_dev->index = ISP1761_HC;/*zero*/
+
+    loc_dev->io_len = length; 
+    if(check_mem_region(loc_dev->io_base,length)<0){
+        err("host controller already in use\n");
+        return -EBUSY;
+    }
+    if(!request_mem_region(loc_dev->io_base, length,isp1761_driver_name)){
+        err("host controller already in use\n");
+        return -EBUSY;
+
+    }
+
+    /*map available memory*/
+    address = ioremap_nocache(isp1761_base,length);
+    if(address == NULL){
+        err("memory map problem\n");
+        release_mem_region(loc_dev->io_base,length);
+        return -ENOMEM;
+    } 
+
+    loc_dev->baseaddress = (u8*)address;
+    //loc_dev->dmabase = (u8*)iobase;
+
+    hal_init(("isp1761 HC MEM Base= %p irq = %d\n", 
+                loc_dev->baseaddress,loc_dev->irq));
+#ifdef ISP1761_DEVICE   
+
+    /*initialize device controller framework*/  
+    loc_dev = &(isp1761_loc_dev[ISP1761_DC]);
+    loc_dev->dev = &pdev->dev;
+    loc_dev->irq = platform_get_irq(pdev, 0);
+    loc_dev->io_base = isp1761_base;
+    loc_dev->start   = isp1761_base;
+    loc_dev->length  = ISP1761_REGSET_LEN;
+    loc_dev->io_len = ISP1761_REGSET_LEN;
+    loc_dev->index = ISP1761_DC;
+    loc_dev->baseaddress = address;
+    loc_dev->active = 1;
+    memcpy(loc_dev->name,"isp1761_dev",11);
+    loc_dev->name[12] = '\0';
+
+
+    {
+        u32 chipid = 0;
+        chipid = readl(address + 0x270);
+        info("pid %04x, vid %04x\n", (chipid & 0xffff), (chipid >> 16));
+    }   
+    hal_init(("isp1761 DC MEM Base= %lx irq = %d\n", 
+                loc_dev->io_base,loc_dev->irq));
+    /* Get the OTG Controller IO and INT resources
+     * OTG controller resources are same as Host Controller resources
+     */
+    loc_dev = &(isp1761_loc_dev[ISP1761_OTG]);
+    loc_dev->dev = &pdev->dev;
+    loc_dev->irq = platform_get_irq(pdev, 0);
+    loc_dev->io_base = isp1761_base;
+    loc_dev->start   =  isp1761_base;
+    loc_dev->length  = ISP1761_REGSET_LEN;     
+    loc_dev->io_len = ISP1761_REGSET_LEN;
+    loc_dev->index = ISP1761_OTG; 
+    loc_dev->baseaddress = address; /*having the same address as of host*/
+    loc_dev->active = 1;
+    memcpy(loc_dev->name,"isp1761_otg",11);
+    loc_dev->name[12] = '\0';
+
+    hal_init(("isp1761 OTG MEM Base= %lx irq = %x\n", 
+                loc_dev->io_base,loc_dev->irq));
+
+#endif
+
+    /* Try to check whether we can access Scratch Register of
+     * Host Controller or not.
+     */
+
+#if 1 // CUSTOM STUFF - 16-bit mode
+    isp1761_reg_write32(loc_dev, HC_HW_MODE_REG, 0x82);
+#endif
+
+    loc_dev = &(isp1761_loc_dev[ISP1761_HC]);
+    isp1761_reg_write32(loc_dev, HC_SCRATCH_REG, 0xFACEECAF);
+    /* perform a read of the chip ID to avoir bus hold effect when
+    * reading back the scratch register */
+    isp1761_reg_read16(loc_dev, HC_CHIP_ID_REG, reg_data);
+    udelay(100); 
+    reg_data = isp1761_reg_read32(loc_dev, HC_SCRATCH_REG,reg_data);
+
+    /* Host Controller presence is detected by writing to scratch register
+     * and reading back and checking the contents are same or not
+     */
+    if(reg_data != 0xFACEECAF) {
+        err("%s scratch register mismatch %x",
+                isp1761_driver_name,reg_data);
+        err("ISP176x device not present");
+        status = -ENODEV;
+        goto clean;
+    }
+
+    memcpy(loc_dev->name, isp1761_driver_name, sizeof(isp1761_driver_name));
+    loc_dev->name[sizeof(isp1761_driver_name)] = 0;
+    loc_dev->active = 1;
+
+    info("controller address %p\n", &pdev->dev);
+
+    s_pdev = pdev;
+    hal_data.irq_usage = 0;
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return 0;
+
+clean:
+    release_mem_region(loc_dev->io_base, loc_dev->io_len);
+    iounmap(loc_dev->baseaddress);
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return status;
+} /* End of isp1761_probe */
+
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_remove
+ *
+ * PCI cleanup function of ISP1761
+ * This function is called from PCI Driver as an removal function
+ * in the absence of PCI device or a de-registration of driver.
+ * This functions checks the registerd linux-3.13/drivers (HCD, DCD, OTG) and calls
+ * the corresponding removal functions. Also initializes the local variables
+ * to zero.
+ *
+ *  Input: 
+ *              struct pci_dev *dev                     ----> PCI Devie data structure 
+ *    
+ *  Output void
+ *
+ *  Called by: system function module_cleanup 
+ * 
+ * 
+ * 
+ --------------------------------------------------------------*/
+static int __devexit
+isp1761_remove (struct platform_device *pdev)
+{
+    struct isp1761_dev  *loc_dev;
+    hal_init(("isp1761_remove(dev=%p)\n",pdev));
+    /*Lets handle the host first*/
+    loc_dev  = &isp1761_loc_dev[ISP1761_HC];
+    /*free the memory occupied by host*/
+    release_mem_region(loc_dev->io_base, loc_dev->io_len);      
+    /*unmap the occupied memory resources*/
+    iounmap(loc_dev->baseaddress);
+    s_pdev = NULL;
+    return 0;
+} /* End of isp1761_remove */
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_pci_suspend
+ *
+ * PCI suspend function of ISP1761
+ * This function is called from PCI Driver.
+ * This functions checks the registerd linux-3.13/drivers (HCD, DCD, OTG) and calls
+ * the corresponding suspend functions if present. 
+ *  Input: 
+ *              struct pci_dev *dev                     ----> PCI Devie data structure 
+ *    
+ *  Output void
+ *
+ *  Called by: system function 
+ * 
+ * 
+ * 
+ --------------------------------------------------------------*/
+
+#ifdef CONFIG_PM
+static int isp1761_pci_suspend (struct pci_dev *dev, __u32 state) 
+{
+    struct isp1761_dev  *loc_dev;
+    int                 index;
+
+    hal_init(("isp1761_pci_suspend(dev=%p, state = %x)\n",dev, state));
+
+
+    loc_dev = (struct isp1761_dev *)pci_get_drvdata(dev);
+
+    /* For each controller check whether driver is registerd
+     * or not. If registerd call the suspend function if it is
+     * present
+     */
+    for(index=ISP1761_1ST_DEV;index<ISP1761_LAST_DEV;(index++,loc_dev++)) {
+        if(loc_dev->driver && loc_dev->driver->suspend) {
+            loc_dev->driver->suspend(loc_dev);
+        }
+    }
+
+    return 0;
+} /* End of isp1761_pci_suspend */
+#endif
+
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_pci_suspend
+ *
+ *  PCI resume function of ISP1761
+ * This function is called from PCI Driver.
+ * This functions checks the registerd linux-3.13/drivers (HCD, DCD, OTG) and calls
+ * the corresponding resume functions if present.  
+ *  Input: 
+ *              struct pci_dev *dev                     ----> PCI Devie data structure 
+ *    
+ *  Output void
+ *
+ *  Called by: system function
+ * 
+ * 
+ --------------------------------------------------------------*/
+#ifdef CONFIG_PM
+static int isp1761_pci_resume (struct pci_dev *dev)
+{
+    struct isp1761_dev  *loc_dev;
+    int                 index;
+    hal_init(("isp1362_pci_resume(dev=%p)\n",dev));
+    loc_dev = (struct isp1761_dev *)pci_get_drvdata(dev);
+
+    /* For each controller check whether driver is registerd
+     * or not. If registerd call the resume function if it is
+     * present
+     */
+    for(index=ISP1761_1ST_DEV;index<ISP1761_LAST_DEV;(index++,loc_dev++)) {
+        if(loc_dev->driver && loc_dev->driver->resume) {
+            loc_dev->driver->resume(loc_dev);
+        }
+    }
+
+    return 0;
+
+} /* End of isp1362_pci_resume */
+#endif
+
+
+
+EXPORT_SYMBOL(isp1761_reg_write16);
+EXPORT_SYMBOL(isp1761_reg_read16);
+EXPORT_SYMBOL(isp1761_reg_read32);
+EXPORT_SYMBOL(isp1761_reg_write32);
+EXPORT_SYMBOL(isp1761_request_irq);
+EXPORT_SYMBOL(isp1761_mem_read);
+EXPORT_SYMBOL(isp1761_mem_write);
+EXPORT_SYMBOL(isp1761_free_irq);
+EXPORT_SYMBOL(isp1761_register_driver);
+EXPORT_SYMBOL(isp1761_unregister_driver);
+
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE ("GPL");
+
+module_init (isp1761_module_init);
+module_exit (isp1761_module_cleanup);
+
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/hal/hal_intf.h linux-3.13/drivers/armadeus/isp1761/hal/hal_intf.h
--- linux-3.13/drivers/armadeus/isp1761/hal/hal_intf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/hal/hal_intf.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,165 @@
+/**********************************************************************
+ * Philips ISP176x Hardware Access Interface header file
+ *
+ * (c) 2002 Koninklijke Philips Electronics N.V. All rights reserved. <usb.linux@philips.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * File Name:   hal_intf.h
+ *
+ * History:     
+ *
+ * Date                Author                  Comments
+ * ---------------------------------------------------------------------
+ * Nov 29 2005        Prabhakar Kalasani      Initial Creation     
+ * Nov 04 2007        NC (armadeus)           Add 2.6.23 compatibility               
+ ***********************************************************************/
+
+#ifndef __HAL_INTF_H__
+#define __HAL_INTF_H__
+
+/* Values for id_flags filed of isp1761_driver_t */
+#define         ISP1761_HC                              0               /* Host Controller Driver */
+#define         ISP1761_DC                              1               /* Device Controller Driver */
+#define         ISP1761_OTG                             2               /* Otg Controller Driver */
+#define         ISP1761_LAST_DEV                        (ISP1761_OTG+1)
+#define         ISP1761_1ST_DEV                         (ISP1761_HC)
+
+#define         HC_SPARAMS_REG                          0x04    /* Structural Parameters Register */
+#define         HC_CPARAMS_REG                          0x08    /* Capability Parameters Register */
+
+#define         HC_USBCMD_REG                           0x20    /* USB Command Register */
+#define         HC_USBSTS_REG                           0x24    /* USB Status Register */
+#define         HC_INTERRUPT_REG_EHCI                   0x28    /* INterrupt Enable Register */
+#define         HC_FRINDEX_REG                          0x2C    /* Frame Index Register */
+
+#define         HC_CONFIGFLAG_REG                       0x60    /* Conigured Flag  Register */
+#define         HC_PORTSC1_REG                          0x64    /* Port Status Control for Port1 */
+
+/*ISO Transfer Registers */
+#define         HC_ISO_PTD_DONEMAP_REG                  0x130   /* ISO PTD Done Map Register */
+#define         HC_ISO_PTD_SKIPMAP_REG                  0x134   /* ISO PTD Skip Map Register */
+#define         HC_ISO_PTD_LASTPTD_REG                  0x138   /* ISO PTD Last PTD Register */
+
+/*INT Transfer Registers */
+#define         HC_INT_PTD_DONEMAP_REG                  0x140   /* INT PTD Done Map Register */
+#define         HC_INT_PTD_SKIPMAP_REG                  0x144   /* INT PTD Skip Map Register */
+#define         HC_INT_PTD_LASTPTD_REG                  0x148   /* INT PTD Last PTD Register  */
+
+/*ATL Transfer Registers */
+#define         HC_ATL_PTD_DONEMAP_REG                  0x150   /* ATL PTD Last PTD Register  */
+#define         HC_ATL_PTD_SKIPMAP_REG                  0x154   /* ATL PTD Last PTD Register  */
+#define         HC_ATL_PTD_LASTPTD_REG                  0x158   /* ATL PTD Last PTD Register  */
+
+/*General Purpose Registers */
+#define         HC_HW_MODE_REG                          0x300   /* H/W Mode Register  */
+#define         HC_CHIP_ID_REG                          0x304   /* Chip ID Register */
+#define         HC_SCRATCH_REG                          0x308   /* Scratch Register */
+#define         HC_RESET_REG                            0x30C   /* HC Reset Register */
+
+/* Interrupt Registers */
+#define         HC_INTERRUPT_REG                        0x310   /* Interrupt Register */
+#define         HC_INTENABLE_REG                        0x314   /* Interrupt enable Register */
+#define         HC_ISO_IRQ_MASK_OR_REG                  0x318   /* ISO Mask OR Register */
+#define         HC_INT_IRQ_MASK_OR_REG                  0x31C   /* INT Mask OR Register*/
+#define         HC_ATL_IRQ_MASK_OR_REG                  0x320   /* ATL Mask OR Register */
+#define         HC_ISO_IRQ_MASK_AND_REG                 0x324   /* ISO Mask AND Register */
+#define         HC_INT_IRQ_MASK_AND_REG                 0x328   /* INT Mask AND Register */
+#define         HC_ATL_IRQ_MASK_AND_REG                 0x32C   /* ATL Mask AND Register */
+
+/*RAM Registers */
+#define         HC_DMACONFIG_REG                        0x330   /* DMA Config Register */
+#define         HC_TRANS_COUNT_REG                      0x334   /* Transfer Counter Register */
+#define         HC_BUFFER_STAT_REG                      0x338   /* Buffer status Register */
+#define         HC_MEM_READ_REG                         0x33C   /* Memory Register */
+
+/*interrupt count and buffer status register*/
+
+#define         HC_BUFFER_STATUS_REG                    0x334
+#define         HC_INT_THRESHOLD_REG                    0x340
+#define         HC_OTG_INTERRUPT                        0x400
+
+struct isp1761_driver;
+typedef struct _isp1761_id {
+    __u16 idVendor;
+    __u16 idProduct;
+    unsigned long driver_info;
+}isp1761_id;
+
+typedef struct isp1761_dev {
+    /*added for pci device*/
+    struct device *dev;
+    struct  isp1761_driver *driver; /* which driver has allocated this device */
+    void            *driver_data;   /* data private to the host controller driver */
+    void            *otg_driver_data; /*data private for otg controler*/
+    unsigned char   index;          /* local controller (HC/DC/OTG) */
+    unsigned int    irq;    /*Interrupt Channel allocated for this device */
+    void (*handler)(struct isp1761_dev *dev,
+            void *isr_data);      /* Interrupt Serrvice Routine */
+    void            *isr_data;              /* isr data of the driver */
+    unsigned long   int_reg;                /* Interrupt register */
+    unsigned long   alt_int_reg;            /* Interrupt register 2*/
+    unsigned long   start;
+    unsigned long   length;
+    struct resource *mem_res;
+    unsigned long   io_base;/* Start Io address space for this device */
+    unsigned long   io_len; /* IO address space length for this device */
+
+    unsigned long   chip_id; /* Chip Id */
+
+    char            name[80];       /* device name */
+    int             active;                         /* device status */
+
+    /* DMA resources should come TODO */
+    unsigned long   dma;
+    u8 *baseaddress;  /*base address for i/o ops*/
+    u8 *dmabase;
+}isp1761_dev_t ;
+
+
+typedef struct isp1761_driver {
+    char            *name;
+    unsigned long   index;  /* HC or DC or OTG */
+    isp1761_id      *id;    /*device ids*/
+    int (*probe)(struct isp1761_dev *dev,
+            isp1761_id *id);        /* New device inserted */
+    void (*remove)(struct isp1761_dev *dev);/* Device removed (NULL if not a hot-plug capable driver) */
+
+#ifdef CONFIG_PM
+    void (*suspend)(struct isp1761_dev *dev);       /* Device suspended */
+    void (*resume)(struct isp1761_dev *dev);        /* Device woken up */
+#endif /* CONFIG_PM */
+
+} isp_1761_driver_t;
+
+struct usb_device * phci_register_otg_device(struct isp1761_dev *dev);
+
+/*otg exported function from host*/
+int     phci_suspend_otg_port(struct isp1761_dev *dev, u32 command);
+int     phci_enumerate_otg_port(struct isp1761_dev *dev, u32 command);
+
+int     isp1761_register_driver(struct isp1761_driver *drv);
+void    isp1761_unregister_driver(struct isp1761_driver *drv);
+int     isp1761_request_irq(void(*handler)(struct isp1761_dev* dev,void* isr_data),
+        struct isp1761_dev* dev, void* isr_data);
+void    isp1761_free_irq(struct isp1761_dev* dev,void* isr_data);
+
+__u32   isp1761_reg_read32(isp1761_dev_t *dev,__u16 reg,__u32 data);
+void    isp1761_reg_write32(isp1761_dev_t *dev,__u16 reg,__u32 data);
+int     isp1761_mem_read(isp1761_dev_t *dev, __u32 start_add, 
+        __u32 end_add, __u32 * buffer, __u32 length, __u16 dir);
+int     isp1761_mem_write(isp1761_dev_t *dev, __u32 start_add, 
+        __u32 end_add, __u32 * buffer, __u32 length, __u16 dir);
+#endif /* __HAL_INTF_H__ */
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/hal/hal_pxa.c linux-3.13/drivers/armadeus/isp1761/hal/hal_pxa.c
--- linux-3.13/drivers/armadeus/isp1761/hal/hal_pxa.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/hal/hal_pxa.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,1012 @@
+/************************************************************
+ * Philips ISP176x Hardware Abstraction Layer code file
+ *
+ * (c) 2002 Koninklijke Philips Electronics N.V. All rights reserved. <usb.linux@philips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * File Name: hal_x86.c
+ *
+ * Refering linux kernel version 2.6.9
+ *
+ * History:
+ *
+ * Date                Author                  Comments
+ * ---------------------------------------------------------------------
+ * Nov 29 2005        Prabhakar Kalasani      Initial Creation     
+ *
+ **********************************************************************
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>  
+#include <linux/usb.h>
+#include <linux/poll.h>
+#include <linux/platform_device.h>
+#include <linux/vmalloc.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <asm/dma.h>
+
+/*--------------------------------------------------------------*
+ *               linux system include files
+ *--------------------------------------------------------------*/
+#include "hal_x86.h" // We can use the x86 headers for now.
+#include "../hal/hal_intf.h"
+#include "../hal/isp1761.h"
+
+/*--------------------------------------------------------------*
+ *               Local variable Definitions
+ *--------------------------------------------------------------*/
+struct isp1761_dev              isp1761_loc_dev[ISP1761_LAST_DEV];
+static  struct isp1761_hal      hal_data;
+static struct platform_device *s_pdev;
+int      iolength = 0;
+static   __u32            isp1761_base = 0;
+
+/*--------------------------------------------------------------*
+ *               Local # Definitions
+ *--------------------------------------------------------------*/
+#define         isp1761_driver_name     "1761-m6"
+#define         ISP1761_IO_EXTENT ((1 << 17)-1) // 17 address bits used.
+#define         ISP1761_REGSET_LEN   0xffff
+
+#undef CONFIG_PM /* PM no workie yet. */
+
+/*--------------------------------------------------------------*
+ *               Local Function 
+ *--------------------------------------------------------------*/
+
+static int __devexit isp1761_remove (struct platform_device *pdev);
+static int __devinit isp1761_probe (struct platform_device *pdev);
+#ifdef CONFIG_PM
+static int isp1761_pci_suspend (struct pci_dev *dev, __u32 state);
+static int isp1761_pci_resume (struct pci_dev *dev);
+#endif
+static irqreturn_t  isp1761_pci_isr (int irq, void *dev_id, struct pt_regs *regs);
+
+
+/*--------------------------------------------------------------*
+ *              ISP 1761 interrupt locking functions
+ *--------------------------------------------------------------*/
+int             isp1761_hw_lock = 0;
+int             isp1761_hw_isr = 0;
+
+void isp1761_disable_interrupt(int      irq) {
+    /* DUMMY functions
+     * Not used */
+    disable_irq(irq);
+    return;
+}
+void isp1761_enable_interrupt(int       irq) {
+    /* DUMMY functions
+     * Not used */
+    enable_irq(irq);
+    return;
+}
+
+/*--------------------------------------------------------------*
+ *               ISP1761 Interrupt Service Routine
+ *--------------------------------------------------------------*/
+/*Interrupt Service Routine for device controller*/
+irqreturn_t isp1761_pci_dc_isr(int irq, void *data, struct pt_regs *r)
+{
+    struct isp1761_dev *dev;
+    dev = &isp1761_loc_dev[ISP1761_DC];
+
+    hal_entry("%s: Entered\n",__FUNCTION__);
+    /*not ready yet*/
+    if(dev->active == 0)
+    {
+        printk("isp1761_pci_dc_isr: dev->active is NULL \n");
+        return IRQ_NONE;
+    }
+
+    /* Get the source of interrupts for Device Controller
+     * Device Controller interrupts are cleared by the driver
+     * during processing
+     */
+
+    /*unblock the device interrupt*/
+
+    isp1761_reg_write32(dev, DEV_UNLOCK_REGISTER, 0xaa37);
+    dev->int_reg = isp1761_reg_read32(dev, DEV_INTERRUPT_REGISTER, dev->int_reg);
+    hal_int("isp1761_pci_dc_isr:INTERRUPT_REGISTER 0x%x\n",dev->int_reg);
+    /*clear the interrupt source*/
+    isp1761_reg_write32(dev, 0x218, dev->int_reg);
+    dev->int_reg &= 0x03fffdb9;
+    if(dev->int_reg)
+        dev->handler(dev, dev->isr_data,r);
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return IRQ_HANDLED;
+}
+
+/* Interrupt Service Routine of isp1761                                   
+ * Reads the source of interrupt and calls the corresponding driver's ISR.
+ * Before calling the driver's ISR clears the source of interrupt.
+ * The linux-3.13/drivers can get the source of interrupt from the dev->int_reg field
+ */
+irqreturn_t     isp1761_pci_isr(int irq, void *__data, struct pt_regs *r) 
+{
+    __u32               irq_mask = 0;
+    struct isp1761_dev  *dev;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+    /* Process the Host Controller Driver */
+    dev = &isp1761_loc_dev[ISP1761_HC];
+    /* Get the source of interrupts for Host Controller*/
+    dev->int_reg = isp1761_reg_read32(dev, HC_INTERRUPT_REG,dev->int_reg);
+    isp1761_reg_write32(dev,HC_INTERRUPT_REG,dev->int_reg);
+    irq_mask = isp1761_reg_read32(dev, HC_INTENABLE_REG,irq_mask);
+
+    dev->int_reg &= irq_mask; /*shared irq ??*/
+    /*call the Host Isr if any valid(minus otg)interrupt is present*/
+    if(dev->int_reg & ~HC_OTG_INTERRUPT)                
+        dev->handler(dev,dev->isr_data,r);
+#ifdef OTG
+#ifndef MSEC_INT_BASED
+    mdelay(1);
+#endif
+    /*process otg interrupt if there is any*/
+    if(dev->int_reg & HC_OTG_INTERRUPT){
+        u32     otg_int;        
+#ifndef MSEC_INT_BASED
+        mdelay(1);
+#endif
+        otg_int = (dev->int_reg & HC_OTG_INTERRUPT);
+        /* Process OTG controller Driver 
+         * Since OTG is part of  HC interrupt register, 
+         * the interrupt source will be HC interrupt Register
+         * */
+        dev = &isp1761_loc_dev[ISP1761_OTG];
+        /* Read the source of  OTG_INT and clear the
+           interrupt source */
+        dev->int_reg = otg_int; 
+        dev->handler(dev, dev->isr_data,r);
+    }   
+#endif
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return IRQ_HANDLED;
+} /* End of isp1362_pci_isr */
+
+/*--------------------------------------------------------------*
+ *               PCI Driver Interface Functions
+ *--------------------------------------------------------------*/
+
+/* Pci driver interface functions */
+static struct platform_driver isp1761_platform_driver = {
+probe:         isp1761_probe,
+remove:        isp1761_remove,
+driver:        { .name = "isp1761" }
+};
+
+
+/*--------------------------------------------------------------*
+ *               ISP1761 Read write routine 
+ *--------------------------------------------------------------*/
+
+/* Write a 32 bit Register of isp1761 */
+void isp1761_reg_write32(struct isp1761_dev *dev,__u16 reg,__u32 data)
+{ 
+    /* Write the 32bit to the register address given to us*/
+    writel(data,dev->baseaddress+reg);
+    //printk("Wrote to 0x%08x value 0x%08x\n", isp1761_base + reg, data);
+}
+
+
+/* Read a 32 bit Register of isp1761 */
+__u32 isp1761_reg_read32(struct isp1761_dev *dev,__u16 reg,__u32 data)
+{ 
+
+    data = readl(dev->baseaddress + reg);
+    //printk("Read from 0x%08x is 0x%08x\n", isp1761_base + reg, data);
+    return data;
+}
+
+
+/* Read a 16 bit Register of isp1761 */
+__u16 isp1761_reg_read16(struct isp1761_dev *dev,__u16 reg,__u16 data)
+{ 
+    data = readw(dev->baseaddress+reg);
+    return data;
+}
+
+/* Write a 16 bit Register of isp1761 */
+void isp1761_reg_write16(struct isp1761_dev *dev,__u16 reg,__u16 data)
+{ 
+    //printk("Wrote to 0x%08x value 0x%04x\n", isp1761_base + reg, data);
+    writew(data,dev->baseaddress+reg);
+
+}
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_mem_read
+ *
+ * Memory read using PIO method.
+ *
+ *  Input: struct isp1761_driver *drv  -->  Driver structure.
+ *                      __u32 start_add     --> Starting address of memory 
+ *              __u32 end_add     ---> End address 
+ *              
+ *              __u32 * buffer      --> Buffer pointer.
+ *              __u32 length       ---> Length 
+ *              __u16 dir          ---> Direction ( Inc or Dec)
+ *                      
+ *  Output     int Length  ----> Number of bytes read 
+ *
+ *  Called by: system function 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+/* Memory read function PIO */
+
+int     
+isp1761_mem_read(struct isp1761_dev *dev, __u32 start_add, 
+        __u32 end_add, __u32 * buffer, __u32 length, __u16 dir)
+{
+    u8 *temp_base_mem = 0;      
+    u8 *one = (u8 *) buffer;
+    u16 *two = (u16 *) buffer;
+    int a = (int)length;
+    u32 w;
+    temp_base_mem= (dev->baseaddress + start_add);
+    /*initialize the Register 0x33C-used to manage Multiple threads */
+    writel(start_add,dev->baseaddress+0x33c);
+
+last:
+    w = readl(temp_base_mem);
+    if(a == 1){
+        *one=(u8)w;
+        return 0;
+    }
+    if(a == 2){
+        *two=(u16)w;
+        return 0;
+    }   
+
+
+    if(a == 3){
+        *two=(u16)w;
+        two += 1;
+        w >>= 16;
+        *two = (u8)(w);
+        return 0;
+
+    }
+
+
+    while(a>0){
+        *buffer = w;
+        temp_base_mem = temp_base_mem+4;
+        start_add +=4;
+        a -= 4;
+        if(a == 0)
+            break;
+        if(a < 4){
+            buffer += 1;
+            one = (u8 *)buffer;
+            two = (u16 *)buffer;
+            goto last;
+        }
+        buffer += 1;
+        w = readl(temp_base_mem); 
+    }
+    return ((a < 0) || (a == 0))?0:(-1);
+
+}
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_mem_write
+ *
+ * Memory write using PIO method.
+ *
+ *  Input: struct isp1761_driver *drv  -->  Driver structure.
+ *                      __u32 start_add     --> Starting address of memory 
+ *              __u32 end_add     ---> End address 
+ *              
+ *              __u32 * buffer      --> Buffer pointer.
+ *              __u32 length       ---> Length 
+ *              __u16 dir          ---> Direction ( Inc or Dec)
+ *                      
+ *  Output     int Length  ----> Number of bytes read 
+ *
+ *  Called by: system function 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+/* Memory read function IO */
+int     
+isp1761_mem_write(struct isp1761_dev *dev, 
+        __u32 start_add, __u32 end_add, 
+        __u32 * buffer, __u32 length,
+        __u16 dir)
+{
+    u8 *temp_base_mem = 0;
+    int a = length;
+    //u8 *temp = (u8*)buffer;
+    u8 one      =(u8 )(*buffer);
+    u16 two     =(u16 )(*buffer);       
+    temp_base_mem = (dev->baseaddress + start_add);
+
+    if(a == 1){
+        writeb(one,temp_base_mem);
+        return 0;
+    }
+    if(a == 2){
+        writew(two,temp_base_mem);
+        return 0;
+    }
+
+    while(a>0){         
+        writel(*buffer, temp_base_mem);
+        temp_base_mem = temp_base_mem+4;
+        start_add +=4;
+        a -=4;
+        if(a <= 0)
+            break;
+        buffer += 1;
+
+    }
+    return ((a < 0) || (a == 0))?0:(-1);
+
+}
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_check_mem_region
+ *
+ *  Check the memory region for Memory Mapping 
+ *  Check with the system about the availability of the region,
+ *  and returns success, if available.
+ *
+ *  Input: struct isp1761_driver *drv  --> Driver structure.
+ *  
+ *  Output result  
+ *         
+ *
+ *  Called by: system function 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+int isp1761_check_mem_region(struct isp1761_dev *dev)
+{
+    int ret;
+    ret=check_mem_region(dev->start, dev->length);
+    return ret;
+}/* End of isp1761_check_mem_region */
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_request_mem_region
+ isp1761_release_mem_region
+ isp1761_get_mem_params
+
+ *
+ *  If the check returns Success, we can request the region for 
+ *  Memory mapping of our chip memory
+ *
+ *  Input: struct isp1761_driver *drv  --> Driver structure.
+ *  
+ *  Output result  
+ *         
+ *
+ *  Called by: system function 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+struct resource* isp1761_request_mem_region(struct isp1761_dev *dev)
+{
+    dev->mem_res = request_mem_region(dev->start, dev->length, "Isp1761_device");
+    return dev->mem_res;
+}/* End of isp1761_request_mem_region */
+
+/* Release an already acquired memory region.
+   It should be done at the rmmod of the module */
+void isp1761_release_mem_region(struct isp1761_dev* dev)
+{
+    release_mem_region (dev->start, dev->length);
+}
+
+/* Get the start address and length of Mapped Memory */ 
+void isp1761_get_mem_params(struct isp1761_dev *dev,struct isp1761_driver *drv)
+{
+    dev->start  =isp1761_loc_dev[drv->index].start;
+    dev->length =isp1761_loc_dev[drv->index].length;
+}/* End of isp1761_get_mem_params*/
+
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_request_irq
+ *
+ * This function registers the ISR of driver with this driver.
+ * Since there is only one interrupt line, when the first driver
+ * is registerd, will call the system function request_irq. The PLX
+ * bridge needs enabling of interrupt in the interrupt control register to 
+ * pass the local interrupts to the PCI (cpu).
+ * For later registrations will just update the variables. On ISR, this driver
+ * will look for registered handlers and calls the corresponding driver's
+ * ISR "handler" function with "isr_data" as parameter.
+ *
+ *  Input: struct 
+ *              (void (*handler)(struct isp1761_dev *, void *)-->handler.
+ *               isp1761_driver *drv  --> Driver structure.
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+int isp1761_request_irq(void (*handler)(struct isp1761_dev *, void *, struct pt_regs *),
+        struct isp1761_dev *dev, void *isr_data) 
+{
+    int result = 0;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+    hal_int("isp1761_request_irq: dev->index %x\n",dev->index);
+    if(dev->index == ISP1761_DC){
+        result = request_irq(dev->irq, isp1761_pci_dc_isr,
+                SA_SHIRQ,
+                dev->name,
+                isr_data);
+    }else {
+        result= request_irq(dev->irq,isp1761_pci_isr,
+                SA_SHIRQ,
+                dev->name,
+                isr_data);
+    }
+
+    /*Interrupt handler routine*/
+    dev->handler = handler;
+    dev->isr_data = isr_data;
+    hal_int("isp1761_request_irq: dev->handler %s\n",dev->handler);
+    hal_int("isp1761_request_irq: dev->isr_data %x\n",dev->isr_data);
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return result;
+} /* End of isp1761_request_irq */
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_free_irq
+ *
+ * This function de-registers the ISR of driver with this driver.
+ * Since there is only one interrupt line, when the last driver
+ * is de-registerd, will call the system function free_irq. The PLX
+ * bridge needs disabling of interrupt in the interrupt control register to 
+ * block the local interrupts to the PCI (cpu).
+ *
+ *  Input: struct 
+ *              (void (*handler)(struct isp1761_dev *, void *)-->handler.
+ *               isp1761_driver *drv  --> Driver structure.
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+void isp1761_free_irq(struct isp1761_dev *dev, void *isr_data)
+{
+    hal_int(("isp1761_free_irq(dev=%p,isr_data=%p)\n",dev,isr_data));
+    free_irq(dev->irq,isr_data);
+} /* isp1761_free_irq */
+
+
+
+/* Allocate Fragmented kernel Memory */
+void* isp_1761_kmalloc(size_t size,int flags)
+{
+    void* ret;
+    ret =kmalloc(size,flags);
+    return ret;
+}
+
+/* Free the memory allocated by kmalloc */
+void isp_1761_kfree(const void* objp)
+{
+    kfree(objp);
+}
+
+/* Allocate Contiguous kernel Memory */
+void* isp_1761_vmalloc(__u32 size, __u16 flags, pgprot_t prot)
+{
+    void* ret;
+    ret = __vmalloc(size, flags, prot);
+    return ret;
+}
+
+/* Free the memory allocated by vmalloc */
+void isp_1761_vfree(const void* objp)
+{
+    kfree(objp);
+}
+
+
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_register_driver
+ *
+ * This function is used by top driver (OTG, HCD, DCD) to register
+ * their communication functions (probe, remove, suspend, resume) using
+ * the drv data structure.
+ * This function will call the probe function of the driver if the ISP1761
+ * corresponding to the driver is enabled
+ *
+ *  Input: struct isp1761_driver *drv  --> Driver structure.
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+int     isp1761_register_driver(struct isp1761_driver *drv) 
+{
+    struct isp1761_dev  *dev;
+    int result;
+    isp1761_id *id;
+
+    hal_entry("%s: Entered\n",__FUNCTION__);
+    info("isp1761_register_driver(drv=%p) \n",drv);
+
+    if(!drv) return -EINVAL;
+    dev = &isp1761_loc_dev[drv->index];
+    if(drv->index == ISP1761_DC){/*FIX for device*/
+        result = drv->probe(dev,drv->id);
+    }else{              
+        id = drv->id;
+        if(dev->active) result = drv->probe(dev,id);
+        else    result = -ENODEV;
+    }
+
+    if(result >= 0 ) {
+        printk(KERN_INFO __FILE__ ": Registered Driver %s\n",
+                drv->name);
+        dev->driver = drv;
+    }
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return result;
+} /* End of isp1761_register_driver */
+
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_unregister_driver
+ *
+ * This function is used by top driver (OTG, HCD, DCD) to de-register
+ * their communication functions (probe, remove, suspend, resume) using
+ * the drv data structure.
+ * This function will check whether the driver is registered or not and
+ * call the remove function of the driver if registered
+ *
+ *  Input: struct isp1761_driver *drv  --> Driver structure.
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+
+void    isp1761_unregister_driver(struct isp1761_driver *drv)
+{
+    struct isp1761_dev  *dev;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+
+    info("isp1761_unregister_driver(drv=%p)\n",drv);
+    dev = &isp1761_loc_dev[drv->index];
+    if(dev->driver == drv) {
+        /* driver registered is same as the requestig driver */
+        drv->remove(dev);
+        dev->driver = NULL;
+        info(": De-registered Driver %s\n",
+                drv->name);
+        return;
+    }
+    hal_entry("%s: Exit\n",__FUNCTION__);
+} /* End of isp1761_unregister_driver */
+
+
+/*--------------------------------------------------------------*
+ *               ISP1761 PCI driver interface routine.
+ *--------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_module_init
+ *
+ *  This  is the module initialization function. It registers to 
+ *  PCI driver for a PLX PCI bridge device. And also resets the
+ *  internal data structures before registering to PCI driver.
+ *
+ *  Input: void 
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ * 
+ -------------------------------------------------------------------*/
+static int __init isp1761_module_init (void) 
+{
+    int result = 0;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+
+    memset(isp1761_loc_dev,0,sizeof(isp1761_loc_dev));
+
+    result = platform_driver_register(&isp1761_platform_driver);
+
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return result;
+}
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_module_cleanup
+ *
+ * This  is the module cleanup function. It de-registers from 
+ * PCI driver and resets the internal data structures.
+ *
+ *  Input: void 
+ *  Output void
+ *
+ *  Called by: system function module_cleanup 
+ * 
+ * 
+ * 
+ --------------------------------------------------------------*/
+
+static void __exit isp1761_module_cleanup (void) 
+{
+    printk("Hal Module Cleanup\n");
+    platform_driver_unregister(&isp1761_platform_driver);
+    memset(isp1761_loc_dev,0,sizeof(isp1761_loc_dev));
+} 
+
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_probe
+ *
+ * PCI probe function of ISP1761
+ * This function is called from PCI Driver as an initialization function
+ * when it founds the PCI device. This functions initializes the information
+ * for the 3 Controllers with the assigned resources and tests the register
+ * access to these controllers and do a software reset and makes them ready
+ * for the linux-3.13/drivers to play with them.
+ *
+ *  Input: 
+ *              struct pci_dev *dev                     ----> PCI Devie data structure 
+ *      const struct pci_device_id *id  ----> PCI Device ID 
+ *  Output void
+ *
+ *  Called by: system function module_cleanup 
+ * 
+ * 
+ * 
+ --------------------------------------------------------------**/
+
+    static int __devinit
+isp1761_probe (struct platform_device *pdev)
+{
+    __u32       reg_data = 0;
+    struct isp1761_dev  *loc_dev;
+    struct resource *res;
+    void *address = 0;
+    int length = ISP1761_IO_EXTENT;
+    int status = 0;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+
+    res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "isp1761-regs");
+    if (!res)
+	    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res)
+	    return -ENODEV;
+
+    isp1761_base = res->start;
+    hal_init(("isp1761 pci base address = %x\n", isp1761_base));
+
+    /* Get the Host Controller IO and INT resources
+     */
+    loc_dev = &(isp1761_loc_dev[ISP1761_HC]);
+    loc_dev->dev = &pdev->dev;
+    loc_dev->irq = platform_get_irq(pdev, 0);
+    loc_dev->io_base = isp1761_base;
+    loc_dev->start   =  isp1761_base;
+    loc_dev->length  = ISP1761_REGSET_LEN;
+    loc_dev->io_len = ISP1761_REGSET_LEN; /*64K*/
+    loc_dev->index = ISP1761_HC;/*zero*/
+
+    loc_dev->io_len = length; 
+    if(check_mem_region(loc_dev->io_base,length)<0){
+        err("host controller already in use\n");
+        return -EBUSY;
+    }
+    if(!request_mem_region(loc_dev->io_base, length,isp1761_driver_name)){
+        err("host controller already in use\n");
+        return -EBUSY;
+
+    }
+
+    /*map available memory*/
+    address = ioremap_nocache(isp1761_base,length);
+    if(address == NULL){
+        err("memory map problem\n");
+        release_mem_region(loc_dev->io_base,length);
+        return -ENOMEM;
+    } 
+
+    loc_dev->baseaddress = (u8*)address;
+    //loc_dev->dmabase = (u8*)iobase;
+
+    hal_init(("isp1761 HC MEM Base= %p irq = %d\n", 
+                loc_dev->baseaddress,loc_dev->irq));
+#ifdef ISP1761_DEVICE   
+
+    /*initialize device controller framework*/  
+    loc_dev = &(isp1761_loc_dev[ISP1761_DC]);
+    loc_dev->dev = &pdev->dev;
+    loc_dev->irq = platform_get_irq(pdev, 0);
+    loc_dev->io_base = isp1761_base;
+    loc_dev->start   = isp1761_base;
+    loc_dev->length  = ISP1761_REGSET_LEN;
+    loc_dev->io_len = ISP1761_REGSET_LEN;
+    loc_dev->index = ISP1761_DC;
+    loc_dev->baseaddress = address;
+    loc_dev->active = 1;
+    memcpy(loc_dev->name,"isp1761_dev",11);
+    loc_dev->name[12] = '\0';
+
+
+    {
+        u32 chipid = 0;
+        chipid = readl(address + 0x270);
+        info("pid %04x, vid %04x\n", (chipid & 0xffff), (chipid >> 16));
+    }   
+    hal_init(("isp1761 DC MEM Base= %lx irq = %d\n", 
+                loc_dev->io_base,loc_dev->irq));
+    /* Get the OTG Controller IO and INT resources
+     * OTG controller resources are same as Host Controller resources
+     */
+    loc_dev = &(isp1761_loc_dev[ISP1761_OTG]);
+    loc_dev->dev = &pdev->dev;
+    loc_dev->irq = platform_get_irq(pdev, 0);
+    loc_dev->io_base = isp1761_base;
+    loc_dev->start   =  isp1761_base;
+    loc_dev->length  = ISP1761_REGSET_LEN;     
+    loc_dev->io_len = ISP1761_REGSET_LEN;
+    loc_dev->index = ISP1761_OTG; 
+    loc_dev->baseaddress = address; /*having the same address as of host*/
+    loc_dev->active = 1;
+    memcpy(loc_dev->name,"isp1761_otg",11);
+    loc_dev->name[12] = '\0';
+
+    hal_init(("isp1761 OTG MEM Base= %lx irq = %x\n", 
+                loc_dev->io_base,loc_dev->irq));
+
+#endif
+
+    /* Try to check whether we can access Scratch Register of
+     * Host Controller or not.
+     */
+
+#if 1 // CUSTOM STUFF - 16-bit mode
+    isp1761_reg_write32(loc_dev, HC_HW_MODE_REG, 2);
+#endif
+
+    loc_dev = &(isp1761_loc_dev[ISP1761_HC]);
+    isp1761_reg_write16(loc_dev, HC_SCRATCH_REG, 0xFACE);
+    udelay(100);
+    reg_data = isp1761_reg_read16(loc_dev, HC_SCRATCH_REG,reg_data);
+
+    /* Host Controller presence is detected by writing to scratch register
+     * and reading back and checking the contents are same or not
+     */
+    if(reg_data != 0xFACE) {
+        err("%s scratch register mismatch %x",
+                isp1761_driver_name,reg_data);
+        status = -ENODEV;
+        goto clean;
+    }
+
+    memcpy(loc_dev->name, isp1761_driver_name, sizeof(isp1761_driver_name));
+    loc_dev->name[sizeof(isp1761_driver_name)] = 0;
+    loc_dev->active = 1;
+
+    info("controller address %p\n", &pdev->dev);
+
+    s_pdev = pdev;
+    hal_data.irq_usage = 0;
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return 0;
+
+clean:
+    release_mem_region(loc_dev->io_base, loc_dev->io_len);
+    iounmap(loc_dev->baseaddress);
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return status;
+} /* End of isp1761_probe */
+
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_remove
+ *
+ * PCI cleanup function of ISP1761
+ * This function is called from PCI Driver as an removal function
+ * in the absence of PCI device or a de-registration of driver.
+ * This functions checks the registerd linux-3.13/drivers (HCD, DCD, OTG) and calls
+ * the corresponding removal functions. Also initializes the local variables
+ * to zero.
+ *
+ *  Input: 
+ *              struct pci_dev *dev                     ----> PCI Devie data structure 
+ *    
+ *  Output void
+ *
+ *  Called by: system function module_cleanup 
+ * 
+ * 
+ * 
+ --------------------------------------------------------------*/
+static int __devexit
+isp1761_remove (struct platform_device *pdev)
+{
+    struct isp1761_dev  *loc_dev;
+    hal_init(("isp1761_remove(dev=%p)\n",pdev));
+    /*Lets handle the host first*/
+    loc_dev  = &isp1761_loc_dev[ISP1761_HC];
+    /*free the memory occupied by host*/
+    release_mem_region(loc_dev->io_base, loc_dev->io_len);      
+    /*unmap the occupied memory resources*/
+    iounmap(loc_dev->baseaddress);
+    s_pdev = NULL;
+    return 0;
+} /* End of isp1761_remove */
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_pci_suspend
+ *
+ * PCI suspend function of ISP1761
+ * This function is called from PCI Driver.
+ * This functions checks the registerd linux-3.13/drivers (HCD, DCD, OTG) and calls
+ * the corresponding suspend functions if present. 
+ *  Input: 
+ *              struct pci_dev *dev                     ----> PCI Devie data structure 
+ *    
+ *  Output void
+ *
+ *  Called by: system function 
+ * 
+ * 
+ * 
+ --------------------------------------------------------------*/
+
+#ifdef CONFIG_PM
+static int isp1761_pci_suspend (struct pci_dev *dev, __u32 state) 
+{
+    struct isp1761_dev  *loc_dev;
+    int                 index;
+
+    hal_init(("isp1761_pci_suspend(dev=%p, state = %x)\n",dev, state));
+
+
+    loc_dev = (struct isp1761_dev *)pci_get_drvdata(dev);
+
+    /* For each controller check whether driver is registerd
+     * or not. If registerd call the suspend function if it is
+     * present
+     */
+    for(index=ISP1761_1ST_DEV;index<ISP1761_LAST_DEV;(index++,loc_dev++)) {
+        if(loc_dev->driver && loc_dev->driver->suspend) {
+            loc_dev->driver->suspend(loc_dev);
+        }
+    }
+
+    return 0;
+} /* End of isp1761_pci_suspend */
+#endif
+
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_pci_suspend
+ *
+ *  PCI resume function of ISP1761
+ * This function is called from PCI Driver.
+ * This functions checks the registerd linux-3.13/drivers (HCD, DCD, OTG) and calls
+ * the corresponding resume functions if present.  
+ *  Input: 
+ *              struct pci_dev *dev                     ----> PCI Devie data structure 
+ *    
+ *  Output void
+ *
+ *  Called by: system function
+ * 
+ * 
+ --------------------------------------------------------------*/
+#ifdef CONFIG_PM
+static int isp1761_pci_resume (struct pci_dev *dev)
+{
+    struct isp1761_dev  *loc_dev;
+    int                 index;
+    hal_init(("isp1362_pci_resume(dev=%p)\n",dev));
+    loc_dev = (struct isp1761_dev *)pci_get_drvdata(dev);
+
+    /* For each controller check whether driver is registerd
+     * or not. If registerd call the resume function if it is
+     * present
+     */
+    for(index=ISP1761_1ST_DEV;index<ISP1761_LAST_DEV;(index++,loc_dev++)) {
+        if(loc_dev->driver && loc_dev->driver->resume) {
+            loc_dev->driver->resume(loc_dev);
+        }
+    }
+
+    return 0;
+
+} /* End of isp1362_pci_resume */
+#endif
+
+
+
+EXPORT_SYMBOL(isp1761_reg_write16);
+EXPORT_SYMBOL(isp1761_reg_read16);
+EXPORT_SYMBOL(isp1761_reg_read32);
+EXPORT_SYMBOL(isp1761_reg_write32);
+EXPORT_SYMBOL(isp1761_request_irq);
+EXPORT_SYMBOL(isp1761_mem_read);
+EXPORT_SYMBOL(isp1761_mem_write);
+EXPORT_SYMBOL(isp1761_free_irq);
+EXPORT_SYMBOL(isp1761_register_driver);
+EXPORT_SYMBOL(isp1761_unregister_driver);
+
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE ("GPL");
+
+module_init (isp1761_module_init);
+module_exit (isp1761_module_cleanup);
+
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/hal/hal_x86.c linux-3.13/drivers/armadeus/isp1761/hal/hal_x86.c
--- linux-3.13/drivers/armadeus/isp1761/hal/hal_x86.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/hal/hal_x86.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,1121 @@
+/************************************************************
+ * NXP ISP176x Hardware Abstraction Layer code file
+ *
+ * (c) 2006 NXP B.V., All rights reserved. <usb.linux@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * File Name: hal_x86.c
+ *
+ * Refering linux kernel version 2.6.9
+ *
+ * History:
+ *
+ * Date                Author                  Comments
+ * ---------------------------------------------------------------------
+ * Nov 29 2005        Prabhakar Kalasani      Initial Creation     
+ *
+ **********************************************************************
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>  
+#include <linux/usb.h>
+#include <linux/pci.h>
+#include <linux/poll.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <asm/dma.h>
+
+/*--------------------------------------------------------------*
+ *               linux system include files
+ *--------------------------------------------------------------*/
+#include "hal_x86.h"
+#include "../hal/hal_intf.h"
+#include "../hal/isp1761.h"
+
+/*--------------------------------------------------------------*
+ *               Local variable Definitions
+ *--------------------------------------------------------------*/
+struct isp1761_dev              isp1761_loc_dev[ISP1761_LAST_DEV];
+static  struct isp1761_hal      hal_data;
+static  __u32             pci_io_base  = 0;
+void     *iobase = 0;
+int      iolength = 0;
+static   __u32           pci_mem_phy0 =0;
+static    __u32           pci_mem_len = 0xffff;
+static  int               isp1761_pci_latency;
+
+/*--------------------------------------------------------------*
+ *               Local # Definitions
+ *--------------------------------------------------------------*/
+#define         PCI_ACCESS_RETRY_COUNT  20
+#define         PLX_INT_CSR_REG         0x68
+#define         PLX_LBRD0_REG           0x18
+#define         PLX_LBRD0_WAIT_STATE_MASK       0x000000C3
+#define         PLX_LBRD0_WAIT_STATES           0x00000003
+#define         isp1761_driver_name     "1761-pci"
+
+/*--------------------------------------------------------------*
+ *               Local Function 
+ *--------------------------------------------------------------*/
+
+static void __devexit isp1761_pci_remove (struct pci_dev *dev);
+static int __devinit isp1761_pci_probe (struct pci_dev *dev, 
+        const struct pci_device_id *id);
+static int isp1761_pci_suspend (struct pci_dev *dev, __u32 state);
+static int isp1761_pci_resume (struct pci_dev *dev);
+static irqreturn_t  isp1761_pci_isr (int irq, void *dev_id, struct pt_regs *regs);
+
+
+/*--------------------------------------------------------------*
+ *              ISP 1761 interrupt locking functions
+ *--------------------------------------------------------------*/
+int             isp1761_hw_lock = 0;
+int             isp1761_hw_isr = 0;
+
+void isp1761_disable_interrupt(void) {
+    
+    struct isp1761_dev  *dev;
+    u32 hw_mode_buff;
+    
+    /* Process the Host Controller Driver */
+    dev = &isp1761_loc_dev[ISP1761_HC];
+    
+    hw_mode_buff = isp1761_reg_read32(dev, HC_HW_MODE_REG, hw_mode_buff);
+
+    /* Disable ISP176x global interrupt */
+    hw_mode_buff &= ~(0x1);
+        
+    isp1761_reg_write32(dev, HC_HW_MODE_REG, hw_mode_buff);
+}
+
+void isp1761_enable_interrupt(void) {
+    struct isp1761_dev  *dev;
+    u32 hw_mode_buff;
+    
+    /* Process the Host Controller Driver */
+    dev = &isp1761_loc_dev[ISP1761_HC];
+    
+    hw_mode_buff = isp1761_reg_read32(dev, HC_HW_MODE_REG, hw_mode_buff);
+
+    /* Enable ISP176x global interrupt */
+    hw_mode_buff |= 0x1;
+    
+    isp1761_reg_write32(dev, HC_HW_MODE_REG, hw_mode_buff);
+}
+
+/*--------------------------------------------------------------*
+ *               ISP1761 Interrupt Service Routine
+ *--------------------------------------------------------------*/
+/*Interrupt Service Routine for device controller*/
+irqreturn_t isp1761_pci_dc_isr(int irq, void *data, struct pt_regs *r)
+{
+    struct isp1761_dev *dev;
+    dev = &isp1761_loc_dev[ISP1761_DC];
+
+    hal_entry("%s: Entered\n",__FUNCTION__);
+    /*not ready yet*/
+    if(dev->active == 0)
+    {
+        printk("isp1761_pci_dc_isr: dev->active is NULL \n");
+        return IRQ_NONE;
+    }
+
+    /* Get the source of interrupts for Device Controller
+     * Device Controller interrupts are cleared by the driver
+     * during processing
+     */
+
+    /*unblock the device interrupt*/
+
+    isp1761_reg_write32(dev, DEV_UNLOCK_REGISTER, 0xaa37);
+    dev->int_reg = isp1761_reg_read32(dev, DEV_INTERRUPT_REGISTER, dev->int_reg);
+    hal_int("isp1761_pci_dc_isr:INTERRUPT_REGISTER 0x%x\n",dev->int_reg);
+    /*clear the interrupt source*/
+    isp1761_reg_write32(dev, 0x218, dev->int_reg);
+    dev->int_reg &= 0x03fffdb9;
+    if(dev->int_reg)
+        dev->handler(dev, dev->isr_data,r);
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return IRQ_HANDLED;
+}
+
+/* Interrupt Service Routine of isp1761                                   
+ * Reads the source of interrupt and calls the corresponding driver's ISR.
+ * Before calling the driver's ISR clears the source of interrupt.
+ * The linux-3.13/drivers can get the source of interrupt from the dev->int_reg field
+ */
+irqreturn_t     isp1761_pci_isr(int irq, void *__data, struct pt_regs *r) 
+{
+    __u32               irq_mask = 0;
+    struct isp1761_dev  *dev;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+    isp1761_disable_interrupt();
+    /* Process the Host Controller Driver */
+    dev = &isp1761_loc_dev[ISP1761_HC];
+    /* Get the source of interrupts for Host Controller*/
+    dev->int_reg = isp1761_reg_read32(dev, HC_INTERRUPT_REG,dev->int_reg);
+    isp1761_reg_write32(dev,HC_INTERRUPT_REG,dev->int_reg);
+    irq_mask = isp1761_reg_read32(dev, HC_INTENABLE_REG,irq_mask);
+
+    dev->int_reg &= irq_mask; /*shared irq ??*/
+    /*call the Host Isr if any valid(minus otg)interrupt is present*/
+    if(dev->int_reg & ~HC_OTG_INTERRUPT)                
+        dev->handler(dev,dev->isr_data,r);
+#ifdef OTG
+#ifndef MSEC_INT_BASED
+    mdelay(1);
+#endif
+    /*process otg interrupt if there is any*/
+    if(dev->int_reg & HC_OTG_INTERRUPT){
+        u32     otg_int;        
+#ifndef MSEC_INT_BASED
+        mdelay(1);
+#endif
+        otg_int = (dev->int_reg & HC_OTG_INTERRUPT);
+        /* Process OTG controller Driver 
+         * Since OTG is part of  HC interrupt register, 
+         * the interrupt source will be HC interrupt Register
+         * */
+        dev = &isp1761_loc_dev[ISP1761_OTG];
+        /* Read the source of  OTG_INT and clear the
+           interrupt source */
+        dev->int_reg = otg_int; 
+        dev->handler(dev, dev->isr_data,r);
+    }   
+#endif
+    dev->handler(dev, dev->isr_data,r);
+    isp1761_enable_interrupt();
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return IRQ_HANDLED;
+} /* End of isp1362_pci_isr */
+
+/*--------------------------------------------------------------*
+ *               PCI Driver Interface Functions
+ *--------------------------------------------------------------*/
+
+static const struct pci_device_id __devinitdata isp1761_pci_ids [] = {
+    {
+        /* handle PCI BRIDE  manufactured by PLX */
+class:          ((PCI_CLASS_BRIDGE_OTHER << 8) | (0x06 << 16)),
+class_mask:     ~0,
+                /* no matter who makes it */
+vendor:         /*0x10B5,*/PCI_ANY_ID,
+device:         /*0x5406,*/PCI_ANY_ID,
+subvendor:      PCI_ANY_ID,
+subdevice:      PCI_ANY_ID,
+    }, 
+    { /* end: all zeroes */ }
+};
+
+MODULE_DEVICE_TABLE (pci, isp1761_pci_ids);
+
+/* Pci driver interface functions */
+static struct pci_driver isp1761_pci_driver = {
+name:           "isp1761-hal",
+id_table:       &isp1761_pci_ids[0],
+probe:         isp1761_pci_probe,
+remove:        isp1761_pci_remove,
+};
+
+
+/*--------------------------------------------------------------*
+ *               ISP1761 Read write routine 
+ *--------------------------------------------------------------*/
+
+/* Write a 32 bit Register of isp1761 */
+void isp1761_reg_write32(struct isp1761_dev *dev,__u16 reg,__u32 data)
+{ 
+    /* Write the 32bit to the register address given to us*/
+    writel(data,dev->baseaddress+reg);
+}
+
+
+/* Read a 32 bit Register of isp1761 */
+__u32 isp1761_reg_read32(struct isp1761_dev *dev,__u16 reg,__u32 data)
+{ 
+
+    data = readl(dev->baseaddress + reg);
+    return data;
+}
+
+
+/* Read a 16 bit Register of isp1761 */
+__u16 isp1761_reg_read16(struct isp1761_dev *dev,__u16 reg,__u16 data)
+{ 
+    data = readw(dev->baseaddress+reg);
+    return data;
+}
+
+/* Write a 16 bit Register of isp1761 */
+void isp1761_reg_write16(struct isp1761_dev *dev,__u16 reg,__u16 data)
+{ 
+    writew(data,dev->baseaddress+reg);
+
+}
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_mem_read
+ *
+ * Memory read using PIO method.
+ *
+ *  Input: struct isp1761_driver *drv  -->  Driver structure.
+ *                      __u32 start_add     --> Starting address of memory 
+ *              __u32 end_add     ---> End address 
+ *              
+ *              __u32 * buffer      --> Buffer pointer.
+ *              __u32 length       ---> Length 
+ *              __u16 dir          ---> Direction ( Inc or Dec)
+ *                      
+ *  Output     int Length  ----> Number of bytes read 
+ *
+ *  Called by: system function 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+/* Memory read function PIO */
+
+int     
+isp1761_mem_read(struct isp1761_dev *dev, __u32 start_add, 
+        __u32 end_add, __u32 * buffer, __u32 length, __u16 dir)
+{
+    u8 *temp_base_mem = 0;      
+    u8 *one = (u8 *) buffer;
+    u16 *two = (u16 *) buffer;
+    int a = (int)length;
+    u32 w;
+    temp_base_mem= (dev->baseaddress + start_add);
+    /*initialize the Register 0x33C-used to manage Multiple threads */
+    writel(start_add,dev->baseaddress+0x33c);
+	if(buffer == NULL)
+	{
+		printk("@@@@ In isp1761_mem_read The buffer is pointing to null\n");
+		return 0;
+	}
+last:
+    w = readl(temp_base_mem);
+    if(a == 1){
+        *one=(u8)w;
+        return 0;
+    }
+    if(a == 2){
+        *two=(u16)w;
+        return 0;
+    }   
+    if(a == 3){
+        *two=(u16)w;
+        two += 1;
+        w >>= 16;
+        *two = (u8)(w);
+        return 0;
+
+    }
+
+    while(a>0){
+        *buffer = w;
+        temp_base_mem = temp_base_mem+4;
+        start_add +=4;
+        a -= 4;
+        if(a == 0)
+            break;
+        if(a < 4){
+            buffer += 1;
+            one = (u8 *)buffer;
+            two = (u16 *)buffer;
+            goto last;
+        }
+        buffer += 1;
+        w = readl(temp_base_mem); 
+    }
+    return ((a < 0) || (a == 0))?0:(-1);
+
+}
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_mem_write
+ *
+ * Memory write using PIO method.
+ *
+ *  Input: struct isp1761_driver *drv  -->  Driver structure.
+ *                      __u32 start_add     --> Starting address of memory 
+ *              __u32 end_add     ---> End address 
+ *              
+ *              __u32 * buffer      --> Buffer pointer.
+ *              __u32 length       ---> Length 
+ *              __u16 dir          ---> Direction ( Inc or Dec)
+ *                      
+ *  Output     int Length  ----> Number of bytes read 
+ *
+ *  Called by: system function 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+/* Memory read function IO */
+int     
+isp1761_mem_write(struct isp1761_dev *dev, 
+        __u32 start_add, __u32 end_add, 
+        __u32 * buffer, __u32 length,
+        __u16 dir)
+{
+    u8 *temp_base_mem = 0;
+    int a = length;
+    u8 *temp = (u8*)buffer;
+    u8 one      =(u8 )(*buffer);
+    u16 two     =(u16 )(*buffer);       
+    temp_base_mem = (dev->baseaddress + start_add);
+
+    if(a == 1){
+        writeb(one,temp_base_mem);
+        return 0;
+    }
+    if(a == 2){
+        writew(two,temp_base_mem);
+        return 0;
+    }
+
+    while(a>0){         
+        writel(*buffer, temp_base_mem);
+        temp_base_mem = temp_base_mem+4;
+        start_add +=4;
+        a -=4;
+        if(a <= 0)
+            break;
+        buffer += 1;
+
+    }
+    return ((a < 0) || (a == 0))?0:(-1);
+
+}
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_check_mem_region
+ *
+ *  Check the memory region for Memory Mapping 
+ *  Check with the system about the availability of the region,
+ *  and returns success, if available.
+ *
+ *  Input: struct isp1761_driver *drv  --> Driver structure.
+ *  
+ *  Output result  
+ *         
+ *
+ *  Called by: system function 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+int isp1761_check_mem_region(struct isp1761_dev *dev)
+{
+    int ret;
+    ret=check_mem_region(dev->start, dev->length);
+    return ret;
+}/* End of isp1761_check_mem_region */
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_request_mem_region
+ isp1761_release_mem_region
+ isp1761_get_mem_params
+
+ *
+ *  If the check returns Success, we can request the region for 
+ *  Memory mapping of our chip memory
+ *
+ *  Input: struct isp1761_driver *drv  --> Driver structure.
+ *  
+ *  Output result  
+ *         
+ *
+ *  Called by: system function 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+struct resource* isp1761_request_mem_region(struct isp1761_dev *dev)
+{
+    dev->mem_res = request_mem_region(dev->start, dev->length, "Isp1761_device");
+    return dev->mem_res;
+}/* End of isp1761_request_mem_region */
+
+/* Release an already acquired memory region.
+   It should be done at the rmmod of the module */
+void isp1761_release_mem_region(struct isp1761_dev* dev)
+{
+    release_mem_region (dev->start, dev->length);
+}
+
+/* Get the start address and length of Mapped Memory */ 
+void isp1761_get_mem_params(struct isp1761_dev *dev,struct isp1761_driver *drv)
+{
+    dev->start  =isp1761_loc_dev[drv->index].start;
+    dev->length =isp1761_loc_dev[drv->index].length;
+}/* End of isp1761_get_mem_params*/
+
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_request_irq
+ *
+ * This function registers the ISR of driver with this driver.
+ * Since there is only one interrupt line, when the first driver
+ * is registerd, will call the system function request_irq. The PLX
+ * bridge needs enabling of interrupt in the interrupt control register to 
+ * pass the local interrupts to the PCI (cpu).
+ * For later registrations will just update the variables. On ISR, this driver
+ * will look for registered handlers and calls the corresponding driver's
+ * ISR "handler" function with "isr_data" as parameter.
+ *
+ *  Input: struct 
+ *              (void (*handler)(struct isp1761_dev *, void *)-->handler.
+ *               isp1761_driver *drv  --> Driver structure.
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+int isp1761_request_irq(void (*handler)(struct isp1761_dev *, void *),
+        struct isp1761_dev *dev, void *isr_data) 
+{
+    int result = 0;
+    u32 intcsr = 0;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+    hal_int("isp1761_request_irq: dev->index %x\n",dev->index);
+    if(dev->index == ISP1761_DC){
+        result = request_irq(dev->irq, isp1761_pci_dc_isr,
+                SA_SHIRQ,
+                dev->name,
+                isr_data);
+    }else {
+        result= request_irq(dev->irq,isp1761_pci_isr,
+                SA_SHIRQ,
+                dev->name,
+                isr_data);
+    }
+
+    /*CONFIGURE PCI/PLX interrupt*/
+    intcsr = readl(iobase+0x68);
+    intcsr |= 0x900;
+    writel(intcsr,iobase+0x68);
+
+    /*Interrupt handler routine*/
+    dev->handler = handler;
+    dev->isr_data = isr_data;
+    hal_int("isp1761_request_irq: dev->handler %s\n",dev->handler);
+    hal_int("isp1761_request_irq: dev->isr_data %x\n",dev->isr_data);
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return result;
+} /* End of isp1761_request_irq */
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_free_irq
+ *
+ * This function de-registers the ISR of driver with this driver.
+ * Since there is only one interrupt line, when the last driver
+ * is de-registerd, will call the system function free_irq. The PLX
+ * bridge needs disabling of interrupt in the interrupt control register to 
+ * block the local interrupts to the PCI (cpu).
+ *
+ *  Input: struct 
+ *              (void (*handler)(struct isp1761_dev *, void *)-->handler.
+ *               isp1761_driver *drv  --> Driver structure.
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+void isp1761_free_irq(struct isp1761_dev *dev, void *isr_data)
+{
+    __u32       intcsr;
+    hal_int(("isp1761_free_irq(dev=%p,isr_data=%p)\n",dev,isr_data));
+    free_irq(dev->irq,isr_data);
+    /*disable the plx/pci interrupt*/
+    intcsr = readl(iobase+0x68);
+    intcsr &= ~0x900;
+    writel(intcsr,iobase+0x68);
+
+} /* isp1761_free_irq */
+
+
+
+/* Allocate Fragmented kernel Memory */
+void* isp_1761_kmalloc(size_t size,int flags)
+{
+    void* ret;
+    ret =kmalloc(size,flags);
+    return ret;
+}
+
+/* Free the memory allocated by kmalloc */
+void isp_1761_kfree(const void* objp)
+{
+    kfree(objp);
+}
+
+/* Allocate Contiguous kernel Memory */
+void* isp_1761_vmalloc(__u32 size, __u16 flags, pgprot_t prot)
+{
+    void* ret;
+    ret =__vmalloc(size, flags, prot);
+    return ret;
+}
+
+/* Free the memory allocated by vmalloc */
+void isp_1761_vfree(const void* objp)
+{
+    kfree(objp);
+}
+
+
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_register_driver
+ *
+ * This function is used by top driver (OTG, HCD, DCD) to register
+ * their communication functions (probe, remove, suspend, resume) using
+ * the drv data structure.
+ * This function will call the probe function of the driver if the ISP1761
+ * corresponding to the driver is enabled
+ *
+ *  Input: struct isp1761_driver *drv  --> Driver structure.
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+int     isp1761_register_driver(struct isp1761_driver *drv) 
+{
+    struct isp1761_dev  *dev;
+    int result;
+    isp1761_id *id;
+
+    hal_entry("%s: Entered\n",__FUNCTION__);
+    info("isp1761_register_driver(drv=%p) \n",drv);
+
+    if(!drv) return -EINVAL;
+    dev = &isp1761_loc_dev[drv->index];
+    if(drv->index == ISP1761_DC){/*FIX for device*/
+        result = drv->probe(dev,drv->id);
+    }else{              
+        id = drv->id;
+        if(dev->active) result = drv->probe(dev,id);
+        else    result = -ENODEV;
+    }
+
+    if(result >= 0 ) {
+        printk(KERN_INFO __FILE__ ": Registered Driver %s\n",
+                drv->name);
+        dev->driver = drv;
+    }
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return result;
+} /* End of isp1761_register_driver */
+
+
+/*--------------------------------------------------------------*
+ *  
+ * Module dtatils: isp1761_unregister_driver
+ *
+ * This function is used by top driver (OTG, HCD, DCD) to de-register
+ * their communication functions (probe, remove, suspend, resume) using
+ * the drv data structure.
+ * This function will check whether the driver is registered or not and
+ * call the remove function of the driver if registered
+ *
+ *  Input: struct isp1761_driver *drv  --> Driver structure.
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ *--------------------------------------------------------------*/
+
+
+void    isp1761_unregister_driver(struct isp1761_driver *drv)
+{
+    struct isp1761_dev  *dev;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+
+    info("isp1761_unregister_driver(drv=%p)\n",drv);
+    dev = &isp1761_loc_dev[drv->index];
+    if(dev->driver == drv) {
+        /* driver registered is same as the requestig driver */
+        drv->remove(dev);
+        dev->driver = NULL;
+        info(": De-registered Driver %s\n",
+                drv->name);
+        return;
+    }
+    hal_entry("%s: Exit\n",__FUNCTION__);
+} /* End of isp1761_unregister_driver */
+
+
+/*--------------------------------------------------------------*
+ *               ISP1761 PCI driver interface routine.
+ *--------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_pci_module_init
+ *
+ *  This  is the module initialization function. It registers to 
+ *  PCI driver for a PLX PCI bridge device. And also resets the
+ *  internal data structures before registering to PCI driver.
+ *
+ *  Input: void 
+ *  Output result 
+ *         0= complete 
+ *         1= error.
+ *
+ *  Called by: system function module_init 
+ * 
+ * 
+ * 
+ -------------------------------------------------------------------*/
+static int __init isp1761_pci_module_init (void) 
+{
+    int result = 0;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+    memset(isp1761_loc_dev,0,sizeof(isp1761_loc_dev));
+
+    if((result = pci_module_init(&isp1761_pci_driver)) < 0) {
+        printk("PCI Iinitialization Fail(error = %d)\n",result);
+        return result;
+    }
+    else
+        info(": %s PCI Initialization Success \n",isp1761_driver_name);
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return result;
+}
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_pci_module_cleanup
+ *
+ * This  is the module cleanup function. It de-registers from 
+ * PCI driver and resets the internal data structures.
+ *
+ *  Input: void 
+ *  Output void
+ *
+ *  Called by: system function module_cleanup 
+ * 
+ * 
+ * 
+ --------------------------------------------------------------*/
+
+static void __exit isp1761_pci_module_cleanup (void) 
+{
+    printk("Hal Module Cleanup\n");
+    pci_unregister_driver (&isp1761_pci_driver);
+    memset(isp1761_loc_dev,0,sizeof(isp1761_loc_dev));
+} 
+
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_pci_probe
+ *
+ * PCI probe function of ISP1761
+ * This function is called from PCI Driver as an initialization function
+ * when it founds the PCI device. This functions initializes the information
+ * for the 3 Controllers with the assigned resources and tests the register
+ * access to these controllers and do a software reset and makes them ready
+ * for the linux-3.13/drivers to play with them.
+ *
+ *  Input: 
+ *              struct pci_dev *dev                     ----> PCI Devie data structure 
+ *      const struct pci_device_id *id  ----> PCI Device ID 
+ *  Output void
+ *
+ *  Called by: system function module_cleanup 
+ * 
+ * 
+ * 
+ --------------------------------------------------------------**/
+
+    static int __devinit
+isp1761_pci_probe (struct pci_dev *dev, const struct pci_device_id *id)
+{
+    u8 latency, limit;
+    __u32       reg_data = 0;
+    int retry_count;
+    struct isp1761_dev  *loc_dev;
+    void *address = 0;
+    int length = 0;
+    int status = 1;
+    hal_entry("%s: Entered\n",__FUNCTION__);
+
+    hal_init(("isp1761_pci_probe(dev=%p)\n",dev));
+    if (pci_enable_device(dev) < 0){
+        err("failed in enabing the device\n");
+        return -ENODEV;
+    }
+    if (!dev->irq) {
+        err("found ISP1761 device with no IRQ assigned."); 
+        err("check BIOS settings!");
+        return -ENODEV;
+    }
+    /* Grab the PLX PCI mem maped port start address we need  */
+    pci_io_base = pci_resource_start(dev, 0);
+    hal_init(("isp1761 pci IO Base= %x\n", pci_io_base));;
+
+    iolength = pci_resource_len(dev, 0);
+    hal_init(("isp1761 pci io length %d\n", iolength));
+    if(!request_mem_region(pci_io_base,iolength,"ISP1761 IO MEM")){
+        err("host controller already in use1\n");
+        return -EBUSY;
+    }   
+    iobase = ioremap_nocache(pci_io_base, iolength);
+    if(!iobase){
+        err("can not map io memory to system memory\n");
+        release_mem_region(pci_io_base,iolength);
+        return -ENOMEM;
+    }
+    /* Grab the PLX PCI shared memory of the ISP 1761 we need  */
+    pci_mem_phy0 = pci_resource_start (dev, 3);         
+    hal_init(("isp1761 pci base address = %x\n", pci_mem_phy0));
+
+    /* Get the Host Controller IO and INT resources
+     */
+    loc_dev = &(isp1761_loc_dev[ISP1761_HC]);
+    loc_dev->irq = dev->irq;
+    loc_dev->io_base = pci_mem_phy0;
+    loc_dev->start   =  pci_mem_phy0;
+    loc_dev->length  = pci_mem_len;
+    loc_dev->io_len = pci_mem_len; /*64K*/
+    loc_dev->index = ISP1761_HC;/*zero*/
+
+    length = pci_resource_len(dev,3);
+    if(length < pci_mem_len){
+        err("memory length for this resource is less than required\n");
+        release_mem_region(pci_io_base, iolength);
+        iounmap(iobase);
+        return  -ENOMEM;                                
+
+    }
+    loc_dev->io_len = length; 
+    if(check_mem_region(loc_dev->io_base,length)<0){
+        err("host controller already in use\n");
+        release_mem_region(pci_io_base, iolength);
+        iounmap(iobase);
+        return -EBUSY;
+    }
+    if(!request_mem_region(loc_dev->io_base, length,isp1761_driver_name)){
+        err("host controller already in use\n");
+        release_mem_region(pci_io_base, iolength);
+        iounmap(iobase);
+        return -EBUSY;
+
+    }
+
+    /*map available memory*/
+    address = ioremap_nocache(pci_mem_phy0,length);
+    if(address == NULL){
+        err("memory map problem\n");
+        release_mem_region(pci_io_base, iolength);
+        iounmap(iobase);
+        release_mem_region(loc_dev->io_base,length);
+        return -ENOMEM;
+    } 
+
+    loc_dev->baseaddress = (u8*)address;
+    loc_dev->dmabase = (u8*)iobase;
+
+    hal_init(("isp1761 HC MEM Base= %p irq = %d\n", 
+                loc_dev->baseaddress,loc_dev->irq));
+#ifdef ISP1761_DEVICE   
+
+    /*initialize device controller framework*/  
+    loc_dev = &(isp1761_loc_dev[ISP1761_DC]);
+    loc_dev->irq = dev->irq;
+    loc_dev->io_base = pci_mem_phy0;
+    loc_dev->start   = pci_mem_phy0;
+    loc_dev->length  = pci_mem_len;
+    loc_dev->io_len = pci_mem_len;
+    loc_dev->index = ISP1761_DC;
+    loc_dev->baseaddress = address;
+    loc_dev->active = 1;
+    memcpy(loc_dev->name,"isp1761_dev",11);
+    loc_dev->name[12] = '\0';
+
+
+    {
+        u32 chipid = 0;
+        chipid = readl(address + 0x270);
+        info("pid %04x, vid %04x\n", (chipid & 0xffff), (chipid >> 16));
+    }   
+    hal_init(("isp1761 DC MEM Base= %lx irq = %d\n", 
+                loc_dev->io_base,loc_dev->irq));
+    /* Get the OTG Controller IO and INT resources
+     * OTG controller resources are same as Host Controller resources
+     */
+    loc_dev = &(isp1761_loc_dev[ISP1761_OTG]);
+    loc_dev->irq = dev->irq; /*same irq also*/
+    loc_dev->io_base = pci_mem_phy0;
+    loc_dev->start   =  pci_mem_phy0;
+    loc_dev->length  = pci_mem_len;     
+    loc_dev->io_len = pci_mem_len;
+    loc_dev->index = ISP1761_OTG; 
+    loc_dev->baseaddress = address; /*having the same address as of host*/
+    loc_dev->active = 1;
+    memcpy(loc_dev->name,"isp1761_otg",11);
+    loc_dev->name[12] = '\0';
+
+    hal_init(("isp1761 OTG MEM Base= %lx irq = %x\n", 
+                loc_dev->io_base,loc_dev->irq));
+
+#endif
+    /* bad pci latencies can contribute to overruns */ 
+    pci_read_config_byte (dev, PCI_LATENCY_TIMER, &latency);
+    if (latency) {
+        pci_read_config_byte (dev, PCI_MAX_LAT, &limit);
+        if (limit && limit < latency) {
+            dbg ("PCI latency reduced to max %d", limit);
+            pci_write_config_byte (dev, PCI_LATENCY_TIMER, limit);
+            isp1761_pci_latency = limit;
+        } else {
+            /* it might already have been reduced */
+            isp1761_pci_latency = latency;
+        }
+    }
+
+    /* Try to check whether we can access Scratch Register of
+     * Host Controller or not. The initial PCI access is retried until 
+     * local init for the PCI bridge is completed 
+     */
+
+    loc_dev = &(isp1761_loc_dev[ISP1761_HC]);
+    retry_count = PCI_ACCESS_RETRY_COUNT;
+    while((reg_data != 0xFACE) && retry_count) {
+        /*by default host is in 16bit mode, so
+         * io operations at this stage must be 16 bit
+         * */
+        isp1761_reg_write16(loc_dev, HC_SCRATCH_REG, 0xFACE);
+        udelay(100);
+        reg_data = isp1761_reg_read16(loc_dev, HC_SCRATCH_REG,reg_data);
+        retry_count--;
+    }
+
+    /* Host Controller presence is detected by writing to scratch register
+     * and reading back and checking the contents are same or not
+     */
+    if(reg_data != 0xFACE) {
+        err("%s scratch register mismatch %x",
+                isp1761_driver_name,reg_data);
+        status = -ENODEV;
+        goto clean;
+    }
+
+    memcpy(loc_dev->name, isp1761_driver_name, sizeof(isp1761_driver_name));
+    loc_dev->name[sizeof(isp1761_driver_name)] = 0;
+    loc_dev->active = 1;
+
+    info("controller address %p\n", &dev->dev);
+    /*keep a copy of pcidevice*/
+    loc_dev->pcidev = dev;
+
+
+    pci_set_master(dev);
+    hal_data.irq_usage = 0;
+    pci_set_drvdata (dev, loc_dev);
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return 1;
+
+clean:
+    release_mem_region(pci_io_base, iolength);
+    iounmap(iobase);
+    release_mem_region(loc_dev->io_base, loc_dev->io_len);
+    iounmap(loc_dev->baseaddress);
+    hal_entry("%s: Exit\n",__FUNCTION__);
+    return status;
+} /* End of isp1761_pci_probe */
+
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_pci_remove
+ *
+ * PCI cleanup function of ISP1761
+ * This function is called from PCI Driver as an removal function
+ * in the absence of PCI device or a de-registration of driver.
+ * This functions checks the registerd linux-3.13/drivers (HCD, DCD, OTG) and calls
+ * the corresponding removal functions. Also initializes the local variables
+ * to zero.
+ *
+ *  Input: 
+ *              struct pci_dev *dev                     ----> PCI Devie data structure 
+ *    
+ *  Output void
+ *
+ *  Called by: system function module_cleanup 
+ * 
+ * 
+ * 
+ --------------------------------------------------------------*/
+    static void __devexit
+isp1761_pci_remove (struct pci_dev *dev)
+{
+    struct isp1761_dev  *loc_dev;
+    hal_init(("isp1761_pci_remove(dev=%p)\n",dev));
+    /*Lets handle the host first*/
+    loc_dev  = &isp1761_loc_dev[ISP1761_HC];
+    /*free the memory occupied by host*/
+    release_mem_region(loc_dev->io_base, loc_dev->io_len);      
+    release_mem_region(pci_io_base, iolength);
+    /*unmap the occupied memory resources*/
+    iounmap(loc_dev->baseaddress);
+    /* unmap the occupied io resources*/
+    iounmap(iobase); 
+    return;
+} /* End of isp1761_pci_remove */
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_pci_suspend
+ *
+ * PCI suspend function of ISP1761
+ * This function is called from PCI Driver.
+ * This functions checks the registerd linux-3.13/drivers (HCD, DCD, OTG) and calls
+ * the corresponding suspend functions if present. 
+ *  Input: 
+ *              struct pci_dev *dev                     ----> PCI Devie data structure 
+ *    
+ *  Output void
+ *
+ *  Called by: system function 
+ * 
+ * 
+ * 
+ --------------------------------------------------------------*/
+
+static int isp1761_pci_suspend (struct pci_dev *dev, __u32 state) 
+{
+    struct isp1761_dev  *loc_dev;
+    int                 index;
+
+    hal_init(("isp1761_pci_suspend(dev=%p, state = %x)\n",dev, state));
+
+
+    loc_dev = (struct isp1761_dev *)pci_get_drvdata(dev);
+
+    /* For each controller check whether driver is registerd
+     * or not. If registerd call the suspend function if it is
+     * present
+     */
+    for(index=ISP1761_1ST_DEV;index<ISP1761_LAST_DEV;(index++,loc_dev++)) {
+        if(loc_dev->driver && loc_dev->driver->suspend) {
+            loc_dev->driver->suspend(loc_dev);
+        }
+    }
+
+    return 0;
+} /* End of isp1761_pci_suspend */
+
+
+/*--------------------------------------------------------------*
+ *
+ *  Module dtatils: isp1761_pci_suspend
+ *
+ *  PCI resume function of ISP1761
+ * This function is called from PCI Driver.
+ * This functions checks the registerd linux-3.13/drivers (HCD, DCD, OTG) and calls
+ * the corresponding resume functions if present.  
+ *  Input: 
+ *              struct pci_dev *dev                     ----> PCI Devie data structure 
+ *    
+ *  Output void
+ *
+ *  Called by: system function
+ * 
+ * 
+ --------------------------------------------------------------*/
+static int isp1761_pci_resume (struct pci_dev *dev)
+{
+    struct isp1761_dev  *loc_dev;
+    int                 index;
+    hal_init(("isp1362_pci_resume(dev=%p)\n",dev));
+    loc_dev = (struct isp1761_dev *)pci_get_drvdata(dev);
+
+    /* For each controller check whether driver is registerd
+     * or not. If registerd call the resume function if it is
+     * present
+     */
+    for(index=ISP1761_1ST_DEV;index<ISP1761_LAST_DEV;(index++,loc_dev++)) {
+        if(loc_dev->driver && loc_dev->driver->resume) {
+            loc_dev->driver->resume(loc_dev);
+        }
+    }
+
+    return 0;
+
+} /* End of isp1362_pci_resume */
+
+
+
+EXPORT_SYMBOL(isp1761_reg_write16);
+EXPORT_SYMBOL(isp1761_reg_read16);
+EXPORT_SYMBOL(isp1761_reg_read32);
+EXPORT_SYMBOL(isp1761_reg_write32);
+EXPORT_SYMBOL(isp1761_request_irq);
+EXPORT_SYMBOL(isp1761_mem_read);
+EXPORT_SYMBOL(isp1761_mem_write);
+EXPORT_SYMBOL(isp1761_free_irq);
+EXPORT_SYMBOL(isp1761_register_driver);
+EXPORT_SYMBOL(isp1761_unregister_driver);
+EXPORT_SYMBOL(isp1761_disable_interrupt);
+EXPORT_SYMBOL(isp1761_enable_interrupt);
+
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE ("GPL");
+
+module_init (isp1761_pci_module_init);
+module_exit (isp1761_pci_module_cleanup);
+
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/hal/hal_x86.h linux-3.13/drivers/armadeus/isp1761/hal/hal_x86.h
--- linux-3.13/drivers/armadeus/isp1761/hal/hal_x86.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/hal/hal_x86.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,142 @@
+/************************************************************
+ * NXP ISP176x Hardware Access Interface header file
+ *
+ * (c) 2006 NXP B.V., All rights reserved. <usb.linux@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * File Name: hal_x86.h
+ *
+ * Refering linux kernel version 2.6.9
+ *
+ * History:
+ *
+ * Date                Author                  Comments
+ * ---------------------------------------------------------------------
+ * Nov 29 2005        Prabhakar Kalasani      Initial Creation     
+ *
+ **********************************************************************
+ */
+
+#ifndef _HAL_X86_H_
+#define _HAL_X86_H_
+
+#define         DRIVER_AUTHOR          "NXP Semiconductors"
+#define         DRIVER_DESC            "ISP1761 bus driver"
+
+/* Driver tuning, per NXP requirements: */
+
+/* BIT defines */
+#define BIT0    (1 << 0)
+#define BIT1    (1 << 1)
+#define BIT2    (1 << 2)
+#define BIT3    (1 << 3)
+#define BIT4    (1 << 4)
+#define BIT5    (1 << 5)
+#define BIT6    (1 << 6)
+#define BIT7    (1 << 7)
+#define BIT8    (1 << 8)
+#define BIT9    (1 << 9)
+#define BIT10   (1 << 10)
+#define BIT11   (1 << 11)
+#define BIT12   (1 << 12)
+#define BIT13   (1 << 13)
+#define BIT14   (1 << 14)
+#define BIT15   (1 << 15)
+#define BIT16   (1 << 16)
+#define BIT17   (1 << 17)
+#define BIT18   (1 << 18)
+#define BIT19   (1 << 19)
+#define BIT20   (1 << 20)
+#define BIT21   (1 << 21)
+#define BIT22   (1 << 22)
+#define BIT23   (1 << 23)
+#define BIT24   (1 << 24)
+#define BIT25   (1 << 26)
+#define BIT27   (1 << 27)
+#define BIT28   (1 << 28)
+#define BIT29   (1 << 29)
+#define BIT30   (1 << 30)
+#define BIT31   (1 << 31)
+
+/* Definitions Related to Little Endian & Big Endian */
+#define tole(x) __constant_cpu_to_le32(x)
+#define tobe(x) __constant_cpu_to_be32(x)
+
+/* Definitions Related to Chip Address and CPU Physical Address 
+ * cpu_phy_add: CPU Physical Address , it uses 32 bit data per address
+ * chip_add   : Chip Address, it uses double word(64) bit data per address
+ */
+#define chip_add(cpu_phy_add)  (cpu_phy_add-0x400)/8
+#define cpu_phy_add(chip_add)  (8*chip_add)+0x400
+
+/* for getting end add, and start add, provided we have one address with us */
+/* IMPORTANT length  hex(base16) and dec(base10) works fine*/
+#define end_add(start_add,length) (start_add+(length-4))
+#define start_add(end_add,length) (end_add-(length-4))
+
+/* Device Registers*/
+#define DEV_UNLOCK_REGISTER             0x27C
+#define DEV_INTERRUPT_REGISTER          0x218
+
+
+/* The QHA Data Structure */
+struct phci_qh {
+    u32                 hw_info1; /* see QHA  W0, the first 32bits */
+    u32                 hw_info2; /* see QHA  W1 */
+    u32                 hw_info3; /* see QHA  W2 */
+    u32                 hw_info4; /* see QHA  W3 */
+    u32                 Reserved1; /* Reserved1..4. NOT in USE */
+    u32                 Reserved2;
+    u32                 Reserved3;
+    u32                 Reserved4;
+}phci_qh  __attribute__ ((aligned (32)));
+
+
+/*
+ *  We have hardware support for asynchronous DMA transfers.  We can use PIO
+ *  mode as well.  The chips registers are mapped as follows:
+ *
+ *  Base address for pio mode: ioremap_nocache(PXA_CS2_BASE,PAGE_SIZE);
+ *  Physical addresses for DMA transfers: 
+ *  Note also that these are normally defined in the platform specific header
+ *  files.  DON'T define them within your driver, that's extremely non-portable.
+ */  
+typedef struct isp1761_hal {
+    void    *mem_base; /* Memory base */
+    __u8        irq_usage;      /* NUmber of linux-3.13/drivers using INT channel */
+} isp1761_hal_t;
+
+typedef struct {
+    char *name;                                 /* dma stream identifier */
+    char *data_buffer;                  /* pointer to in memory dma buffer (virtual) */
+    char *phys_data_buffer;             /* pointer to in memory dma buffer (physical) */
+    char *trash_buffer;                 /* don't ask... */
+    char *phys_trash_buffer;
+    u_int dma_ch;                               /* DMA channel number */
+    volatile u32 *drcmr;                /* the dma request channel to use, not to be confused with the above */
+    u_long dcmd;                                /* DMA dcmd field */
+    u_long dev_addr;                    /* device physical address for this channel */
+    u_long blklen;                              /* block length of specific transfer */
+    char output;                                /* 0 for input, 1 for ouput */
+} isp1761_channel_t;
+
+typedef struct {
+    isp1761_channel_t *dreq0;
+    isp1761_channel_t *dreq1;
+    struct semaphore sem;       /* may be handy for races... */
+} dma_state_t;
+
+#endif /*_HAL_X86_H_ */
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/hal/isp1761.h linux-3.13/drivers/armadeus/isp1761/hal/isp1761.h
--- linux-3.13/drivers/armadeus/isp1761/hal/isp1761.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/hal/isp1761.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,231 @@
+/********************************************************************
+ * NXP ISP176x Debugging and Conditinal Compilation header file
+ *
+ * (c) 2006 NXP B.V., All rights reserved. <usb.linux@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * File Name: isp1761.h
+ *
+ * Refering linux kernel version 2.6.9
+ *
+ * History:
+ *
+ * Date               Author                  Comments
+ * --------------------------------------------------------------------
+ * Nov 29 2005       Prabhakar Kalasani       Initial version
+ * May 5, 2006       Grant Hatamosa           Added ISO support
+ * May 5, 2006       Grace Baldonasa          Added MTP support (Available only
+ *                                            with Peripheral Controller code)
+ *
+ **********************************************************************
+ */
+
+
+/*******************START HOST CONTROLLER********************************/
+/* Host controller conditional defines*/
+#define MSEC_INT_BASED                                  /* define to run host on SOF interrupt */
+
+/* For Iso support */
+#ifdef MSEC_INT_BASED /* Iso support is only currently available in this mode */
+#define CONFIG_ISO_SUPPORT /* Comment to remove isochronous transfer support */
+#endif
+
+#ifdef CONFIG_ISO_SUPPORT
+
+#define ISO_DBG_ENTRY FALSE
+#define ISO_DBG_EXIT FALSE
+#define ISO_DBG_ADDR TRUE
+#define ISO_DBG_DATA TRUE
+#define ISO_DBG_ERR  TRUE
+#define ISO_DBG_INFO TRUE
+
+#if 0 /* Set to 1 to enable isochronous debugging */
+#define iso_dbg(category, format, arg...) \
+do \
+{ \
+    if(category) \
+    { \
+        printk(format, ## arg); \
+    } \
+} while(0)
+#else
+#define iso_dbg(category, format, arg...) while(0)
+#endif
+
+#endif /* CONFIG_ISO_SUPPORT */
+
+		/*End ISO support stuff*/
+	/*------------------------------------------*/
+
+/*Debug For Entry/Exit of the functions */ 
+#undef HCD_DEBUG_LEVEL1
+#ifdef HCD_DEBUG_LEVEL1
+#define pehci_entry(format, args... ) printk(format, ##args)
+#else
+#define pehci_entry(format, args...) do { } while(0)
+#endif
+
+/*Debug for Port Info and Errors */
+#undef HCD_DEBUG_LEVEL2
+#ifdef HCD_DEBUG_LEVEL2
+#define pehci_print(format, args... ) printk(format, ##args)
+#else
+#define pehci_print(format, args...) do { } while(0)
+#endif
+
+/*Debug For the Port changes and Enumeration */
+#undef HCD_DEBUG_LEVEL3
+#ifdef HCD_DEBUG_LEVEL3
+#define pehci_info(format,arg...) printk(format, ##arg)
+#else
+#define pehci_info(format,arg...) do {} while (0)
+#endif
+
+/*Debug For Transfer flow  */
+#undef HCD_DEBUG_LEVEL4
+#ifdef HCD_DEBUG_LEVEL4
+#define pehci_check(format,args...) printk(format, ##args)
+#else
+#define pehci_check(format,args...)
+#endif 
+/*******************END HOST CONTROLLER**********************************/
+
+
+
+/*******************START DEVICE CONTROLLER******************************/
+
+/* For MTP support */
+#undef MTP_ENABLE /* Enable to add MTP support on ISP1761 Device Controller
+                   * Requires MTP class driver 
+                   */
+
+/*Debug Entery/Exit of Function as well as some other Information(I'm not sure)*/
+#undef DEV_DEBUG_LEVEL2
+#ifdef DEV_DEBUG_LEVEL2
+#define dev_print(format,arg...) printk(format, ##arg)
+#else
+#define dev_print(format,arg...) do {} while (0)
+#endif
+
+/*Debug for Interrupt , Registers , Device Enable/Disable and some other info */
+#undef DEV_DEBUG_LEVEL3
+#ifdef DEV_DEBUG_LEVEL3
+#define dev_inform(format,arg...) printk(format, ##arg)
+#else
+#define dev_inform(format,arg...) do {} while (0)
+#endif
+
+/*Debug for Transfer flow , Enumeration and Packet info */
+#undef DEV_DEBUG_LEVEL4
+#ifdef DEV_DEBUG_LEVEL4
+#define dev_check(format,args...) printk(format, ##args)
+#else
+#define dev_check(format,args...) do{}while(0)
+#endif
+/*******************END DEVICE CONTROLLER********************************/
+
+
+/*******************START MSCD*******************************************/
+/*Debug Entery/Exit of Function as well as some other Information(I'm not sure)*/
+#undef MSCD_DEBUG_LEVEL2
+#ifdef MSCD_DEBUG_LEVEL2
+#define mscd_print(format,arg...) printk(format, ##arg)
+#else
+#define mscd_print(format,arg...) do {} while (0)
+#endif
+
+/*Debug for Info */
+#undef MSCD_DEBUG_LEVEL3
+#ifdef MSCD_DEBUG_LEVEL3
+#define mscd_info(format,arg...) printk(format, ##arg)
+#else
+#define mscd_info(format,arg...) do {} while (0)
+#endif
+/*******************END MSCD*********************************************/
+
+
+/*******************START OTG CONTROLLER*********************************/
+#undef OTG      /*undef for Host only and Device only */
+#undef ALL_FSM_FLAGS
+/*Debug for Entry/Exit and Info */
+#undef OTG_DEBUG_LEVEL1
+#ifdef OTG_DEBUG_LEVEL1
+#define otg_entry(format, args... ) printk(format, ##args)
+#else
+#define otg_entry(format, args...) do { } while(0)
+#endif
+
+/*Debug for State Machine Flow */
+#undef OTG_DEBUG_LEVEL2
+#ifdef OTG_DEBUG_LEVEL2
+#define otg_print(format,arg...) printk(format, ##arg)
+#else
+#define otg_print(format,arg...) do {} while (0)
+#endif
+/*Debug for Info */
+#undef OTG_DEBUG_LEVEL3
+#ifdef OTG_DEBUG_LEVEL3
+#define otg_info(format,arg...) printk(format, ##arg)
+#else
+#define otg_info(format,arg...) do {} while (0)
+#endif
+/*******************END OTG CONTROLLER***********************************/
+
+
+
+/*******************START FOR HAL ***************************************/
+/*Debug For Entry and Exit of the functions */ 
+#undef HAL_DEBUG_LEVEL1
+#ifdef HAL_DEBUG_LEVEL1
+#define hal_entry(format, args... ) printk(format, ##args)
+#else
+#define hal_entry(format, args...) do { } while(0)
+#endif
+
+/*Debug For Interrupt information */ 
+#undef HAL_DEBUG_LEVEL2
+#ifdef HAL_DEBUG_LEVEL2
+#define hal_int(format, args... ) printk(format, ##args)
+#else
+#define hal_int(format, args...) do { } while(0)
+#endif
+
+/*Debug For HAL Initialisation and Mem Initialisation */ 
+#undef HAL_DEBUG_LEVEL3
+#ifdef HAL_DEBUG_LEVEL3
+#define hal_init(format, args... ) printk(format, ##args)
+#else
+#define hal_init(format, args...) do { } while(0)
+#endif
+/*******************END FOR HAL*******************************************/
+
+
+
+/*******************START FOR ALL CONTROLLERS*****************************/
+#undef CONFIG_USB_OTG   /*undef for Host only and Device only */
+#define ISP1761_DEVICE 
+
+#ifdef CONFIG_USB_DEBUG
+#define DEBUG
+#else
+#undef DEBUG
+#endif
+/*******************END FOR ALL CONTROLLERS*******************************/
+
+#include <linux/version.h>
+#define info(format, arg...) printk(KERN_INFO KBUILD_MODNAME ": " format "\n" , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING KBUILD_MODNAME ": " format "\n" , ## arg)
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/host/Makefile linux-3.13/drivers/armadeus/isp1761/host/Makefile
--- linux-3.13/drivers/armadeus/isp1761/host/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/host/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,10 @@
+#
+#
+obj-$(CONFIG_ARMADEUS_ISP1761) :=	pehci.o
+
+clean:
+	find . -name '*.mod.[co]' -or -name '.*.o.cmd' | xargs rm -f
+	find . -name '*.ko' -or -name '*.ver' -or -name '*.mod' | xargs rm -f
+	find . -name '*.o' -or -name '*.ko.cmd'| xargs rm -f
+	find . -name '.*.*.cmd' | xargs rm -f
+	rm -rf .tmp_versions
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/host/itdptd.c linux-3.13/drivers/armadeus/isp1761/host/itdptd.c
--- linux-3.13/drivers/armadeus/isp1761/host/itdptd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/host/itdptd.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,933 @@
+/*******************************************************************************
+ * NXP ISP176x Isochronous Transfer support code file
+ *
+ * (c) 2006 NXP B.V., All rights reserved. <usb.linux@nxp.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * File Name: itdptd.c
+ * 
+ *
+ * History:     
+ *
+ * Date                 Author/Modified by      Comments
+ * -----------------------------------------------------------------------------
+ * Jan 16, 2006         Grant H.               Initial version
+ * Feb 6, 2006          Grant H.               First stable release
+ * May 02 2007		Prabhakar	       ported to 2.6.20 with backward 
+ *                                             compatibility with 2.6.9  
+ *
+ *******************************************************************************
+ */
+
+#ifdef CONFIG_ISO_SUPPORT
+
+/*
+ * phcd_iso_itd_to_ptd - convert an ITD into a PTD
+ *
+ * phci_hcd *hcd
+ *      - Main host controller driver structure
+ * struct ehci_itd *itd
+ *  - Isochronous Transfer Descriptor, contains elements as defined by the
+ *        EHCI standard plus a few more NXP specific elements.
+ * struct urb *urb
+ *  - USB Request Block, contains information regarding the type and how much data
+ *    is requested to be transferred.
+ * void  * ptd 
+ *  - Points to the ISO ptd structure that needs to be initialized
+ *
+ * API Description
+ * This is mainly responsible for:
+ *  -Initializing the PTD that will be used for the ISO transfer
+ */
+void * phcd_iso_itd_to_ptd( phci_hcd *hcd,
+        struct ehci_itd *itd,
+        struct urb *urb,
+        void  * ptd
+        )
+{
+    struct _isp1761_isoptd *iso_ptd;
+    struct isp1761_mem_addr *mem_addr;
+
+    unsigned long max_packet, mult, length, td_info1, td_info3;
+    unsigned long token, port_num, hub_num, data_addr;
+    unsigned long frame_number;
+
+    iso_dbg(ISO_DBG_ENTRY, "phcd_iso_itd_to_ptd entry\n");
+
+    /* Variable initialization */
+    iso_ptd = (struct _isp1761_isoptd *)ptd;
+    mem_addr = &itd->mem_addr;
+
+    /*
+     * For both ISO and INT endpoints descriptors, new bit fields we added to
+     * specify whether or not the endpoint supports high bandwidth, and if so
+     * the number of additional packets that the endpoint can support during a 
+     * single microframe.
+     * Bits 12:11 specify whether the endpoint supports high-bandwidth transfers
+     * Valid values:
+     *             00 None (1 transaction/uFrame)
+     *             01 1 additional transaction
+     *             10 2 additional transactions
+     *             11 reserved
+     */
+    max_packet = usb_maxpacket( urb->dev,
+            urb->pipe,
+            usb_pipeout(urb->pipe)
+            );  
+
+    /* 
+     * We need to add 1 since our Multi starts with 1 instead of the USB specs defined
+     * zero (0).
+     */
+    mult = 1 + ((max_packet >> 11) & 0x3);
+    max_packet &= 0x7ff;
+
+    /* This is the size of the request (bytes to write or bytes to read) */
+    length = itd->length;
+
+    /*
+     * Set V bit to indicate that there is payload to be sent or received. And 
+     * indicate that the current PTD is active.
+     */
+    td_info1 = QHA_VALID;
+
+    /* 
+     * Set the number of bytes that can be transferred by this PTD. This indicates
+     * the depth of the data field.
+     */
+    td_info1 |= (length << 3);
+
+    /*
+     * Set the maximum packet length which indicates the maximum number of bytes that
+     * can be sent to or received from the endpoint in a single data packet.
+     */
+    if (urb->dev->speed != USB_SPEED_HIGH)
+    {
+        /* 
+         * According to the ISP1761 specs for sITDs, OUT token max packet should
+         * not be more  than 188 bytes, while IN token max packet not more than
+         * 192 bytes (ISP1761 Rev 3.01, Table 72, page 79
+         */
+        if(usb_pipein(urb->pipe) &&
+                (max_packet > 192))
+        {
+            iso_dbg(ISO_DBG_INFO, "[phcd_iso_itd_to_ptd]: IN Max packet over maximum\n");
+            max_packet = 192;                   
+        }
+
+        if((!usb_pipein(urb->pipe)) &&
+                (max_packet > 188))
+        {
+            iso_dbg(ISO_DBG_INFO, "[phcd_iso_itd_to_ptd]: OUT Max packet over maximum\n");
+            max_packet = 188;                   
+        }
+    }
+    td_info1 |= (max_packet << 18);
+
+    /*
+     * Place the FIRST BIT of the endpoint number here.
+     */
+    td_info1 |= (usb_pipeendpoint(urb->pipe) << 31);
+
+    /*
+     * Set the number of successive packets the HC can submit to the endpoint.
+     */
+    if(urb->dev->speed == USB_SPEED_HIGH)
+    {
+        td_info1 |= MULTI(mult);
+    }
+
+    /* Set the first DWORD */
+    iso_ptd->td_info1 = td_info1;
+    iso_dbg(ISO_DBG_DATA, "[phcd_iso_itd_to_ptd]: DWORD0 = 0x%08x\n", iso_ptd->td_info1);
+
+    /*
+     * Since the first bit have already been added on the first DWORD of the PTD         
+     * we only need to add the last 3-bits of the endpoint number.
+     */
+    token = (usb_pipeendpoint(urb->pipe) & 0xE) >> 1;
+
+    /*
+     * Get the device address and set it accordingly to its assigned bits of the 2nd
+     * DWORD.
+     */
+    token |= usb_pipedevice(urb->pipe) << 3;
+
+    /* See a split transaction is needed */
+    if(urb->dev->speed != USB_SPEED_HIGH)
+    {
+        /* 
+         * If we are performing a SPLIT transaction indicate that it is so by setting
+         * the S bit of the second DWORD.
+         */             
+        token |= 1 << 14;
+
+        port_num = urb->dev->ttport;
+        hub_num = urb->dev->tt->hub->devnum;
+
+        /* Set the the port number of the hub or embedded TT */
+        token |= port_num << 18;
+
+        /* 
+         * Set the hub address, this should be zero for the internal or
+         * embedded hub
+         */
+        token |= hub_num << 25;
+    } /* if(urb->dev->speed != USB_SPEED_HIGH) */
+
+    /* 
+     * Determine if the direction of this pipe is IN, if so set the Token bit of 
+     * the second DWORD to indicate it as IN. Since it is initialized to zero and
+     * zero indicates an OUT token, then we do not need anything to the Token bit
+     * if it is an OUT token.
+     */
+    if(usb_pipein(urb->pipe))
+        token |= (IN_PID << 10);
+
+    /* Set endpoint type to Isochronous */
+    token |= EPTYPE_ISO;
+
+    /* Set the second DWORD */  
+    iso_ptd->td_info2 = token;  
+    iso_dbg(ISO_DBG_DATA, "[phcd_iso_itd_to_ptd]: DWORD1 = 0x%08x\n", iso_ptd->td_info2);
+
+    /*
+     * Get the physical address of the memory location that was allocated for this PTD 
+     * in the PAYLOAD region, using the formula indicated in sectin 7.2.2 of the ISP1761 specs
+     * rev 3.01 page 17 to 18.
+     */
+    data_addr = ( (unsigned long) (mem_addr->phy_addr) & 0xffff ) - 0x400;
+    data_addr >>= 3;
+
+    /*  Set it to its location in the third DWORD */
+    td_info3 = data_addr << 8;
+
+    /*
+     * Set the frame number when this PTD will be sent for ISO OUT or IN
+     * Bits 0 to 2 are don't care, only bits 3 to 7.
+     */
+    frame_number = itd->framenumber;
+    td_info3 |= (frame_number << 3);
+
+    /* Set the third DWORD */
+    iso_ptd->td_info3 = td_info3;
+    iso_dbg(ISO_DBG_DATA, "[phcd_iso_itd_to_ptd]: DWORD2 = 0x%08x\n", iso_ptd->td_info3);
+
+    /* 
+     * Set the A bit of the fourth DWORD to 1 to indicate that this PTD is active.
+     * This have the same functionality with the V bit of DWORD0 
+     */
+    iso_ptd->td_info4 = QHA_ACTIVE;
+    iso_dbg(ISO_DBG_DATA, "[phcd_iso_itd_to_ptd]: DWORD3 = 0x%08x\n", iso_ptd->td_info4);
+
+    /* Set the fourth DWORD to specify which uSOFs the start split needs to be placed */
+    iso_ptd->td_info5 = itd->ssplit;
+    iso_dbg(ISO_DBG_DATA, "[phcd_iso_itd_to_ptd]: DWORD4 = 0x%08x\n", iso_ptd->td_info5);
+
+    /* 
+     * Set the fifth DWORD to specify which uSOFs the complete split needs to be sent.
+     * This is VALID only for IN (since ISO transfers don't have handshake stages)
+     */
+    iso_ptd->td_info6 = itd->csplit;
+    iso_dbg(ISO_DBG_DATA, "[phcd_iso_itd_to_ptd]: DWORD5 = 0x%08x\n", iso_ptd->td_info6);
+
+    iso_dbg(ISO_DBG_EXIT, "phcd_iso_itd_to_ptd exit\n");
+    return iso_ptd;
+}/* phcd_iso_itd_to_ptd */
+
+/*
+ * phcd_iso_scheduling_info - Initializing the start split and complete split.
+ *
+ * phci_hcd *hcd
+ *      - Main host controller driver structure
+ * struct ehci_qh *qhead
+ *  - Contains information about the endpoint.
+ * unsigned long max_pkt
+ *  - Maximum packet size that the endpoint in capable of handling
+ * unsigned long high_speed
+ *  - Indicates if the bus is a high speed bus
+ * unsigned long ep_in
+ *  - Inidcates if the endpoint is an IN endpoint
+ *
+ * API Description
+ * This is mainly responsible for:
+ *  - Determining the number of start split needed during an OUT transaction or
+ *    the number of complete splits needed during an IN transaction.
+ */
+unsigned long phcd_iso_scheduling_info( phci_hcd *hcd,
+        struct ehci_qh *qhead,
+        unsigned long max_pkt,
+        unsigned long high_speed,
+        unsigned long ep_in
+        )
+{
+    unsigned long count, usof, temp;
+
+    /* Local variable initialization */
+    usof = 0x1;
+
+    if(high_speed)
+    {
+        qhead->csplit = 0;
+
+        /* Always send high speed transfers in first uframes */
+        qhead->ssplit = 0x1;
+        return 0;
+    }
+
+    /* Determine how many 188 byte-transfers are needed to send all data */
+    count = max_pkt/188;
+
+    /* 
+     * Check is the data is not a factor of 188, if it is not then we need 
+     * one more 188 transfer to move the last set of data less than 188.
+     */
+    if(max_pkt % 188)
+        count += 1;
+
+    /* 
+     * Remember that usof was initialized to 0x1 so that means
+     * that usof is always guranteed a value of 0x1 and then
+     * depending on the maxp, other bits of usof will also be set.
+     */
+    for(temp = 0; temp < count; temp++)
+        usof |= (0x1 << temp);
+
+    if(ep_in)
+    {
+        /* 
+         * Send start split into first frame.
+         */     
+        qhead->ssplit = 0x1;
+
+        /* 
+         * Inidicate that we can send a complete split starting from
+         * the third uFrame to how much complete split is needed to
+         * retrieve all data. 
+         *
+         * Of course, the first uFrame is reserved for the start split, the
+         * second is reserved for the TT to send the request and get some
+         * data.
+         */      
+        qhead->csplit = (usof << 2);
+    } /* if(ep_in) */
+    else
+    {
+        /* 
+         * For ISO OUT we don't need to send out a complete split 
+         * since we do not require and data coming in to us (since ISO
+         * do not have integrity checking/handshake).
+         *
+         * For start split we indicate that we send a start split from the 
+         * first uFrame up to the the last uFrame needed to retrieve all
+         * data
+         */
+        qhead->ssplit = usof;
+        qhead->csplit = 0;
+    } /* else for if(ep_in) */          
+    return 0;
+}/* phcd_iso_scheduling_info */
+
+/*
+ * phcd_iso_itd_fill - Allocate memory from the PAYLOAD memory region
+ *
+ * phci_hcd *pHcd_st
+ *  - Main host controller driver structure
+ * struct ehci_itd *itd
+ *  - Isochronous Transfer Descriptor, contains elements as defined by the
+ *        EHCI standard plus a few more NXP specific elements.
+ * struct urb *urb
+ *  - USB Request Block, contains information regarding the type and how much data
+ *    is requested to be transferred.
+ * unsigned long packets
+ *  - Total number of packets to completely transfer this ISO transfer request.
+ *
+ * API Description
+ * This is mainly responsible for:
+ * - Initialize the following elements of the ITS structure
+ *       > itd->length = length;        -- the size of the request
+ *       > itd->multi = multi;          -- the number of transactions for 
+ *                                         this EP per micro frame
+ *       > itd->hw_bufp[0] = buf_dma;   -- The base address of the buffer where 
+ *                                         to put the data (this base address was
+ *                                         the buffer provided plus the offset)
+ * - Allocating memory from the PAYLOAD memory area, where the data coming from
+ *   the requesting party will be placed or data requested by the requesting party will
+ *   be retrieved when it is available.
+ */
+unsigned long phcd_iso_itd_fill ( phci_hcd *hcd,
+        struct ehci_itd *itd,
+        struct urb *urb,
+        unsigned long packets
+        )
+{
+    unsigned long length, offset, pipe;
+    unsigned long max_pkt, mult;
+    dma_addr_t buff_dma;
+    struct isp1761_mem_addr *mem_addr;
+
+    iso_dbg(ISO_DBG_ENTRY, "phcd_iso_itd_fill entry\n");
+    /* 
+     * The value for both these variables are supplied by the one
+     * who submitted the URB.
+     */
+    length = urb->iso_frame_desc[packets].length;
+    offset = urb->iso_frame_desc[packets].offset;
+
+    /* Initialize the status and actual length of this packet*/
+    urb->iso_frame_desc[packets].actual_length = 0;
+    urb->iso_frame_desc[packets].status = -EXDEV;
+
+    /* Buffer for this packet*/
+    buff_dma = cpu_to_le32((unsigned char *)urb->transfer_buffer + offset);
+
+    /* Memory for this packet*/
+    mem_addr = &itd->mem_addr;
+
+    pipe = urb->pipe;
+    max_pkt = usb_maxpacket(urb->dev, pipe, usb_pipeout(pipe));
+
+    mult = 1 + ((max_pkt >> 11) & 0x3); 
+    max_pkt = max_pkt & 0x7FF;  
+    max_pkt *= mult;
+
+    if( (length < 0) || (max_pkt < length) )
+    {
+        iso_dbg(ISO_DBG_ERR,"[phcd_iso_itd_fill Error]: No available memory.\n");
+        return -ENOSPC;
+    }
+    itd->buf_dma = buff_dma;
+
+    /* 
+     * Allocate memory in the PAYLOAD memory region for the 
+     * data buffer for this ITD
+     */
+    phci_hcd_mem_alloc(length, mem_addr, 0);
+    if( length && ( (mem_addr->phy_addr == 0 ) || 
+                (mem_addr->virt_addr == 0) ) )
+    {   
+        mem_addr = 0;
+        iso_dbg(ISO_DBG_ERR, "[phcd_iso_itd_fill Error]: No payload memory available\n");
+        return -ENOMEM;
+    }
+
+    /* Length of this packet */
+    itd->length = length;
+
+    /* Number of transaction per uframe */
+    itd->multi = mult;
+
+    /* Buffer address, one ptd per packet */
+    itd->hw_bufp[0] = buff_dma;
+
+    iso_dbg(ISO_DBG_EXIT, "phcd_iso_itd_fill exit\n");  
+    return 0;
+} /* phcd_iso_itd_fill */
+
+/*
+ * phcd_iso_get_itd_ptd_index - Allocate an ISO PTD from the ISO PTD map list
+ *
+ * phci_hcd *hcd
+ *      - Main host controller driver structure
+ * struct ehci_itd *itd
+ *  - Isochronous Transfer Descriptor, contains elements as defined by the
+ *        EHCI standard plus a few more NXP specific elements.
+ *
+ * API Description
+ * This is mainly responsible for:
+ * - Allocating an ISO PTD from the ISO PTD map list
+ * - Set the equivalent bit of the allocated PTD to active
+ *   in the bitmap so that this PTD will be included into
+ *   the periodic schedule
+ */
+void phcd_iso_get_itd_ptd_index( phci_hcd *hcd, struct ehci_itd *itd )
+{
+    td_ptd_map_buff_t *ptd_map_buff;    
+    unsigned long buff_type, max_ptds;
+    unsigned char itd_index, bitmap;
+
+    /* Local variable initialization */
+    bitmap = 0x1;
+    buff_type = td_ptd_pipe_x_buff_type[TD_PTD_BUFF_TYPE_ISTL];
+    ptd_map_buff = (td_ptd_map_buff_t *) &(td_ptd_map_buff[buff_type]); 
+    max_ptds = ptd_map_buff->max_ptds;
+
+    for(itd_index = 0; itd_index < max_ptds; itd_index++) 
+    {   
+        /* 
+         * ISO have 32 PTDs, the first thing to do is look for a free PTD.
+         */
+        if(ptd_map_buff->map_list[itd_index].state == TD_PTD_NEW) 
+        {
+            /* 
+             * Determine if this is a newly allocated ITD by checking the
+             * itd_index, since it was set to TD_PTD_INV_PTD_INDEX during
+             * initialization
+             */
+            if( itd->itd_index == TD_PTD_INV_PTD_INDEX ) 
+            {
+                itd->itd_index = itd_index;
+            }
+
+            /* Once there is a free slot, indicate that it is already taken */
+            ptd_map_buff->map_list[itd_index].datatoggle = 0;
+            ptd_map_buff->map_list[itd_index].state = TD_PTD_ACTIVE;
+            ptd_map_buff->map_list[itd_index].qtd = NULL;
+
+            /* Put a connection to the ITD with the PTD maplist */
+            ptd_map_buff->map_list[itd_index].itd  = itd;
+            ptd_map_buff->map_list[itd_index].qh = NULL;
+
+            /* ptd_bitmap just holds the bit assigned to this PTD. */            
+            ptd_map_buff->map_list[itd_index].ptd_bitmap = bitmap << itd_index;
+
+            phci_hcd_fill_ptd_addresses(&ptd_map_buff->map_list[itd_index], 
+                    itd->itd_index, buff_type); 
+
+            /* 
+             * Indicate that this ITD is the last in the list and update 
+             * the number of active PTDs
+             */
+            ptd_map_buff->map_list[itd_index].lasttd = 0;
+            ptd_map_buff->total_ptds ++;
+
+            /* TO DO: This variable is not used from what I have seen. */                       
+            ptd_map_buff->active_ptd_bitmap |= (bitmap << itd_index);
+            break;
+        }/* if(ptd_map_buff->map_list[itd_index].state == TD_PTD_NEW) */
+    }/* for(itd_index = 0; itd_index < max_ptds; itd_index++) */
+    return;
+}/* phcd_iso_get_itd_ptd_index */
+
+/*
+ * phcd_iso_itd_free_list - Free memory used by ITDs in ITD list
+ *
+ * phci_hcd *hcd
+ *      - Main host controller driver structure
+ * struct urb *urb
+ *  - USB Request Block, contains information regarding the type and how much data
+ *    is requested to be transferred.
+ * unsigned long status
+ *  - Variable provided by the calling routine that contain the status of the 
+ *        ITD list.
+ *
+ * API Description
+ * This is mainly responsible for:
+ *  - Cleaning up memory used by each ITD in the ITD list
+ */
+void phcd_iso_itd_free_list( phci_hcd *hcd,
+        struct urb *urb,
+        unsigned long status
+        )
+{
+    td_ptd_map_buff_t *ptd_map_buff;
+    struct ehci_itd *first_itd, *next_itd, *itd;
+    td_ptd_map_t *td_ptd_map;
+
+    /* Local variable initialization */
+    ptd_map_buff = &(td_ptd_map_buff[TD_PTD_BUFF_TYPE_ISTL]);
+    first_itd = (struct ehci_itd *) urb->hcpriv;        
+    itd = first_itd;
+
+    /* 
+     * Check if there is only one ITD, if so immediately 
+     * go and clean it up.
+     */
+    if(itd->hw_next == EHCI_LIST_END)
+    {           
+        if(itd->itd_index != TD_PTD_INV_PTD_INDEX)
+        {
+            td_ptd_map = &ptd_map_buff->map_list[itd->itd_index];
+            td_ptd_map->state = TD_PTD_NEW;
+        }
+
+        if(status != -ENOMEM)
+            phci_hcd_mem_free(&itd->mem_addr);
+
+        list_del (&itd->itd_list);
+        qha_free(qha_cache, itd);
+
+        urb->hcpriv = 0;
+        return;
+    } /* if(itd->hw_next == EHCI_LIST_END) */
+
+    while(1)
+    {
+        /* Get the ITD following the head ITD */
+        next_itd = (struct ehci_itd *) le32_to_cpu(itd->hw_next);
+        if(next_itd->hw_next == EHCI_LIST_END)
+        {               
+            /* 
+             * If the next ITD is the end of the list, check if space have 
+             * already been allocated in the PTD array.
+             */
+            if(next_itd->itd_index != TD_PTD_INV_PTD_INDEX)
+            {
+                /* Free up its allocation */
+                td_ptd_map = &ptd_map_buff->map_list[next_itd->itd_index];
+                td_ptd_map->state = TD_PTD_NEW;
+            }
+
+            /* 
+             * If the error is not about memory allocation problems, then
+             * free up the memory used.
+             */
+            if(status != -ENOMEM)       
+            {
+                iso_dbg(ISO_DBG_ERR,"[phcd_iso_itd_free_list Error]: Memory not available\n");
+                phci_hcd_mem_free(&next_itd->mem_addr);
+            }
+
+            /* Remove from the ITD list and free up space allocated for ITD structure */
+            list_del (&next_itd->itd_list);
+            qha_free(qha_cache, next_itd);
+            break;
+        } /* if(next_itd->hw_next == EHCI_LIST_END)*/ 
+
+        /* 
+         * If ITD is not the end of the list, it only means that it already have everything allocated
+         * and there is no need to check which procedure failed. So just free all resourcs immediately
+         */
+        itd->hw_next = next_itd->hw_next;
+
+        td_ptd_map = &ptd_map_buff->map_list[next_itd->itd_index];
+        td_ptd_map->state = TD_PTD_NEW;
+        phci_hcd_mem_free(&next_itd->mem_addr);
+        list_del (&next_itd->itd_list);
+        qha_free(qha_cache, next_itd);
+    } /*  while(1) */
+
+    /* Now work on the head ITD, it is the last one processed. */
+    if(first_itd->itd_index != TD_PTD_INV_PTD_INDEX)
+    {
+        td_ptd_map = &ptd_map_buff->map_list[first_itd->itd_index];
+        td_ptd_map->state = TD_PTD_NEW;
+    }
+
+    if(status != -ENOMEM)
+    {
+        iso_dbg(ISO_DBG_ERR,"[phcd_iso_itd_free_list Error]: No memory\n");
+        phci_hcd_mem_free(&first_itd->mem_addr);
+    }
+
+    list_del (&first_itd->itd_list);
+    qha_free(qha_cache, first_itd);
+    urb->hcpriv = 0;
+    return;
+}/* phcd_iso_itd_free_list */
+
+/*
+ * phcd_submit_iso - ISO transfer URB submit routine
+ *
+ * phci_hcd *hcd
+ *      - Main host controller driver structure
+ * struct urb *urb
+ *  - USB Request Block, contains information regarding the type and how much data
+ *    is requested to be transferred.
+ * unsigned long *status
+ *  - Variable provided by the calling routine that will contain the status of the 
+ *        phcd_submit_iso actions
+ *
+ * API Description
+ * This is mainly responsible for:
+ *  - Allocating memory for the endpoint information structure (pQHead_st)
+ *  - Requesting for bus bandwidth from the USB core
+ *  - Allocating and initializing Payload and PTD memory
+ */
+unsigned long phcd_submit_iso( phci_hcd *hcd,
+	struct usb_host_endpoint *ep,
+        struct urb *urb,
+        unsigned long *status
+        )
+{
+    struct _periodic_list *periodic_list;
+    struct hcd_dev *dev;
+    struct ehci_qh *qhead;
+    struct ehci_itd *itd, *prev_itd;
+    struct list_head *itd_list;
+
+    unsigned long ep_in, max_pkt, mult;
+    unsigned long bus_time, high_speed, start_frame;
+    unsigned long flags, packets;
+
+    iso_dbg(ISO_DBG_ENTRY, "phcd_submit_iso Entry\n");
+
+    /* Local variable initialization */
+    high_speed = 0;
+    periodic_list = &hcd->periodic_list[0];
+    dev = (struct hcd_dev*) bus_to_hcd(urb->dev->bus);
+    urb->hcpriv = (void *) 0;
+    prev_itd = (struct ehci_itd *) 0;
+    itd = (struct ehci_itd *) 0;
+    start_frame = 0;
+
+    ep_in = usb_pipein(urb->pipe);
+
+    /* 
+     * Take the endpoint, if there is still no memory allocated
+     * for it allocate some and indicate this is for ISO.
+     */
+    qhead  = ep->hcpriv;
+    if(!qhead)
+    {
+        /* 
+         * TO DO: Check who free this up, I did not observed this
+         * freed up 
+         */
+        qhead = phci_hcd_qh_alloc(hcd);
+        if(qhead == 0)
+        {
+            iso_dbg(ISO_DBG_ERR,"[phcd_submit_iso Error]: Not enough memory\n");
+            return -ENOMEM;
+        }
+        qhead->type = TD_PTD_BUFF_TYPE_ISTL;
+        ep->hcpriv = qhead;
+    } /* if(!qhead) */
+
+    /* 
+     * Get the number of additional packets that the endpoint can support during a 
+     * single microframe.
+     */
+    max_pkt = usb_maxpacket(urb->dev, urb->pipe, usb_pipeout(urb->pipe)); 
+
+    /* 
+     * We need to add 1 since our Multi starts with 1 instead of the USB specs defined
+     * zero (0).
+     */
+    mult  = 1 + ((max_pkt >> 11) & 0x3);
+
+    /* This is the actual length per for the whole transaction */
+    max_pkt *= mult;
+
+    /* Check bandwidth */
+    bus_time= 0;
+
+    if(urb->dev->speed == USB_SPEED_FULL)
+    {
+        bus_time = usb_check_bandwidth(urb->dev, urb);
+        if(bus_time < 0)
+        {                           
+            usb_dec_dev_use(urb->dev);
+            *status = bus_time;
+            return *status;
+        }
+    } /*if(urb->dev->speed == USB_SPEED_FULL)  */   
+    else /*HIGH SPEED*/
+    {
+        high_speed = 1;
+
+        /* 
+         * Calculate bustime as dictated by the USB Specs Section 5.11.3 
+         * for high speed ISO
+         */
+        bus_time = 633232L;
+        bus_time +=   (2083L * ((3167L + BitTime(max_pkt) * 1000L)/1000L));
+        bus_time = bus_time/1000L;
+        bus_time += BW_HOST_DELAY;
+        bus_time = NS_TO_US(bus_time);
+    }
+
+    usb_claim_bandwidth(urb->dev, urb, bus_time, 1);
+
+    /* Initialize the start split (ssplit) and complete split (csplit) variables of qhead */
+    if( phcd_iso_scheduling_info(hcd, qhead, max_pkt, high_speed, ep_in) < 0 )
+    {
+        iso_dbg(ISO_DBG_ERR, "[phcd_submit_iso Error]: No space available\n");
+        return -ENOSPC;
+    }
+
+    if(urb->iso_frame_desc[0].offset != 0)
+    {
+        *status = -EINVAL;
+        iso_dbg(ISO_DBG_ERR, "[phcd_submit_iso Error]: Invalid value\n");
+        return *status;
+    }
+
+    if(qhead->next_uframe == -1 ||
+            hcd->periodic_sched == 0)
+    {   
+        /* Calculate the current frame number */
+        if(urb->transfer_flags & URB_ISO_ASAP)
+            start_frame = isp1761_reg_read32( hcd->dev,
+                    hcd->regs.frameindex, 
+                    start_frame
+                    );
+        else
+            start_frame = urb->start_frame;
+
+        INIT_LIST_HEAD(&hcd->urb_list);
+
+        /* The only valid bits of the frame index is the lower 14 bits. */
+        start_frame = start_frame & 0xFF;
+
+        /* 
+         * Remove the count for the micro frame (uSOF) and just leave the 
+         * count for the frame (SOF). Since 1 SOF is equal to 8 uSOF then
+         * shift right by three is like dividing it by 8 (each shift is divide by two)
+         */ 
+        start_frame >>= 3;
+
+        start_frame += 2;                           
+        qhead->next_uframe = start_frame + urb->number_of_packets;
+
+    } /* if(qhead->next_uframe == -1 || hcd->periodic_sched == 0) */
+    else
+    {
+        /* 
+         * The periodic frame list size is only 32 elements deep, so we need 
+         * the frame index to be less than or equal to 32 (actually 31 if we 
+         * start from 0) 
+         */
+        start_frame = (qhead->next_uframe) % PTD_PERIODIC_SIZE;
+        qhead->next_uframe = start_frame + urb->number_of_packets;
+        qhead->next_uframe %= PTD_PERIODIC_SIZE;
+    }
+
+    spin_lock_irqsave(&hcd->lock, flags);
+    iso_dbg(ISO_DBG_DATA,"[phcd_submit_iso]: Number of packets: %d\n", urb->number_of_packets);
+    iso_dbg(ISO_DBG_DATA,"[phcd_submit_iso]: Packet Length: %d\n",
+            urb->iso_frame_desc[0].length);
+    iso_dbg(ISO_DBG_DATA,"[phcd_submit_iso]: Max packet: %d\n", (int) max_pkt);
+
+    /* Make as many tds as number of packets */
+    for(packets = 0; packets < urb->number_of_packets; packets++)
+    {
+        /* 
+         * Allocate memory for the ITD data structure and initialize it.
+         *
+         * This data structure follows the format of the ITD
+         * structure defined by the EHCI standard on the top part
+         * but also contains NXP specific elements in the bottom
+         * part
+         */
+        itd = (struct ehci_itd *) kmalloc(sizeof(struct ehci_itd), GFP_ATOMIC);
+        if(!itd)
+        {
+            *status = -ENOMEM;
+
+            /* Handle ITD list cleanup */
+            if(urb->hcpriv)
+            {
+                phcd_iso_itd_free_list(hcd, urb, *status);
+            }
+            iso_dbg(ISO_DBG_ERR,"[phcd_submit_iso Error]: No memory available\n");
+            return *status;
+        }
+
+        memset(itd, 0, sizeof(struct ehci_itd));
+
+        INIT_LIST_HEAD(&itd->itd_list);
+
+        itd->itd_dma = cpu_to_le32(itd);
+        itd->urb = urb;
+
+        /* 
+         * Indicate that this ITD is the last in the list.
+         *
+         * Also set the itd_index to TD_PTD_INV_PTD_INDEX 
+         * (0xFFFFFFFF). This would indicate when we allocate
+         * a PTD that this ITD did not have a PTD allocated
+         * before.
+         */
+
+        itd->hw_next = EHCI_LIST_END;
+        itd->itd_index = TD_PTD_INV_PTD_INDEX;
+
+        /* This ITD will go into this frame*/
+        itd->framenumber = start_frame + packets;
+
+        /* Number of the packet*/
+        itd->index = packets;
+
+        itd->framenumber = itd->framenumber % PTD_PERIODIC_SIZE;
+        itd->ssplit = qhead->ssplit;
+        itd->csplit = qhead->csplit;
+
+        /* Initialize the following elements of the ITS structure
+         *      > itd->length = length;                 -- the size of the request
+         *      > itd->multi = multi;                   -- the number of transactions for 
+         *                                         this EP per micro frame
+         *      > itd->hw_bufp[0] = buf_dma;    -- The base address of the buffer where 
+         *                                         to put the data (this base address was
+         *                                         the buffer provided plus the offset)
+         * And then, allocating memory from the PAYLOAD memory area, where the data 
+         * coming from the requesting party will be placed or data requested by the 
+         * requesting party will be retrieved when it is available.
+         */
+        *status  = phcd_iso_itd_fill(hcd, itd, urb, packets);
+
+        if(*status !=0)
+        {
+            /* Handle ITD list cleanup */
+            if(urb->hcpriv)
+            {
+                phcd_iso_itd_free_list(hcd, urb, *status);
+            }
+            iso_dbg(ISO_DBG_ERR,"[phcd_submit_iso Error]: Error in filling up ITD\n");
+            return *status;
+        }
+
+        /* 
+         * If this ITD is not the head/root ITD, link this ITD to the ITD 
+         * that came before it.
+         */
+        if(prev_itd)
+            prev_itd->hw_next = cpu_to_le32(itd);
+
+        prev_itd = itd;
+
+        /*               
+         * Allocate an ISO PTD from the ISO PTD map list and
+         * set the equivalent bit of the allocated PTD to active
+         * in the bitmap so that this PTD will be included into
+         * the periodic schedule
+         */
+        phcd_iso_get_itd_ptd_index(hcd, itd);
+
+        /*if we dont have any space left*/
+        if(itd->itd_index == TD_PTD_INV_PTD_INDEX)
+        {
+            *status  =  -ENOSPC;
+
+            /* Handle ITD list cleanup */
+            if(urb->hcpriv)
+            {
+                phcd_iso_itd_free_list(hcd, urb, *status);
+            }
+            return *status;                     
+        }
+
+        /* Insert this td into the periodic list*/
+        periodic_list[itd->framenumber].framenumber = itd->framenumber;
+        itd_list = &periodic_list[itd->framenumber].itd_head;
+        list_add_tail(&itd->itd_list, itd_list);
+
+        /* Inidcate that a new ITD have been scheduled */
+        hcd->periodic_sched++;
+
+        /* Determine if there are any ITD scheduled before this one. */
+        if(urb->hcpriv == 0)
+            urb->hcpriv = itd;
+    }/* for(packets = 0; packets... */
+
+    spin_unlock_irqrestore(&hcd->lock, flags);   
+
+    /* Last td of current transaction*/
+    itd->hw_next = EHCI_LIST_END;
+    urb->error_count = 0;
+    return *status;
+} /* phcd_submit_iso */
+#endif /* CONFIG_ISO_SUPPORT */
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/host/mem.c linux-3.13/drivers/armadeus/isp1761/host/mem.c
--- linux-3.13/drivers/armadeus/isp1761/host/mem.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/host/mem.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,169 @@
+/************************************************************
+ * NXP ISP176x Host Controller Interface code file
+ *
+ * (c) 2006 NXP B.V., All rights reserved. <usb.linux@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * File Name: mem.c
+ *
+ * Refering linux kernel version 2.6.9
+ *
+ * History:
+ *
+ * Date                  Author                  Comments
+ * --------------------------------------------------------------------
+ * June 21, 2006          krishan                 Initial version
+ *  
+ **********************************************************************
+ */
+
+/*memory utilization fuctions*/
+    void
+phci_hcd_mem_init (void)
+{
+    int i = 0;
+    u32 start_addr = 0x1000;
+    struct isp1761_mem_addr *memaddr;
+    for(i = 0;i<BLK_TOTAL;i++){
+        memaddr = &memalloc[i];
+        memset(memaddr,0,sizeof *memaddr);
+    }
+
+    /*initialize block of 256bytes*/
+    for(i=0;i<BLK_256_;i++){
+        memaddr = &memalloc[i];
+        memaddr->blk_num = i;
+        memaddr->blk_size = BLK_SIZE_256;
+        memaddr->phy_addr = start_addr;
+        start_addr += BLK_SIZE_256;
+    }
+    /*initialize block of 1024bytes*/
+    for(i = BLK_256_;i<(BLK_256_ + BLK_1024_);i++){
+        memaddr = &memalloc[i];
+        memaddr->blk_num = i;
+        memaddr->blk_size = BLK_SIZE_1024;
+        memaddr->phy_addr = start_addr;
+        start_addr += BLK_SIZE_1024;
+    }
+
+    /*initialize block of  4kbytes*/
+    for(i=(BLK_256_ + BLK_1024_);i<(BLK_256_ + BLK_1024_+BLK_4096_);i++){
+        memaddr = &memalloc[i];
+        memaddr->blk_num = i;
+        memaddr->blk_size = BLK_SIZE_4096;
+        memaddr->phy_addr = start_addr;
+        start_addr += BLK_SIZE_4096;
+    }
+
+}
+
+
+/*free memory*/
+    static void
+phci_hcd_mem_free(struct isp1761_mem_addr *memptr)
+{
+    /*block number to be freed*/
+    int block = memptr->blk_num;
+
+    if((memptr->blk_size) &&
+            (memalloc[block].used != 0))
+    {
+        memalloc[block].used = 0;
+    }
+}
+
+
+/*allocate memory*/
+static void
+phci_hcd_mem_alloc(
+        u32 size,
+        struct isp1761_mem_addr *memptr,
+        u32 flag)
+{
+    u32 blk_size = size;
+    u16 i;
+    u32 nextblk1=0,nextblk4=0;
+    u32 start = 0,end = 0;
+    struct isp1761_mem_addr *memaddr = 0;
+
+    memset(memptr,0,sizeof *memptr);
+
+    pehci_print("phci_hcd_mem_alloc(size = %d)\n",size);
+
+    if(blk_size==0) {
+        memptr->phy_addr = 0;
+        memptr->virt_addr = 0;
+        memptr->blk_size = 0;
+        memptr->num_alloc = 0;
+        memptr->blk_num = 0;
+        return;
+    }
+
+    /*end of the 1k blocks*/
+    nextblk1 = BLK_256_ +  BLK_1024_;
+    /*end of the 4k blocks*/
+    nextblk4 = nextblk1 +  BLK_4096_;
+
+
+    if(blk_size<=BLK_SIZE_256){
+        blk_size = BLK_SIZE_256;
+        start = 0;
+        end = BLK_256_;
+    }
+    else if(blk_size<=BLK_SIZE_1024){
+        blk_size = BLK_SIZE_1024;
+        start = BLK_256_;
+        end = start + BLK_1024_;
+    }
+    else if(blk_size > BLK_SIZE_1024){
+        blk_size = BLK_SIZE_4096;
+        start = BLK_256_ + BLK_1024_;
+        end = start + BLK_4096_;
+    }
+
+    for(i = start;i<end;i++){
+        memaddr = &memalloc[i];
+        if(!memaddr->used){
+            memaddr->used = 1;
+            memptr->blk_num = i;
+            memptr->blk_size = blk_size;
+            memptr->phy_addr = memaddr->phy_addr;
+            memptr->virt_addr = memptr->phy_addr;
+            return;
+        }
+    }
+
+    /*look for in the next block if memory is free*/
+    /*start from the first place of the next block*/
+    start = end;
+
+    /*for 1k and 256 size request only 4k can be returned*/
+    end = nextblk4;
+
+    for(i = start;i<end;i++){
+        memaddr = &memalloc[i];
+        if(!memaddr->used){
+            memaddr->used = 1;
+            memptr->blk_num = i;
+            memptr->blk_size = blk_size;
+            memptr->phy_addr = memaddr->phy_addr;
+            memptr->virt_addr = memptr->phy_addr;
+            return;
+        }
+    }
+
+}
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/host/modifications linux-3.13/drivers/armadeus/isp1761/host/modifications
--- linux-3.13/drivers/armadeus/isp1761/host/modifications	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/host/modifications	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,21 @@
+issues:
+20/07/2005
+1. turnaround /timeout when we didnt get the all the data from the device
+  solution: resubmit the td for this case
+  status: done	
+
+2. abborting the transfer and completing mass storage urbs	
+   solution: not to call urb->complete in case of usb_async_unlink flag is set
+   status: done
+
+12/08/2005
+1. reading/writing always 4 bytes in dma.c 
+   solution: read the remaining bytes to be read/written , and if not
+	     multiple of 4 then call appropriately read/write calls
+   status: done
+		
+26/08/2005
+1. transaction/turnaround clear bit when retrying the td
+
+
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/host/otg.c linux-3.13/drivers/armadeus/isp1761/host/otg.c
--- linux-3.13/drivers/armadeus/isp1761/host/otg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/host/otg.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,119 @@
+/********************************************************************
+ * NXP ISP176x Host Controller Interface code file
+ *
+ * (c) 2006 NXP B.V., All rights reserved. <usb.linux@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * File Name: otg.c
+ *
+ * Refering linux kernel version 2.6.9
+ *
+ * History:
+ *
+ * Date                  Author                  Comments
+ * --------------------------------------------------------------------
+ * June 21, 2006          krishan                 Initial version
+ * 
+ **********************************************************************
+ */
+
+#ifdef OTG
+
+/*otg device*/
+struct usb_device *otgdev = 0;
+/*otg hub urb*/
+struct urb    *otgurb;
+
+#define OTG_DEVICE_ADDRESS  (2)
+#define OTG_PORT_NUMBER     (0)
+
+/*return otghub from here*/
+struct usb_device *phci_register_otg_device (struct isp1761_dev *dev)
+{
+    if(otgdev && otgdev->devnum == 0x2)
+        return otgdev;
+
+    return NULL;        
+}
+
+/*suspend the otg port(0)
+ * needed when port is switching
+ * from host to device
+ * */
+int
+phci_suspend_otg_port(struct isp1761_dev *dev,
+        u32   command)
+{
+    int status = 0;
+    otgdev->otgstate = USB_OTG_SUSPEND;
+    if(otgurb->status == -EINPROGRESS)
+        otgurb->status = 0;
+
+    /*complete the urb*/
+    otgurb->complete(otgurb,NULL);      
+
+    /*reset the otghub urb status*/
+    otgurb->status = -EINPROGRESS;
+    g_1761_enum_complete=0;
+    return status;
+}
+
+/*set the flag to enumerate the device*/
+int
+phci_enumerate_otg_port(struct isp1761_dev *dev,
+        u32 command)
+{
+    /*set the flag to enumerate*/
+    /*connect change interrupt will happen from
+     * phci_intl_worker only
+     * */
+    otgdev->otgstate = USB_OTG_ENUMERATE;
+    if(otgurb->status == -EINPROGRESS)
+        otgurb->status = 0;
+    /*complete the urb*/
+    otgurb->complete(otgurb,NULL);
+    /*reset the otghub urb status*/
+    otgurb->status = -EINPROGRESS;
+    while(1)
+    {
+        if(g_1761_enum_complete == 1)
+            break;
+    }
+    g_1761_enum_complete=0;
+    return 0;
+}
+
+/*host controller resume sequence at otg port*/
+int
+phci_resume_otg_port(struct isp1761_dev *dev,
+        u32   command)
+{
+    printk("Resume is called\n");
+    otgdev->otgstate = USB_OTG_RESUME;
+    if(otgurb->status == -EINPROGRESS)
+        otgurb->status = 0;
+    /*complete the urb*/
+    otgurb->complete(otgurb,NULL);
+    /*reset the otghub urb status*/
+    otgurb->status = -EINPROGRESS;
+    return 0;
+}
+EXPORT_SYMBOL(phci_register_otg_device);
+EXPORT_SYMBOL(phci_enumerate_otg_port);
+EXPORT_SYMBOL(phci_suspend_otg_port);
+EXPORT_SYMBOL(phci_resume_otg_port);
+#endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/host/pehci.c linux-3.13/drivers/armadeus/isp1761/host/pehci.c
--- linux-3.13/drivers/armadeus/isp1761/host/pehci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/host/pehci.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,3234 @@
+/*******************************************************************************
+ * NXP ISP176x Host Controller Interface code file
+ *
+ * (c) 2006 NXP B.V., All rights reserved. <usb.linux@nxp.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * File Name: pehci.c
+ * 
+ * Refering linux kernel version 2.6.9
+ *
+ * History:     
+ *
+ * Date                  Author                  Comments
+ * -----------------------------------------------------------------------------
+ * June 21, 2005         krishan                  Initial version
+ * July 4, 2005          krishan                  Handling unprotected urbs
+ * Feb 6, 2006           Grant H.                 Added ISO support
+ * April 21, 2006        Grant H.                 Added bug fixes
+ * May 02 2007           Prabhakar                ported to 2.6.20 with 
+ *                                                backward compatibility 
+ *                                                with 2.6.9
+ * Nov 04, 2007          NC (Armadeus)            Add 2.6.23 compatibility
+ * Nov 11, 2008          JB (Armadeus)            Add 2.6.27 compatibility
+ *******************************************************************************
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/usb.h>
+#include <linux/version.h>
+#include <stdarg.h>
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+
+#include "pehci.h"
+#include "../hal/hal_intf.h"
+#include "../hal/isp1761.h"
+
+#define EHCI_TUNE_CERR          3
+#define URB_NO_INTERRUPT        0x0080
+#define EHCI_TUNE_RL_TT         0
+#define EHCI_TUNE_MULT_TT       1
+#define EHCI_TUNE_RL_HS         0
+#define EHCI_TUNE_MULT_HS       1
+
+#ifdef CONFIG_ISO_SUPPORT
+
+#define FALSE 0
+#define TRUE (!FALSE)
+
+extern void * phcd_iso_itd_to_ptd( phci_hcd *hcd,
+        struct ehci_itd *itd,
+        struct urb *urb,
+        void  * ptd
+        );
+
+extern  unsigned long phcd_submit_iso( phci_hcd *hcd,
+	struct usb_host_endpoint *ep,
+        struct urb *urb,
+        unsigned long *status
+        );
+#endif /* CONFIG_ISO_SUPPORT */
+
+#ifdef OTG
+#include "otg.c"
+#endif
+
+/*Enable all other interrupt.*/
+#ifdef MSEC_INT_BASED
+#define INTR_ENABLE_MASK (HC_MSEC_INT /* | HC_EOT_INT | HC_CLKREADY_INT | HC_INTL_INT | HC_ATL_INT | HC_ISO_INT*/)
+#else
+#define INTR_ENABLE_MASK (/*HC_MSEC_INT |*/ HC_INTL_INT | HC_ATL_INT | HC_EOT_INT /*| HC_ISO_INT*/)
+#endif
+
+/*---------------------------------------------------
+ *    Globals for EHCI 
+ -----------------------------------------------------*/
+
+/* used when updating hcd data */
+static spinlock_t hcd_data_lock = SPIN_LOCK_UNLOCKED;
+
+static const char       hcd_name [] = "ISP1761HCD";
+static td_ptd_map_buff_t td_ptd_map_buff[TD_PTD_TOTAL_BUFF_TYPES];      /* td-ptd map buffer for all 1362 buffers */
+
+static __u8             td_ptd_pipe_x_buff_type[TD_PTD_TOTAL_BUFF_TYPES] = {    
+    TD_PTD_BUFF_TYPE_ATL,                                       
+    TD_PTD_BUFF_TYPE_INTL,                                      
+    TD_PTD_BUFF_TYPE_ISTL                                       
+};
+
+/*global memory blocks*/
+isp1761_mem_addr_t memalloc[BLK_TOTAL];
+#include "mem.c"
+#include "qtdptd.c"
+
+#ifdef CONFIG_ISO_SUPPORT 
+#include "itdptd.c"
+#endif /* CONFIG_ISO_SUPPORT */
+
+static int
+pehci_rh_control (struct usb_hcd *usb_hcd,u16  typeReq,
+        u16 wValue,u16 wIndex,char *buf,u16 wLength);
+
+/*----------------------------------------------------*/
+    static void 
+pehci_complete_device_removal(phci_hcd *hcd,struct ehci_qh *qh)
+{
+    td_ptd_map_t *td_ptd_map;
+    td_ptd_map_buff_t *td_ptd_buff;
+
+    if(qh->type == TD_PTD_BUFF_TYPE_ISTL){
+        return;
+    }
+
+    td_ptd_buff = &td_ptd_map_buff[qh->type];
+    td_ptd_map = &td_ptd_buff->map_list[qh->qtd_ptd_index];
+
+    /*this flag should only be set when device is going*/
+    td_ptd_map->state = TD_PTD_REMOVE;
+    /*if nothing there*/
+    if(list_empty(&qh->qtd_list)){
+        if(td_ptd_map->state != TD_PTD_NEW){
+            phci_hcd_release_td_ptd_index(qh);
+        }
+        qha_free(qha_cache, qh);
+        qh = 0;
+        return;
+    }
+    /*MUST not come down below this*/
+    err("Never Error: Should not come to this portion of code\n");    
+
+    return;
+}
+
+/*functions looks for the values in register
+  specified in ptr, if register values masked
+  with the mask and result is equal to done,
+  operation is successful else fails with timeout*/
+    static int
+pehci_hcd_handshake (phci_hcd *hcd,u32 ptr,u32 mask,u32 done,int usec)
+{
+    u32 result = 0;
+    do {
+        result = isp1761_reg_read32(hcd->dev,ptr,result);
+        if (result == ~(u32)0)          /* card removed */
+            return -ENODEV;
+        result &= mask;
+        if (result == done)
+            return 0;
+        udelay (1);
+        usec--;
+    } while (usec > 0);
+    return -ETIMEDOUT;
+}
+
+#ifndef MSEC_INT_BASED
+/*schedule atl and interrupt tds,
+  only when we are not running on sof interrupt
+ */
+    static void
+pehci_hcd_td_ptd_submit_urb(phci_hcd *hcd,struct ehci_qh *qh,u8 bufftype)
+{
+    unsigned long flags;
+    struct ehci_qtd *qtd = 0;
+    struct urb *urb = 0;
+    struct _isp1761_qha *qha = 0;
+    u32 location  = 0;
+    u32 skipmap = 0;
+    u32 buffstatus = 0;
+    u32 ormask = 0;
+    u32 intormask = 0;
+    u32 length = 0;
+    struct list_head *head;
+
+    td_ptd_map_t        *td_ptd_map;
+    td_ptd_map_buff_t *ptd_map_buff;
+    struct isp1761_mem_addr *mem_addr = 0;
+
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+    pehci_print("Buuffer type %d\n",bufftype);
+
+    spin_lock_irqsave(&hcd->lock, flags);
+    ptd_map_buff = &td_ptd_map_buff[bufftype];
+    qha = &hcd->qha;
+    switch(bufftype){
+        case TD_PTD_BUFF_TYPE_ATL:
+            skipmap = isp1761_reg_read32(hcd->dev, hcd->regs.atltdskipmap, skipmap);
+            ormask = isp1761_reg_read32(hcd->dev, hcd->regs.atl_irq_mask_or, ormask);
+            break;
+        case TD_PTD_BUFF_TYPE_INTL:
+            skipmap = isp1761_reg_read32(hcd->dev, hcd->regs.inttdskipmap, skipmap);
+            intormask = isp1761_reg_read32(hcd->dev, hcd->regs.int_irq_mask_or,intormask);
+            break;
+        default:
+            skipmap = isp1761_reg_read32(hcd->dev, hcd->regs.isotdskipmap, skipmap);
+            break;
+
+    }
+
+    buffstatus = isp1761_reg_read32(hcd->dev,hcd->regs.buffer_status,buffstatus);
+
+    /*header, qtd, and urb of current transfer*/
+    location = qh->qtd_ptd_index;
+    td_ptd_map = &ptd_map_buff->map_list[location];
+
+    if(!(qh->qh_state & QH_STATE_TAKE_NEXT)){
+        pehci_check("qh will schdule from interrupt routine,map %x\n",td_ptd_map->ptd_bitmap);
+        spin_unlock_irqrestore(&hcd->lock, flags);
+        return;
+    }
+    head = &qh->qtd_list;
+    qtd = list_entry(head->next, struct ehci_qtd, qtd_list);
+
+    /*already scheduled??????, may be from interrupt*/
+    if(!(qtd->state & QTD_STATE_NEW)){
+        pehci_check("qtd already in, state %x\n",qtd->state);
+        spin_unlock_irqrestore(&hcd->lock, flags);
+        return;
+    }
+
+    qtd->state &= ~QTD_STATE_NEW;
+    qtd->state |= QTD_STATE_SCHEDULED;
+
+    qh->qh_state &= ~QH_STATE_TAKE_NEXT;
+    /*take the first td*/
+    td_ptd_map->qtd = qtd;
+    /*take the urb*/
+    urb = qtd->urb;
+    ptd_map_buff->active_ptds++;
+
+    /*trust the atl worker, at this location there wont be any td*/
+    /*if this td is the last one*/
+    if(qtd->state & QTD_STATE_LAST){
+        qh->hw_current = cpu_to_le32(0);
+        /*else update the hw_next of qh to the next td*/
+    }else{
+        qh->hw_current = qtd->hw_next;
+    }
+    memset(qha, 0, sizeof( isp1761_qha));
+
+    pehci_check("td being scheduled : length: %d, device: %d, map: %x\n", qtd->length,urb->dev->devnum, td_ptd_map->ptd_bitmap);
+    /*NEW, now need to get the memory for this transfer*/
+    length = qtd->length;
+    mem_addr = &qtd->mem_addr;
+    phci_hcd_mem_alloc(length,mem_addr,0);
+    if(length && ((mem_addr->phy_addr == 0 )
+                || (mem_addr->virt_addr == 0))){
+        err("Never Error: Can not allocate memory for the current td,length %d\n",length);
+        /*should not happen*/
+        /*can happen only when we exceed the limit of devices we support
+          MAX 4 mass storage at a time*/        
+    }   
+    phci_hcd_qha_from_qtd(hcd,qtd,qtd->urb, (void *)qha,
+            td_ptd_map->ptd_ram_data_addr,
+            qh
+            /*td_ptd_map->datatoggle*/);
+    if(qh->type == TD_PTD_BUFF_TYPE_INTL){
+        phci_hcd_qhint_schedule(hcd, qh,qtd,(isp1761_qhint *)qha,qtd->urb);
+    }
+    /*write qha into the header of the host controller*/
+    isp1761_mem_write(hcd->dev, td_ptd_map->ptd_header_addr,0,(u32 *)(qha),PHCI_QHA_LENGTH,0);
+
+    /*if this is SETUP/OUT token , then need to write into the buffer*/
+    /*length should be valid and supported by the ptd*/
+    if(qtd->length && (qtd->length <= HC_ATL_PL_SIZE))
+        switch(PTD_PID(qha->td_info2)){
+            case OUT_PID:
+            case SETUP_PID:
+                isp1761_mem_write(hcd->dev,(u32)mem_addr->phy_addr,0,(le32_to_cpu(qtd->hw_buf[0])),length,0);
+                break;
+        }
+
+    /*unskip the tds at this location*/
+    switch(bufftype){
+        case TD_PTD_BUFF_TYPE_ATL:
+            skipmap &= ~td_ptd_map->ptd_bitmap;
+            /*enable atl interrupts on donemap*/
+            ormask |=  td_ptd_map->ptd_bitmap;
+            isp1761_reg_write32(hcd->dev, hcd->regs.atl_irq_mask_or, ormask);
+            break;
+
+        case TD_PTD_BUFF_TYPE_INTL:
+            skipmap &= ~td_ptd_map->ptd_bitmap;
+            intormask |= td_ptd_map->ptd_bitmap;
+            isp1761_reg_write32(hcd->dev, hcd->regs.int_irq_mask_or, intormask);
+            break;
+
+        case TD_PTD_BUFF_TYPE_ISTL:
+            skipmap &= ~td_ptd_map->ptd_bitmap;
+            isp1761_reg_write32(hcd->dev, hcd->regs.isotdskipmap, skipmap);
+            break;
+    }
+
+    /*if any new schedule, enable the atl buffer*/
+    switch(bufftype){
+        case TD_PTD_BUFF_TYPE_ATL:
+            isp1761_reg_write32(hcd->dev, hcd->regs.buffer_status, buffstatus | ATL_BUFFER);
+            isp1761_reg_write32(hcd->dev, hcd->regs.atltdskipmap, skipmap);
+            buffstatus |= ATL_BUFFER;
+            break;
+        case TD_PTD_BUFF_TYPE_INTL:
+            isp1761_reg_write32(hcd->dev, hcd->regs.buffer_status, buffstatus | INT_BUFFER);
+            isp1761_reg_write32(hcd->dev, hcd->regs.inttdskipmap, skipmap);
+            break;
+        case TD_PTD_BUFF_TYPE_ISTL:
+            /*not supposed to be seen here*/
+            isp1761_reg_write32(hcd->dev, hcd->regs.buffer_status, buffstatus | ISO_BUFFER);
+            break;
+    }
+    spin_unlock_irqrestore(&hcd->lock, flags);
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+    return;
+
+}
+#endif
+
+/*schedule next (atl/int)tds and any pending tds*/
+    static void
+pehci_hcd_schedule_pending_ptds(phci_hcd *hcd,u32 donemap,u8 bufftype,u16 only)
+{
+    struct ehci_qtd *qtd = 0;
+    struct ehci_qh  *qh = 0;
+    struct list_head *qtd_list = 0;
+    struct _isp1761_qha allqha;
+    struct _isp1761_qha *qha = 0;
+    u32 mask = 0x1, index = 0;
+    u32 location  = 0;
+    u32 skipmap = 0;
+    u32    newschedule = 0;
+    u32 buffstatus = 0;
+    u32 schedulemap = 0;
+#ifndef CONFIG_ISO_SUPPORT
+    u32 lasttd = 1;
+#endif
+    u32 lastmap = 0;
+    struct urb *urb = 0;
+    urb_priv_t *urbpriv = 0;    
+    int length = 0;
+    u32 ormask = 0,andmask = 0;
+    u32 intormask = 0;
+    td_ptd_map_t        *td_ptd_map;
+    td_ptd_map_buff_t *ptd_map_buff;
+    struct isp1761_mem_addr *mem_addr = 0;
+
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+    pehci_print("Buffer type %d\n", bufftype);
+
+    /*need to hold this lock if another interrupt is comming
+      for previously scheduled transfer, while scheduling new tds
+     */
+    spin_lock(&hcd_data_lock);
+    ptd_map_buff = &td_ptd_map_buff[bufftype];
+    qha  = &allqha;
+    switch(bufftype){
+        case TD_PTD_BUFF_TYPE_ATL:
+            skipmap = isp1761_reg_read32(hcd->dev, hcd->regs.atltdskipmap, skipmap);
+            rmb();
+            ormask = isp1761_reg_read32(hcd->dev, hcd->regs.atl_irq_mask_or, ormask);
+            andmask = isp1761_reg_read32(hcd->dev, hcd->regs.atl_irq_mask_and, andmask);
+            break;
+        case TD_PTD_BUFF_TYPE_INTL:
+            skipmap = isp1761_reg_read32(hcd->dev, hcd->regs.inttdskipmap, skipmap);
+            /*read the interrupt mask registers*/
+            intormask = isp1761_reg_read32(hcd->dev, hcd->regs.int_irq_mask_or,intormask);
+            break;
+        default:
+            err("Never Error: Bogus type of bufer\n");
+            return;
+    }
+
+
+    buffstatus = isp1761_reg_read32(hcd->dev,hcd->regs.buffer_status,buffstatus);
+    /*td headers need attention*/
+    schedulemap = donemap;
+    while(schedulemap){
+        index = schedulemap & mask;
+        schedulemap &= ~mask;
+        mask <<= 1;
+
+        if(!index){
+            location++;
+            continue;
+        }
+
+        td_ptd_map = &ptd_map_buff->map_list[location];
+        /*      can happen if donemap comes after
+                removal of the urb and associated tds
+         */
+        if((td_ptd_map->state ==  TD_PTD_NEW) || 
+                (td_ptd_map->state == TD_PTD_REMOVE)){
+            qh = td_ptd_map->qh;
+            pehci_check("should not come here, map %x,pending map %x\n", td_ptd_map->ptd_bitmap,
+                    ptd_map_buff->pending_ptd_bitmap);
+
+            pehci_check("buffer type %s\n", (bufftype == 0)?"ATL":"INTL");      
+            donemap &= ~td_ptd_map->ptd_bitmap;
+            /*clear the pending map*/
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            location++;
+            continue;
+        }
+
+        /*no endpoint at this location*/
+        if(!(td_ptd_map->qh)){
+            err("queue head can not be null here\n");
+            /*move to the next location*/
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            location++;
+            continue;
+        }
+
+        /*current endpoint*/
+        qh = td_ptd_map->qh;
+        if(!(skipmap & td_ptd_map->ptd_bitmap)){
+            /*should not happen, if happening, then*/
+            pehci_check("buffertype %d,td_ptd_map %x,skipnap %x\n",
+                    bufftype, td_ptd_map->ptd_bitmap,skipmap);
+            lastmap = td_ptd_map->ptd_bitmap;
+            donemap &= ~td_ptd_map->ptd_bitmap;
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            location++;
+            continue;
+        }
+
+        /*if we processed all the tds in ths transfer*/
+        if(td_ptd_map->lasttd){
+            err("should not show  map %x,qtd %p\n", td_ptd_map->ptd_bitmap,td_ptd_map->qtd);
+            /*this can happen in case the transfer is not being
+             * procesed by the host , tho the transfer is there
+             * */
+            qh->hw_current = cpu_to_le32(td_ptd_map->qtd);
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            location++;
+            continue;
+        }
+
+        /*if we have ptd that is going for reload*/
+        if((td_ptd_map->qtd) && (td_ptd_map->state & TD_PTD_RELOAD)){
+            warn("%s: reload td\n",__FUNCTION__);
+            td_ptd_map->state &= ~TD_PTD_RELOAD;
+            qtd = td_ptd_map->qtd;
+            goto loadtd;
+        }
+
+        /* qh is there but no qtd so it means fresh transfer*/
+        if((td_ptd_map->qh) && !(td_ptd_map->qtd)){
+            if(list_empty(&qh->qtd_list)){
+                /*should not hapen again, as it comes here
+                  when it has td in its map
+                 */     
+                pehci_check("must not come here any more, td map %x\n",td_ptd_map->ptd_bitmap);
+                /*this location is idle and can be free next time if
+                  no new transfers are comming for this*/
+                donemap &= ~td_ptd_map->ptd_bitmap;
+                td_ptd_map->state |= TD_PTD_IDLE;
+                ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+                location++;
+                continue;
+            }
+            qtd_list = &qh->qtd_list;
+            qtd = td_ptd_map->qtd =     list_entry(qtd_list->next, struct ehci_qtd, qtd_list);
+            /*got the td, now goto reload*/
+            goto loadtd;
+        }
+
+        /*if there is already one qtd there in the transfer*/
+        if(td_ptd_map->qtd){
+            /*new schedule*/
+            qtd = td_ptd_map->qtd;      
+        }
+loadtd:
+        /*should not happen*/
+        if(!qtd){
+            err("this piece of code should not be executed\n");
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            location++;
+            continue;
+        }
+
+        ptd_map_buff->active_ptds++;
+        /*clear the pending map here*/
+        ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+
+
+
+        /*if this td is the last one*/
+        if(qtd->state & QTD_STATE_LAST){
+            /*no qtd anymore*/
+            qh->hw_current = cpu_to_le32(0);
+
+            /*else update the hw_next of qh to the next td*/
+        }else{
+            qh->hw_current = qtd->hw_next;
+        }
+
+        if(location != qh->qtd_ptd_index){
+            err("Never Error: Endpoint header location and scheduling information are not same\n");
+        }
+
+        /*next location*/
+        location++;
+        /*found new transfer*/
+        newschedule = 1;
+        /*take the urb*/
+        urb = qtd->urb;
+        /*sometimes we miss due to skipmap
+          so to make sure that we dont put again the 
+          same stuff
+         */
+        if(!(qtd->state & QTD_STATE_NEW))
+        {    
+            err("Never Error: We should not put the same stuff\n");
+            continue;
+        }
+
+        urbpriv = (urb_priv_t*)urb->hcpriv;
+        urbpriv->timeout = 0;   
+
+        /*no more new*/
+        qtd->state &= ~QTD_STATE_NEW;
+        qtd->state |= QTD_STATE_SCHEDULED;
+
+
+
+        /*NEW, now need to get the memory for this transfer*/
+        length = qtd->length;
+        mem_addr = &qtd->mem_addr;
+        phci_hcd_mem_alloc(length,mem_addr,0);
+        if(length && (
+                    (mem_addr->phy_addr == 0 )
+                    || (mem_addr->virt_addr == 0))){
+
+            err("Never Error: Can not allocate memory for the current td,length %d\n",length);
+            location++;
+            continue;
+        }       
+
+        pehci_check("qtd being scheduled %p, device %d,map %x\n", qtd,urb->dev->devnum,td_ptd_map->ptd_bitmap);
+
+
+        memset(qha, 0, sizeof(isp1761_qha));
+        /*convert qtd to qha*/
+        phci_hcd_qha_from_qtd(hcd,qtd,qtd->urb, (void *)qha,
+                td_ptd_map->ptd_ram_data_addr,
+                qh
+                /*td_ptd_map->datatoggle*/);
+
+        if(qh->type == TD_PTD_BUFF_TYPE_INTL){
+            phci_hcd_qhint_schedule(hcd, qh,qtd,(isp1761_qhint *)qha,qtd->urb);
+
+        }
+
+
+        length = PTD_XFERRED_LENGTH(qha->td_info1 >> 3);
+        if(length > HC_ATL_PL_SIZE){
+            err("Never Error: Bogus length,length %d(max %d)\n",qtd->length, HC_ATL_PL_SIZE);
+        }
+
+        /*write qha into the header of the host controller*/
+        isp1761_mem_write(hcd->dev, td_ptd_map->ptd_header_addr,0,(u32 *)(qha),PHCI_QHA_LENGTH,0);
+        /*if this is SETUP/OUT token , then need to write into the buffer*/
+        /*length should be valid*/
+        if(qtd->length && ( length <= HC_ATL_PL_SIZE))
+            switch(PTD_PID(qha->td_info2)){
+                case OUT_PID:
+                case SETUP_PID:
+                    isp1761_mem_write(hcd->dev,(u32)mem_addr->phy_addr,0,(void*)(le32_to_cpu(qtd->hw_buf[0])),length,0);
+                    break;
+            }
+
+        /*unskip the tds at this location*/
+        switch(bufftype){
+            case TD_PTD_BUFF_TYPE_ATL:
+                skipmap &= ~td_ptd_map->ptd_bitmap;
+                lastmap = td_ptd_map->ptd_bitmap;
+                /*try to reduce the interrupts*/
+                ormask |= td_ptd_map->ptd_bitmap;
+                isp1761_reg_write32(hcd->dev, hcd->regs.atl_irq_mask_or, ormask);
+                break;
+
+            case TD_PTD_BUFF_TYPE_INTL:
+                skipmap &= ~td_ptd_map->ptd_bitmap;
+                lastmap = td_ptd_map->ptd_bitmap;
+                intormask |= td_ptd_map->ptd_bitmap;
+                isp1761_reg_write32(hcd->dev, hcd->regs.int_irq_mask_or,intormask);
+                break;
+
+            case TD_PTD_BUFF_TYPE_ISTL:
+#ifdef CONFIG_ISO_SUPPORT
+                iso_dbg(ISO_DBG_INFO,"Never Error: Should not come here\n");
+#else
+                skipmap &= ~td_ptd_map->ptd_bitmap;
+                isp1761_reg_write32(hcd->dev, hcd->regs.isotdskipmap, skipmap);
+                isp1761_reg_write32(hcd->dev, hcd->regs.isotdlastmap,lasttd/*td_ptd_map->ptd_bitmap*/);
+#endif /* CONFIG_ISO_SUPPORT */
+                break;
+        }
+
+
+    }
+    /*if any new schedule, enable the atl buffer*/
+
+    if(newschedule){
+        switch(bufftype){
+            case TD_PTD_BUFF_TYPE_ATL:
+                isp1761_reg_write32(hcd->dev, hcd->regs.buffer_status, buffstatus | ATL_BUFFER);
+                /*i am comming here to only those tds that has to be scheduled*/
+                /*so skip map must be in place*/
+                if(skipmap & donemap){
+                    pehci_check("must be both ones compliment of each other\n");
+                    pehci_check("problem, skipmap %x, donemap %x,\n",skipmap,donemap);
+
+                }
+                skipmap &= ~donemap;
+                isp1761_reg_write32(hcd->dev, hcd->regs.atltdskipmap, skipmap);
+
+                break;
+            case TD_PTD_BUFF_TYPE_INTL:
+                isp1761_reg_write32(hcd->dev, hcd->regs.buffer_status, buffstatus | INT_BUFFER);
+                skipmap &= ~donemap;
+                isp1761_reg_write32(hcd->dev, hcd->regs.inttdskipmap, skipmap);
+                break;
+            case TD_PTD_BUFF_TYPE_ISTL:
+#ifndef CONFIG_ISO_SUPPORT
+                isp1761_reg_write32(hcd->dev, hcd->regs.buffer_status, buffstatus | ISO_BUFFER);
+#endif
+                break;
+        }
+    }
+    spin_unlock(&hcd_data_lock);
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+}
+
+static void
+pehci_hcd_qtd_schedule(phci_hcd *hcd,struct ehci_qtd *qtd,
+        struct ehci_qh *qh,td_ptd_map_t *td_ptd_map)
+{
+
+    struct urb *urb;
+    urb_priv_t *urbpriv  = 0;
+    u32 length;
+    struct isp1761_mem_addr *mem_addr = 0;
+    struct _isp1761_qha *qha, qhtemp;
+
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+
+    /*redundant*/
+    qha = &qhtemp;
+
+    /*if this td is the last one*/
+    if(qtd->state & QTD_STATE_LAST){
+        /*no qtd anymore*/
+        qh->hw_current = cpu_to_le32(0);
+
+        /*else update the hw_next of qh to the next td*/
+    }else{
+        qh->hw_current = qtd->hw_next;
+    }
+
+    urb = qtd->urb;
+    urbpriv = (urb_priv_t*)urb->hcpriv;
+    urbpriv->timeout = 0;       
+
+    /*NEW, now need to get the memory for this transfer*/
+    length = qtd->length;
+    mem_addr = &qtd->mem_addr;
+    phci_hcd_mem_alloc(length,mem_addr,0);
+    if(length && (
+                (mem_addr->phy_addr == 0 )
+                || (mem_addr->virt_addr == 0))){
+        err("Never Error: Cannot allocate memory for the current td,length %d\n",length);
+        return;
+    }   
+
+    pehci_check("newqtd being scheduled, device: %d,map: %x\n", urb->dev->devnum,td_ptd_map->ptd_bitmap);
+
+    memset(qha, 0, sizeof(isp1761_qha));
+    /*convert qtd to qha*/
+    phci_hcd_qha_from_qtd(hcd,qtd,qtd->urb, (void *)qha,
+            td_ptd_map->ptd_ram_data_addr,
+            qh
+            /*td_ptd_map->datatoggle*/);
+
+    if(qh->type == TD_PTD_BUFF_TYPE_INTL){
+        phci_hcd_qhint_schedule(hcd, qh,qtd,(isp1761_qhint *)qha,qtd->urb);
+    }
+
+
+    length = PTD_XFERRED_LENGTH(qha->td_info1 >> 3);
+    if(length > HC_ATL_PL_SIZE){
+        err("Never Error: Bogus length,length %d(max %d)\n",qtd->length, HC_ATL_PL_SIZE);
+    }
+
+    /*write qha into the header of the host controller*/
+    isp1761_mem_write(hcd->dev, td_ptd_map->ptd_header_addr,0,(u32 *)(qha),PHCI_QHA_LENGTH,0);
+    /*if this is SETUP/OUT token , then need to write into the buffer*/
+    /*length should be valid*/
+    if(qtd->length && ( length <= HC_ATL_PL_SIZE))
+        switch(PTD_PID(qha->td_info2)){
+            case OUT_PID:
+            case SETUP_PID:
+                isp1761_mem_write(hcd->dev, (u32)mem_addr->phy_addr, 0,(void*)(le32_to_cpu(qtd->hw_buf[0])),length,0);
+                break;
+        }
+
+    /*qtd is scheduled*/
+    qtd->state &= ~QTD_STATE_NEW;
+    qtd->state |= QTD_STATE_SCHEDULED;
+
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+    return;
+}
+
+
+
+static void 
+pehci_hcd_urb_complete(phci_hcd *hcd,struct ehci_qh *qh, struct urb *urb, 
+        td_ptd_map_t    *td_ptd_map)
+{
+
+    static u32 remove  = 0;
+    urb_priv_t *urb_priv = (urb_priv_t *)urb->hcpriv;
+
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+    pehci_check("complete the td , length: %d\n", td_ptd_map->qtd->length);
+    urb_priv->timeout = 0;
+
+    if((td_ptd_map->state == TD_PTD_REMOVE) ||
+            (urb_priv->state == DELETE_URB)    ||
+            !HCD_IS_RUNNING(hcd->state))
+        remove = 1;
+
+    qh->qh_state = QH_STATE_COMPLETING;
+    /*remove the done tds*/
+    spin_lock(&hcd_data_lock);
+    phci_hcd_urb_free_priv(hcd, urb_priv,qh);
+    spin_unlock(&hcd_data_lock);
+
+    urb_priv->timeout = 0;
+    kfree(urb_priv);
+    urb->hcpriv = 0;
+
+
+    /*if normal completion???*/
+    if(urb->status == -EINPROGRESS)
+        urb->status = 0;
+
+    spin_unlock(&hcd->lock);
+    usb_hcd_giveback_urb (&hcd->usb_hcd, urb, urb->status);
+    spin_lock(&hcd->lock);
+
+    /*lets handle to the remove case*/
+    if(remove){
+        remove  = 0;
+        if(list_empty(&qh->qtd_list)){
+            pehci_check("no transfers anymore, free the endpoint\n");
+            phci_hcd_release_td_ptd_index(qh);
+        }
+    }
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+}
+
+/*update the error status of the td*/
+    static void
+pehci_hcd_update_error_status(u32 ptdstatus,struct urb *urb)
+{
+    /*if ptd status is halted*/
+    if(ptdstatus & PTD_STATUS_HALTED){
+        if(ptdstatus & PTD_XACT_ERROR){
+            /*transaction error results due to retry count goes to zero*/
+            if(PTD_RETRY(ptdstatus)){
+                /*halt the endpoint*/
+                pehci_check("transaction error , retries %d\n", PTD_RETRY(ptdstatus));
+                urb->status = -EPIPE;}
+            else {
+                pehci_check("transaction error , retries %d\n", PTD_RETRY(ptdstatus));
+                /*protocol error*/
+                urb->status = -EPROTO;}
+        }
+        else if(ptdstatus & PTD_BABBLE){
+            pehci_check("babble error, qha %x\n", ptdstatus);
+            /*babble error*/
+            urb->status = -EOVERFLOW;}
+        else if(PTD_RETRY(ptdstatus)){
+            pehci_check("endpoint halted with retrie remaining %d\n",PTD_RETRY(ptdstatus));
+            urb->status = -EPIPE;}
+        else { /*unknown error, i will report it as halted, as i will never see xact error bit set*/
+            pehci_check("protocol error, qha %x\n", ptdstatus);
+            urb->status = -EPIPE;}
+
+            /*if halted need to recover*/
+            if (urb->status == -EPIPE) {
+            }
+    }
+}
+
+#ifdef CONFIG_ISO_SUPPORT /* New code for ISO support */
+
+/*******************************************************************
+ * phcd_iso_handler - ISOCHRONOUS Transfer handler
+ *
+ * phci_hcd *hcd,
+ *      Host controller driver structure which contains almost all data
+ *      needed by the host controller driver to process data and interact
+ *      with the host controller.
+ *
+ *
+ * API Description
+ * This is the ISOCHRONOUS Transfer handler, mainly responsible for:
+ *  - Checking the periodic list if there are any ITDs for scheduling or 
+ *    removal.
+ *  - For ITD scheduling, converting an ITD into a PTD, which is the data 
+ *    structure that the host contrtoller can understand and process.
+ *  - For ITD completion, checking the transfer status and performing the 
+ *    required actions depending on status.
+ *  - Freeing up memory used by an ITDs once it is not needed anymore.
+ ************************************************************************/
+void phcd_iso_handler(phci_hcd *hcd)
+{
+    struct _isp1761_isoptd *iso_ptd;
+    struct isp1761_mem_addr *mem_addr;
+    struct ehci_itd *itd, *current_itd; 
+    td_ptd_map_t *td_ptd_map;
+    td_ptd_map_buff_t *ptd_map_buff;
+
+    struct list_head *itd_sched, *itd_remove, *position, *lst_temp;     
+    struct urb *urb;
+
+    unsigned long buff_stat, skip_map;
+    unsigned long last_map;
+    unsigned long frame_num, rmv_frm_num, sched_frm_num;
+    unsigned long uframe_cnt, usof_stat, length;
+    unsigned char schedule, remove, last_td;
+
+    /* Local variable initialization */                 
+    buff_stat = 0;
+    skip_map = 0;
+    frame_num = 0;
+    schedule = FALSE;
+    remove = FALSE;     
+    iso_ptd = &hcd->isotd;
+    last_map = 0;
+
+    /* Check if there are any ITDs scheduled  for processing */
+    if( hcd->periodic_sched == 0 )
+    {
+        return;
+    }
+
+    ptd_map_buff = &(td_ptd_map_buff[TD_PTD_BUFF_TYPE_ISTL]);
+
+    /* Read buffer status register to check later if the ISO buffer is filled or not */
+    buff_stat = isp1761_reg_read32(hcd->dev, hcd->regs.buffer_status, buff_stat);
+
+    /* Read the contents of the ISO skipmap register */
+    skip_map = isp1761_reg_read32(hcd->dev, hcd->regs.isotdskipmap, skip_map);
+
+    /* Read the contents of the ISO lastmap  register */
+    last_map = isp1761_reg_read32(hcd->dev, hcd->regs.isotdlastmap, last_map);
+
+    /* Get also the frame number, which we will use as index into the periodic frame list */
+    frame_num = isp1761_reg_read32(hcd->dev, hcd->regs.frameindex, frame_num);
+
+    /* Bits 0 to 2 are don't care, only bits 3 to 7 are used as index */
+    frame_num &= 0xff;
+    frame_num >>= 3;
+
+    /* Get a copy of the current frame number to adjust it depending on what we will be processing */
+    rmv_frm_num = frame_num;
+    sched_frm_num = frame_num;
+
+    /* For ITD removal, work on the ITD linked to the frame prior to the current frame */
+    if(rmv_frm_num == 0)
+        rmv_frm_num = 31;
+    else
+        rmv_frm_num = rmv_frm_num - 1;
+
+    rmv_frm_num %= PTD_PERIODIC_SIZE;
+
+    /* Process ITDs linked to this frame, checking for completed ITDs */
+    itd_remove = &hcd->periodic_list[rmv_frm_num].itd_head;
+    iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: Removal Frame number: %d\n", (int) rmv_frm_num);            
+
+    /* For ITD scheduling, work on the ITD linked to the frame after the current frame */
+    if(sched_frm_num == 31)
+        sched_frm_num = 0;
+    else
+        sched_frm_num = sched_frm_num + 1;
+
+    sched_frm_num %= PTD_PERIODIC_SIZE;
+
+    /* Process ITDs linked to this frame, checking if there are any that needs to be scheduled */
+    itd_sched = &hcd->periodic_list[sched_frm_num].itd_head;
+    iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: Schedule Frame number: %d\n", (int) sched_frm_num);         
+
+    /* Check if the ITD lists are empty */
+    if( !list_empty(itd_sched))
+    {
+        iso_dbg(ISO_DBG_INFO, "[phcd_iso_handler]: ISO schedule list not empty\n");          
+        schedule = TRUE;
+    }
+    else
+    {
+        iso_dbg(ISO_DBG_INFO, "[phcd_iso_handler]: ISO schedule list empty\n");              
+    }
+
+    if( !list_empty(itd_remove))
+    {
+        iso_dbg(ISO_DBG_INFO, "[phcd_iso_handler]: ISO remove list not empty\n");            
+        remove = TRUE;
+    }
+    else
+    {
+        iso_dbg(ISO_DBG_INFO, "[phcd_iso_handler]: ISO remove list empty\n");                
+    }
+
+    if( schedule == TRUE )
+    {
+        iso_dbg(ISO_DBG_INFO, "[phcd_iso_handler]: Something is scheduled\n");               
+        /* There is an ITD to be scheduled, go over and check each ITD in this list */
+        list_for_each(position, itd_sched)
+        {
+            /* Get an ITD in the list for processing */
+            itd = list_entry(position, struct ehci_itd, itd_list);
+
+            iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: ITD Index: %d\n", itd->itd_index);            
+            /* Get the PTD allocated for this ITD. */                   
+            td_ptd_map = &ptd_map_buff->map_list[itd->itd_index];
+            memset(iso_ptd, 0, sizeof(struct _isp1761_isoptd));                 
+
+            /* Create a PTD from an ITD*/
+            phcd_iso_itd_to_ptd( hcd,
+                    itd,
+                    itd->urb,
+                    (void *) iso_ptd
+                    );
+
+            /* Indicate that this ITD's PTD have been filled up */
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+
+            /*
+             * Place the newly initialized ISO PTD structure into the location allocated 
+             * for this PTD in the ISO PTD memory region.
+             */
+            isp1761_mem_write( hcd->dev,
+                    td_ptd_map->ptd_header_addr,
+                    0,
+                    (__u32 *) iso_ptd,
+                    PHCI_QHA_LENGTH,
+                    0
+                    );
+
+            /* 
+             * Set this flag to avoid unlinking before schedule
+             * at particular frame number
+             */
+            td_ptd_map->state = TD_PTD_IN_SCHEDULE;
+
+            /* 
+             * If the length is not zero and the direction is OUT then copy the
+             * data to be transferred into the PAYLOAD memory area.
+             */
+            if(itd->length)
+            {
+                switch(PTD_PID(iso_ptd->td_info2)) 
+                {
+                    case OUT_PID:                                       
+                        /* Get the Payload memory allocated for this PTD */
+                        mem_addr = &itd->mem_addr;
+                        isp1761_mem_write( hcd->dev,
+                                (unsigned long )mem_addr->phy_addr,
+                                0,
+                                (__u32 *) (le32_to_cpu(itd->hw_bufp[0])),
+                                itd->length,
+                                0
+                                );
+                        break;
+                } /* switch(PTD_PID(iso_ptd->td_info2)) */
+            } /* if(itd->length) */
+
+            /* If this is the last td, indicate to complete the URB */
+            if(itd->hw_next == EHCI_LIST_END)
+                td_ptd_map->lasttd = 1;
+
+            /*
+             * Clear the bit corresponding to this PTD in the skip map so that it will be
+             * processed on the next schedule traversal.
+             */
+            skip_map &= ~td_ptd_map->ptd_bitmap;                
+
+            iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: Skip Map: 0x%08x\n", (unsigned int) skip_map);
+            isp1761_reg_write32(hcd->dev, hcd->regs.isotdskipmap, skip_map);
+
+            /* 
+             * Update the last map register to indicate that the newly created PTD is the 
+             * last PTD added only if it is larger than the previous bitmap.
+             */                 
+            if(last_map < td_ptd_map->ptd_bitmap)
+            {
+                isp1761_reg_write32(hcd->dev, hcd->regs.isotdlastmap, td_ptd_map->ptd_bitmap);
+                iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: Last Map: 0x%08x\n", td_ptd_map->ptd_bitmap);     
+            }
+
+            /*
+             * Set the ISO_BUF_FILL bit to 1 to indicate that there is a PTD for ISO that needs to
+             * be processed.
+             */
+            iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: Buffer Status: 0x%08x\n", (unsigned int) (buff_stat | ISO_BUFFER));
+            isp1761_reg_write32(hcd->dev, hcd->regs.buffer_status, (buff_stat | ISO_BUFFER));
+        } /* list_for_each(position, itd_sched) */      
+
+        iso_dbg(ISO_DBG_INFO, "[phcd_iso_handler]: ISO-Frame scheduling done\n");
+    } /* if( schedule == TRUE ) */
+
+    if( remove == TRUE)
+    {
+        iso_dbg(ISO_DBG_INFO, "[phcd_iso_handler]: Something is for removal\n");             
+        list_for_each_safe(position, lst_temp, itd_remove)
+        {
+            last_td = FALSE;
+
+            /* Get an ITD in the list for processing */
+            itd = list_entry(position, struct ehci_itd, itd_list);
+
+            /* Get the PTD that was allocated for this particular ITD. */
+            td_ptd_map = &ptd_map_buff->map_list[itd->itd_index];
+
+            iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: ITD Index: %d\n", itd->itd_index);            
+            urb = itd->urb;
+
+            /*
+             * Get the base address of the memory allocated in the
+             * PAYLOAD region for this ITD
+             */
+            mem_addr = &itd->mem_addr;
+            memset(iso_ptd, 0, sizeof(struct _isp1761_isoptd));
+
+            /* 
+             * Read this ptd from the ram address,address is in the
+             * td_ptd_map->ptd_header_addr
+             */
+            isp1761_mem_read( hcd->dev, 
+                    td_ptd_map->ptd_header_addr,
+                    0,
+                    (__u32 *) iso_ptd,
+                    PHCI_QHA_LENGTH,
+                    0
+                    );
+
+            iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: DWORD0 = 0x%08x\n", iso_ptd->td_info1);
+            iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: DWORD1 = 0x%08x\n", iso_ptd->td_info2);
+            iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: DWORD2 = 0x%08x\n", iso_ptd->td_info3);
+            iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: DWORD3 = 0x%08x\n", iso_ptd->td_info4);
+            iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: DWORD4 = 0x%08x\n", iso_ptd->td_info5);
+            iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: DWORD5 = 0x%08x\n", iso_ptd->td_info6);
+            iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: DWORD6 = 0x%08x\n", iso_ptd->td_info7);
+            iso_dbg(ISO_DBG_DATA, "[phcd_iso_handler]: DWORD7 = 0x%08x\n", iso_ptd->td_info8);
+
+            /* Go over the status of each of the 8 Micro Frames */
+            for( uframe_cnt = 0; uframe_cnt < 8; uframe_cnt++)
+            {
+                /* 
+                 * We go over the status one at a time. The status bits and their
+                 * equivalent status are:
+                 * Bit 0 - Transaction Error (IN and OUT)
+                 * Bit 1 - Babble (IN token only)
+                 * Bit 2 - Underrun (OUT token only)
+                 */
+                usof_stat = iso_ptd->td_info5 >> (8 + (uframe_cnt * 3));
+
+                switch(usof_stat & 0x7) 
+                {
+                    case INT_UNDERRUN:                          
+                        iso_dbg(ISO_DBG_ERR, "[phcd_iso_handler Error]: Buffer underrun\n");         
+                        urb->error_count++;
+                        break;
+                    case INT_EXACT:                                     
+                        iso_dbg(ISO_DBG_ERR, "[phcd_iso_handler Error]: Transaction error\n");               
+                        urb->error_count++;
+                        break;
+                    case INT_BABBLE:                                    
+                        iso_dbg(ISO_DBG_ERR, "[phcd_iso_handler Error]: Babble error\n");            
+                        urb->iso_frame_desc[itd->itd_index].status = -EOVERFLOW;
+                        urb->error_count++;
+                        break;
+                } /* switch(usof_stat & 0x7) */
+            } /* end of for( ulMicroFrmCnt = 0; ulMicroFrmCnt < 8; ulMicroFrmCnt++) */
+
+            /*
+             * Get the number of bytes transferred. This indicates the number of
+             * bytes sent or received for this transaction.
+             */                 
+            if(urb->dev->speed != USB_SPEED_HIGH)
+                /* Length is 1K for full/low speed device */
+                length = PTD_XFERRED_NONHSLENGTH(iso_ptd->td_info4);
+            else
+                /* Length is 32K for high speed device */
+                length = PTD_XFERRED_LENGTH(iso_ptd->td_info4);
+
+            /* Halted, need to finish all the transfer on this endpoint*/
+            if(iso_ptd->td_info4 & PTD_STATUS_HALTED)
+            {
+                iso_dbg(ISO_DBG_ERR, "[phcd_iso_handler Error] PTD Halted\n");
+                /* 
+                 * When there is an error, do not process the other PTDs.
+                 * Stop at the PTD with the error and remove all other PTDs.
+                 */
+                td_ptd_map->lasttd = 1;
+
+                /* 
+                 * In case of halt, next transfer will start with toggle zero,
+                 * USB specs, 5.8.5
+                 */                             
+                td_ptd_map->datatoggle = 0;                             
+            } /* if(iso_ptd->td_info4 & PTD_STATUS_HALTED) */
+
+            /* Update the actual length of the transfer from the data we got earlier */
+            urb->iso_frame_desc[itd->index].actual_length = length;
+
+            /* If the PTD have been executed properly the V bit should be cleared */                    
+            if(iso_ptd->td_info1 & QHA_VALID)
+            {
+                iso_dbg(ISO_DBG_ERR,"[phcd_iso_handler Error]: Valid bit not cleared\n");
+                urb->iso_frame_desc[itd->index].status = -ENOSPC;
+            }
+            else
+            {
+                urb->iso_frame_desc[itd->index].status = 0;
+            }
+
+            /* Check if this is the last ITD either due to some error or normal completion*/
+            if((td_ptd_map->lasttd) ||(itd->hw_next == EHCI_LIST_END))
+            {
+                last_td = TRUE;
+            }
+
+            /* Copy data to/from */
+            if(length && (length <= MAX_PTD_BUFFER_SIZE))
+            {
+                switch(PTD_PID(iso_ptd->td_info2))
+                {
+                    case IN_PID:
+                        /* 
+                         * Get the data from the PAYLOAD area and place it into
+                         * the buffer provided by the requestor.
+                         */
+                        isp1761_mem_read( hcd->dev,
+                                (unsigned long) mem_addr->phy_addr,
+                                0,
+                                (__u32 *)(le32_to_cpu(itd->hw_bufp[0])),
+                                length,
+                                0
+                                );
+                    case OUT_PID:
+                        /* 
+                         * urb->actual length was initialized to zero, so for the first
+                         * uFrame having it incremented immediately is not a problem.
+                         */
+                        urb->actual_length += length;
+                        break;
+                }/* switch(PTD_PID(iso_ptd->td_info2)) */
+            }/* if(length && (length <= MAX_PTD_BUFFER_SIZE)) */
+
+            if( last_td == TRUE )
+            {
+                /* Start removing the ITDs in the list */
+                while(1)
+                {                                       
+                    /* 
+                     * This indicates that we are processing the tail PTD.
+                     * Perform cleanup procedure on this last PTD
+                     */
+                    if(itd->hw_next == EHCI_LIST_END) 
+                    {
+                        td_ptd_map = &ptd_map_buff->map_list[itd->itd_index];
+
+                        /* 
+                         * Free up our allocation in the PAYLOAD area so that others can use 
+                         * it.
+                         */
+                        phci_hcd_mem_free(&itd->mem_addr);
+
+                        /* Remove this ITD entry in the ITD list */
+                        list_del(&itd->itd_list);
+
+                        /* Free up the memory allocated for the ITD structure */
+                        qha_free(qha_cache, itd);
+
+                        /* Indicate that the PTD we have used is now free */    
+                        td_ptd_map->state = TD_PTD_NEW;
+
+                        /* Decrease the number of active PTDs scheduled*/
+                        hcd->periodic_sched --;
+
+                        /* Skip this PTD during the next PTD processing. */
+                        skip_map |= td_ptd_map->ptd_bitmap;
+                        isp1761_reg_write32(hcd->dev, hcd->regs.isotdskipmap, skip_map);
+
+                        /* All ITDs in this list have been successfully removed. */
+                        break;
+                    } /* if(itd->hw_next == EHCI_LIST_END) */
+
+                    /* 
+                     * This indicates that we stopped due to an error on a PTD that is
+                     * not the last in the list. We need to free up this PTD as well as 
+                     * the PTDs after it.
+                     */
+                    else
+                    {
+                        /* 
+                         * Put the current ITD error onto this variable.
+                         * We will be unlinking this from the list and free up its
+                         * resources later.
+                         */
+                        current_itd = itd;
+
+                        td_ptd_map = &ptd_map_buff->map_list[itd->itd_index];
+
+                        /* 
+                         * Get the next ITD, and place it to the itd variable.
+                         * In a way we are moving forward in the ITD list.
+                         */
+                        itd = (struct ehci_itd *)le32_to_cpu(current_itd->hw_next);
+
+                        /* Free up the current ITD's resources */
+                        phci_hcd_mem_free(&current_itd->mem_addr);
+
+                        /* Remove this ITD entry in the ITD list */
+                        list_del(&current_itd->itd_list);
+
+                        /* Free up the memory allocated for the ITD structure */
+                        qha_free(qha_cache,current_itd);
+
+                        /* Inidicate that the PTD we have used is now free */
+                        td_ptd_map->state = TD_PTD_NEW;
+
+                        /* Decrease the number of active PTDs scheduled*/
+                        hcd->periodic_sched --;
+
+                        /* Sine it is done, skip this PTD during the next PTD processing. */
+                        skip_map |= td_ptd_map->ptd_bitmap;
+                        isp1761_reg_write32(hcd->dev, hcd->regs.isotdskipmap, skip_map);
+
+                        /* 
+                         * Start all over again until it gets to the tail of the 
+                         * list of PTDs/ITDs 
+                         */
+                        continue;
+                    } /* else of if(itd->hw_next == EHCI_LIST_END) */
+
+                    /* It should never get here, but I put this as a precaution */
+                    break;
+                } /* end of while(1) */
+
+                /* Check if there were ITDs that were not processed due to the error */
+                if(urb->status == -EINPROGRESS)
+                {
+                    if( (urb->actual_length != urb->transfer_buffer_length) && 
+                            (urb->transfer_flags & URB_SHORT_NOT_OK))
+                    {
+                        iso_dbg(ISO_DBG_ERR,"[phcd_iso_handler Error]: Short Packet\n");
+                        urb->status = -EREMOTEIO;
+                    }
+                    else
+                    {
+                        urb->status = 0;
+                    }
+                }
+
+                urb->hcpriv = 0;
+
+                /* We need to unlock this here, since this was locked when we are called
+                 * from the interrupt handler */
+                spin_unlock(&hcd->lock);
+
+                /* Perform URB cleanup */
+                usb_hcd_giveback_urb (&hcd->usb_hcd, urb, urb->status);
+                spin_lock(&hcd->lock);
+                continue;
+            }/* if( last_td == TRUE ) */
+
+            /* 
+             * If the last_td is not set then we do not need to check for errors and directly
+             * proceed with the cleaning sequence.                       
+             */
+
+            /* Decrement the count of active PTDs */
+            hcd->periodic_sched --;
+
+            /* Free up the memory we allocated in the PAYLOAD area */
+            phci_hcd_mem_free(&itd->mem_addr);
+
+            /* Remove this ITD from the list of active ITDs */
+            list_del(&itd->itd_list);
+
+            /* Free up the memory we allocated for the ITD structure */
+            qha_free(qha_cache, itd);
+
+            /* 
+             * Clear the bit associated with this PTD from the grouptdmap and
+             * make this PTD available for other transfers
+             */
+
+            td_ptd_map->state = TD_PTD_NEW;         
+
+            /* Skip this PTD during the next PTD processing. */
+            skip_map |= td_ptd_map->ptd_bitmap;
+            isp1761_reg_write32(hcd->dev, hcd->regs.isotdskipmap, skip_map);
+        } /* list_for_each_safe(position, lst_temp, itd_remove) */
+        iso_dbg(ISO_DBG_INFO, "[phcd_iso_handler]: ISO-Frame removal done\n");
+    } /* if( remove == TRUE) */
+
+    /*
+     * When there is no more PTDs queued for scheduling or removal
+     * clear the buffer status to indicate there are no more PTDs for 
+     * processing and set the skip map to 1 to indicate that the first
+     * PTD is also the last PTD.
+     */
+    if(hcd->periodic_sched <= 0)
+    {
+        iso_dbg(ISO_DBG_INFO, "[phcd_iso_handler]: No more PTDs queued\n");
+        buff_stat &= ~ISO_BUFFER;
+        isp1761_reg_write32(hcd->dev, hcd->regs.buffer_status, buff_stat);
+        isp1761_reg_write32(hcd->dev,hcd->regs.isotdlastmap, 0x1);
+        hcd->periodic_sched = 0;
+    }           
+} /* end of phcd_iso_handler */
+
+#endif /* CONFIG_ISO_SUPPORT */
+
+/*interrupt transfer handler*/
+/********************************************************
+  1. read done map
+  2. read the ptd to see any errors
+  3. copy the payload to and from
+  4. update ehci td
+  5. make new ptd if transfer there and earlier done
+  6. schedule
+ *********************************************************/
+    static void
+pehci_hcd_intl_worker(phci_hcd *hcd)
+{
+    int i = 0;
+    u32 donemap = 0, donetoclear;
+    u32 mask = 0x1,index = 0;
+    u32 pendingmap = 0;
+    u32 location = 0;
+    u32 length = 0;
+    u32 skipmap = 0;
+    u32 ormask = 0;
+    u32 usofstatus = 0;
+    struct urb *urb;
+    struct ehci_qtd *qtd = 0;
+    struct ehci_qh *qh = 0;
+    struct _isp1761_qhint *qhint = &hcd->qhint;
+    td_ptd_map_t                *td_ptd_map;
+    td_ptd_map_buff_t   *ptd_map_buff;
+    struct isp1761_mem_addr *mem_addr = 0;
+    u32 dontschedule = 0;       
+
+    ptd_map_buff = &(td_ptd_map_buff[TD_PTD_BUFF_TYPE_INTL]);
+    pendingmap = ptd_map_buff->pending_ptd_bitmap;
+
+    /*read the done map for interrupt transfers*/
+    donetoclear = donemap = isp1761_reg_read32(hcd->dev, hcd->regs.inttddonemap,donemap);
+    if(donemap){
+        /*skip done tds*/
+        skipmap = isp1761_reg_read32(hcd->dev, hcd->regs.inttdskipmap, skipmap);
+        skipmap |= donemap;
+        isp1761_reg_write32(hcd->dev, hcd->regs.inttdskipmap, skipmap);
+        donemap |=      pendingmap;
+    }
+    /*if sof interrupt is enabled*/
+#ifdef MSEC_INT_BASED
+    else{
+        /*if there is something pending , put this transfer in*/
+        if(ptd_map_buff->pending_ptd_bitmap){
+            pehci_hcd_schedule_pending_ptds(hcd,pendingmap,(u8)TD_PTD_BUFF_TYPE_INTL,1);
+        }
+        return;
+    }
+#else
+    else{
+        return;
+    }
+
+#endif
+
+
+    ormask = isp1761_reg_read32(hcd->dev, hcd->regs.int_irq_mask_or, ormask);
+    /*process all the endpoints first those are done*/
+    donetoclear = donemap;
+    while(donetoclear){
+        /*index is the number of endpoints open currently*/
+        index = donetoclear & mask;
+        donetoclear &= ~mask;
+        mask <<= 1;
+        /*what if we are in the middle of schedule
+          where nothing is done*/
+        if(!index ){
+            location++;
+            continue;
+        }
+
+        /*read our td_ptd_map*/
+        td_ptd_map = &ptd_map_buff->map_list[location];
+
+        /*if this one is already in the removal*/
+        if(td_ptd_map->state == TD_PTD_REMOVE ||
+                td_ptd_map->state ==  TD_PTD_NEW){
+            pehci_check("interrupt td is being removed\n");
+            /*this will be handled by urb_remove*/
+            /*if this is last urb no need to complete it again*/
+            donemap &= ~td_ptd_map->ptd_bitmap;
+            /*if there is something pending*/
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            continue;
+        }
+
+
+        /*if we found something already in*/
+        if(!(skipmap & td_ptd_map->ptd_bitmap)){
+            pehci_check("intr td_ptd_map %x,skipnap %x\n",
+                    td_ptd_map->ptd_bitmap,skipmap);
+            donemap &= ~td_ptd_map->ptd_bitmap;
+            /*in case pending*/
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap; ;
+            location++;
+            continue;
+        }
+
+
+        if(td_ptd_map->state ==  TD_PTD_NEW){
+            pehci_check("interrupt not come here, map %x,location %d\n", td_ptd_map->ptd_bitmap,location);
+            donemap &= ~td_ptd_map->ptd_bitmap;
+            /*in case pending*/
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            donemap &= ~td_ptd_map->ptd_bitmap;
+            location++;
+            continue;
+        }
+
+        /*move to the next schedule*/
+        location ++;
+        /*endpoint, td, urb and memory
+         * for current transfer*/
+        qh = td_ptd_map->qh;
+        qtd = td_ptd_map->qtd;
+        if(qtd->state & QTD_STATE_NEW){
+            /*we need to schedule it*/
+            goto schedule;
+        }
+        urb = qtd->urb;
+        mem_addr = &qtd->mem_addr;
+
+        /*clear the irq mask for this transfer*/
+        ormask &= ~td_ptd_map->ptd_bitmap;
+        isp1761_reg_write32(hcd->dev, hcd->regs.int_irq_mask_or, ormask);
+
+        ptd_map_buff->active_ptds--;
+        memset(qhint, 0, sizeof(struct _isp1761_qhint));
+
+        /*read this ptd from the ram address,address is in the
+          td_ptd_map->ptd_header_addr*/
+        isp1761_mem_read(hcd->dev, td_ptd_map->ptd_header_addr,0,(u32 *)(qhint),PHCI_QHA_LENGTH,0);
+
+        /*statuc of 8 uframes*/
+        for(i=0;i<8;i++){
+            /*take care of errors*/
+            usofstatus = qhint->td_info5 >> (8 + i * 3);
+            switch(usofstatus & 0x7){
+                case INT_UNDERRUN:
+                    pehci_print("under run , %x\n", usofstatus);
+                    break;
+                case INT_EXACT:
+                    pehci_print("transaction error, %x\n", usofstatus);
+                    break;
+                case INT_BABBLE:
+                    pehci_print("babble error, %x\n", usofstatus);
+                    break;
+            }
+        }
+
+        if(urb->dev->speed != USB_SPEED_HIGH)
+            /*length is 1K for full/low speed device*/
+            length = PTD_XFERRED_NONHSLENGTH(qhint->td_info4);
+        else
+            /*length is 32K for high speed device*/
+            length = PTD_XFERRED_LENGTH(qhint->td_info4);
+
+        pehci_hcd_update_error_status(qhint->td_info4, urb);
+        /*halted, need to finish all the transfer on this endpoint*/
+        if(qhint->td_info4 & PTD_STATUS_HALTED){
+            //td_ptd_map->lasttd = 1;
+            qtd->state |= QTD_STATE_LAST;
+            /*in case of halt, next transfer will start with toggle zero,
+             *USB speck, 5.8.5*/
+            qh->datatoggle = td_ptd_map->datatoggle = 0;
+            donemap &= ~td_ptd_map->ptd_bitmap;
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            dontschedule = 1;
+            goto copylength;
+        }
+
+
+copylength:
+        /*preserve the current data toggle*/
+        qh->datatoggle = td_ptd_map->datatoggle = PTD_NEXTTOGGLE(qhint->td_info4);
+        /*copy data from the host*/
+        switch(PTD_PID(qhint->td_info2)){
+            case IN_PID:
+                if(length && (length <= MAX_PTD_BUFFER_SIZE))
+                    /*do read only when there is somedata*/
+                    isp1761_mem_read(hcd->dev,(u32)mem_addr->phy_addr,0,(void*)(le32_to_cpu(qtd->hw_buf[0])),length,0);
+            case OUT_PID:
+                urb->actual_length += length;
+                qh->hw_current = qtd->hw_next;
+                phci_hcd_mem_free(&qtd->mem_addr);
+                qtd->state &= ~QTD_STATE_NEW;
+                qtd->state |= QTD_STATE_DONE;
+                break;
+        }
+
+        if(qtd->state & QTD_STATE_LAST){
+            pehci_hcd_urb_complete(hcd,qh,urb,td_ptd_map);
+            if(dontschedule){ /*cleanup will start from linux-3.13/drivers*/
+                dontschedule = 0;
+                continue;
+            }
+
+            /*take the next if in the queue*/
+            if(!list_empty(&qh->qtd_list)){
+                struct list_head *head;
+                /*last td of previous urb*/
+                head = &qh->qtd_list;
+                qtd = list_entry(head->next,struct ehci_qtd, qtd_list);
+                td_ptd_map->qtd = qtd;
+                qh->hw_current = cpu_to_le32(qtd);
+                qh->qh_state = QH_STATE_LINKED;
+
+            }else{
+                td_ptd_map->qtd = (struct ehci_qtd *) le32_to_cpu(0);
+                qh->hw_current = cpu_to_le32(0);
+                qh->qh_state = QH_STATE_TAKE_NEXT;
+                donemap &= ~td_ptd_map->ptd_bitmap;
+                ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+                continue;
+            }
+
+        }
+
+schedule:    
+        {
+            /*current td comes from qh->hw_current*/    
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            ormask |= td_ptd_map->ptd_bitmap;
+            ptd_map_buff->active_ptds++;
+            pehci_check("inter schedule next qtd %p, active tds %d\n", qtd,ptd_map_buff->active_ptds);
+            pehci_hcd_qtd_schedule(hcd,qtd,qh,td_ptd_map);
+        }        
+
+    } /*end of while*/
+
+
+    /*clear all the tds inside this routine*/
+    skipmap &= ~donemap;
+    isp1761_reg_write32(hcd->dev, hcd->regs.inttdskipmap, skipmap);
+    ormask |= donemap;
+    isp1761_reg_write32(hcd->dev, hcd->regs.int_irq_mask_or,ormask);
+}
+
+/*atl(bulk/control) transfer handler*/
+/*1. read done map
+  2. read the ptd to see any errors
+  3. copy the payload to and from
+  4. update ehci td
+  5. make new ptd if transfer there and earlier done
+  6. schedule
+ */
+    static void
+pehci_hcd_atl_worker(phci_hcd *hcd)
+{
+    u32 donemap = 0, donetoclear=0;
+    u32 pendingmap = 0;
+    u32 rl = 0; 
+    u32 mask = 0x1,index = 0;
+    u32 location = 0;
+    u32 nakcount = 0;
+    u32 active = 0;
+    u32 length = 0;
+    u32 skipmap = 0;
+    u32 tempskipmap = 0;        
+    u32 ormask=0;
+    struct urb *urb;
+    struct ehci_qtd *qtd = 0;
+    struct ehci_qh *qh;
+    struct _isp1761_qha   atlqha;
+    struct _isp1761_qha *qha;
+    td_ptd_map_t       *td_ptd_map;
+    td_ptd_map_buff_t   *ptd_map_buff;
+    urb_priv_t          *urbpriv = 0;   
+    struct isp1761_mem_addr *mem_addr = 0;
+    u32 dontschedule = 0;       
+
+    ptd_map_buff = &(td_ptd_map_buff[TD_PTD_BUFF_TYPE_ATL]);
+    pendingmap = ptd_map_buff->pending_ptd_bitmap;
+
+#ifdef MSEC_INT_BASED
+    /*running on skipmap rather donemap,
+      some cases donemap may not be set 
+      for complete transfer
+     */                 
+    skipmap = isp1761_reg_read32(hcd->dev, hcd->regs.atltdskipmap, skipmap);
+    tempskipmap = ~skipmap;
+    if(tempskipmap){
+        donemap = isp1761_reg_read32(hcd->dev, hcd->regs.atltddonemap,donemap);
+        skipmap |= donemap;
+        isp1761_reg_write32(hcd->dev, hcd->regs.atltdskipmap, skipmap);
+        qha = &atlqha;
+        donemap |= pendingmap;
+        tempskipmap &= ~donemap;
+    }
+
+    /*if sof interrupt enabled*/
+    else{
+        /*if there is something pending , put this transfer in*/
+        if(pendingmap){
+            pehci_hcd_schedule_pending_ptds(hcd,pendingmap,(u8)TD_PTD_BUFF_TYPE_ATL,1);
+        }
+        return;
+    }
+#else
+
+    donemap = isp1761_reg_read32(hcd->dev, hcd->regs.atltddonemap,donemap);
+    if(donemap){
+        skipmap = isp1761_reg_read32(hcd->dev, hcd->regs.atltdskipmap, skipmap);
+        skipmap |= donemap;
+        isp1761_reg_write32(hcd->dev, hcd->regs.atltdskipmap, skipmap);
+        qha = &atlqha;
+    }
+    else{
+        return;
+
+    }
+#endif
+
+    /*read the interrupt mask registers*/
+    ormask = isp1761_reg_read32(hcd->dev, hcd->regs.atl_irq_mask_or, ormask);
+
+
+    /*this map is used only to update and
+     * scheduling for the tds who are not
+     * complete. the tds those are complete
+     * new schedule will happen from
+     * td_ptd_submit_urb routine
+     * */
+    donetoclear = donemap;
+    /*we will be processing skipped tds also*/
+    donetoclear |= tempskipmap; 
+    /*process all the endpoints first those are done*/
+    while(donetoclear){
+        /*index is the number of endpoint open currently*/
+        index = donetoclear & mask;
+        donetoclear &= ~mask;
+        mask <<= 1;
+        /*what if we are in the middle of schedule
+          where nothing is done
+         */
+        if(!index ){
+            location++;
+            continue;
+        }
+
+        /*read our td_ptd_map*/
+        td_ptd_map = &ptd_map_buff->map_list[location];
+
+        /*urb is in remove*/
+        if(td_ptd_map->state == TD_PTD_NEW ||
+                td_ptd_map->state ==  TD_PTD_REMOVE){
+            pehci_check("atl td is being removed,map %x, skipmap %x\n", td_ptd_map->ptd_bitmap, skipmap);
+            pehci_check("temp skipmap %x, pendign map %x,done %x\n",tempskipmap, pendingmap,donemap);
+
+            /*unlink urb will take care of this*/
+            donemap &= ~td_ptd_map->ptd_bitmap;
+            /*in case pending*/
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            location++;
+            continue;
+        }
+
+
+        /*move to the next endpoint*/
+        location ++;
+        /*endpoint, td, urb and memory
+         * for current endpoint*/
+        qh = td_ptd_map->qh;
+        qtd = td_ptd_map->qtd;
+        if(!qh || !qtd)
+        {
+            err("Never Error:QH and QTD must not be zero\n");
+            donemap &= ~td_ptd_map->ptd_bitmap;
+            /*in case pending*/
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;            
+            continue;
+        } 
+#ifdef MSEC_INT_BASED           
+        /*new td must be scheduled*/
+        if((qtd->state & QTD_STATE_NEW) /*&&
+                                          (pendingmap & td_ptd_map->ptd_bitmap)*/){
+            /*this td will come here first time from
+             *pending tds, so its qh->hw_current needs to
+             * adjusted
+             */
+            qh->hw_current = QTD_NEXT (qtd->qtd_dma);
+            goto schedule;
+        }
+#endif                  
+
+        urb = qtd->urb;
+        urbpriv = (urb_priv_t *)urb->hcpriv;
+        mem_addr = &qtd->mem_addr;
+
+#ifdef MSEC_INT_BASED
+        /*check here for the td if its done*/
+        if(donemap & td_ptd_map->ptd_bitmap){
+            /*nothing to do*/
+            ;
+        }else{
+            /*if td is not done, lets check how long 
+              its been scheduled
+             */
+            if(tempskipmap & td_ptd_map->ptd_bitmap){
+                /*i will give 20 msec to complete*/
+                if(urbpriv->timeout < 20){
+                    urbpriv->timeout++; 
+                    continue;
+                }
+                urbpriv->timeout++;
+                /*otherwise check its status*/
+            }
+
+        }
+#endif          
+        memset(qha, 0, sizeof(struct _isp1761_qha));
+
+        /*read this ptd from the ram address,address is in the
+          td_ptd_map->ptd_header_addr*/
+        isp1761_mem_read(hcd->dev, td_ptd_map->ptd_header_addr,0,(u32 *)(qha),PHCI_QHA_LENGTH,0);
+
+#ifdef MSEC_INT_BASED   
+        /*since we are running on skipmap
+          tds will be checked for completion state
+         */
+        if((qha->td_info1 & QHA_VALID)){
+
+            pehci_check("pendign map %x, donemap %x, tempskipmap %x\n",
+                    pendingmap,donemap, tempskipmap);
+            /*this could be one of the unprotected urbs, clear it*/
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            /*here also we need to increment the tds timeout count*/
+            urbpriv->timeout++;
+            continue;
+        }else{
+            /*this td is going to be done,
+              this td could be the one un-skipped but no donemap or
+              maybe it could be one of those where we get unprotected urbs,
+              so checking against tempskipmap may not give us correct td
+             */
+
+            skipmap |= td_ptd_map->ptd_bitmap;
+            isp1761_reg_write32(hcd->dev, hcd->regs.atltdskipmap,
+                    skipmap);
+
+            /*of course this is going to be as good
+              as td that is done and donemap is set
+              also skipmap is set
+             */                 
+            donemap |= td_ptd_map->ptd_bitmap;
+        }
+#endif          
+
+
+        /*clear the corrosponding mask register*/
+        ormask &= ~td_ptd_map->ptd_bitmap;
+        isp1761_reg_write32(hcd->dev, hcd->regs.atl_irq_mask_or,ormask);
+
+        ptd_map_buff->active_ptds--;
+
+        urbpriv->timeout = 0;
+
+        /*take care of errors*/
+        pehci_hcd_update_error_status(qha->td_info4, urb);
+        /*halted, need to finish all the transfer on this endpoint*/
+        if(qha->td_info4 & PTD_STATUS_HALTED){
+            qtd->state |= QTD_STATE_LAST;
+
+            donemap &= ~td_ptd_map->ptd_bitmap; 
+            /*in case pending*/
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            /*in case of halt, next transfer will start with toggle
+              zero,USB speck, 5.8.5*/
+            qh->datatoggle =  td_ptd_map->datatoggle = 0;
+            /*cleanup the ping*/
+            qh->ping = 0;
+            /*force cleanup after this*/
+            dontschedule = 1;
+            goto copylength;
+        }
+
+        /*read the reload count*/
+        rl = (qha->td_info3 >> 23);
+        rl &= 0xf;
+
+
+
+        /*if there is a transaction error and the status is not halted,
+         * process whatever the length we got.if the length is what we
+         * expected complete the transfer*/
+        if((qha->td_info4 & PTD_XACT_ERROR) &&
+                !(qha->td_info4 & PTD_STATUS_HALTED) &&
+                (qha->td_info4 & QHA_ACTIVE)){
+
+            if(PTD_XFERRED_LENGTH(qha->td_info4) == qtd->length){
+                ;/*nothing to do its fake*/}
+            else{
+
+                pehci_print("xact error, info1 0x%08x,info4 0x%08x\n", qha->td_info1,qha->td_info4);
+
+                /*if this is the case then we need to 
+                  resubmit the td again*/
+                qha->td_info1 |= QHA_VALID;
+                skipmap &= ~td_ptd_map->ptd_bitmap;
+                ormask |= td_ptd_map->ptd_bitmap;
+                donemap &= ~td_ptd_map->ptd_bitmap;
+
+                /*set the retry count to 3 again*/
+                qha->td_info4 |= (rl << 19);
+                /*set the active bit, if cleared, will be cleared if we have some length*/
+                qha->td_info4 |= QHA_ACTIVE;
+
+                /*clear the xact error*/
+                qha->td_info4 &= ~PTD_XACT_ERROR;
+                isp1761_reg_write32(hcd->dev, hcd->regs.atl_irq_mask_or,ormask);
+
+                /*copy back into the header, payload is already
+                 * present no need to write again
+                 */
+                isp1761_mem_write(hcd->dev, td_ptd_map->ptd_header_addr,0,(u32*)(qha),PHCI_QHA_LENGTH,0);
+                /*unskip this td*/
+                isp1761_reg_write32(hcd->dev, hcd->regs.atltdskipmap, skipmap);
+                continue;
+        }
+        goto copylength;
+    }
+
+    /*check for the nak count and active condition
+     * to reload the ptd if needed*/
+    nakcount = qha->td_info4 >> 19;
+    nakcount &= 0xf;
+    active  = qha->td_info4 & QHA_ACTIVE;
+    /*if nak count is zero and active bit is set , it
+     *means that device is naking and need to reload
+     *the same td*/
+    if(!nakcount && active){
+        pehci_info("%s: ptd is going for reload,length %d\n",
+                __FUNCTION__,length);
+        /*make this td valid*/
+        qha->td_info1 |= QHA_VALID;
+        donemap &= ~td_ptd_map->ptd_bitmap;
+        /*just like fresh td*/
+
+        /*set the retry count to 3 again*/
+        qha->td_info4 |= (rl << 19);
+        ptd_map_buff->active_ptds++;
+        skipmap &= ~td_ptd_map->ptd_bitmap;
+        ormask |= td_ptd_map->ptd_bitmap;
+        isp1761_reg_write32(hcd->dev, hcd->regs.atl_irq_mask_or,ormask);
+        /*copy back into the header, payload is already
+         * present no need to write again */
+        isp1761_mem_write(hcd->dev, td_ptd_map->ptd_header_addr,0,(u32 *)(qha),PHCI_QHA_LENGTH,0);
+        /*unskip this td*/
+        isp1761_reg_write32(hcd->dev, hcd->regs.atltdskipmap, skipmap);
+        continue;
+    }
+
+copylength:
+    /*read the length transferred*/
+    length = PTD_XFERRED_LENGTH(qha->td_info4);
+
+    /*short complete in case of BULK only*/
+    if((length < qtd->length) &&
+            usb_pipebulk(urb->pipe)){
+
+        /*if current ptd is not able to fetech enough data as
+         * been asked then device has no data, so complete this transfer
+         * */
+        /*can we complete our transfer here*/
+        if((urb->transfer_flags & URB_SHORT_NOT_OK)){
+            pehci_check("short read, length %d(expected %d)\n", 
+                    length, qtd->length);       
+            urb->status = -EREMOTEIO;
+            /*if this is the only td,donemap will be cleared
+              at completion, otherwise take the next one
+             */
+            donemap &= ~td_ptd_map->ptd_bitmap;
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            /*force the cleanup from here*/
+            dontschedule = 1;
+        }
+
+        /*this will be the last td,in case of short read/write*/
+        /*donemap, pending maps will be handled at the while scheduling or completion*/
+        qtd->state |= QTD_STATE_LAST;
+
+    }
+    /*preserve the current data toggle*/
+    qh->datatoggle =td_ptd_map->datatoggle = PTD_NEXTTOGGLE(qha->td_info4);
+    qh->ping = PTD_PING_STATE(qha->td_info4);   
+    /*copy data from*/
+    switch(PTD_PID(qha->td_info2)){
+        case IN_PID:
+            qh->ping = 0;
+            /*do read only when there is some data*/
+            if(length && (length <= HC_ATL_PL_SIZE)){
+                isp1761_mem_read(hcd->dev,(u32)mem_addr->phy_addr,0,(void*)(le32_to_cpu(qtd->hw_buf[0])),length,0);
+            }
+
+        case OUT_PID:
+            urb->actual_length += length;
+            qh->hw_current = qtd->hw_next;
+            phci_hcd_mem_free(&qtd->mem_addr);
+            qtd->state |= QTD_STATE_DONE;
+
+            break;
+        case SETUP_PID:
+            qh->hw_current = qtd->hw_next;
+            phci_hcd_mem_free(&qtd->mem_addr);
+            qtd->state |= QTD_STATE_DONE;
+            break;
+    }
+
+    if(qtd->state & QTD_STATE_LAST){
+        pehci_hcd_urb_complete(hcd,qh,urb,td_ptd_map);
+        if(dontschedule){ /*cleanup will start from linux-3.13/drivers*/
+            dontschedule = 0;
+            /*so that we can take next one*/
+            qh->qh_state = QH_STATE_TAKE_NEXT;                                  
+            continue;
+        }
+        /*take the next if in the queue*/
+        if(!list_empty(&qh->qtd_list)){
+            struct list_head *head;
+            /*last td of previous urb*/
+            head = &qh->qtd_list;
+            qtd = list_entry(head->next,struct ehci_qtd, qtd_list);
+            td_ptd_map->qtd = qtd;
+            qh->hw_current = cpu_to_le32(qtd);
+            qh->qh_state = QH_STATE_LINKED;
+
+        }else{
+            td_ptd_map->qtd = (struct ehci_qtd *) le32_to_cpu(0);
+            qh->hw_current = cpu_to_le32(0);
+            qh->qh_state = QH_STATE_TAKE_NEXT;
+            donemap &= ~td_ptd_map->ptd_bitmap;
+            ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+            continue;
+        }
+    }
+
+schedule:    
+    {
+        /*current td comes from qh->hw_current*/        
+        ptd_map_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+        td_ptd_map->qtd = (struct ehci_qtd *)(le32_to_cpu(qh->hw_current));
+        qtd = td_ptd_map->qtd;
+        ormask |= td_ptd_map->ptd_bitmap;
+        ptd_map_buff->active_ptds++;
+        pehci_hcd_qtd_schedule(hcd,qtd,qh,td_ptd_map);
+    }    
+
+} /*end of while*/
+
+/*clear all the tds inside this routine*/
+skipmap &= ~donemap;
+isp1761_reg_write32(hcd->dev, hcd->regs.atltdskipmap, skipmap);
+ormask |= donemap;
+isp1761_reg_write32(hcd->dev, hcd->regs.atl_irq_mask_or,ormask);
+pehci_entry("-- %s: Exit\n",__FUNCTION__);
+}
+
+/*--------------------------------------------------------*
+  root hub functions
+ *--------------------------------------------------------*/
+
+/*return root hub descriptor, can not fail*/
+static void
+pehci_hub_descriptor (
+        phci_hcd                        *hcd,
+        struct usb_hub_descriptor       *desc)
+{
+    u32         ports = 0;
+    u16         temp = 0;
+
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+    ports = isp1761_reg_read32(hcd->dev, hcd->regs.hcsparams, ports);
+    ports = ports & 0xf;
+    pehci_info("%s: number of ports %d\n", __FUNCTION__, ports);
+
+    desc->bDescriptorType = 0x29;
+    desc->bPwrOn2PwrGood = 10;  
+
+    desc->bHubContrCurrent = 0;
+
+    desc->bNbrPorts = ports;
+    temp = 1 + (ports / 8);
+    desc->bDescLength = 7 + 2 * temp;
+    /* two bitmaps:  ports removable, and usb 1.0 legacy PortPwrCtrlMask */
+
+    memset (&desc->DeviceRemovable[0], 0, temp);
+    memset (&desc->PortPwrCtrlMask[temp], 0xff, temp);
+
+    temp = 0x0008;                      /* per-port overcurrent reporting */
+    temp |= 0x0001;             /* per-port power control */
+    temp |= 0x0080;             /* per-port indicators (LEDs) */
+    desc->wHubCharacteristics = cpu_to_le16 (temp);
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+}
+
+/*after reset on root hub,
+ * device high speed or non-high speed
+ * */
+    static int
+phci_check_reset_complete (phci_hcd *hcd,int index,int port_status)
+{
+    pehci_print("check reset complete\n");
+    if (!(port_status & PORT_CONNECT)) {
+        hcd->reset_done [index] = 0;
+        return port_status;
+    }
+
+    /* if reset finished and it's still not enabled -- handoff */
+    if (!(port_status & PORT_PE)) {
+        printk ("port %d full speed --> companion\n",
+                index + 1);
+        port_status |= PORT_OWNER;
+        isp1761_reg_write32(hcd->dev,hcd->regs.ports[index],port_status);
+
+    } else
+        pehci_print ("port %d high speed\n", index + 1);
+
+    return port_status;
+
+}
+
+/*----------------------------------------------*
+  host controller initialization, removal functions
+ *----------------------------------------------*/
+
+
+/*initialize all three buffer(iso/atl/int) type headers*/
+    static void
+pehci_hcd_init_map_buffers(phci_hcd     *phci) 
+{
+    td_ptd_map_buff_t   *ptd_map_buff;
+    u8                          buff_type, ptd_index;
+    u32                         bitmap;
+
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+    pehci_print("phci_init_map_buffers(phci = 0x%p)\n",phci);
+    /* initialize for each buffer type */
+    for(buff_type = 0; buff_type < TD_PTD_TOTAL_BUFF_TYPES; buff_type++)
+    {
+        ptd_map_buff = &(td_ptd_map_buff[buff_type]);
+        ptd_map_buff->buffer_type = buff_type;
+        ptd_map_buff->active_ptds = 0;
+        ptd_map_buff->total_ptds = 0;
+        /*each bufer type can have atleast 32 ptds*/
+        ptd_map_buff->max_ptds = 32;
+        ptd_map_buff->active_ptd_bitmap = 0;
+        /*everything skipped*/
+        /*nothing is pending*/
+        ptd_map_buff->pending_ptd_bitmap = 0x00000000;
+
+        /* For each ptd index of this buffer, set the fiedls */
+        bitmap = 0x00000001;
+        for(ptd_index = 0; ptd_index < TD_PTD_MAX_BUFF_TDS; ptd_index++)
+        {
+            /*datatoggle zero*/
+            ptd_map_buff->map_list[ptd_index].datatoggle = 0;
+            /*td state is not used*/
+            ptd_map_buff->map_list[ptd_index].state = TD_PTD_NEW;
+            /*no endpoint, no qtd*/
+            ptd_map_buff->map_list[ptd_index].qh = NULL;
+            ptd_map_buff->map_list[ptd_index].qtd = NULL;
+            ptd_map_buff->map_list[ptd_index].ptd_header_addr = 0xFFFF;
+        }/* for( ptd_index */
+    }   /* for(buff_type */
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+} /* phci_init_map_buffers */
+
+
+/*put the host controller into operational mode
+ * called phci_hcd_start routine,
+ * return 0, success else
+ * timeout, fails*/
+
+    static int
+pehci_hcd_start_controller(phci_hcd *hcd)
+{
+    u32 command = 0;
+    int retval = 0;
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+    /*initialize the host controller*/
+    command |= CMD_RUN;
+    isp1761_reg_write32(hcd->dev,hcd->regs.command,command);
+
+    command &=0;
+    command  =  isp1761_reg_read32(hcd->dev,hcd->regs.command,command);
+    /*should be in operation in 1000 usecs*/
+    if((retval = pehci_hcd_handshake(hcd,hcd->regs.command, CMD_RUN, CMD_RUN,100000))){
+        err("Host is not up(CMD_RUN) in 1000 usecs\n");
+        return retval;
+    }
+
+    /*put the host controller to ehci mode*/
+    command &=0;
+    command |= 1;
+    isp1761_reg_write32(hcd->dev,hcd->regs.configflag, command);
+    /*check if ehci mode switching is correct or not*/
+    if((retval = pehci_hcd_handshake(hcd, hcd->regs.configflag,1,1,100))){
+        err("Host is not into ehci mode in 100 usecs\n");
+        return retval;
+    }
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+    return retval;
+}
+
+
+/*enable the interrupts
+ *called phci_1761_start routine
+ * return void*/
+    static void
+pehci_hcd_enable_interrupts(phci_hcd *hcd)
+{
+    u32  temp = 0;
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+    /*disable the interrupt source*/
+    temp &= 0;
+    /*clear all the interrupts that may be there */
+    temp |= INTR_ENABLE_MASK;
+    isp1761_reg_write32(hcd->dev, hcd->regs.interrupt, temp);
+
+    /*enable interrupts*/
+    temp = 0;
+    temp |= INTR_ENABLE_MASK;
+    pehci_print("%s: enabled mask 0x%08x\n",__FUNCTION__, temp);
+    isp1761_reg_write32(hcd->dev,hcd->regs.interruptenable, temp);
+
+    /*enable the global interrupt*/
+    temp &=0;
+    temp = isp1761_reg_read32(hcd->dev, hcd->regs.hwmodecontrol, temp);
+    temp |= 0x003;/*enable the global interrupt*/
+    isp1761_reg_write32(hcd->dev, hcd->regs.hwmodecontrol, temp);
+    /*maximum rate is one msec*/
+    /*enable the atl interrupts OR and AND mask*/
+    temp = 0;
+    isp1761_reg_write32(hcd->dev, hcd->regs.atl_irq_mask_and, temp);
+    temp = 0;
+    isp1761_reg_write32(hcd->dev,hcd->regs.atl_irq_mask_or, temp);
+    temp = 0;
+    isp1761_reg_write32(hcd->dev, hcd->regs.int_irq_mask_and, temp);
+    temp = 0x0;
+    isp1761_reg_write32(hcd->dev,hcd->regs.int_irq_mask_or, temp);
+    temp = 0;
+    isp1761_reg_write32(hcd->dev, hcd->regs.iso_irq_mask_and, temp);
+    temp = 0xffffffff;
+    isp1761_reg_write32(hcd->dev,hcd->regs.iso_irq_mask_or, temp);
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+}
+
+/*initialize the host controller register map from Isp 1761 to EHCI */
+    static void
+pehci_hcd_init_reg(phci_hcd *hcd)
+{
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+    /* scratch pad for the test*/
+    hcd->regs.scratch = HC_SCRATCH_REG  ;
+
+    /*make a copy of our interrupt locations*/
+    hcd->regs.command = HC_USBCMD_REG   ;
+    hcd->regs.usbstatus = HC_USBSTS_REG;
+    hcd->regs.usbinterrupt = HC_INTERRUPT_REG_EHCI;
+
+    hcd->regs.hcsparams = HC_SPARAMS_REG;
+    hcd->regs.frameindex = HC_FRINDEX_REG;
+
+    /*transfer specific registers*/
+    hcd->regs.hwmodecontrol = HC_HW_MODE_REG;
+    hcd->regs.interrupt = HC_INTERRUPT_REG;
+    hcd->regs.interruptenable = HC_INTENABLE_REG;
+    hcd->regs.atl_irq_mask_and = HC_ATL_IRQ_MASK_AND_REG;
+    hcd->regs.atl_irq_mask_or = HC_ATL_IRQ_MASK_OR_REG;
+
+    hcd->regs.int_irq_mask_and = HC_INT_IRQ_MASK_AND_REG;
+    hcd->regs.int_irq_mask_or = HC_INT_IRQ_MASK_OR_REG;
+    hcd->regs.iso_irq_mask_and = HC_ISO_IRQ_MASK_AND_REG;
+    hcd->regs.iso_irq_mask_or = HC_ISO_IRQ_MASK_OR_REG;
+    hcd->regs.buffer_status = HC_BUFFER_STATUS_REG;
+    hcd->regs.interruptthreshold = HC_INT_THRESHOLD_REG;
+    /*initialization specific*/
+    hcd->regs.reset = HC_RESET_REG;
+    hcd->regs.configflag = HC_CONFIGFLAG_REG;
+    hcd->regs.ports[0]  = HC_PORTSC1_REG;
+    hcd->regs.ports[1]      = 0;        /*port1,port2,port3 status reg are removed */
+    hcd->regs.ports[2]      = 0;
+    hcd->regs.ports[3]      = 0;
+    /*transfer registers*/
+    hcd->regs.isotddonemap = HC_ISO_PTD_DONEMAP_REG;
+    hcd->regs.isotdskipmap = HC_ISO_PTD_SKIPMAP_REG;
+    hcd->regs.isotdlastmap = HC_ISO_PTD_LASTPTD_REG;
+
+    hcd->regs.inttddonemap = HC_INT_PTD_DONEMAP_REG;
+
+    hcd->regs.inttdskipmap = HC_INT_PTD_SKIPMAP_REG;
+    hcd->regs.inttdlastmap = HC_INT_PTD_LASTPTD_REG;
+
+    hcd->regs.atltddonemap = HC_ATL_PTD_DONEMAP_REG;
+    hcd->regs.atltdskipmap = HC_ATL_PTD_SKIPMAP_REG;
+    hcd->regs.atltdlastmap = HC_ATL_PTD_LASTPTD_REG;
+
+    /*initialize the host controller initial values*/
+    /*disable all the buffer*/
+    isp1761_reg_write32(hcd->dev, hcd->regs.buffer_status,0);
+    /*skip all the transfers*/
+    isp1761_reg_write32(hcd->dev, hcd->regs.atltdskipmap, NO_TRANSFER_ACTIVE);
+    isp1761_reg_write32(hcd->dev, hcd->regs.inttdskipmap, NO_TRANSFER_ACTIVE);
+    isp1761_reg_write32(hcd->dev, hcd->regs.isotdskipmap, NO_TRANSFER_ACTIVE);
+    /*clear done map*/
+    isp1761_reg_write32(hcd->dev, hcd->regs.atltddonemap, ~NO_TRANSFER_ACTIVE);
+    isp1761_reg_write32(hcd->dev, hcd->regs.inttddonemap, ~NO_TRANSFER_ACTIVE);
+    isp1761_reg_write32(hcd->dev, hcd->regs.isotddonemap, ~NO_TRANSFER_ACTIVE);
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+}
+
+/*---------------------------------------------------
+ *  Interrupt request function
+ -----------------------------------------------------*/
+
+/*tasklet function*/
+    static void
+pehci_hcd_tasklet(unsigned long arg)
+{
+    phci_hcd *hcd = (phci_hcd *) arg;
+#ifdef CONFIG_ISO_SUPPORT
+    phcd_iso_handler(hcd);
+#endif
+    pehci_hcd_atl_worker(hcd);
+    pehci_hcd_intl_worker(hcd);
+    return;
+
+}
+
+    static void
+pehci_interrupt_handler(phci_hcd *hcd)
+{
+    spin_lock(&hcd->lock);
+#ifdef CONFIG_ISO_SUPPORT
+    phcd_iso_handler(hcd);
+#endif
+    pehci_hcd_atl_worker(hcd);
+    pehci_hcd_intl_worker(hcd);
+    spin_unlock(&hcd->lock);
+    return;
+}
+
+
+    irqreturn_t
+pehci_hcd_irq1(struct usb_hcd *hcd)
+{
+    info("%s: doing nothing\n",__FUNCTION__);
+    return IRQ_NONE;
+}
+
+/*isr routine*/
+    irqreturn_t
+pehci_hcd_irq(struct usb_hcd *usb_hcd) //struct isp1761_dev *dev, void *__irq_data, struct pt_regs *regs) 
+{
+    struct isp1761_dev *dev;
+    int work = 0;
+    phci_hcd    *pehci_hcd;
+    u32 intr = 0;
+
+    if(!(usb_hcd->state & USB_STATE_READY)){
+        //info("interrupt handler state not ready yet\n");
+        return IRQ_NONE;
+    }
+
+    /*our host*/        
+    pehci_hcd = usb_hcd_to_pehci_hcd(usb_hcd);
+    dev = pehci_hcd->dev;
+    intr = dev->int_reg;
+    if(atomic_read(&pehci_hcd->nuofsofs)){
+        return IRQ_HANDLED;     
+    }
+    atomic_inc(&pehci_hcd->nuofsofs);
+    set_bit(HCD_FLAG_SAW_IRQ, &usb_hcd->flags);
+#ifdef MSEC_INT_BASED
+    work = 1;
+#else
+    if(intr & (HC_MSEC_INT & INTR_ENABLE_MASK))
+        work = 1;       /* phci_iso_worker(hcd); */
+    if(intr & (HC_ATL_INT & INTR_ENABLE_MASK)){
+        spin_lock(&pehci_hcd->lock);
+        pehci_hcd_atl_worker(pehci_hcd);
+        spin_unlock(&pehci_hcd->lock);  
+        work = 0;       /*phci_atl_worker(hcd); */
+    }
+
+    if(intr & (HC_INTL_INT & INTR_ENABLE_MASK)){
+        spin_lock(&pehci_hcd->lock);
+        pehci_hcd_intl_worker(pehci_hcd);
+        spin_unlock(&pehci_hcd->lock);
+        work = 0;       /*phci_intl_worker(hcd); */
+    }
+#endif
+    if(work)
+        pehci_interrupt_handler(pehci_hcd);
+
+    atomic_dec(&pehci_hcd->nuofsofs);
+    return IRQ_HANDLED;
+}
+
+/*reset the host controller
+ *called phci_hcd_start routine
+ *return 0, success else
+ *timeout, fails*/
+static int
+pehci_hcd_reset(
+        struct usb_hcd *usb_hcd)
+{
+    u32         command = 0;
+    u32         temp = 0;
+    phci_hcd *hcd = usb_hcd_to_pehci_hcd(usb_hcd);
+    /*reset the host controller */
+    temp &= 0;
+    temp |= 1;
+    isp1761_reg_write32(hcd->dev,HC_RESET_REG, temp);
+    mdelay(50);
+
+    /*reset the ehci controller registers*/
+    temp = 0;
+    temp |= (1<<1);
+    isp1761_reg_write32(hcd->dev,HC_RESET_REG, temp);
+
+    isp1761_reg_write32(hcd->dev,HC_HW_MODE_REG, 2); // 16-bit data bus. falling edge intr
+    isp1761_reg_write32(hcd->dev,0x374, 0x00800018); // Configure port 1 as HC
+
+    /*read the command register */
+    command = isp1761_reg_read32(hcd->dev,HC_USBCMD_REG,command);
+
+    command |= CMD_RESET;
+    /*write back and wait for, 250 msec */
+    isp1761_reg_write32(hcd->dev,HC_USBCMD_REG,command);
+    /*wait for maximum 250 msecs*/
+    return pehci_hcd_handshake(hcd,HC_USBCMD_REG, CMD_RESET,0, 250 * 1000);
+}
+
+
+/*host controller initialize routine,
+ *called by phci_hcd_probe
+ * */
+    static int
+pehci_hcd_start(struct usb_hcd  *usb_hcd)
+
+{
+    int                 retval;
+    int          count = 0;
+    phci_hcd            *pehci_hcd = NULL;
+
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+    pehci_hcd = usb_hcd_to_pehci_hcd(usb_hcd);
+
+    spin_lock_init(&pehci_hcd->lock);
+    atomic_set(&pehci_hcd->nuofsofs,0);
+    atomic_set(&pehci_hcd->missedsofs,0);
+
+    /*Initialize host controller registers*/
+    pehci_hcd_init_reg(pehci_hcd);
+
+    /*reset the host controller*/
+    retval = pehci_hcd_reset(usb_hcd);
+    if(retval){
+        err("phci_1761_start: error failing with status %x\n",retval);
+        return retval;
+    }
+
+    /*enable interrupts*/
+    pehci_hcd_enable_interrupts(pehci_hcd);
+
+    /*put controller into operational mode*/
+    retval = pehci_hcd_start_controller(pehci_hcd);
+    if(retval){
+        err("phci_1761_start: error failing with status %x\n",retval);
+        return retval;
+    }
+
+    /*Init the phci qtd <-> ptd map buffers */
+    pehci_hcd_init_map_buffers(pehci_hcd);
+
+
+    /*set last maps, for iso its only 1, else 32 tds bitmap*/
+    isp1761_reg_write32(pehci_hcd->dev, pehci_hcd->regs.atltdlastmap,0x80000000);
+    isp1761_reg_write32(pehci_hcd->dev, pehci_hcd->regs.inttdlastmap, 0x80000000);
+    isp1761_reg_write32(pehci_hcd->dev, pehci_hcd->regs.isotdlastmap, 0x00000001);
+    /*iso transfers are not active*/
+    pehci_hcd->next_uframe = -1;
+    pehci_hcd->periodic_sched = 0;
+
+    /*initialize the periodic list*/
+    for(count = 0;count < PTD_PERIODIC_SIZE;count++){
+        pehci_hcd->periodic_list[count].framenumber = 0;
+        INIT_LIST_HEAD(&pehci_hcd->periodic_list[count].itd_head);
+    }
+
+    /*initialize the tasket*/
+    pehci_hcd->tasklet.func = pehci_hcd_tasklet;
+    pehci_hcd->tasklet.data = (unsigned long)pehci_hcd;
+
+    /*set the state of the host to ready,
+     * start processing interrupts
+     * */
+    usb_hcd->state =  HC_STATE_RUNNING;
+    pehci_hcd->state = HC_STATE_RUNNING;
+
+    /*initialize root hub timer*/
+    init_timer(&pehci_hcd->rh_timer);
+    /*initialize watchdog*/
+    init_timer(&pehci_hcd->watchdog);
+
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+    return 0;
+}
+
+    static void
+pehci_hcd_stop(struct usb_hcd *usb_hcd)
+{
+
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+
+    /* no more interrupts ... */
+    if (usb_hcd->state == USB_STATE_RUNNING)
+        mdelay(2);
+    if (in_interrupt ()) {              /* must not happen!! */
+        pehci_info( "stopped in_interrupt!\n");
+
+        return;
+    }
+
+    /*power off our root hub*/
+    pehci_rh_control(usb_hcd, ClearPortFeature, USB_PORT_FEAT_POWER,
+            1, NULL, 0);
+
+    /*let the roothub power go off*/
+    mdelay(20);
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+
+    return;
+}
+
+/*submit urb , other than root hub*/
+    static int
+pehci_hcd_urb_enqueue(struct usb_hcd *usb_hcd, struct urb *urb, gfp_t mem_flags)
+{
+
+    struct list_head    qtd_list;
+    struct ehci_qh              *qh = 0;
+    phci_hcd                    *pehci_hcd = usb_hcd_to_pehci_hcd(usb_hcd);
+    int status  = 0;
+    int temp = 0, max = 0,num_tds = 0,mult = 0;
+    urb_priv_t   *urb_priv = NULL;
+    struct usb_host_endpoint *ep = urb->ep;
+
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+    INIT_LIST_HEAD(&qtd_list);
+    urb->transfer_flags &= ~EHCI_STATE_UNLINK;
+
+    temp = usb_pipetype(urb->pipe);
+    max = usb_maxpacket (urb->dev, urb->pipe, !usb_pipein(urb->pipe));
+
+#ifdef OTG
+    /*pathch to get the otg device*/
+    if(!otgdev){
+        if(urb->dev->devnum == 0x2){
+            otgdev = urb->dev;
+        }
+    }
+#endif
+    switch(temp){
+        case PIPE_INTERRUPT:
+            /*only one td*/
+            num_tds = 1;
+            mult = 1 + ((max >> 11) & 0x03);
+            max &= 0x07ff;
+            max *= mult;
+
+            if (urb->transfer_buffer_length > max){
+                err("interrupt urb length is greater then %d\n", max);
+                return -EINVAL;
+            }
+#ifdef OTG
+            if(otgdev && urb->dev->devnum == 0x2)
+                otgurb = urb;
+#endif
+            break;
+
+        case PIPE_CONTROL:
+            /*calculate the number of tds, follow 1 pattern*/
+            num_tds  = (urb->transfer_buffer_length == 0) ? 2 :
+                ((urb->transfer_buffer_length -1)/HC_ATL_PL_SIZE + 3);
+
+            break;
+        case PIPE_BULK:
+            num_tds = (urb->transfer_buffer_length -1)/HC_ATL_PL_SIZE + 1;
+            if((urb->transfer_flags & URB_ZERO_PACKET) &&
+                    !(urb->transfer_buffer_length % max))
+                num_tds++;
+            break;
+#ifdef CONFIG_ISO_SUPPORT
+        case PIPE_ISOCHRONOUS:
+            /* Don't need to do anything here */
+            break;
+#endif
+        default:
+            return -EINVAL; /*not supported isoc transfers*/
+
+
+    }
+
+#ifdef CONFIG_ISO_SUPPORT
+    if( temp != PIPE_ISOCHRONOUS)
+    {
+#endif
+        /*make number of tds required*/
+        urb_priv = kmalloc(sizeof (urb_priv_t) +
+                num_tds * sizeof(struct ehci_qtd),mem_flags);
+        if(!urb_priv)
+        {
+            err("memory   allocation error\n");
+            return -ENOMEM;
+        }
+
+        memset(urb_priv, 0, sizeof (urb_priv_t) +
+                num_tds * sizeof(struct ehci_qtd));
+        urb_priv->qtd[0] = NULL;
+        urb_priv->length = num_tds;
+        {
+            int i  = 0;
+            /*allocate number of tds here. better to do this in qtd_make routine*/
+            for(i = 0; i < num_tds;i++){
+                urb_priv->qtd[i] = phci_hcd_qtd_allocate(mem_flags);
+                if(!urb_priv->qtd[i]){
+                    phci_hcd_urb_free_priv(pehci_hcd, urb_priv,NULL);
+                    return -ENOMEM;
+                }
+            }
+        }
+        /*keep a copy of this*/
+        urb->hcpriv = urb_priv;
+#ifdef CONFIG_ISO_SUPPORT               
+    }
+#endif       
+
+    switch(temp){
+        case PIPE_INTERRUPT:
+            phci_hcd_make_qtd(pehci_hcd, &qtd_list,urb, &status);
+            if(status < 0)
+                return status;
+            qh = phci_hcd_submit_interrupt(pehci_hcd, ep, &qtd_list, urb, &status);
+            if(status < 0)
+                return status;
+            break;
+
+        case PIPE_CONTROL:
+        case PIPE_BULK:
+            phci_hcd_make_qtd(pehci_hcd, &qtd_list,urb, &status);
+            if(status < 0)
+                return status;
+
+            qh = phci_hcd_submit_async(pehci_hcd, ep, &qtd_list, urb, &status);
+            if(status < 0)
+                return status;
+            break;
+#ifdef CONFIG_ISO_SUPPORT        
+        case PIPE_ISOCHRONOUS:
+            iso_dbg(ISO_DBG_DATA,"[pehci_hcd_urb_enqueue]: URB Transfer buffer: 0x%08x\n", 
+                    (long) urb->transfer_buffer);
+            iso_dbg(ISO_DBG_DATA,"[pehci_hcd_urb_enqueue]: URB Buffer Length: %d\n", 
+                    (long) urb->transfer_buffer_length);
+            phcd_submit_iso(pehci_hcd, ep, urb, (unsigned long *) &status);
+
+            return status;
+
+            break;
+#endif          
+        default:
+            return -ENODEV;
+    }/*end of switch*/
+
+#ifdef MSEC_INT_BASED
+    return 0;
+#else
+    /*submit tds but iso*/
+    pehci_hcd_td_ptd_submit_urb(pehci_hcd, qh, qh->type);
+#endif
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+    return 0;
+}
+
+/*---------------------------------------------*
+  io request handlers
+ *---------------------------------------------*/
+
+/*unlink urb*/
+static int
+pehci_hcd_urb_dequeue(struct usb_hcd  *usb_hcd, struct urb *urb, int status)
+{
+    td_ptd_map_buff_t *td_ptd_buf;
+    td_ptd_map_t        *td_ptd_map;
+    struct ehci_qh *qh = 0;
+    u32   skipmap = 0;
+    u32 buffstatus = 0;
+    unsigned long flags;
+    struct ehci_qtd *qtd = 0;
+
+    struct list_head *qtd_list=0;
+    urb_priv_t *urb_priv = (urb_priv_t *)urb->hcpriv;
+    phci_hcd *hcd = usb_hcd_to_pehci_hcd(usb_hcd);
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+
+    pehci_info("device %d\n",urb->dev->devnum);
+
+    spin_lock_irqsave(&hcd->lock, flags);       
+    switch (usb_pipetype (urb->pipe)) {
+        case PIPE_CONTROL:
+        case PIPE_BULK:
+            if (!urb->hcpriv){
+                break;
+            }
+
+            qh = urb_priv->qh;
+
+
+            td_ptd_buf = &td_ptd_map_buff[TD_PTD_BUFF_TYPE_ATL];
+            td_ptd_map = &td_ptd_buf->map_list[qh->qtd_ptd_index];
+
+            /*if its already been removed*/
+            if(td_ptd_map->state == TD_PTD_NEW){
+                break;
+            }
+
+            /* These TDs are not pending anymore */
+            td_ptd_buf->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+
+            /*tell atl worker this urb is going to be removed*/
+            td_ptd_map->state = TD_PTD_REMOVE;
+            urb_priv->state |= DELETE_URB;
+      
+            /*read the skipmap, to see if this transfer has to be rescheduled*/
+            skipmap=isp1761_reg_read32(hcd->dev,hcd->regs.atltdskipmap,skipmap);
+            pehci_check("remove skip map %x, ptd map %x\n", skipmap, td_ptd_map->ptd_bitmap);
+
+            buffstatus = isp1761_reg_read32(hcd->dev, hcd->regs.buffer_status,buffstatus);
+
+            /*avoid race between isr completion and this one*/
+            isp1761_reg_write32(hcd->dev, hcd->regs.atltdskipmap,
+                    skipmap | td_ptd_map->ptd_bitmap);
+
+            while(!(skipmap & td_ptd_map->ptd_bitmap)){
+                udelay(125);
+                skipmap = isp1761_reg_read32(hcd->dev,
+                        hcd->regs.atltdskipmap, skipmap);
+            }
+
+            /* if all  transfers skipped,
+             * then disable the atl buffer,
+             * so that new transfer can come in
+             * need to see the side effects
+             * */
+            if(skipmap == NO_TRANSFER_ACTIVE){
+                /*disable the buffer*/
+                pehci_info("disable the atl buffer\n");
+                buffstatus &= ~ATL_BUFFER;
+                isp1761_reg_write32(hcd->dev,hcd->regs.buffer_status,buffstatus);
+            }
+
+            qtd_list = &qh->qtd_list;
+            /*this should remove all pending transfers*/
+            pehci_check("num tds %d, urb length %d,device %d\n",
+                    urb_priv->length, urb->transfer_buffer_length,urb->dev->devnum); 
+
+            pehci_check("remove first qtd address %p\n", urb_priv->qtd[0]);
+            pehci_check("length of the urb %d, completed %d\n", 
+                    urb->transfer_buffer_length, urb->actual_length);
+            qtd = urb_priv->qtd[urb_priv->length-1];
+            pehci_check("qtd state is %x\n", qtd->state);       
+            pehci_hcd_urb_complete(hcd,qh,urb,td_ptd_map);
+
+#if 0 /* Set only for memory leak debugging */
+            {
+                if(!list_empty(qtd_list))
+                {
+                    unsigned long i, mem_end, unfree;
+
+                    mem_end = BLK_256_ + BLK_1024_ + BLK_4096_;
+
+                    for(i = 0, unfree = 0; i < mem_end; i++)
+                    {
+                        if(memalloc[i].used == 1)
+                            unfree++;                       
+                    }
+                    printk("DBG: There are %d unfreed memory\n");
+                }
+            }
+#endif /* Mem leak debug */
+
+
+            break;
+        case PIPE_INTERRUPT:
+            pehci_check("phci_1761_urb_dequeue: INTR needs to be done\n");
+            if (!urb->hcpriv){
+                break;
+            }
+
+            qh = urb_priv->qh;
+            td_ptd_buf = &td_ptd_map_buff[TD_PTD_BUFF_TYPE_INTL];
+            td_ptd_map = &td_ptd_buf->map_list[qh->qtd_ptd_index];
+
+            /*urb is already been removed*/
+            if(td_ptd_map->state == TD_PTD_NEW){
+                kfree(urb_priv);
+                break;
+            }
+
+            /* These TDs are not pending anymore */
+            td_ptd_buf->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+
+            td_ptd_map->state = TD_PTD_REMOVE;
+            urb_priv->state |= DELETE_URB;
+
+            /*read the skipmap, to see if this transfer has to be rescheduled*/
+            skipmap = isp1761_reg_read32(hcd->dev, hcd->regs.inttdskipmap, skipmap);
+            isp1761_reg_write32(hcd->dev, hcd->regs.inttdskipmap,
+                    skipmap | td_ptd_map->ptd_bitmap);
+            qtd_list = &qh->qtd_list;
+            pehci_hcd_urb_complete(hcd,qh,urb,td_ptd_map);
+            if(!list_empty(qtd_list))
+            {   
+                err("Never Error: List must not be emplyt\n"); /*only one td in my endpoint*/
+            }
+            break;
+        case PIPE_ISOCHRONOUS:
+            /*nothing to do here, wait till all transfers are done in iso worker*/
+            break;
+    }
+
+    spin_unlock_irqrestore(&hcd->lock, flags);
+    pehci_info("status %d\n",status);
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+    return status;
+}
+
+/* bulk qh holds the data toggle */
+
+    static void
+pehci_hcd_endpoint_disable (struct usb_hcd *usb_hcd, struct usb_host_endpoint *ep)//struct hcd_dev *dev, int ep)
+{
+    phci_hcd            *ehci = usb_hcd_to_pehci_hcd (usb_hcd);
+    unsigned long               flags;
+    struct ehci_qh              *qh;
+
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+    /* ASSERT:  any requests/urbs are being unlinked */
+    /* ASSERT:  nobody can be submitting urbs for this any more */
+
+    spin_lock_irqsave (&ehci->lock, flags);
+    qh = ep->hcpriv;
+    if (!qh){
+        goto done;
+    }else {
+        /*i will complete whatever left on this endpoint*/
+        pehci_complete_device_removal(ehci,qh);
+	ep->hcpriv = NULL;
+        goto done;
+    }
+done:
+    ep->hcpriv = NULL;
+    spin_unlock_irqrestore (&ehci->lock, flags);
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+    return;
+}
+
+/*called by core, for current frame number*/
+    static int
+pehci_hcd_get_frame_number(struct usb_hcd *usb_hcd)
+{
+    u32 framenumber = 0;
+    phci_hcd *pehci_hcd = usb_hcd_to_pehci_hcd(usb_hcd);
+    framenumber = isp1761_reg_read32(pehci_hcd->dev, pehci_hcd->regs.frameindex, framenumber);
+    return framenumber;
+}
+
+/*root hub status data, called by root hub timer
+ *return 0, if no change, else
+ *      1, incase of high speed device
+ */
+    static int
+pehci_rh_status_data (struct usb_hcd *usb_hcd,char *buf)
+{
+
+    u32         temp = 0, status = 0;
+    u32         ports = 0, i, retval = 1;
+    unsigned long       flags;
+    phci_hcd *hcd = usb_hcd_to_pehci_hcd(usb_hcd);
+
+    /* init status to no-changes */
+    buf [0] = 0;
+    /*number of ports*/
+    ports = isp1761_reg_read32(hcd->dev, hcd->regs.hcsparams, ports);
+    ports &= 0xf;
+    spin_lock_irqsave(&hcd->lock, flags);
+    /*read the port status registers*/
+    for(i=0;i<ports;i++)
+    {
+        temp = isp1761_reg_read32(hcd->dev,hcd->regs.ports[i],temp);
+        if(temp & PORT_OWNER){
+            /* dont report the port status change in case of CC HCD
+             * but clear the port status , if there is any*/
+            if(temp & PORT_CSC){
+                temp &=~PORT_CSC;
+                isp1761_reg_write32(hcd->dev, hcd->regs.ports[i],temp);
+                continue;
+            }
+        }
+
+        if (!(temp & PORT_CONNECT))
+            hcd->reset_done [i] = 0;
+        if ((temp & (PORT_CSC | PORT_PEC | PORT_OCC)) != 0) {
+            if (i < 7)
+                buf [0] |= 1 << (i + 1);
+            else
+                buf [1] |= 1 << (i - 7);
+            status = STS_PCD;
+        }
+    }
+
+    spin_unlock_irqrestore (&hcd->lock, flags);
+    return status ? retval : 0;
+}
+
+/*root hub control requests*/
+static int
+pehci_rh_control (struct usb_hcd *usb_hcd,u16 typeReq,u16 wValue,
+        u16 wIndex,char *buf,u16 wLength)
+{
+    u32         ports = 0;
+    u32         temp = 0, status;
+    unsigned long       flags;
+    int         retval = 0;
+    phci_hcd *hcd = usb_hcd_to_pehci_hcd(usb_hcd);
+
+    ports = isp1761_reg_read32(hcd->dev, hcd->regs.hcsparams, ports);
+    pehci_info("%s: number of ports %d\n",__FUNCTION__, ports);
+    spin_lock_irqsave(&hcd->lock,flags);
+    switch(typeReq){
+        case ClearHubFeature:
+            switch (wValue) {
+                case C_HUB_LOCAL_POWER:
+                case C_HUB_OVER_CURRENT:
+                    /* no hub-wide feature/status flags */
+                    break;
+                default:
+                    goto error;
+            }
+            break;
+        case ClearPortFeature:
+            if (!wIndex || wIndex > (ports & 0xf)){
+                pehci_info("ClearPortFeature not valid port number %d, should be %d\n",
+                        wIndex, (ports & 0xf));
+                goto error;}
+                wIndex--;
+                temp = isp1761_reg_read32(hcd->dev, hcd->regs.ports[wIndex], temp);
+                if (temp & PORT_OWNER){
+                    printk("port is owned by the CC host\n");
+                    break;}
+
+                    switch (wValue) {
+                        case USB_PORT_FEAT_ENABLE:
+                            isp1761_reg_write32(hcd->dev,hcd->regs.ports[wIndex],
+                                    temp & ~PORT_PE);
+
+                            break;
+                        case USB_PORT_FEAT_C_ENABLE:
+                            printk("disable the port\n");
+                            isp1761_reg_write32(hcd->dev,hcd->regs.ports[wIndex],temp | PORT_PEC);
+                            break;
+                        case USB_PORT_FEAT_SUSPEND:
+                        case USB_PORT_FEAT_C_SUSPEND:
+                            break;
+                        case USB_PORT_FEAT_POWER:
+                            if(ports & 0x10){/*port has has power control switches*/
+                                isp1761_reg_write32(hcd->dev, hcd->regs.ports[wIndex], temp & ~PORT_POWER);
+                            }
+                            break;
+                        case USB_PORT_FEAT_C_CONNECTION:
+                            pehci_print("connect change, status is 0x%08x\n",temp);
+                            isp1761_reg_write32(hcd->dev, hcd->regs.ports[wIndex], temp | PORT_CSC);
+                            break;
+                        case USB_PORT_FEAT_C_OVER_CURRENT:
+                            isp1761_reg_write32(hcd->dev, hcd->regs.ports[wIndex], temp | PORT_OCC);
+                            break;
+                        default:
+                            goto error;
+
+                    }
+                    break;
+
+        case GetHubDescriptor:
+                    pehci_hub_descriptor(hcd, (struct usb_hub_descriptor *)buf);
+                    break;
+
+        case GetHubStatus:
+                    /* no hub-wide feature/status flags */
+                    memset (buf, 0, 4);
+                    break;
+        case GetPortStatus:
+                    if (!wIndex || wIndex > (ports & 0xf)){
+                        pehci_info("GetPortStatus,not valid port number %d, should be %d\n",
+                                wIndex, (ports & 0xf));
+                        goto error;}
+                        wIndex--;
+                        status = 0;
+                        temp = isp1761_reg_read32(hcd->dev, hcd->regs.ports[wIndex], temp);
+                        /*connect status chnage*/
+                        if (temp & PORT_CSC){
+                            status |= 1 << USB_PORT_FEAT_C_CONNECTION;
+                            pehci_print("feature CSC 0x%08x and status 0x%08x  \n", temp, status);
+                        }
+                        /*port enable change*/
+                        if (temp & PORT_PEC){
+                            status |= 1 << USB_PORT_FEAT_C_ENABLE;
+                            pehci_print("feature PEC  0x%08x and status 0x%08x  \n", temp, status);
+                        }
+                        /*port over-current*/
+                        if (temp & PORT_OCC){
+                            status |= 1 << USB_PORT_FEAT_C_OVER_CURRENT;
+                            pehci_print("feature OCC 0x%08x and status 0x%08x  \n", temp, status);
+                        }
+
+                        /* whoever resets must GetPortStatus to complete it!! */
+                        if ((temp & PORT_RESET) && jiffies > hcd->reset_done[wIndex]){
+                            status |= 1 << USB_PORT_FEAT_C_RESET;
+                            pehci_print("feature reset 0x%08x and status 0x%08x\n", temp, status);
+                            /* force reset to complete */
+                            isp1761_reg_write32(hcd->dev, hcd->regs.ports[wIndex], temp & ~PORT_RESET);
+                            do {
+                                temp = isp1761_reg_read32(hcd->dev, hcd->regs.ports[wIndex], temp);
+                                udelay(20);
+                            } while (temp & PORT_RESET);
+                            /* see what we found out */
+                            temp = phci_check_reset_complete (hcd, wIndex, temp);
+                        }
+
+                        /* don't show wPortStatus if it's owned by a companion hc */
+
+                        if (!(temp & PORT_OWNER)) {
+                            if (temp & PORT_CONNECT) {
+                                status |= 1 << USB_PORT_FEAT_CONNECTION;
+                                status |= 1 << USB_PORT_FEAT_HIGHSPEED;
+                            }
+                            if (temp & PORT_PE)
+                                status |= 1 << USB_PORT_FEAT_ENABLE;
+                            if (temp & PORT_SUSPEND)
+                                status |= 1 << USB_PORT_FEAT_SUSPEND;
+                            if (temp & PORT_OC)
+                                status |= 1 << USB_PORT_FEAT_OVER_CURRENT;
+                            if (temp & PORT_RESET)
+                                status |= 1 << USB_PORT_FEAT_RESET;
+                            if (temp & PORT_POWER)
+                                status |= 1 << USB_PORT_FEAT_POWER;
+                        }
+
+                        /* This alignment is good, caller used kmalloc() */
+                        *((u32 *) buf) = cpu_to_le32 (status);
+                        break;
+
+        case SetHubFeature:
+                        switch (wValue) {
+                            case C_HUB_LOCAL_POWER:
+                            case C_HUB_OVER_CURRENT:
+                                /* no hub-wide feature/status flags */
+                                break;
+                            default:
+                                goto error;
+                        }
+                        break;
+        case SetPortFeature:
+                        if (!wIndex || wIndex > (ports & 0xf)){
+                            pehci_info("SetPortFeature not valid port number %d, should be %d\n",
+                                    wIndex, (ports & 0xf));
+                            goto error;}
+                            wIndex--;
+                            temp = isp1761_reg_read32(hcd->dev, hcd->regs.ports[wIndex], temp);
+                            if (temp & PORT_OWNER){
+                                break;
+                            }
+                            switch (wValue) {
+                                case USB_PORT_FEAT_ENABLE:
+                                    /*enable the port*/
+                                    isp1761_reg_write32(hcd->dev, hcd->regs.ports[wIndex], temp | PORT_PE);
+                                    break;
+                                case USB_PORT_FEAT_SUSPEND:
+                                    isp1761_reg_write32(hcd->dev, hcd->regs.ports[wIndex], temp | PORT_SUSPEND);
+                                    break;
+                                case USB_PORT_FEAT_POWER:
+                                    if(ports & 0x10){
+                                        isp1761_reg_write32(hcd->dev, hcd->regs.ports[wIndex], temp | PORT_POWER);
+                                    }
+                                    break;
+                                case USB_PORT_FEAT_RESET:
+                                    if ((temp & (PORT_PE|PORT_CONNECT)) == PORT_CONNECT
+                                            && PORT_USB11 (temp)) {
+                                        printk("error:port %d low speed --> companion\n",
+                                                wIndex + 1);
+                                        temp |= PORT_OWNER;
+                                    } else {
+                                        temp |= PORT_RESET;
+                                        temp &= ~PORT_PE;
+
+                                        /*
+                                         * caller must wait, then call GetPortStatus
+                                         * usb 2.0 spec says 50 ms resets on root
+                                         */
+                                        hcd->reset_done [wIndex] = jiffies
+                                            + ((50 /* msec */ * HZ) / 1000);
+                                    }
+                                    isp1761_reg_write32(hcd->dev,hcd->regs.ports[wIndex], temp);
+                                    break;
+                                default:
+                                    goto error;
+                            }
+                            break;
+        default:
+                            pehci_print("this request doesnt fit anywhere\n");
+error:
+                            /* "stall" on error */
+                            pehci_info("unhandled root hub request: typereq 0x%08x, wValue %d, wIndex %d\n",
+                                    typeReq, wValue, wIndex);
+                            retval = -EPIPE;
+    }
+    spin_unlock_irqrestore (&hcd->lock, flags);
+    return retval;
+}
+
+
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver pehci_driver = {
+    .description =              hcd_name,
+    .product_desc = "NXP ISP1761",
+    .hcd_priv_size = sizeof(phci_hcd) - sizeof(struct usb_hcd),
+
+    .irq = pehci_hcd_irq,
+
+    /*
+     * generic hardware linkage
+     */
+    .flags =            HCD_USB2 | HCD_MEMORY,
+
+    /*
+     * basic lifecycle operations
+     */
+    .reset =            pehci_hcd_reset,
+    .start =            pehci_hcd_start,
+    .stop =                     pehci_hcd_stop,
+
+    /*
+     * managing i/o requests and associated device resources
+     */
+    .urb_enqueue =              pehci_hcd_urb_enqueue,
+    .urb_dequeue =              pehci_hcd_urb_dequeue,
+    .endpoint_disable = pehci_hcd_endpoint_disable,
+
+    /*
+     * scheduling support
+     */
+    .get_frame_number = pehci_hcd_get_frame_number,
+
+    /*
+     * root hub support
+     */
+    .hub_status_data =  pehci_rh_status_data,
+    .hub_control =              pehci_rh_control,
+};
+
+/*probe the PCI host*/
+    int 
+pehci_hcd_probe(struct isp1761_dev *tmp_1761_dev , isp1761_id *ids )
+{
+    struct usb_hcd          *usb_hcd;
+    phci_hcd                *pehci_hcd;
+    struct device *dev = tmp_1761_dev->dev;
+
+    int             status =0;
+
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+    if (usb_disabled())
+        return -ENODEV;
+
+    usb_hcd = usb_create_hcd(&pehci_driver, dev, "platform");
+    if (usb_hcd == NULL){
+        status = -ENOMEM;
+        goto clean;
+    }
+
+    /*this is our host*/
+    pehci_hcd = usb_hcd_to_pehci_hcd(usb_hcd);
+    pehci_hcd->dev = tmp_1761_dev;
+    pehci_hcd->iobase = (u8*)tmp_1761_dev->baseaddress;
+    pehci_hcd->iolength = tmp_1761_dev->length;
+    pehci_hcd->plxiobase = (u8*)tmp_1761_dev->dmabase;
+    pehci_hcd->plxiolength = tmp_1761_dev->length;
+
+
+    /*lets keep our host here*/
+    tmp_1761_dev->driver_data = usb_hcd;
+
+    status = usb_add_hcd(usb_hcd, tmp_1761_dev->irq, IRQF_DISABLED | IRQF_SHARED);
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+    return status;
+
+clean:
+    return status;
+
+} 
+
+/*remove the host controller*/
+    static void
+pehci_hcd_remove(struct isp1761_dev *tmp_1761_dev)
+
+{
+    struct usb_hcd          *usb_hcd;
+
+    phci_hcd *hcd = NULL;
+    usb_hcd = (struct usb_hcd *)tmp_1761_dev->driver_data;
+    if (!usb_hcd)
+        return;
+
+    hcd = usb_hcd_to_pehci_hcd(usb_hcd);
+
+    usb_remove_hcd(usb_hcd);
+
+    return;
+}
+
+
+static isp1761_id ids = {
+    .idVendor =   0x04cc, /*philips isp1761 vendor_id*/
+    .idProduct =  0x1A64, /*philips isp1761 product_id*/
+    .driver_info =  (unsigned long) &pehci_driver,
+};
+
+/* pci driver glue; this is a "new style" PCI driver module */
+static struct isp1761_driver pehci_hcd_pci_driver = {
+    .name = (char *) hcd_name,
+    .index = 0,
+    .id = &ids,
+    .probe = pehci_hcd_probe,
+    .remove = pehci_hcd_remove,
+};
+
+static int  __init pehci_module_init(void)
+{
+    int result = 0;
+    phci_hcd_mem_init();
+
+    /*register driver*/
+    result = isp1761_register_driver(&pehci_hcd_pci_driver);
+    if(!result)
+        info("Host Driver has been Registered");
+    else
+        err("Host Driver has not been Registered with errors : %d",result);
+    return result;
+
+}
+
+static void __exit pehci_module_cleanup (void) {        
+    isp1761_unregister_driver(&pehci_hcd_pci_driver);
+}
+
+MODULE_DESCRIPTION (DRIVER_DESC);
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_LICENSE ("GPL");
+module_init (pehci_module_init);
+module_exit (pehci_module_cleanup);
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/host/pehci.h linux-3.13/drivers/armadeus/isp1761/host/pehci.h
--- linux-3.13/drivers/armadeus/isp1761/host/pehci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/host/pehci.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,636 @@
+/***************************************************************************************************
+ * NXP ISP176x host controller interface header file
+ *
+ * (c) 2006 NXP B.V., All rights reserved. <usb.linux@nxp.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * File Name:   pehci.h
+ * 
+ * Refering linux kernel version 2.6.9
+ *
+ * History:     
+ *
+ * Date                Author                  Comments
+ * ----------------------------------------------------------------------------------------------------
+ * May 16, 2003        krishan                  initial version
+ * May 02 2007	       Prabhakar		ported to 2.6.20 with backward compatibility with 2.6.9  
+ *                                                                              
+ *******************************************************************************************************/
+
+#ifndef __PEHCI_H__
+#define __PEHCI_H__
+
+#define DRIVER_AUTHOR 	"NXP Semiconductors"
+#define DRIVER_DESC 	"ISP1761 Enhanced Host Controller (EHCI) Driver"
+
+/*    bus related stuff */
+#define __ACTIVE                0x01
+#define __SLEEPY                0x02
+#define __SUSPEND               0x04
+#define __TRANSIENT             0x80
+
+#define USB_STATE_HALT          0
+#define USB_STATE_RUNNING       (__ACTIVE)
+#define USB_STATE_READY         (__ACTIVE|__SLEEPY)
+#define USB_STATE_QUIESCING     (__SUSPEND|__TRANSIENT|__ACTIVE)
+#define USB_STATE_RESUMING      (__SUSPEND|__TRANSIENT)
+#define USB_STATE_SUSPENDED     (__SUSPEND)
+
+/* System flags  */
+#define HCD_MEMORY              0x0001
+#define HCD_USB2                0x0020
+#define HCD_USB11               0x0010
+
+#define HCD_IS_RUNNING(state) ((state) & __ACTIVE)
+#define HCD_IS_SUSPENDED(state) ((state) & __SUSPEND)
+
+
+/*---------------------------------------------------
+ *    Host controller related 
+ -----------------------------------------------------*/
+// IRQ line for the ISP 1761 
+#define HCD_IRQ                 IRQ_GPIO(25)
+#define CMD_RESET               (1<<1)          /* reset HC not bus */
+#define CMD_RUN                 (1<<0)          /* start/stop HC */
+#define STS_PCD                 (1<<2)          /* port change detect */
+/* NOTE:  urb->transfer_flags expected to not use this bit !!! */
+#define EHCI_STATE_UNLINK       0x8000          /* urb being unlinked */
+
+/*  Bits definations for qha*/
+/* Bits PID*/
+#define SETUP_PID               (2)
+#define OUT_PID                 (0)
+#define IN_PID                  (1)
+
+/* Bits MULTI*/
+#define MULTI(x)                ((x)<< 29)      
+#define XFER_PER_UFRAME(x)      (((x) >> 29) & 0x3)
+
+/*Active, EP type and speed bits */
+#define QHA_VALID               (1<<0)
+#define QHA_ACTIVE              (1<<31)
+
+/*1761 error bit maps*/
+#define HC_SOF_INT              (1<< 0)
+#define HC_MSEC_INT             (1 << 1)
+#define HC_EOT_INT              (1 << 3)
+
+#define HC_INTL_INT             (1 << 7)
+#define HC_ATL_INT              (1 << 8)
+#define HC_ISO_INT              (1 << 9)
+
+/*PTD error codes*/
+#define PTD_STATUS_HALTED       (1 << 30)
+#define PTD_XACT_ERROR          (1 << 28)
+#define PTD_BABBLE              (1 << 29)
+
+/*ep types*/
+#define EPTYPE_BULK             (2 << 12)
+#define EPTYPE_CONTROL          (0 << 12)
+#define EPTYPE_INT              (3 << 12)
+#define EPTYPE_ISO              (1 << 12)
+
+#define PHCI_QHA_LENGTH         32
+
+/*LINUX269*/
+#define usb_inc_dev_use         usb_get_dev
+#define usb_dec_dev_use         usb_put_dev
+#define usb_free_dev            usb_put_dev
+
+/*1761 host controller periodic size*/
+#define PTD_PERIODIC_SIZE       32
+#define MAX_PERIODIC_SIZE       32
+
+/*periodic list*/
+struct _periodic_list{
+    int  framenumber;
+    struct list_head itd_head;
+};
+typedef struct _periodic_list periodic_list;
+
+
+/*iso ptd*/
+struct _isp1761_isoptd{
+    u32   td_info1;
+    u32   td_info2;
+    u32   td_info3;
+    u32   td_info4;
+    u32   td_info5;
+    u32   td_info6;
+    u32   td_info7;
+    u32   td_info8;
+}__attribute__ ((aligned (32)));
+
+typedef struct _isp1761_isoptd isp1761_isoptd;
+
+struct _isp1761_qhint{
+    u32   td_info1;
+    u32   td_info2;
+    u32   td_info3;
+    u32   td_info4;
+    u32   td_info5;
+#define INT_UNDERRUN (1 << 2)
+#define INT_BABBLE    (1 << 1)
+#define INT_EXACT     (1 << 0)
+    u32   td_info6;
+    u32   td_info7;
+    u32   td_info8;
+}__attribute__ ((aligned (32)));
+
+typedef struct _isp1761_qhint isp1761_qhint;
+
+
+struct _isp1761_qha{
+    u32   td_info1;   /* First 32 bit */
+    u32   td_info2;   /* Second 32 bit */
+    u32   td_info3;   /* third 32 bit */
+    u32   td_info4;   /* fourth 32 bit */
+    u32   reserved[4];  
+};
+typedef struct _isp1761_qha isp1761_qha, *pisp1761_qha;
+
+
+
+
+/*this does not cover all interrupts in 1761 chip*/
+typedef struct _ehci_regs {
+
+    /*standard ehci registers*/
+    u32                 command;
+    u32                 usbinterrupt;
+    u32                 usbstatus;
+    u32                 hcsparams;
+    u32                 frameindex;
+
+    /*isp1761 interrupt specific registers*/
+    u32                 hwmodecontrol;  
+    u32                 interrupt;
+    u32                 interruptenable;
+    u32                 interruptthreshold;
+    u32                 iso_irq_mask_or;
+    u32                 int_irq_mask_or;
+    u32                 atl_irq_mask_or;
+    u32                 iso_irq_mask_and;
+    u32                 int_irq_mask_and;
+    u32                 atl_irq_mask_and;
+    u32     buffer_status;
+
+    /*isp 1761 initialization registers*/
+    u32                 reset;
+    u32                 configflag;
+    u32                 ports[4];
+
+    /*isp1761 transfer specific registers*/
+    u32                 isotddonemap;
+    u32                 inttddonemap;
+    u32                 atltddonemap;
+    u32                 isotdskipmap;
+    u32                 inttdskipmap;
+    u32                 atltdskipmap;
+    u32                 isotdlastmap;
+    u32                 inttdlastmap;
+    u32                 atltdlastmap;
+    u32                     scratch;
+
+}ehci_regs, *pehci_regs;
+
+/* type tag from {qh,itd,sitd,fstn}->hw_next */
+#define Q_NEXT_TYPE(dma) ((dma) & __constant_cpu_to_le32 (3 << 1))
+
+/* values for that type tag */
+#define Q_TYPE_ITD      __constant_cpu_to_le32 (0 << 1)
+#define Q_TYPE_QH       __constant_cpu_to_le32 (1 << 1)
+#define Q_TYPE_SITD     __constant_cpu_to_le32 (2 << 1)
+#define Q_TYPE_FSTN     __constant_cpu_to_le32 (3 << 1)
+
+/*next queuehead in execution*/
+#define QH_NEXT(dma)    cpu_to_le32((u32)dma)
+
+struct ehci_qh {
+    /* first part defined by EHCI spec */
+    u32                 hw_next;         /* see EHCI 3.6.1 */
+    u32                 hw_info1;        /* see EHCI 3.6.2 */
+
+    u32                 hw_info2;        /* see EHCI 3.6.2 */
+    u32                 hw_current;      /* qtd list - see EHCI 3.6.4 */
+
+    /* qtd overlay (hardware parts of a struct ehci_qtd) */
+    u32                 hw_qtd_next;
+    u32                 hw_alt_next;
+    u32                 hw_token;
+    u32                 hw_buf [5];
+    u32                 hw_buf_hi [5];
+
+    /* the rest is HCD-private */
+    dma_addr_t          qh_dma;         /* address of qh */
+    struct list_head    qtd_list;       /* sw qtd list */
+    struct ehci_qtd             *dummy;
+    struct ehci_qh              *reclaim;       /* next to reclaim */
+
+    atomic_t                    refcount;
+    wait_queue_head_t   waitforcomplete;
+    unsigned            stamp;
+
+    u8                  qh_state;
+
+    /* periodic schedule info */
+    u8                  usecs;          /* intr bandwidth */
+    u8                  gap_uf;         /* uframes split/csplit gap */
+    u8                  c_usecs;        /* ... split completion bw */
+    unsigned short              period;         /* polling interval */
+    unsigned short              start;          /* where polling starts */
+    u8                  datatoggle;     /*data toggle*/
+
+    /*handling the ping stuffs*/
+    u8                  ping;   /*ping bit*/
+
+    /*qtd <-> ptd management*/
+
+    u32         qtd_ptd_index;  /* Td-PTD map index for this ptd */
+    u32             type;          /* endpoint type */
+
+    /*iso stuffs*/
+    int                 next_uframe; /*next uframe for this endpoint*/
+    struct list_head    itd_list;   /*list of tds to this endpoint*/
+
+    /*scheduling requirements for this endpoint*/
+    u32                    ssplit;
+    u32                 csplit;
+};
+
+/* urb private part for the driver. */
+typedef struct {
+    struct ehci_qh      *qh;
+    u16                 length;         /* number of tds associated with this request */
+    u16                 td_cnt;         /* number of tds already serviced */
+    int                 state;          /* State machine state when URB is deleted  */
+    int         timeout;        /* timeout for bulk transfers */
+    wait_queue_head_t   wait;   /* wait State machine state when URB is deleted */
+    /*FIX solve the full speed dying*/
+    struct timer_list   urb_timer;
+    struct ehci_qtd             *qtd[0]; /* list pointer to all corresponding TDs associated with this request */
+
+} urb_priv_t;
+
+/*
+ * EHCI Specification 0.95 Section 3.6
+ * QH: describes control/bulk/interrupt endpoints
+ * See Fig 3-7 "Queue Head Structure Layout".
+ *
+ * These appear in both the async and (for interrupt) periodic schedules.
+ */
+
+
+/*Defination required for the ehci Queuehead */
+#define QH_HEAD                 0x00008000
+#define QH_STATE_LINKED         1               /* HC sees this */
+#define QH_STATE_UNLINK         2               /* HC may still see this */
+#define QH_STATE_IDLE           3               /* HC doesn't see this */
+#define QH_STATE_UNLINK_WAIT    4               /* LINKED and on reclaim q */
+#define QH_STATE_COMPLETING     5               /* don't touch token.HALT */
+#define QH_STATE_TAKE_NEXT      8               /*take the new transfer from*/
+#define NO_FRAME ((unsigned short)~0)           /* pick new start */
+
+
+/*memory management structures*/
+#define MEM_KV
+#ifdef MEM_KV
+typedef struct isp1761_mem_addr {
+    u32 phy_addr;       /* Physical address of the memory */
+    u32 virt_addr;      /* after ioremap() function call */
+    u8  num_alloc;  /* In case n*smaller size is allocated then for clearing purpose */
+    u32 blk_size;    /*block size*/
+    u8  blk_num;    /* number of the block*/
+    u8  used;       /*used/free*/
+} isp1761_mem_addr_t;
+#else 
+typedef struct isp1761_mem_addr {
+    void        *phy_addr;      /* Physical address of the memory */
+    void     *virt_addr;        /* after ioremap() function call */
+    __u8          usage; 
+    __u32       blk_size;    /*block size*/
+}isp1761_mem_addr_t;
+
+#endif
+
+struct ehci_itd {
+    /* first part defined by EHCI spec */
+    u32                 hw_next;           /* see EHCI 3.3.1 */
+    u32                 hw_transaction [8]; /* see EHCI 3.3.2 */
+#define EHCI_ISOC_ACTIVE        (1<<31)        /* activate transfer this slot */
+#define EHCI_ISOC_BUF_ERR       (1<<30)        /* Data buffer error */
+#define EHCI_ISOC_BABBLE        (1<<29)        /* babble detected */
+#define EHCI_ISOC_XACTERR       (1<<28)        /* XactErr - transaction error */
+
+#define EHCI_ITD_LENGTH(tok)    (((tok)>>16) & 0x7fff)
+#define EHCI_ITD_IOC            (1 << 15)       /* interrupt on complete */
+
+    u32                 hw_bufp [7];    /* see EHCI 3.3.3 */ 
+    u32                 hw_bufp_hi [7]; /* Appendix B */
+
+    /* the rest is HCD-private */
+    dma_addr_t          itd_dma;        /* for this itd */
+    struct urb          *urb;
+    struct list_head    itd_list;       /* list of urb frames' itds */
+    dma_addr_t          buf_dma;        /* frame's buffer address */
+
+    /* for now, only one hw_transaction per itd */
+    u32                 transaction;
+    u16                 index;          /* in urb->iso_frame_desc */
+    u16                 uframe;         /* in periodic schedule */
+    u16                 usecs;
+    /*memory address*/
+    struct isp1761_mem_addr mem_addr;
+    int   length;
+    u32   multi;
+    u32   framenumber;
+    u32   ptdframe;
+    int itd_index;
+    /*scheduling fields*/
+    u32  ssplit;
+    u32  csplit;
+};
+
+/*
+ * EHCI Specification 0.95 Section 3.5
+ * QTD: describe data transfer components (buffer, direction, ...) 
+ * See Fig 3-6 "Queue Element Transfer Descriptor Block Diagram".
+ *
+ * These are associated only with "QH" (Queue Head) structures,
+ * used with control, bulk, and interrupt transfers.
+ */
+struct ehci_qtd {
+    /* first part defined by EHCI spec */
+    u32                 hw_next;          /* see EHCI 3.5.1 */
+    u32                 hw_alt_next;      /* see EHCI 3.5.2 */
+    u32                 hw_token;         /* see EHCI 3.5.3 */       
+
+    u32                 hw_buf [5];        /* see EHCI 3.5.4 */
+    u32                 hw_buf_hi [5];        /* Appendix B */
+
+    /* the rest is HCD-private */
+    dma_addr_t          qtd_dma;                /* qtd address */
+    struct list_head    qtd_list;               /* sw qtd list */
+    struct urb          *urb;                   /* qtd's urb */
+    size_t                      length;                 /* length of buffer */
+    u32                         state;                  /*state of the qtd*/
+#define QTD_STATE_NEW                   0x100 
+#define QTD_STATE_DONE                  0x200
+#define QTD_STATE_SCHEDULED             0x400
+#define QTD_STATE_LAST                  0x800
+    struct isp1761_mem_addr mem_addr;
+};
+
+#define QTD_TOGGLE                      (1 << 31)       /* data toggle */
+#define QTD_LENGTH(tok)                 (((tok)>>16) & 0x7fff)
+#define QTD_IOC                         (1 << 15)       /* interrupt on complete */
+#define QTD_CERR(tok)                   (((tok)>>10) & 0x3)
+#define QTD_PID(tok)                    (((tok)>>8) & 0x3)
+#define QTD_STS_ACTIVE                  (1 << 7)        /* HC may execute this */
+#define QTD_STS_HALT                    (1 << 6)        /* halted on error */
+#define QTD_STS_DBE                     (1 << 5)        /* data buffer error (in HC) */
+#define QTD_STS_BABBLE                  (1 << 4)        /* device was babbling (qtd halted) */
+#define QTD_STS_XACT                    (1 << 3)        /* device gave illegal response */
+#define QTD_STS_MMF                     (1 << 2)        /* incomplete split transaction */
+#define QTD_STS_STS                     (1 << 1)        /* split transaction state */
+#define QTD_STS_PING                    (1 << 0)        /* issue PING? */
+
+/* for periodic/async schedules and qtd lists, mark end of list */
+#define EHCI_LIST_END   __constant_cpu_to_le32(1) /* "null pointer" to hw */
+#define QTD_NEXT(dma)   cpu_to_le32((u32)dma)
+
+struct _phci_driver;
+struct _isp1761_hcd;
+#define EHCI_MAX_ROOT_PORTS 1
+
+#include "../linux-3.13/drivers/usb/core/hcd.h"
+
+/*host controller*/
+typedef struct _phci_hcd {
+    struct usb_hcd       usb_hcd;
+    spinlock_t  lock;
+    /* async schedule support */
+    struct ehci_qh              *async;
+    struct ehci_qh              *reclaim;
+    /* periodic schedule support */
+    unsigned            periodic_size;
+    int                         next_uframe;    /* scan periodic, start here */
+    int                         periodic_sched; /* periodic activity count */
+    struct usb_device     *otgdev;   /*otg deice, with address 2*/
+    struct timer_list   rh_timer;       /* drives root hub */
+    struct list_head    dev_list;       /* devices on this bus */
+    struct list_head       urb_list;  /*iso testing*/
+
+    /*msec break in interrupts*/
+    atomic_t                    nuofsofs;
+    atomic_t                    missedsofs;
+
+    struct isp1761_dev  *dev;
+    /*hw info*/
+    u8                                  *iobase;
+    u32                                  iolength;
+    u8                                   *plxiobase;
+    u32                                   plxiolength;  
+
+    int                         irq;            /* irq allocated */
+    int                         state;/*state of the host controller*/
+    unsigned long       reset_done[EHCI_MAX_ROOT_PORTS];
+    ehci_regs   regs;
+    struct _isp1761_qha qha;
+    struct _isp1761_qhint qhint;
+    struct _isp1761_isoptd isotd;
+    struct tasklet_struct tasklet;
+    /*this timer is going to run every 20 msec*/
+    struct timer_list   watchdog;
+    void (*worker_function) (struct _phci_hcd* hcd);
+    struct _periodic_list periodic_list[PTD_PERIODIC_SIZE];
+}phci_hcd,*pphci_hcd;
+
+/*usb_device->hcpriv, points to this structure*/
+typedef struct hcd_dev{
+    struct list_head        dev_list;
+    struct list_head        urb_list;
+}hcd_dev;
+
+#define usb_hcd_to_pehci_hcd(hcd)   container_of(hcd, struct _phci_hcd, usb_hcd)
+
+/*td allocation*/
+#ifdef CONFIG_PHCI_MEM_SLAB
+
+#define         qha_alloc(t,c)  kmem_cache_alloc(c,ALLOC_FLAGS)
+#define         qha_free(c,x)   kmem_cache_free(c,x)
+static          kmem_cache_t    *qha_cache, *qh_cache,*qtd_cache;
+static int phci_hcd_mem_init (void)
+{
+    /* qha TDs accessed by controllers and host */
+    qha_cache = kmem_cache_create ("phci_ptd", sizeof (isp1761_qha), 0,
+            SLAB_HWCACHE_ALIGN, NULL, NULL);
+    if (!qha_cache) {
+        printk("no TD cache?");
+        return -ENOMEM;
+    }
+
+    /* qh TDs accessed by controllers and host */
+    qh_cache = kmem_cache_create ("phci_ptd", sizeof (isp1761_qha), 0,
+            SLAB_HWCACHE_ALIGN, NULL, NULL);
+    if (!qh_cache) {
+        printk("no TD cache?");
+        return -ENOMEM;
+    }
+
+    /* qtd  accessed by controllers and host */
+    qtd_cache = kmem_cache_create ("phci_ptd", sizeof (isp1761_qha), 0,
+            SLAB_HWCACHE_ALIGN, NULL, NULL);
+    if (!qtd_cache) {
+        printk("no TD cache?");
+        return -ENOMEM;
+    }
+    return 0;
+}
+    static void 
+phci_mem_cleanup(void) 
+{
+    if (qha_cache && kmem_cache_destroy (qha_cache))
+        err ("td_cache remained");
+    qha_cache = 0;
+}
+#else
+
+#define qha_alloc(t,c)                  kmalloc(t,ALLOC_FLAGS)
+#define qha_free(c,x)                   kfree(x)
+#define qha_cache                       0
+/*memory constants*/
+#define BLK_256_                        32 /*8k*/
+#define BLK_1024_                       20 /*20K*/
+#define BLK_4096_                       8  /*32K*/
+#define BLK_TOTAL                       (BLK_256_ + BLK_1024_ + BLK_4096_)
+#define BLK_SIZE_256                    256
+#define BLK_SIZE_1024                   1024
+#define BLK_SIZE_4096                   4096
+static void phci_hcd_mem_init(void);
+static inline void phci_mem_cleanup (void) { return; }
+
+#endif
+
+#define PORT_WKOC_E                     (1<<22)         /* wake on overcurrent (enable) */
+#define PORT_WKDISC_E                   (1<<21)         /* wake on disconnect (enable) */
+#define PORT_WKCONN_E                   (1<<20)         /* wake on connect (enable) */
+/* 19:16 for port testing */
+/* 15:14 for using port indicator leds (if HCS_INDICATOR allows) */
+#define PORT_OWNER                      (1<<13)         /* true: companion hc owns this port */
+#define PORT_POWER                      (1<<12)         /* true: has power (see PPC) */
+#define PORT_USB11(x)                   (((x)&(3<<10))==(1<<10))        /* USB 1.1 device */
+/* 11:10 for detecting lowspeed devices (reset vs release ownership) */
+/* 9 reserved */
+#define PORT_RESET                      (1<<8)          /* reset port */
+#define PORT_SUSPEND                    (1<<7)          /* suspend port */
+#define PORT_RESUME                     (1<<6)          /* resume it */
+#define PORT_OCC                        (1<<5)          /* over current change */
+
+#define PORT_OC                         (1<<4)          /* over current active */
+#define PORT_PEC                        (1<<3)          /* port enable change */
+#define PORT_PE                         (1<<2)          /* port enable */
+#define PORT_CSC                        (1<<1)          /* connect status change */
+#define PORT_CONNECT                    (1<<0)          /* device connected */
+/*Legends,
+ * ATL    control, bulk transfer
+ * INTL   interrupt transfer
+ * ISTL   iso transfer
+ * */
+
+/*buffer(transfer) bitmaps*/
+#define ATL_BUFFER                      0x1
+#define INT_BUFFER                      0x2
+#define ISO_BUFFER                      0x4
+#define BUFFER_MAP                      0x7
+
+/* buffer type for NXP HC */
+#define         TD_PTD_BUFF_TYPE_ATL    0       /* ATL buffer */
+#define         TD_PTD_BUFF_TYPE_INTL   1       /* INTL buffer */
+#define         TD_PTD_BUFF_TYPE_ISTL   2       /* ISO buffer */
+#define         TD_PTD_TOTAL_BUFF_TYPES (TD_PTD_BUFF_TYPE_ISTL +1)
+/*maximum number of tds per transfer type*/
+#define         TD_PTD_MAX_BUFF_TDS     32              
+/*invalid td index in the headers*/
+#define         TD_PTD_INV_PTD_INDEX    0xFFFFFFFF      
+/*Host controller buffer defination*/
+#define         INVALID_FRAME_NUMBER    0xFFFFFFFF
+/*per td transfer size*/
+#define         HC_ATL_PL_SIZE          4096
+#define         HC_ISTL_PL_SIZE         1024
+#define         HC_INTL_PL_SIZE         1024
+
+/*TD_PTD_MAP states*/
+#define TD_PTD_NEW                      0x0000
+#define TD_PTD_ACTIVE                   0x0001
+#define TD_PTD_IDLE                     0x0002 
+#define TD_PTD_REMOVE                   0x0004
+#define TD_PTD_RELOAD                   0x0008
+#define TD_PTD_IN_SCHEDULE              0x0010
+#define TD_PTD_DONE                     0x0020
+
+#define PTD_RETRY(x)                    (((x) >> 23) & 0x3)
+#define PTD_PID(x)                      (((x) >> 10) & (0x3))
+#define PTD_NEXTTOGGLE(x)               (((x) >> 25) & (0x1))
+#define PTD_XFERRED_LENGTH(x)           ((x) & 0x7fff) 
+#define PTD_XFERRED_NONHSLENGTH(x)      ((x) & 0x7ff)
+#define PTD_PING_STATE(x)               (((x) >> 26) & (0x1)) 
+
+/* urb state*/
+#define DELETE_URB                      0x0008
+#define NO_TRANSFER_ACTIVE              0xFFFFFFFF
+#define MAX_PTD_BUFFER_SIZE             4096 /*max ptd size*/
+
+/*information of the td in headers of host memory*/ 
+typedef struct td_ptd_map {
+    u32         state;          /* ACTIVE, NEW, TO_BE_REMOVED */
+    u8          datatoggle;     /*to preserve the data toggle for ATL/ISTL transfers*/
+    u32         ptd_bitmap;     /* Bitmap of this ptd in HC headers */
+    u32         ptd_header_addr;/* headers address of  this td */
+    u32         ptd_data_addr;  /*data address of this td to write in and read from*/ 
+    /*this is address is actual RAM address not the CPU address
+     * RAM address = (CPU ADDRESS-0x400) >> 3
+     * */       
+    u32         ptd_ram_data_addr;
+    u8          lasttd;       /*last td , complete the transfer*/
+    struct ehci_qh *qh;       /* endpoint */
+    struct ehci_qtd *qtd;             /* qtds for this endpoint */
+    struct ehci_itd *itd;         /*itd pointer*/
+    /*iso specific only*/
+    u32    grouptdmap;             /*if td need to complete with error, then process all the tds
+                                     in the groupmap    */   
+} td_ptd_map_t;
+
+/*buffer(ATL/ISTL/INTL) managemnet*/
+typedef struct td_ptd_map_buff {
+    u8                  buffer_type;    /* Buffer type: BUFF_TYPE_ATL/INTL/ISTL0/ISTL1 */
+    u8                  active_ptds;    /* number of active td's in the buffer */
+    u8                  total_ptds;     /* Total number of td's present in the buffer (active + tobe removed + skip) */
+    u8                  max_ptds;       /* Maximum number of ptd's(32) this buffer can withstand */
+    u32                 active_ptd_bitmap;      /* Active PTD's bitmap */
+    u32                 pending_ptd_bitmap;     /* skip PTD's bitmap */
+    td_ptd_map_t                map_list[TD_PTD_MAX_BUFF_TDS];  /* td_ptd_map list */
+} td_ptd_map_buff_t;
+
+#endif
+
+
+
+
+
+
+
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/isp1761/host/qtdptd.c linux-3.13/drivers/armadeus/isp1761/host/qtdptd.c
--- linux-3.13/drivers/armadeus/isp1761/host/qtdptd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/isp1761/host/qtdptd.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,1348 @@
+/***************************************************************************************************
+ * NXP ISP176x Host Controller Interface code file
+ *
+ * (c) 2006 NXP B.V., All rights reserved. <usb.linux@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * File Name: qtdptd.c
+ *
+ * Refering linux kernel version 2.6.23
+ *
+ * History:
+ *
+ * Date                   Author                  Comments
+ * --------------------------------------------------------------------
+ * June 21, 2005          krishan                  Initial version
+ * Nov  04, 2007          NC (armadeus)            Add 2.6.23 compatibility      
+ **********************************************************************
+ */
+
+/*   Td managenment routines  */
+
+#define QUEUE_HEAD_NOT_EMPTY    0x001
+
+/*
+ * usb_check_bandwidth():
+ *
+ * old_alloc is from host_controller->bandwidth_allocated in microseconds;
+ * bustime is from calc_bus_time(), but converted to microseconds.
+ *
+ * returns <bustime in us> if successful,
+ * or -ENOSPC if bandwidth request fails.
+ *
+ * FIXME:
+ * This initial implementation does not use Endpoint.bInterval
+ * in managing bandwidth allocation.
+ * It probably needs to be expanded to use Endpoint.bInterval.
+ * This can be done as a later enhancement (correction).
+ *
+ * This will also probably require some kind of
+ * frame allocation tracking...meaning, for example,
+ * that if multiple linux-3.13/drivers request interrupts every 10 USB frames,
+ * they don't all have to be allocated at
+ * frame numbers N, N+10, N+20, etc.  Some of them could be at
+ * N+11, N+21, N+31, etc., and others at
+ * N+12, N+22, N+32, etc.
+ *
+ * Similarly for isochronous transfers...
+ *
+ * Individual HCDs can schedule more directly ... this logic
+ * is not correct for high speed transfers.
+ */
+int usb_check_bandwidth (struct usb_device *dev, struct urb *urb)
+{
+	unsigned int	pipe = urb->pipe;
+	long		bustime;
+	int		is_in = usb_pipein (pipe);
+	int		is_iso = usb_pipeisoc (pipe);
+	int		old_alloc = dev->bus->bandwidth_allocated;
+	int		new_alloc;
+
+
+	bustime = NS_TO_US (usb_calc_bus_time (dev->speed, is_in, is_iso,
+			usb_maxpacket (dev, pipe, !is_in)));
+	if (is_iso)
+		bustime /= urb->number_of_packets;
+
+	new_alloc = old_alloc + (int) bustime;
+	if (new_alloc > FRAME_TIME_MAX_USECS_ALLOC) {
+#ifdef	DEBUG
+		char	*mode = 
+#ifdef CONFIG_USB_BANDWIDTH
+			"";
+#else
+			"would have ";
+#endif
+		dev_dbg (&dev->dev, "usb_check_bandwidth %sFAILED: %d + %ld = %d usec\n",
+			mode, old_alloc, bustime, new_alloc);
+#endif
+#ifdef CONFIG_USB_BANDWIDTH
+		bustime = -ENOSPC;	/* report error */
+#endif
+	}
+
+	return bustime;
+}
+
+/**
+ * usb_claim_bandwidth - records bandwidth for a periodic transfer
+ * @dev: source/target of request
+ * @urb: request (urb->dev == dev)
+ * @bustime: bandwidth consumed, in (average) microseconds per frame
+ * @isoc: true iff the request is isochronous
+ *
+ * Bus bandwidth reservations are recorded purely for diagnostic purposes.
+ * HCDs are expected not to overcommit periodic bandwidth, and to record such
+ * reservations whenever endpoints are added to the periodic schedule.
+ *
+ * FIXME averaging per-frame is suboptimal.  Better to sum over the HCD's
+ * entire periodic schedule ... 32 frames for OHCI, 1024 for UHCI, settable
+ * for EHCI (256/512/1024 frames, default 1024) and have the bus expose how
+ * large its periodic schedule is.
+ */
+void usb_claim_bandwidth (struct usb_device *dev, struct urb *urb, int bustime, int isoc)
+{
+	dev->bus->bandwidth_allocated += bustime;
+	if (isoc)
+		dev->bus->bandwidth_isoc_reqs++;
+	else
+		dev->bus->bandwidth_int_reqs++;
+
+#ifdef USB_BANDWIDTH_MESSAGES
+	dev_dbg (&dev->dev, "bandwidth alloc increased by %d (%s) to %d for %d requesters\n",
+		bustime,
+		isoc ? "ISOC" : "INTR",
+		dev->bus->bandwidth_allocated,
+		dev->bus->bandwidth_int_reqs + dev->bus->bandwidth_isoc_reqs);
+#endif
+}
+
+
+/*free the location used by removed urb/endpoint*/
+    static void
+phci_hcd_release_td_ptd_index(struct ehci_qh *qh)
+{
+    td_ptd_map_buff_t *td_ptd_buff = &td_ptd_map_buff[qh->type];
+    td_ptd_map_t     *td_ptd_map = &td_ptd_buff->map_list[qh->qtd_ptd_index];
+    pehci_entry("++ %s: Entered\n", __FUNCTION__);
+    /*hold the global lock here*/
+    td_ptd_map->state = TD_PTD_NEW;
+    qh->qh_state = QH_STATE_IDLE;
+    /*
+       set these values to NULL as schedule 
+       is based on these values, 
+       rather td_ptd_map state
+     */
+    td_ptd_map->qh = NULL;
+    td_ptd_map->qtd = NULL;
+
+    td_ptd_buff->active_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+    
+    /* Only pending transfers on current QH must be cleared */
+    td_ptd_buff->pending_ptd_bitmap &= ~td_ptd_map->ptd_bitmap;
+
+    pehci_entry("-- %s: Exit\n",__FUNCTION__);
+
+}
+
+/*print ehciqtd*/
+    static void
+print_ehci_qtd(struct ehci_qtd *qtd)
+{
+    pehci_print("hwnext 0x%08x, altnext 0x%08x,token 0x%08x, length %d\n",
+            qtd->hw_next, qtd->hw_alt_next, 
+            le32_to_cpu(qtd->hw_token), qtd->length);
+
+    pehci_print("buf[0] 0x%08x\n",qtd->hw_buf[0]);
+
+}
+
+/*delete all qtds linked with this urb*/
+static void 
+phci_hcd_qtd_list_free (
+        phci_hcd                *ehci,
+        struct urb              *urb,
+        struct list_head        *qtd_list) 
+{
+    struct list_head    *entry, *temp;
+
+    pehci_entry("++ %s: Entered\n", __FUNCTION__);
+
+    list_for_each_safe (entry, temp, qtd_list) {
+        struct ehci_qtd *qtd;
+        qtd = list_entry (entry, struct ehci_qtd, qtd_list);
+        list_del (&qtd->qtd_list);
+        qha_free(qha_cache, qtd);
+    }
+
+    pehci_entry("-- %s: Exit \n", __FUNCTION__);        
+}
+
+
+/*
+ * free all the qtds for this transfer, also
+ * free the Host memory to be reused
+ */
+static void
+phci_hcd_urb_free_priv(
+        phci_hcd *hcd,  
+        urb_priv_t *urb_priv_to_remove,
+        struct ehci_qh  *qh)
+{
+    int i = 0;
+    struct ehci_qtd *qtd;
+    for(i = 0;i<urb_priv_to_remove->length;i++){
+        if(urb_priv_to_remove->qtd[i]){
+            qtd = urb_priv_to_remove->qtd[i];
+            list_del(&qtd->qtd_list);
+
+            /* This is required when the device is abruptly disconnected and the
+             * PTDs are not completely processed
+             */       
+            if(qtd->length)
+                phci_hcd_mem_free(&qtd->mem_addr);
+
+            qha_free(qha_cache,qtd);
+            urb_priv_to_remove->qtd[i] = 0;
+            qtd=0;
+        }
+
+    }
+    return;
+
+}
+
+
+/*allocate the qtd*/
+    struct ehci_qtd * 
+phci_hcd_qtd_allocate(int mem_flags)
+{
+
+    struct ehci_qtd *qtd = 0;
+    qtd = (struct ehci_qtd *)kmalloc(sizeof *qtd,mem_flags);
+    if(!qtd)
+        return 0;
+    memset (qtd, 0, sizeof *qtd);
+    qtd->qtd_dma = cpu_to_le32(qtd);
+    qtd->hw_next = EHCI_LIST_END;
+    qtd->hw_alt_next = EHCI_LIST_END;
+    qtd->state = QTD_STATE_NEW;
+    INIT_LIST_HEAD (&qtd->qtd_list);
+    return qtd;
+}
+
+/*
+ * calculates host memory for current length transfer td,
+ * maximum td length is 4K(custom made)
+ * */
+static int 
+phci_hcd_qtd_fill(struct urb *urb,
+        struct ehci_qtd *qtd, 
+        dma_addr_t buf, 
+        size_t len, 
+        int token,
+        int *status)
+{
+    int count = 0;
+
+    qtd->hw_buf [0] = (u32)buf;
+    /*max lenggth is HC_ATL_PL_SIZE*/
+    if(len > HC_ATL_PL_SIZE)
+        count = HC_ATL_PL_SIZE;
+    else                
+        count = len;    
+    qtd->hw_token = cpu_to_le32 ((count << 16) | token);
+    qtd->length = count;
+
+    pehci_print ("%s:qtd %p, token %8x bytes %d dma %x\n",
+            __FUNCTION__,qtd, le32_to_cpu (qtd->hw_token), count, qtd->hw_buf [0]);
+
+    return count;
+}
+
+/*
+ * makes number of qtds required for
+ * interrupt/bulk/control transfer length
+ * and initilize qtds
+ * */
+struct list_head* 
+phci_hcd_make_qtd(
+        phci_hcd *hcd, 
+        struct list_head *head, 
+        struct urb *urb,
+        int  *status)
+{
+
+    struct ehci_qtd             *qtd, *qtd_prev;
+    dma_addr_t buf,map_buf;
+    int                 len, maxpacket;
+    int                 is_input;
+    u32                 token;
+    int cnt = 0; 
+    urb_priv_t *urb_priv = (urb_priv_t *)urb->hcpriv;
+
+    pehci_entry("++ %s, Entered\n",__FUNCTION__);   
+
+    /*take the qtd from already allocated 
+      structure from hcd_submit_urb
+     */
+    qtd = urb_priv->qtd[cnt];
+    if (unlikely (!qtd)){
+        *status = -ENOMEM;
+        return 0;
+    }
+
+    qtd_prev = 0;
+    list_add_tail (&qtd->qtd_list, head);
+
+    qtd->urb = urb;
+
+    token = QTD_STS_ACTIVE;
+    token |= (EHCI_TUNE_CERR << 10);
+
+    len = urb->transfer_buffer_length; 
+
+    is_input = usb_pipein (urb->pipe); 
+
+    if (usb_pipecontrol (urb->pipe)) { 
+        /* SETUP pid */
+        if(phci_hcd_qtd_fill (urb,qtd, cpu_to_le32(urb->setup_packet), 
+                    sizeof (struct usb_ctrlrequest),token | (2 /* "setup" */ << 8),
+                    status) < 0)
+            goto cleanup;
+
+        cnt++; /* increment the index */
+        print_ehci_qtd(qtd);
+        /* ... and always at least one more pid */
+        token ^= QTD_TOGGLE;
+        qtd_prev = qtd;
+        qtd = urb_priv->qtd[cnt];
+        if (unlikely (!qtd)){
+            *status = -ENOMEM;
+            goto cleanup;
+        }
+        qtd->urb = urb;
+        qtd_prev->hw_next = QTD_NEXT (qtd->qtd_dma);
+        list_add_tail (&qtd->qtd_list, head);
+    } 
+
+    /*
+     * data transfer stage:  buffer setup
+     */
+    len = urb->transfer_buffer_length;
+    if (likely (len > 0)) 
+        /*update the buffer address*/
+        buf = cpu_to_le32(urb->transfer_buffer);
+    else
+        buf = map_buf = cpu_to_le32(0); /*set-up stage has no data.*/
+
+    /* So are we waiting for the ack only or there is a data stage with out.*/
+    if (!buf || usb_pipein (urb->pipe))
+        token |= (1 /* "in" */ << 8);
+    /* else it's already initted to "out" pid (0 << 8) */
+    maxpacket = usb_maxpacket (urb->dev, urb->pipe,
+            usb_pipeout (urb->pipe)) & 0x07ff;
+
+
+    /*
+     * buffer gets wrapped in one or more qtds;
+     * last one may be "short" (including zero len)
+     * and may serve as a control status ack
+     */
+
+    for (;;) {
+        int this_qtd_len; 
+        this_qtd_len = phci_hcd_qtd_fill (urb,qtd, buf, len, token,status);
+        if(this_qtd_len < 0) goto cleanup;
+        print_ehci_qtd(qtd);
+        len -= this_qtd_len;
+        buf += this_qtd_len;
+        cnt++;
+        /* qh makes control packets use qtd toggle; maybe switch it */
+        if ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)
+            token ^= QTD_TOGGLE;
+
+        if (likely (len <= 0))
+            break;
+        qtd_prev = qtd;
+        qtd =  urb_priv->qtd[cnt];
+        if (unlikely (!qtd))
+            goto cleanup;
+        qtd->urb = urb;
+        qtd_prev->hw_next = QTD_NEXT (qtd->qtd_dma);
+        list_add_tail (&qtd->qtd_list, head);
+    }
+
+    /*
+     * control requests may need a terminating data "status" ack;
+     * bulk ones may need a terminating short packet (zero length).
+     */
+    if (likely (buf != 0)) {
+        int     one_more = 0;
+        if (usb_pipecontrol (urb->pipe)) {
+            one_more = 1;
+            token ^= 0x0100;    /* "in" <--> "out"  */
+            token |= QTD_TOGGLE;        /* force DATA1 */
+
+        } else if (usb_pipebulk (urb->pipe) /* bulk data exactly terminated on zero lenth */
+                && (urb->transfer_flags & URB_ZERO_PACKET)
+                && !(urb->transfer_buffer_length % maxpacket)) {
+            one_more = 1;
+        }
+        if (one_more) {
+            qtd_prev = qtd;
+            qtd = urb_priv->qtd[cnt];
+            if (unlikely (!qtd))
+                goto cleanup;
+
+            qtd->urb = urb;
+            qtd_prev->hw_next = QTD_NEXT (qtd->qtd_dma);
+            list_add_tail (&qtd->qtd_list, head);
+            phci_hcd_qtd_fill (urb,qtd, 0, 0, token,status);
+            print_ehci_qtd(qtd);
+            cnt++;
+
+        }
+
+    }
+
+    /*this is our last td for current transfer*/
+    qtd->state |= QTD_STATE_LAST;       
+
+    /*number of tds*/
+    if(urb_priv->length != cnt){
+        err("Never Error: number of tds allocated %d exceeding %d\n",
+                urb_priv->length, cnt);
+    }
+    /* by default, enable interrupt on urb completion */
+    if (likely (!(urb->transfer_flags & URB_NO_INTERRUPT)))
+        qtd->hw_token |= __constant_cpu_to_le32 (QTD_IOC);
+
+    pehci_entry("-- %s, Exit\n",__FUNCTION__);   
+    return head;
+
+cleanup:
+    phci_hcd_qtd_list_free (hcd, urb, head);
+    return 0;
+}
+
+/*allocates a queue head(endpoint*/
+    struct ehci_qh *
+phci_hcd_qh_alloc (phci_hcd *hcd)
+{
+
+    struct ehci_qh *qh = (struct ehci_qh *)kmalloc(sizeof(struct ehci_qh), GFP_ATOMIC);
+    if (!qh)
+        return qh;
+    memset (qh, 0, sizeof *qh);
+    atomic_set (&qh->refcount, 1);
+    init_waitqueue_head(&qh->waitforcomplete);
+    qh->qh_dma = (u32)qh;
+    INIT_LIST_HEAD (&qh->qtd_list);
+    INIT_LIST_HEAD(&qh->itd_list);
+    qh->next_uframe = -1;
+    return qh;
+}
+
+/* calculates header address for the tds*/
+static int
+phci_hcd_fill_ptd_addresses(
+        td_ptd_map_t *td_ptd_map,
+        int  index,
+        int bufftype)
+{
+    int i = 0;
+    unsigned long tdlocation = 0;
+    /*
+     * the below payloadlocation and 
+     * payloadsize are redundant
+     * */
+    unsigned long payloadlocation = 0;
+    unsigned long payloadsize = 0;
+    pehci_entry("++ %s: enter\n",__FUNCTION__);
+    switch(bufftype){
+        /*atl header starts at 0xc00*/
+        case TD_PTD_BUFF_TYPE_ATL:
+            tdlocation = 0x0c00;
+            /*redundant*/
+            payloadsize = 0x1000;
+            payloadlocation = 0x1000;
+            break;
+        case TD_PTD_BUFF_TYPE_INTL:
+            /*interrupt header
+             * starts at 0x800
+             * */
+            tdlocation = 0x0800;
+            /*redundant*/
+            payloadlocation = 0x1000;
+            payloadsize = 0x1000;
+            break;
+
+        case TD_PTD_BUFF_TYPE_ISTL:
+            /*iso header starts
+             * at 0x400*/
+
+            tdlocation = 0x0400;
+            /*redunndant*/
+            payloadlocation = 0x1000;
+            payloadsize = 0x1000;
+
+            break;
+    }
+
+
+    i = index;
+    payloadlocation += (i) * payloadsize;/*each payload is of 4096 bytes*/
+    tdlocation += (i) * PHCI_QHA_LENGTH; /*each td is of 32 bytes*/
+    td_ptd_map->ptd_header_addr = tdlocation;
+    td_ptd_map->ptd_data_addr = payloadlocation;
+    td_ptd_map->ptd_ram_data_addr = ((payloadlocation - 0x0400) >> 3);
+    pehci_print("Index: %d, Header: 0x%08x, Payload: 0x%08x,Data start address: 0x%08x\n",index,
+            td_ptd_map->ptd_header_addr, td_ptd_map->ptd_data_addr,
+            td_ptd_map->ptd_ram_data_addr);
+    pehci_entry("-- %s: Exit",__FUNCTION__);
+    return payloadlocation;
+}
+
+
+/*--------------------------------------------------------------*
+ * calculate the header location for the current
+ * endpoint, if found returns a valid index
+ * else invalid
+ -----------------------------------------------------------*/
+static void     
+phci_hcd_get_qtd_ptd_index(struct ehci_qh *qh,
+        struct ehci_qtd *qtd,
+        struct ehci_itd *itd) 
+{
+
+    u8  buff_type = td_ptd_pipe_x_buff_type[qh->type];
+    u8  qtd_ptd_index;/*, index;*/
+    /*this is the location of the ptd's skip map/done map, also
+      calculating the td header, payload, data start address 
+      location*/        
+    u8  bitmap = 0x1;
+    u8  max_ptds;
+
+    td_ptd_map_buff_t   *ptd_map_buff = &(td_ptd_map_buff[buff_type]);
+    pehci_entry("++ %s, Entered, buffer type %d\n",__FUNCTION__, buff_type);
+
+    /* ATL PTDs can wait */
+    max_ptds = (buff_type == TD_PTD_BUFF_TYPE_ATL) 
+        ? TD_PTD_MAX_BUFF_TDS : ptd_map_buff->max_ptds;
+
+    for(qtd_ptd_index = 0; qtd_ptd_index < max_ptds; qtd_ptd_index++) {                 /* Find the first free slot */
+        if(ptd_map_buff->map_list[qtd_ptd_index].state == TD_PTD_NEW) {
+            /* Found a free slot */
+            if( qh->qtd_ptd_index == TD_PTD_INV_PTD_INDEX ) {
+                qh->qtd_ptd_index = qtd_ptd_index;
+            }
+            ptd_map_buff->map_list[qtd_ptd_index].datatoggle = 0;
+            /*put the ptd_index into operational state*/
+            ptd_map_buff->map_list[qtd_ptd_index].state = TD_PTD_ACTIVE;
+            ptd_map_buff->map_list[qtd_ptd_index].qtd = qtd;
+            /* No td transfer is in progress */
+            ptd_map_buff->map_list[qtd_ptd_index].itd  = itd;
+            /*initialize endpoint(queuehead)*/
+            ptd_map_buff->map_list[qtd_ptd_index].qh = qh;
+            ptd_map_buff->map_list[qtd_ptd_index].ptd_bitmap = 
+                bitmap << qtd_ptd_index;
+            phci_hcd_fill_ptd_addresses(&ptd_map_buff->map_list[qtd_ptd_index],qh->qtd_ptd_index,buff_type); 
+            ptd_map_buff->map_list[qtd_ptd_index].lasttd = 0;
+            ptd_map_buff->total_ptds ++;        /* update # of total td's */
+            /*make the queuehead map, to process in the phci_schedule_ptds*/
+            ptd_map_buff->active_ptd_bitmap |= (bitmap << qtd_ptd_index);
+            break;
+        }
+    }
+    pehci_entry("-- %s, Exit\n", __FUNCTION__);
+    return;
+
+} /* phci_get_td_ptd_index */
+
+
+
+/* 
+ * calculate the header location for the endpoint and
+ * all tds on this endpoint will use the same
+ * header location for all transfers on this endpoint.
+ * also puts the endpoint into the linked state
+ * */
+    static void 
+phci_hcd_qh_link_async (phci_hcd *hcd, struct ehci_qh *qh, int *status)
+{
+    struct ehci_qtd *qtd = 0;
+    struct list_head *qtd_list = &qh->qtd_list;
+
+    td_ptd_map_buff_t       *ptd_map_buff;
+    td_ptd_map_t            *td_ptd_map;
+
+    /*  take the first td, in case we are not able to schedule the new td
+        and this is going for remove
+     */
+    qtd = list_entry(qtd_list->next, struct ehci_qtd, qtd_list);
+
+    pehci_entry("++ %s: Entered\n", __FUNCTION__);
+
+    /* Assign a td-ptd index for this ed so that we can put ptd's in the HC buffers */
+
+    qh->qtd_ptd_index = TD_PTD_INV_PTD_INDEX;
+    phci_hcd_get_qtd_ptd_index(qh, qtd, NULL);  /* Get a td-ptd index */
+    if(qh->qtd_ptd_index ==  TD_PTD_INV_PTD_INDEX){
+        err("can not find the location in our buffer\n");
+        *status = -ENOSPC;
+        return;
+    }
+
+
+#ifdef MSEC_INT_BASED
+    /*first transfers in sof interrupt goes into pending*/
+    ptd_map_buff = &(td_ptd_map_buff[qh->type]);
+    td_ptd_map = &ptd_map_buff->map_list[qh->qtd_ptd_index];
+    ptd_map_buff->pending_ptd_bitmap |= td_ptd_map->ptd_bitmap;
+
+#endif
+    /* open the halt so that it acessed */
+    qh->hw_token &= ~__constant_cpu_to_le32 (QTD_STS_HALT);
+    qh->qh_state = QH_STATE_LINKED;
+    qh->qh_state |= QH_STATE_TAKE_NEXT;
+    pehci_entry("-- %s: Exit , qh %p\n", __FUNCTION__, qh);
+
+
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* 
+ * mainly used for setting up current td on current 
+ * endpoint(queuehead), endpoint may be new or
+ * halted one
+ * */
+
+    static inline void
+phci_hcd_qh_update (phci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)
+{
+    /*make this current td*/
+    qh->hw_current = QTD_NEXT (qtd->qtd_dma);
+    qh->hw_qtd_next = QTD_NEXT (qtd->qtd_dma);
+    qh->hw_alt_next = EHCI_LIST_END;
+    /* HC must see latest qtd and qh data before we clear ACTIVE+HALT */
+    wmb (); 
+    qh->hw_token &= __constant_cpu_to_le32 (QTD_TOGGLE | QTD_STS_PING);
+}
+
+/*
+ * used for ATL, INT transfers  
+ * function creates new endpoint, 
+ * calculates bandwidth for interrupt transfers,
+ * and initialize the qh based on endpoint type/speed
+ * */
+struct ehci_qh *
+phci_hcd_make_qh (
+        phci_hcd                *hcd,
+        struct urb              *urb,
+        struct list_head *qtd_list,
+        int *status) 
+{
+    struct ehci_qh              *qh = 0;
+    u32                 info1 = 0, info2 = 0;
+    int                 is_input, type;
+    int                 maxp = 0;
+    int mult = 0;
+    int bustime = 0;
+    struct ehci_qtd *qtd = list_entry(qtd_list->next, struct ehci_qtd, qtd_list);
+
+
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);   
+
+    qh = phci_hcd_qh_alloc (hcd);
+    if (!qh){
+        *status  = -ENOMEM;
+        return 0;
+    }
+
+    /*
+     * init endpoint/device data for this QH
+     */
+    info1 |= usb_pipeendpoint(urb->pipe) << 8;
+    info1 |= usb_pipedevice(urb->pipe) << 0;
+
+    is_input = usb_pipein(urb->pipe);
+    type = usb_pipetype (urb->pipe);
+    maxp = usb_maxpacket (urb->dev, urb->pipe, !is_input);
+    mult = 1 + ((maxp >> 11) & 0x3);
+
+    /*set this queueheads index to invalid*/
+    qh->qtd_ptd_index = TD_PTD_INV_PTD_INDEX;
+
+    switch(type){
+        case PIPE_CONTROL:
+        case PIPE_BULK:
+            qh->type = TD_PTD_BUFF_TYPE_ATL;
+            break;
+
+        case PIPE_INTERRUPT:
+            qh->type = TD_PTD_BUFF_TYPE_INTL;
+            break;
+        case PIPE_ISOCHRONOUS:
+            qh->type = TD_PTD_BUFF_TYPE_ISTL;
+            break;
+
+    }
+
+
+
+    if (type == PIPE_INTERRUPT) {
+        /*for this interrupt transfer check how much bustime in usecs required*/
+
+        bustime = usb_check_bandwidth(urb->dev, urb);
+
+        if(bustime < 0){
+            *status  = -ENOSPC; 
+            goto done;
+        }
+
+        usb_claim_bandwidth(urb->dev,urb,bustime,usb_pipeisoc(urb->pipe));
+
+        qh->usecs = bustime;
+
+        qh->start = NO_FRAME;
+
+        if (urb->dev->speed == USB_SPEED_HIGH) {
+            qh->c_usecs = 0;
+            qh->gap_uf = 0;
+            /*after how many uframes this interrupt is to be executed*/
+            qh->period = urb->interval >> 3;
+            if (qh->period < 1) {
+                printk("intr period %d uframes,\n",
+                        urb->interval);
+            }
+            /*restore the original urb->interval in qh->period*/
+            qh->period = urb->interval;
+
+        } else {
+            /* gap is f(FS/LS transfer times) */
+            qh->gap_uf = 1 + 7;/*usb_calc_bus_time (urb->dev->speed,
+                                 is_input, 0, maxp) / (125 * 1000);*/
+
+            if (is_input) {             /* SPLIT, gap, CSPLIT+DATA */
+
+                qh->c_usecs = qh->usecs + 1;/*HS_USECS (0);*/
+                qh->usecs = 10;/*HS_USECS (1);*/
+            } else {            /* SPLIT+DATA, gap, CSPLIT */
+                qh->usecs += 10;/*HS_USECS (1);*/
+                qh->c_usecs = 1;/*HS_USECS (0);*/
+            }
+
+
+            /*take the period ss/cs scheduling will be
+              handled by submit urb
+             */
+            qh->period = urb->interval;
+        }
+    }
+
+    /* using TT? */
+    switch (urb->dev->speed) {
+        case USB_SPEED_LOW:
+            info1 |= (1 << 12); /* EPS "low" */
+            /* FALL THROUGH */
+
+        case USB_SPEED_FULL:
+            /* EPS 0 means "full" */
+            if (type != PIPE_INTERRUPT)
+                info1 |= (EHCI_TUNE_RL_TT << 28);
+            if (type == PIPE_CONTROL) {
+                info1 |= (1 << 27);     /* for TT */
+                info1 |= 1 << 14;       /* toggle from qtd */
+            }
+            info1 |= maxp << 16;
+
+            info2 |= (EHCI_TUNE_MULT_TT << 30);
+            info2 |= urb->dev->ttport << 23;
+            info2 |= urb->dev->tt->hub->devnum << 16;
+            break;
+
+
+        case USB_SPEED_HIGH:            /* no TT involved */
+            info1 |= (2 << 12); /* EPS "high" */
+            if (type == PIPE_CONTROL) {
+                info1 |= (EHCI_TUNE_RL_HS << 28);
+                info1 |= 64 << 16;      /* usb2 fixed maxpacket */
+
+                info1 |= 1 << 14;       /* toggle from qtd */
+                info2 |= (EHCI_TUNE_MULT_HS << 30);
+            } else if (type == PIPE_BULK) {
+                info1 |= (EHCI_TUNE_RL_HS << 28);
+                info1 |= 512 << 16;     /* usb2 fixed maxpacket */
+                info2 |= (EHCI_TUNE_MULT_HS << 30);
+            } else {            /* PIPE_INTERRUPT */
+                info1 |= (maxp & 0x7ff)/*max_packet (maxp)*/ << 16;
+                info2 |= mult/*hb_mult (maxp)*/ << 30;
+            }
+            break;
+
+        default:
+            pehci_print("bogus dev %p speed %d", urb->dev, urb->dev->speed);
+done:
+            qha_free(qha_cache, qh);
+            return 0;
+    }/*end of switch*/
+
+    /* NOTE:  if (PIPE_INTERRUPT) { scheduler sets s-mask } */
+
+    /* init as halted, toggle clear, advance to dummy */
+    qh->qh_state = QH_STATE_IDLE;
+    qh->hw_info1 = cpu_to_le32 (info1);
+    qh->hw_info2 = cpu_to_le32 (info2);
+    /*link the tds here*/
+    list_splice(qtd_list, &qh->qtd_list);
+    phci_hcd_qh_update (hcd, qh, qtd);
+    qh->hw_token = cpu_to_le32 (QTD_STS_HALT);
+    if(!usb_pipecontrol(urb->pipe))
+        usb_settoggle (urb->dev, usb_pipeendpoint (urb->pipe), !is_input, 1);
+    pehci_entry("-- %s: Exit, qh %p\n",__FUNCTION__,qh);   
+    return qh;
+}
+
+
+/*-----------------------------------------------------------*/
+/*
+ * Hardware maintains data toggle (like OHCI) ... here we (re)initialize
+ * the hardware data toggle in the QH, and set the pseudo-toggle in udev
+ * so we can see if usb_clear_halt() was called.  NOP for control, since
+ * we set up qh->hw_info1 to always use the QTD toggle bits. 
+ */
+    static inline void
+phci_hcd_clear_toggle (struct usb_device *udev, int ep, int is_out, struct ehci_qh *qh)
+{
+    pehci_print("clear toggle, dev %d ep 0x%x-%s\n",
+            udev->devnum, ep, is_out ? "out" : "in");
+    qh->hw_token &= ~__constant_cpu_to_le32 (QTD_TOGGLE);
+    usb_settoggle (udev, ep, is_out, 1);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * For control/bulk/interrupt, return QH with these TDs appended.
+ * Allocates and initializes the QH if necessary.
+ * Returns null if it can't allocate a QH it needs to.
+ * If the QH has TDs (urbs) already, that's great.
+ */
+struct ehci_qh * 
+phci_hcd_qh_append_tds (
+        phci_hcd                *hcd, 
+	struct usb_host_endpoint *ep,
+        struct urb              *urb,
+        struct list_head        *qtd_list,
+        void                    **ptr,
+        int               *status
+        )
+{
+    int epnum;
+    struct ehci_qh              *qh = 0;
+    struct ehci_qtd *qtd = list_entry(qtd_list->next, struct ehci_qtd, qtd_list);
+    td_ptd_map_buff_t   *ptd_map_buff;
+    td_ptd_map_t                *td_ptd_map;
+
+
+
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);   
+
+    epnum = ep->desc.bEndpointAddress;
+    qh = (struct ehci_qh *) *ptr;
+    if(likely(qh != 0)){
+        u32     hw_next = QTD_NEXT (qtd->qtd_dma);
+        pehci_print("%Queue head already %p\n",qh);
+
+        ptd_map_buff = &(td_ptd_map_buff[qh->type]);
+        td_ptd_map = &ptd_map_buff->map_list[qh->qtd_ptd_index];
+
+        /* maybe patch the qh used for set_address */
+        if (unlikely (epnum == 0
+                    && le32_to_cpu (qh->hw_info1 & 0x7f) == 0))
+            qh->hw_info1 |= cpu_to_le32 (usb_pipedevice(urb->pipe));
+
+        /* is an URB is queued to this qh already? */
+        if (unlikely (!list_empty (&qh->qtd_list))) {
+            struct ehci_qtd             *last_qtd;
+            /* update the last qtd's "next" pointer */
+            last_qtd = list_entry (qh->qtd_list.prev,
+                    struct ehci_qtd, qtd_list);
+
+            /*queue head is not empty just add the
+              td at the end of it , and return from here
+             */  
+            last_qtd->hw_next = hw_next;
+
+            /*set the status as positive*/
+            *status = (u32)QUEUE_HEAD_NOT_EMPTY;
+
+            /* no URB queued */
+        } else {
+
+            if(td_ptd_map->state == TD_PTD_NEW){
+                qh->qh_state = QH_STATE_IDLE;
+            }
+            td_ptd_map->qtd = qtd;      
+            /* usb_clear_halt() means qh data toggle gets reset */
+            if (usb_pipebulk (urb->pipe)
+                    && unlikely (!usb_gettoggle (urb->dev,
+                            (epnum & 0x0f),
+                            !(epnum & 0x10)))) {
+
+                phci_hcd_clear_toggle(urb->dev,
+                        epnum & 0x0f, !(epnum & 0x10), qh);
+
+                /*reset our data toggle*/
+                td_ptd_map->datatoggle = 0;
+                qh->datatoggle = 0;
+                qh->ping = 0;
+
+            }
+            phci_hcd_qh_update (hcd,qh, qtd);
+        }
+        /*put everything in pedning, will be cleared during scheduling*/
+        ptd_map_buff->pending_ptd_bitmap |= td_ptd_map->ptd_bitmap;
+        list_splice (qtd_list, qh->qtd_list.prev);
+    }else{
+        qh = phci_hcd_make_qh(hcd, urb, qtd_list, status);
+        *ptr = qh;
+    }
+    pehci_entry("-- %s: Exit qh %p\n",__FUNCTION__,qh);   
+    return qh;
+}
+
+/*link qtds to endpoint(qh)*/
+struct ehci_qh * 
+phci_hcd_submit_async(
+        phci_hcd *hcd, 
+	struct usb_host_endpoint *ep,
+        struct list_head *qtd_list, 
+        struct urb *urb,
+        int *status)
+
+
+{
+    struct ehci_qtd             *qtd;
+    struct hcd_dev             *dev;
+    int                         epnum;
+    unsigned long               flags;
+    struct ehci_qh              *qh = 0;
+
+    urb_priv_t  *urb_priv = urb->hcpriv;
+
+
+    qtd = list_entry (qtd_list->next, struct ehci_qtd, qtd_list);
+    dev = (struct hcd_dev*) bus_to_hcd(urb->dev->bus);
+    epnum = usb_pipeendpoint (urb->pipe);
+    if (usb_pipein (urb->pipe) && !usb_pipecontrol (urb->pipe))
+        epnum |= 0x10;
+
+    pehci_entry("++ %s, enter\n", __FUNCTION__);    
+
+
+
+    /* ehci_hcd->lock guards shared data against other CPUs:
+     *   ehci_hcd:      async, reclaim, periodic (and shadow), ...
+     *   hcd_dev:       ep[]
+
+     *   ehci_qh:       qh_next, qtd_list
+
+     *   ehci_qtd:      qtd_list
+     *
+     * Also, hold this lock when talking to HC registers or
+     * when updating hw_* fields in shared qh/qtd/... structures.
+     */
+
+    spin_lock_irqsave (&hcd->lock, flags);
+    spin_lock(&hcd_data_lock);
+    qh = phci_hcd_qh_append_tds (hcd, ep, urb, qtd_list, &ep->hcpriv,status);
+    if(!qh  || *status < 0)
+        goto cleanup;
+    /* Control/bulk operations through TTs don't need scheduling,
+     * the HC and TT handle it when the TT has a buffer ready.
+     */
+
+    /* now the quehead can not be in the unlink state paranoid ??? */
+
+    if(qh->qh_state == QH_STATE_UNLINK){
+        pehci_info("%s: free the urb,qh->state %x\n",__FUNCTION__, qh->qh_state);
+        phci_hcd_qtd_list_free (hcd, urb, &qh->qtd_list);
+        spin_unlock(&hcd_data_lock);
+        spin_unlock_irqrestore (&hcd->lock, flags);
+        *status = -ENODEV;
+        return 0;
+    }
+
+    if (likely (qh != 0)) {
+        urb_priv->qh = qh;
+        if (likely (qh->qh_state == QH_STATE_IDLE))
+            phci_hcd_qh_link_async (hcd, qh,status);
+    }
+
+cleanup:        
+    spin_unlock(&hcd_data_lock);
+    /* free it from lock systme can sleep now */
+    spin_unlock_irqrestore (&hcd->lock, flags);
+    /* could not get the QH terminate and clean. */
+    if (unlikely (qh == 0) || *status < 0) {
+        phci_hcd_qtd_list_free (hcd, urb, qtd_list);
+        return qh;
+    }
+    return qh;
+}
+
+/*
+ * initilaize the s-mask c-mask for
+ * interrupt transfers.
+ */
+static int
+phci_hcd_qhint_schedule(
+        phci_hcd *hcd, 
+        struct ehci_qh *qh,
+        struct ehci_qtd *qtd,
+        struct _isp1761_qhint *qha,
+        struct urb *urb)
+{
+    int i = 0;
+    u32 td_info3 = 0;
+    u32 td_info5 = 0;
+    u32 period = 0;
+    u32 usofmask = 1;
+    u32  usof = 0;
+    u32 ssplit=0,csplit = 0xFF;
+    int maxpacket;
+    u32 numberofusofs = 0;
+
+    /*and since whol msec frame is empty, i can schedule in any uframe*/
+    maxpacket = usb_maxpacket(urb->dev, urb->pipe,!usb_pipein(urb->pipe));
+    maxpacket &= 0x7ff;
+    /*length of the data per uframe*/
+    maxpacket = XFER_PER_UFRAME(qha->td_info1) * maxpacket;
+
+    /*caculate the number of uframes are required*/
+    numberofusofs = urb->transfer_buffer_length/maxpacket;
+    /*if something left*/
+    if(urb->transfer_buffer_length % maxpacket)
+        numberofusofs += 1;
+
+    for(i = 0;i<numberofusofs;i++){
+        usofmask <<= i;
+        usof |= usofmask;
+
+    }
+
+    /*
+       for full/low speed devices, as we 
+       have seperate location for all the endpoints
+       let the start split goto the first uframe, means 0 uframe
+     */
+    if(urb->dev->speed != USB_SPEED_HIGH &&
+            usb_pipeint(urb->pipe)){
+        /*set the complete splits*/
+        /*set all the bits and lets see whats happening*/
+        /*but this will be set based on the maximum packet size*/
+        ssplit = usof;
+        /*  need to fix it*/
+        csplit = 0x1C;
+        qha->td_info6 = csplit;
+        period = qh->period;
+        if(period >= 32){
+            period = qh->period/2;
+        }
+        td_info3 = period;
+        goto done;
+
+    }else{
+        if(qh->period >= 8){
+            period = qh->period/8;
+        }else{
+            period = qh->period;
+        }
+    }
+    /*our limitaion is maximum of 32 ie 31, 5 bits*/
+    if(period >= 32){
+        period  = 32;
+        /*devide by 2*/
+        period >>= 1;
+    }
+    if(qh->period >= 8){
+        /*millisecond period*/
+        td_info3 = (period << 3);
+    }else{
+        /*usof based tranmsfers*/
+        /*minimum 4 usofs*/
+        td_info3  = period;
+        usof = 0x11;
+    }
+
+done:
+    td_info5 = usof;
+    qha->td_info3 |= td_info3;
+    qha->td_info5 |= usof;
+    return numberofusofs;
+}
+
+/*link interrupts qtds to endpoint*/
+struct ehci_qh *
+phci_hcd_submit_interrupt(
+        phci_hcd *hcd, 
+	struct usb_host_endpoint *ep,
+        struct list_head *qtd_list, 
+        struct urb *urb,
+        int *status)
+{
+
+    struct ehci_qtd             *qtd;
+    struct hcd_dev             *dev;
+    int                 epnum;
+    unsigned long               flags;
+    struct ehci_qh              *qh = 0;
+    urb_priv_t  *urb_priv = (urb_priv_t *)urb->hcpriv;
+
+
+    qtd = list_entry (qtd_list->next, struct ehci_qtd, qtd_list);
+    dev = (struct hcd_dev*) bus_to_hcd(urb->dev->bus);
+    epnum = ep->desc.bEndpointAddress;
+
+    pehci_entry("++ %s, enter\n", __FUNCTION__);    
+
+
+    /*check for more than one urb queued for this endpoint*/
+    qh = ep->hcpriv;
+
+    spin_lock_irqsave (&hcd->lock, flags);
+    if(unlikely(qh != 0)){
+        if(!list_empty(&qh->qtd_list)){
+            *status = -EBUSY;
+            goto done;
+        } else {
+            td_ptd_map_buff_t   *ptd_map_buff;
+            td_ptd_map_t                *td_ptd_map;
+            ptd_map_buff = &(td_ptd_map_buff[qh->type]);
+            td_ptd_map = &ptd_map_buff->map_list[qh->qtd_ptd_index];
+            ptd_map_buff->pending_ptd_bitmap |= td_ptd_map->ptd_bitmap; 
+            /*NEW*/
+            td_ptd_map->qtd = qtd;
+            /* maybe reset hardware's data toggle in the qh */
+            if (unlikely (!usb_gettoggle (urb->dev, epnum & 0x0f,
+                            !(epnum & 0x10)))) {
+
+                /*reset our data toggle*/
+                td_ptd_map->datatoggle = 0;
+                usb_settoggle (urb->dev, epnum & 0x0f,
+                        !(epnum & 0x10), 1);
+                qh->datatoggle = 0;
+            }
+            /* trust the QH was set up as interrupt ... */
+            list_splice (qtd_list, &qh->qtd_list);
+        }
+    }
+
+
+    if(!qh){
+        qh = phci_hcd_make_qh(hcd, urb, qtd_list,status);
+        if(likely(qh == 0)){
+            *status = -ENOMEM;
+            goto done;
+        }
+        ep->hcpriv = qh;
+    }
+
+    if (likely (qh != 0)) {
+        urb_priv->qh = qh;
+        if (likely (qh->qh_state == QH_STATE_IDLE))
+            phci_hcd_qh_link_async (hcd, qh, status);
+    }
+
+
+done:
+    /* free it from lock systme can sleep now */
+    spin_unlock_irqrestore (&hcd->lock, flags);
+    /* could not get the QH terminate and clean. */
+    if (unlikely (qh == 0) || *status < 0) {
+        phci_hcd_qtd_list_free (hcd, urb, qtd_list);
+        return qh;
+    }
+    return qh;
+}
+
+
+
+
+/*
+ * converts original EHCI QTD into PTD(philips transfer descriptor)
+ * we call PTD as qha also for atl transfers
+ * for ATL and INT transfers
+ */
+void *
+phci_hcd_qha_from_qtd(
+        phci_hcd        *hcd,
+        struct ehci_qtd *qtd,
+        struct urb *urb,
+        void *ptd,
+        u32 ptd_data_addr,
+        struct ehci_qh *qh )
+{
+    u8 toggle = qh->datatoggle;
+    u32 token = 0;
+    u32         td_info1 = 0;
+    u32         td_info3 = 0;
+    u32         td_info4 = 0;
+    int maxpacket = 0;
+    u32 length = 0, temp  = 0;
+    /*for non high speed devices*/
+    u32     portnum = 0;
+    u32     hubnum = 0;
+    u32 se = 0,rl = 0xf,nk = 0xf;
+    u8 datatoggle = 0;
+    struct isp1761_mem_addr *mem_addr = &qtd->mem_addr;
+    u32 data_addr = 0;
+    u32 multi = 0;
+    struct _isp1761_qha *qha = (isp1761_qha*)ptd;
+    pehci_entry("++ %s: Entered\n",__FUNCTION__);
+
+
+    maxpacket = usb_maxpacket(urb->dev,
+            urb->pipe,
+            usb_pipeout(urb->pipe));
+
+    multi = 1 + ((maxpacket >> 11) & 0x3);
+
+    maxpacket &= 0x7ff;
+
+    /************************first word*********************************/
+    length = qtd->length;
+    td_info1 = QHA_VALID;
+    td_info1 |= (length << 3);
+    td_info1 |= (maxpacket << 18);
+    td_info1 |= (usb_pipeendpoint(urb->pipe) << 31);
+    td_info1 |= MULTI(multi);
+    /*set the first dword*/
+    qha->td_info1 = td_info1;
+
+    pehci_print("%s: length %d, 1st word 0x%08x\n", __FUNCTION__,length,qha->td_info1);
+
+    /*******************second word***************************************/
+    temp = qtd->hw_token;
+
+    /*take the pid, thats of only interest to me from qtd,
+     */
+
+    temp = temp & 0x0300;
+    temp = temp >> 8;
+    /*take the endpoint and its 3 bits*/
+    token = (usb_pipeendpoint(urb->pipe) & 0xE) >> 1;
+    token |= usb_pipedevice(urb->pipe) << 3;
+
+    if(urb->dev->speed != USB_SPEED_HIGH){
+        pehci_print("device is full/low speed, %d\n",urb->dev->speed);
+        token |= 1 << 14;
+        portnum = urb->dev->ttport;
+        /*IMMED*/
+        hubnum = urb->dev->tt->hub->devnum;
+        token |= portnum << 18;
+        token |= hubnum << 25;
+        /*for non-high speed transfer
+          reload and nak counts are zero
+         */  
+        rl = 0x0;
+        nk = 0x0;
+
+    }
+
+    /*se should be 0x2 for only low speed devices*/
+    if(urb->dev->speed == USB_SPEED_LOW)
+        se = 0x2;
+
+    if(usb_pipeint(urb->pipe)){
+        /*      reload count and nakcount is 
+                required for only async transfers
+         */
+        rl = 0x0;
+    }
+
+    /*set the se field, should be zero for all 
+      but low speed devices
+     */
+    token |= se << 16;  
+    /*take the pid*/
+    token |=  temp << 10;
+
+    if(usb_pipebulk(urb->pipe))
+        token  |= EPTYPE_BULK;
+    else if(usb_pipeint(urb->pipe))
+        token |= EPTYPE_INT;
+    else if (usb_pipeisoc(urb->pipe))
+        token |= EPTYPE_ISO;
+
+
+    qha->td_info2 = token;
+
+    pehci_print("%s: second word 0x%08x, qtd token 0x%08x\n",
+            __FUNCTION__, qha->td_info2,temp);
+
+    /***********************Third word*************************************/
+
+    /*calculate the data start address from mem_addr for qha*/
+
+    data_addr = ((u32)(mem_addr->phy_addr) & 0xffff) - 0x400;
+    data_addr >>= 3;
+    pehci_print("data start address %x\n", data_addr);
+    /*use this field only if there
+     * is something to transfer
+     * */
+    if(length)  
+        td_info3 = data_addr << 8;
+    /*RL Count, 16*/
+    td_info3 |= (rl << 25);
+    qha->td_info3 = td_info3;
+
+    pehci_print("%s: third word 0x%08x, tdinfo 0x%08x\n",
+            __FUNCTION__, qha->td_info3,td_info3);
+
+
+    /**************************fourt word*************************************/
+
+    if(usb_pipecontrol(urb->pipe))
+        datatoggle = qtd->hw_token >> 31;
+    else
+        /*take the data toggle from the previous completed transfer
+          or zero in case of fresh*/
+        datatoggle = toggle;
+
+    td_info4 = QHA_ACTIVE;
+    /*dt*/
+    td_info4 |= datatoggle << 25;/*QHA_DATA_TOGGLE; */
+    /*3 retry count for setup else forever*/
+    if(PTD_PID(qha->td_info2) == SETUP_PID)
+        td_info4 |= (3 << 23);
+    else
+        td_info4 |= (0 << 23);
+    /*nak count*/
+    td_info4 |= (nk << 19);
+
+    td_info4 |= (qh->ping << 26);
+    qha->td_info4 = td_info4;
+    pehci_print("%s: fourt word 0x%08x\n",__FUNCTION__, qha->td_info4);
+    pehci_entry("-- %s: Exit, qha %p\n",__FUNCTION__, qha);
+    return qha;
+
+}
+
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/max1027/Kconfig linux-3.13/drivers/armadeus/max1027/Kconfig
--- linux-3.13/drivers/armadeus/max1027/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/max1027/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,9 @@
+#
+#
+
+config ARMADEUS_MAX1027
+        tristate "Armadeus Max1027 ADC driver (fast version)"
+        default n
+        depends on ARMADEUS_DRIVERS
+        ---help---
+	  Max1027 fast driver
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/max1027/Makefile linux-3.13/drivers/armadeus/max1027/Makefile
--- linux-3.13/drivers/armadeus/max1027/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/max1027/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,24 @@
+#
+# Makefile for the Armadeus Max1027 
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_ARMADEUS_MAX1027)	+= max1027.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/max1027/README linux-3.13/drivers/armadeus/max1027/README
--- linux-3.13/drivers/armadeus/max1027/README	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/max1027/README	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,20 @@
+Max1027 analog to digital driver
+================================
+
+Compilation
+-----------
+To compile, use make in this directory:
+
+> make
+
+Usage
+-----
+First create all nodes using loadmax.sh script
+> ./loadmax.sh
+
+TODO
+
+Links
+-----
+Drivers usages are described on [ARMadeus Wiki](http://www.armadeus.com/wiki/index.php?title=ADC_max1027)
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/max1027/loadmax.sh linux-3.13/drivers/armadeus/max1027/loadmax.sh
--- linux-3.13/drivers/armadeus/max1027/loadmax.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/max1027/loadmax.sh	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,28 @@
+#!/bin/ash
+
+#
+# This script will load Armadeus Max1027 module and create /dev/xxx entries
+#
+
+MAX_DEV_DIR=/dev/max1027
+
+if [ -d "$1" ]; then
+	MAX_MODULES_DIR="$1"
+	insmod $MAX_MODULES_DIR/max1027.ko
+else
+	modprobe max1027
+fi
+
+MAX_MAJOR=`cat /proc/devices | grep max1027 | cut -d " " -f 1`
+
+if [ "$MAX_MAJOR" == "" ]; then
+	echo "Max1027 module not loaded, exiting"
+	exit 1
+fi
+
+mkdir -p $MAX_DEV_DIR
+
+for channel in 0 1 2 3 4 5 6; do
+	minor=$channel
+	mknod $MAX_DEV_DIR/AIN$channel c $MAX_MAJOR $minor
+done
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/max1027/max1027.c linux-3.13/drivers/armadeus/max1027/max1027.c
--- linux-3.13/drivers/armadeus/max1027/max1027.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/max1027/max1027.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,911 @@
+/*
+ * MAX1027 (ADC) driver for kernel >= 2.6.23
+ *
+ * Copyright (C) 2006-2008 Armadeus Project / Armadeus Systems
+ * Authors: Nicolas Colombain / Julien Boibessot
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+/*#define DEBUG 1*/
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/interrupt.h> /* request_irq */
+#include <linux/version.h>
+#include <linux/spi/max1027.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/sysfs.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+#include <linux/irq.h> /* set_irq_type */
+#if defined(CONFIG_HWMON) || defined(CONFIG_HWMON_MODULE)
+#include <linux/hwmon.h>
+#endif
+
+#include <mach/gpio.h>
+#include <asm/uaccess.h>     /* copy_to_user */
+
+#define DRIVER_NAME    "max1027"
+#define DRIVER_VERSION "0.71"
+
+
+/* Internal registers prefixes */
+#define MAX1027_REG_CONV    0x80
+#define MAX1027_REG_SETUP   0x40
+#define MAX1027_REG_AVG     0x20
+#define MAX1027_REG_RESET   0x10
+#define MAX1027_REG_UNI     0x00
+#define MAX1027_REG_BIPO    0x00
+
+/* register specifics */
+#define MAX1027_REG_CONV_SCAN1		(1 << 2)
+#define MAX1027_REG_SETUP_CKSEL1	(1 << 5)
+#define GET_SELECTED_CHANNEL(conv)	( (conv & 0x78) >> 3 )
+#define MAX1027_SETUP_DIFFSEL_MASK 	0x03
+#define GET_NB_SCAN(avg)		( 4 * ((avg & 0x03)+1) )
+#define MAX1027_RESET_ALL		(0x0|MAX1027_REG_RESET)
+#define MAX1027_RESET_FIFO		(0x8|MAX1027_REG_RESET)
+#define MAX1027_UNI_UCH(x)		((x&0x0f)<<4)
+#define MAX1027_BIPO_BCH(x)		((x&0x0f)<<4)
+
+#define NB_CHANNELS			8
+#define MAX_RESULTS_PER_CHANNEL		16   /* NSCAN = 11 */
+#define MAX_NB_RESULTS			(MAX_RESULTS_PER_CHANNEL+1) /* + temp */
+
+#define FIFO_SIZE 128
+
+
+/* Global variables */
+struct max1027_operations *driver_ops;
+static int max1027_major = 0; /* Dynamic major allocation */
+
+struct adc_channel {
+	int id;  /* channel  ID */
+#define DATA_AVAILABLE 0
+	unsigned long status;
+
+	/* channel FIFO */
+	volatile unsigned int head, tail;
+	int nb_data_required;
+	volatile u16 buffer[FIFO_SIZE];
+
+	/* channel wait queue */
+	wait_queue_head_t change_wq;
+	struct spi_dev *spi; /* clean ?? */
+};
+
+struct max1027 {
+	struct device *cdev;
+	struct mutex update_lock;
+
+#define CONVERSION_RUNNING 0
+	unsigned long status;
+
+	u16 ain[NB_CHANNELS]; /* latest channels value */
+	struct adc_channel* channels[NB_CHANNELS];
+	int temperature; /* current one in millidegree Celcius */
+	/* Shadow registers to hold current configuration */
+	u8 conv_reg;
+	u8 setup_reg;
+	u8 avg_reg;
+	int cnvst; /* conversion start pin */
+
+	struct tasklet_struct tasklet;
+
+	wait_queue_head_t conv_wq;	/* stores waiters of end of conv */
+	int missed_eoc;			/* stores all missed EOC interrupts */
+};
+
+#define CS_CHANGE(val)			0  /* <-- what is it for ??? */
+
+static struct spi_device *current_spi;
+
+struct spi_transfer transfer[MAX_NB_RESULTS];
+struct spi_message message;
+u8 buffer[MAX_NB_RESULTS*2]; /* each result is sent with 16 bits */
+
+
+static inline void trig_cnvst(struct max1027* max1027)
+{	
+	gpio_set_value(max1027->cnvst, 0); /* Platform specific no ? */
+	udelay(1);
+	gpio_set_value(max1027->cnvst, 1);
+}
+
+static void max1027_start_conv(struct max1027*, struct adc_channel*);
+
+static void fifo_flush(struct adc_channel* channel)
+{
+	channel->head = 0;
+	channel->tail = 0; 
+	channel->nb_data_required = 0;
+}
+
+static u16 fifo_inuse(struct adc_channel* channel)
+{
+	return channel->head - channel->tail; 
+}
+
+static void fifo_put(u16 c, struct adc_channel* channel)
+{
+	if (fifo_inuse(channel) != FIFO_SIZE) {
+		channel->buffer[channel->head++%FIFO_SIZE] = c;
+		if (channel->nb_data_required)
+			channel->nb_data_required--;
+	} else {
+		pr_debug("put fifo full %d\n", channel->id);
+		printk("put fifo full %d\n", channel->id);
+	}
+
+	if (channel->nb_data_required <= 0) {
+		set_bit(DATA_AVAILABLE, &channel->status);
+		wake_up_interruptible(&(channel->change_wq));
+	}
+}
+
+static u16 fifo_get(u16 * c, u16 count, struct adc_channel* channel)
+{
+	int j, i=0;
+
+	channel->nb_data_required = 0;
+	j = fifo_inuse(channel);
+	for (i = 0; i < min(j, (int)count); i++) {
+		c[i] = channel->buffer[channel->tail++%FIFO_SIZE];
+	}
+	channel->nb_data_required = min(count-i, FIFO_SIZE);
+
+	return i;
+}
+
+static void inline max1027_wait_end_of_conv(struct max1027 *max1027)
+{
+	int delay;
+
+	delay = wait_event_timeout(max1027->conv_wq, max1027->status==0, msecs_to_jiffies(20));
+	if (delay == 0) {
+		printk(KERN_WARNING "error: missed conversion %lu ", max1027->status);
+		if (test_bit(CONVERSION_RUNNING, &max1027->status)) {
+			max1027->missed_eoc++;
+			clear_bit(CONVERSION_RUNNING, &max1027->status);
+		}
+	}
+
+	/*printk("delay %lu\n", delay);*/
+}
+
+/* Must be used within mutex and outside of IRQ context !!! */
+static void max1027_send_cmd(struct spi_device *spi, u8 cmd)
+{
+	u8 buf = cmd;
+	struct max1027 *p_max1027 = dev_get_drvdata(&spi->dev);
+
+	/* !! order is important here !! ;-) */
+	if (cmd & MAX1027_REG_CONV) {
+		p_max1027->conv_reg = cmd;
+	}
+	else if (cmd & MAX1027_REG_SETUP) {
+		p_max1027->setup_reg = cmd;
+	}
+	else if (cmd & MAX1027_REG_AVG) {
+		p_max1027->avg_reg = cmd;
+	}
+
+	spi_write_then_read(spi, &buf, 1, NULL, 0);
+}
+
+static void max1027_start_conv(struct max1027 *max1027, struct adc_channel *channel)
+{
+	if (test_and_set_bit(CONVERSION_RUNNING, &max1027->status)) {
+		printk("conv already running\n");
+		return;
+	}
+
+	/* No conversion running: launch one */
+
+	if (channel)
+		clear_bit(DATA_AVAILABLE, &channel->status);
+	/* Use CNVST triggered conv. */
+	trig_cnvst(max1027);
+} 
+
+/* Called when SPI got results from MAX1027 */
+static void max1027_process_results(struct max1027 *max1027)
+{
+	u8 msb, lsb;
+	u16 value;
+	int i=0, values_to_read=0, start=0, nb_data_required=0;
+	unsigned int scan_mode, selected_channel;
+
+	pr_debug("%s: ", __FUNCTION__);
+
+	selected_channel = GET_SELECTED_CHANNEL(max1027->conv_reg);
+	if (selected_channel >= NB_CHANNELS)
+		selected_channel = NB_CHANNELS - 1;
+	scan_mode = GET_SCAN_MODE(max1027->conv_reg);
+	if (scan_mode == SCAN_MODE_00) {
+		values_to_read = selected_channel + 1;
+	} else if (scan_mode == SCAN_MODE_01) {
+		values_to_read = NB_CHANNELS - selected_channel + 1;
+	} else {
+		values_to_read = 1;
+	}
+
+	if (max1027->conv_reg & MAX1027_CONV_TEMP)
+		values_to_read += 1;
+#ifdef DEBUG
+	for (i=0; i<values_to_read*2; i++) {
+		printk("%02x ", buffer[i]);
+	}
+	printk("\n");
+#endif
+
+	start = 0;
+	/* temp */
+	if (max1027->conv_reg & MAX1027_CONV_TEMP) {
+		msb = buffer[0] & 0x0f;
+		lsb = buffer[1];
+		value = ((msb << 8) | lsb);
+		max1027->temperature = (value * 1000) >> 3; /* 1 unit = 1/8 C + save it in millidegree */
+		pr_debug("%d mC ", max1027->temperature);
+		start = 1;
+	}
+	nb_data_required = 0;
+	for (i=start; i<values_to_read; i++) {
+		msb = buffer[i*2] & 0x0f;
+		lsb = buffer[(i*2)+1];
+		value = ((msb << 8) | lsb) >> 2;
+		if (scan_mode == SCAN_MODE_00) {
+			int id = i-start;
+			if (max1027->channels[id] != NULL) {
+				fifo_put(value, max1027->channels[id]);
+				nb_data_required = max(nb_data_required, max1027->channels[id]->nb_data_required);
+			}
+			max1027->ain[i-start] = value;
+		} else {
+			if (max1027->channels[selected_channel] != NULL) {
+				fifo_put(value, max1027->channels[selected_channel]);
+				nb_data_required = max(nb_data_required, max1027->channels[selected_channel]->nb_data_required);
+			}
+			max1027->ain[selected_channel++] = value;
+		}
+		pr_debug("0x%04x ", value);
+	}
+	pr_debug("\n");
+
+	if (nb_data_required) {
+		max1027_start_conv(max1027, max1027->channels[selected_channel]);
+	} else {
+		clear_bit(CONVERSION_RUNNING, &max1027->status);
+	}
+
+	/* Somebody's waiting for the "global" End Of Conversion ? */
+	wake_up(&(max1027->conv_wq));
+}
+
+static void max1027_reads_async(struct spi_device *spi, int num_values)
+{
+	int ret, i;
+
+	spi_message_init(&message);
+	message.complete = (void (*)(void *)) max1027_process_results;
+	message.context  = dev_get_drvdata(&current_spi->dev); /* cradingue ? */
+
+	i = 0;
+	while (i < num_values) {
+		transfer[i].tx_buf = 0;
+		transfer[i].rx_buf = buffer+(i*2);
+		transfer[i].len = 2;
+		transfer[i].cs_change = CS_CHANGE(i == num_values);
+		spi_message_add_tail(&transfer[i++], &message);
+	}
+
+	ret = spi_async(spi, &message);
+	if (ret)
+		printk(KERN_ERR "%s: error %i in SPI request\n",
+				__FUNCTION__, ret);
+}
+
+/*
+ * Handles read() done on /dev/...
+ */
+static ssize_t max1027_dev_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+	unsigned minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	u16 value[FIFO_SIZE];
+	ssize_t ret = 0; 
+	struct adc_channel *channel = file->private_data;
+	struct max1027 *max1027 = dev_get_drvdata(&current_spi->dev); /* cradingue */
+	
+	if (count == 0)
+		return count; 
+	pr_debug("- %s %d byte(s) on minor %d -> channel %d\n", __FUNCTION__, count, minor, channel->id);
+
+	if (fifo_inuse(channel) == 0) {
+		max1027_start_conv(max1027, channel);
+
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		if (wait_event_interruptible(channel->change_wq, channel->status))
+			return -ERESTARTSYS;
+	}
+	//printk("count dev %d\n", count);
+	count = fifo_get(value, count>>1, channel)<<1;
+	//printk("count %d\n", count);
+
+	/* Copy result to given userspace buffer */
+	//count = min( count, (size_t)sizeof(u16) );
+	if (copy_to_user(buf, value, count)) {
+		ret = -EFAULT;
+		goto out;
+	}
+	ret = count;
+
+out:
+	return ret;
+}
+
+/* Tasklet to get results after EOC interrupt */
+static void read_conversion_results(unsigned long data)
+{
+	struct spi_device *spi = (struct spi_device *)data;
+	struct max1027 *max1027 = dev_get_drvdata(&spi->dev);
+	int size = 0;
+
+	/* Calculate parameters to get conversion results from chip
+	   (depends on conversion mode) */
+	switch (GET_SCAN_MODE(max1027->conv_reg))
+	{
+		case SCAN_MODE_00:
+			size = GET_SELECTED_CHANNEL(max1027->conv_reg) + 1;
+		break;
+
+		case SCAN_MODE_01:
+			size = NB_CHANNELS - GET_SELECTED_CHANNEL(max1027->conv_reg);
+		break;
+
+		case SCAN_MODE_10:
+			size = GET_NB_SCAN(max1027->avg_reg);
+		break;
+
+		case SCAN_MODE_11:
+			size = 1;
+		break;
+
+		default:
+			printk(KERN_ERR "%s: max1027 scan mode not supported\n",
+				__FUNCTION__);
+		break;
+	}
+
+	/* Get the results */
+	if (max1027->conv_reg & MAX1027_CONV_TEMP) {
+		max1027_reads_async(spi, size+1);
+	} else {
+		max1027_reads_async(spi, size);
+	}
+}
+
+/* EOC (End Of Conversion) IRQ handler */
+static irqreturn_t max1027_interrupt(int irq, void *dev_id)
+{
+	struct max1027 *max1027 = dev_id;
+
+	/* schedules task for reading conversion results outside of IRQ */
+	tasklet_hi_schedule(&max1027->tasklet);
+
+	return IRQ_HANDLED;
+}
+
+
+static void max1027_flush_all_channels(struct max1027 *p_max1027)
+{
+	int i;
+
+	for (i=0; i < NB_CHANNELS; i++) {
+		if (p_max1027->channels[i] != NULL)
+			fifo_flush(p_max1027->channels[i]);
+	}
+}
+
+static int max1027_dev_open(struct inode *inode, struct file *file)
+{
+	unsigned minor = MINOR(inode->i_rdev);
+	int ret = 0;
+	struct adc_channel *channel;
+	struct max1027 *max1027 = dev_get_drvdata(&current_spi->dev); /* suite du cradingue */
+
+	channel = kzalloc(sizeof(struct adc_channel), GFP_KERNEL);
+	if (!channel)
+		goto err_request;
+
+	file->private_data = channel;
+	//spin_lock_init(&channel->lock);
+	init_waitqueue_head(&channel->change_wq);
+
+	channel->id = minor;
+	channel->status = 0;
+
+	pr_debug("Opening /dev/max1027/AN%d\n", minor);
+	fifo_flush(channel);
+	max1027->channels[minor & 0x07] = channel;
+
+	return 0;
+
+err_request:
+	/* what about spinlock & wait_queue ?? */
+	return ret;
+}
+
+static int max1027_dev_release(struct inode *inode, struct file *file)
+{
+	unsigned minor = MINOR(inode->i_rdev);
+	struct adc_channel *channel = file->private_data;
+	struct max1027 *max1027 = dev_get_drvdata(&current_spi->dev); /* suite du cradingue */
+
+	mutex_lock(&max1027->update_lock);
+	max1027->channels[channel->id] = NULL;
+	kfree(channel);
+	mutex_unlock(&max1027->update_lock);
+
+	pr_debug("Closing access to /dev/max1027/AN%d\n", minor);
+	return 0;
+}
+
+static struct file_operations max1027_fops = {
+	.owner   = THIS_MODULE,
+	.llseek  = no_llseek,
+//	.write   = no_write,
+	.read    = max1027_dev_read,
+	.open    = max1027_dev_open,
+	.release = max1027_dev_release,
+};
+
+/* sysfs hook functions */
+
+/* Given value will be put in MAX1027 conversion register.
+   Writing to this register will start an acquisition/conversion if
+   clock mode 1x is configured in setup register.
+*/
+static ssize_t max1027_set_conversion(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct max1027 *max1027 = dev_get_drvdata(&spi->dev);
+	int val;
+
+	/* Only 1 conversion can be launched that way at a given time */
+	mutex_lock(&max1027->update_lock);
+
+	val = (simple_strtol(buf, NULL, 10)) & 0xff;
+	pr_debug("\n%s: 0x%02x\n", __FUNCTION__, val);
+	max1027_flush_all_channels(max1027);
+	/* Warn if a conversion is already launched and selected mode will
+	   trigger a new one */
+        if (test_and_set_bit(CONVERSION_RUNNING, &max1027->status)) {
+		/* Should not occur !! */
+		printk("%s: conv already running!\n", __func__);
+	}
+	/* Send value to chip */
+	max1027_send_cmd(spi, MAX1027_REG_CONV | val);
+	if (!(max1027->setup_reg & MAX1027_REG_SETUP_CKSEL1)) {
+		if (max1027->cnvst == 0){
+			printk(KERN_WARNING DRIVER_NAME "CNVST pin not defined!\n");
+			return 0;
+		}
+		mdelay(1); 
+		/* Use CNVST triggered conv. */
+		trig_cnvst(max1027);
+	}
+
+	/* Wait until current convertion is finished if corresponding clock
+	   mode is selected */
+	max1027_wait_end_of_conv(max1027);
+	pr_debug("%s end\n", __FUNCTION__);
+
+	mutex_unlock(&max1027->update_lock);
+
+	return count;
+}
+
+static ssize_t max1027_get_conversion(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret_size = 0;
+	struct spi_device *spi = to_spi_device(dev);
+	struct max1027 *max1027 = dev_get_drvdata(&spi->dev);
+
+	ret_size = sprintf(buf,"0x%02x", max1027->conv_reg);
+
+	return ret_size;
+}
+
+/* buf value <256 -> accesss to "config" register
+   buf value >=256 -> "Unipolar" or "Bipolar" mode registers */
+static ssize_t max1027_set_setup(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct max1027 *max1027 = dev_get_drvdata(&spi->dev);
+	int val;
+
+	val = simple_strtol(buf, NULL, 10);
+	pr_debug("%s: 0x%02x", __FUNCTION__, val);
+
+	mutex_lock(&max1027->update_lock);
+	max1027_send_cmd(spi, MAX1027_REG_SETUP | (val&0xff));
+	/* check whether we need to configure the uni or bipolar mode IOs or not */
+	if (((val&0xff) & MAX1027_SETUP_DIFFSEL_MASK) > MAX1027_SETUP_DIFFSEL(1)) {
+		max1027_send_cmd(spi, val>>8);
+		pr_debug("+ 0x%02x", val);
+	}
+	max1027_flush_all_channels(max1027);
+	mutex_unlock(&max1027->update_lock);
+
+	pr_debug("\n");
+
+	return count;
+}
+
+static ssize_t max1027_get_setup(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret_size = 0;
+	struct spi_device *spi = to_spi_device(dev);
+	struct max1027 *p_max1027 = dev_get_drvdata(&spi->dev);
+
+	ret_size = sprintf(buf,"0x%02x", p_max1027->setup_reg);
+
+	return ret_size;
+}
+
+static ssize_t max1027_set_averaging(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	int val;
+	struct max1027 *p_max1027 = dev_get_drvdata(&spi->dev);
+
+	val = (simple_strtol(buf, NULL, 10)) & 0xff;
+	pr_debug("%s: 0x%02x\n", __FUNCTION__, val);
+
+	mutex_lock(&p_max1027->update_lock);
+	max1027_send_cmd(spi, MAX1027_REG_AVG | val);
+	max1027_flush_all_channels(p_max1027);
+	mutex_unlock(&p_max1027->update_lock);
+
+	return count;
+}
+
+static ssize_t max1027_get_averaging(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret_size = 0;
+	struct spi_device *spi = to_spi_device(dev);
+	struct max1027 *p_max1027 = dev_get_drvdata(&spi->dev);
+
+	ret_size = sprintf(buf, "0x%02x", p_max1027->avg_reg);
+
+	return ret_size;
+}
+
+static DEVICE_ATTR(conversion, S_IWUSR | S_IRUGO, max1027_get_conversion, max1027_set_conversion);
+static DEVICE_ATTR(setup,      S_IWUSR | S_IRUGO, max1027_get_setup, max1027_set_setup);
+static DEVICE_ATTR(averaging,  S_IWUSR | S_IRUGO, max1027_get_averaging, max1027_set_averaging);
+/* Unipolar / Bipolar are set with Setup register specials modes !!!
+static DEVICE_ATTR(unipolar,   S_IWUSR, NULL, max1027_unipolar);
+static DEVICE_ATTR(bipolar,    S_IWUSR, NULL, max1027_bipolar);*/
+
+/* For debug: */
+static ssize_t max1027_get_statistics(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret_size = 0;
+        struct spi_device *spi = to_spi_device(dev);
+        struct max1027 *max1027 = dev_get_drvdata(&spi->dev);
+
+	ret_size = sprintf(buf, "%d", max1027->missed_eoc);
+
+	return ret_size;
+}
+
+static ssize_t max1027_set_statistics(struct device *dev,
+                struct device_attribute *attr, const char *buf, size_t count)
+{
+        struct spi_device *spi = to_spi_device(dev);
+        struct max1027 *max1027 = dev_get_drvdata(&spi->dev);
+
+	/* Whatever was given, clear statistics */
+	max1027->missed_eoc = 0;
+
+        return count;
+}
+
+static DEVICE_ATTR(statistics, S_IWUSR | S_IRUGO, max1027_get_statistics, max1027_set_statistics);
+
+/* For channel values: */
+#define show_in(offset) \
+static ssize_t show_in##offset##_input(struct device *dev, \
+					struct device_attribute *attr, char *buf) \
+{ \
+	int result; \
+	ssize_t size; \
+	struct spi_device *spi = to_spi_device(dev); \
+	struct max1027 *max1027 = dev_get_drvdata(&spi->dev); \
+\
+	result = max1027->ain[offset]; \
+	size = sprintf(buf, "%d\n", (result*2500)>>10); /* millivolt with 2.5V ref */ \
+\
+	return size; \
+} 
+
+show_in(0);
+show_in(1);
+show_in(2);
+show_in(3);
+show_in(4);
+show_in(5);
+show_in(6);
+show_in(7);
+
+static DEVICE_ATTR(in0_input, S_IRUGO, show_in0_input, NULL);
+static DEVICE_ATTR(in1_input, S_IRUGO, show_in1_input, NULL);
+static DEVICE_ATTR(in2_input, S_IRUGO, show_in2_input, NULL);
+static DEVICE_ATTR(in3_input, S_IRUGO, show_in3_input, NULL);
+static DEVICE_ATTR(in4_input, S_IRUGO, show_in4_input, NULL);
+static DEVICE_ATTR(in5_input, S_IRUGO, show_in5_input, NULL);
+static DEVICE_ATTR(in6_input, S_IRUGO, show_in6_input, NULL);
+static DEVICE_ATTR(in7_input, S_IRUGO, show_in7_input, NULL);
+
+/* On chip temperature: */
+static ssize_t max1027_get_temperature(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int result;
+	ssize_t size;
+	struct spi_device *spi = to_spi_device(dev);
+	struct max1027 *max1027 = dev_get_drvdata(&spi->dev);
+
+	result = max1027->temperature;
+	size = sprintf(buf, "%d\n", result);
+
+	return size;
+}
+
+static DEVICE_ATTR(temp1_input, S_IRUGO, max1027_get_temperature, NULL);
+
+
+#define SYSFS_ERROR_STRING "Unable to create sysfs attribute for max1027"
+
+#define CREATE_SYSFS_FOR_AIN(id) \
+	if ((status = device_create_file(&spi->dev, &dev_attr_in##id##_input))) { \
+		printk(KERN_WARNING SYSFS_ERROR_STRING "in##id## \n"); \
+		goto end; \
+	}
+
+static int max1027_create_sys_entries(struct spi_device *spi)
+{
+	int status = 0;
+
+	if ((status = device_create_file(&spi->dev, &dev_attr_conversion))) {
+		printk(KERN_WARNING SYSFS_ERROR_STRING " Conversion register\n");
+		goto end;
+	}
+
+	if ((status = device_create_file(&spi->dev, &dev_attr_setup))) {
+		printk(KERN_WARNING SYSFS_ERROR_STRING " Setup register\n");
+		goto end;
+	}
+
+	if ((status = device_create_file(&spi->dev, &dev_attr_averaging))) {
+		printk(KERN_WARNING SYSFS_ERROR_STRING " Averaging register\n");
+		goto end;
+	}
+
+        if ((status = device_create_file(&spi->dev, &dev_attr_statistics))) {
+                printk(KERN_WARNING SYSFS_ERROR_STRING " missed EOC accessor\n");
+                goto end;
+        }
+
+	if ((status = device_create_file(&spi->dev, &dev_attr_temp1_input))){ 
+		printk(KERN_WARNING SYSFS_ERROR_STRING " temp1\n");
+		goto end;
+	}
+
+	CREATE_SYSFS_FOR_AIN(0);
+	CREATE_SYSFS_FOR_AIN(1);
+	CREATE_SYSFS_FOR_AIN(2);
+	CREATE_SYSFS_FOR_AIN(3);
+	CREATE_SYSFS_FOR_AIN(4);
+	CREATE_SYSFS_FOR_AIN(5);
+	CREATE_SYSFS_FOR_AIN(6);
+	CREATE_SYSFS_FOR_AIN(7);
+
+end:
+	return status;
+}
+
+static void max1027_remove_sys_entries(struct spi_device *spi)
+{
+	device_remove_file(&spi->dev, &dev_attr_conversion);
+	device_remove_file(&spi->dev, &dev_attr_setup);
+	device_remove_file(&spi->dev, &dev_attr_averaging);
+	device_remove_file(&spi->dev, &dev_attr_statistics);
+	device_remove_file(&spi->dev, &dev_attr_temp1_input);
+	device_remove_file(&spi->dev, &dev_attr_in0_input);
+	device_remove_file(&spi->dev, &dev_attr_in1_input);
+	device_remove_file(&spi->dev, &dev_attr_in2_input);
+	device_remove_file(&spi->dev, &dev_attr_in3_input);
+	device_remove_file(&spi->dev, &dev_attr_in4_input);
+	device_remove_file(&spi->dev, &dev_attr_in5_input);
+	device_remove_file(&spi->dev, &dev_attr_in6_input);
+	device_remove_file(&spi->dev, &dev_attr_in7_input);
+}
+
+static int __devinit max1027_probe(struct spi_device *spi)
+{
+	struct max1027 *max1027;
+	struct max1027_config *platform_info; 
+	int i, result;
+
+	pr_debug("%s\n", __FUNCTION__);
+
+	platform_info = (struct max1027_config *)(spi->dev.platform_data);
+	if (!platform_info) {
+		dev_err(&spi->dev, "can't get the platform data for MAX1027\n");
+		return -EINVAL;
+	}
+
+	max1027 = kzalloc(sizeof(struct max1027), GFP_KERNEL);
+	if (!max1027)
+		return -ENOMEM;
+	mutex_init(&max1027->update_lock);
+	for (i=0; i < NB_CHANNELS; i++) {
+		max1027->channels[i] = NULL;
+	}
+
+	/* Register the driver as character device by getting a major number */
+	result = register_chrdev(max1027_major, DRIVER_NAME, &max1027_fops);
+	if (result < 0) {
+		printk(KERN_WARNING DRIVER_NAME ": can't get major %d\n", max1027_major);
+		return result;
+	}
+	if (max1027_major == 0)
+		max1027_major = result; /* dynamic Major allocation */
+
+	/* Setup any GPIO active */
+	result = platform_info->init(spi);
+	if (result) {
+		printk(KERN_WARNING DRIVER_NAME ": can't reserve gpios\n");
+		goto err_irq;
+	}
+	max1027->cnvst = platform_info->cnvst_pin;
+	if (max1027->cnvst > 0)
+		gpio_set_value(max1027->cnvst, 1);
+
+	/* Create /sys entries */
+	/* sysfs hook */
+	dev_set_drvdata(&spi->dev, max1027);
+	current_spi = spi;
+
+#if defined(CONFIG_HWMON) || defined(CONFIG_HWMON_MODULE)
+	/* register to hwmon */
+	max1027->cdev = hwmon_device_register(&spi->dev);
+	if (IS_ERR(max1027->cdev)) {
+		result = PTR_ERR(max1027->cdev);
+		goto err_hwmon;
+	}
+#endif
+
+	result = max1027_create_sys_entries(spi);
+	if (result)
+		goto err_sys;
+
+	tasklet_init(&max1027->tasklet, read_conversion_results, (unsigned long)spi);
+	max1027->status = 0;
+	init_waitqueue_head(&max1027->conv_wq);
+
+	/* setup spi_device */
+	spi->bits_per_word = 8;
+	spi_setup(spi);
+
+	/* configure the MAX */
+	max1027_send_cmd(spi, MAX1027_RESET_ALL);
+	max1027_send_cmd(spi, platform_info->setup | MAX1027_REG_SETUP);
+	max1027_send_cmd(spi, platform_info->avg | MAX1027_REG_AVG);
+	max1027->conv_reg = (u8)(platform_info->conv | MAX1027_REG_CONV);
+
+	set_irq_type(spi->irq, IRQF_TRIGGER_FALLING); /* machine specific... */
+	/* Request interrupt for EOC */ /* Should be put before GPIO init no ? */
+	result = request_irq(spi->irq, max1027_interrupt, 0, DRIVER_NAME, max1027);
+	if (result)
+		goto err_irq;
+
+	printk(DRIVER_NAME " v" DRIVER_VERSION " successfully probed !\n");
+
+	return 0;
+
+err_sys:
+	free_irq(spi->irq, max1027);
+#if defined(CONFIG_HWMON) || defined(CONFIG_HWMON_MODULE)
+err_hwmon:
+	hwmon_device_unregister(max1027->cdev);
+#endif
+err_irq:
+	unregister_chrdev(max1027_major, DRIVER_NAME);
+
+	return result;
+}
+
+static int __devexit max1027_remove(struct spi_device *spi)
+{
+	int i;
+	struct max1027 *max1027 = dev_get_drvdata(&spi->dev);
+	struct max1027_config *platform_info =
+		(struct max1027_config *)(spi->dev.platform_data);
+
+	pr_debug("%s\n", __FUNCTION__);
+
+	max1027_remove_sys_entries(spi);
+#if defined(CONFIG_HWMON) || defined(CONFIG_HWMON_MODULE)
+	hwmon_device_unregister(max1027->cdev);
+#endif
+
+	tasklet_kill(&max1027->tasklet);
+
+	/* De-register from /dev interface */
+	unregister_chrdev(max1027_major, DRIVER_NAME);
+
+	free_irq(spi->irq, max1027);
+	/* Free GPIOs*/
+	platform_info->exit(spi);
+
+	dev_set_drvdata(&spi->dev, NULL);
+
+	for (i=0; i < NB_CHANNELS; i++) {
+		kfree(max1027->channels[i]);
+	}
+	kfree(max1027);
+
+	return 0;
+} 
+
+static struct spi_driver max1027_driver = {
+	.driver = {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe	= max1027_probe,
+	.remove	= __devexit_p(max1027_remove),
+};
+
+static int __init max1027_init(void)
+{
+	return spi_register_driver(&max1027_driver);
+}
+
+static void __exit max1027_exit(void)
+{
+	spi_unregister_driver(&max1027_driver);
+}
+
+module_init(max1027_init);
+module_exit(max1027_exit);
+
+MODULE_AUTHOR("Julien Boibessot / Nicolas Colombain - Armadeus Systems");
+MODULE_DESCRIPTION("Max1027 driver");
+MODULE_LICENSE("GPL");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/max9768/Kconfig linux-3.13/drivers/armadeus/max9768/Kconfig
--- linux-3.13/drivers/armadeus/max9768/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/max9768/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,10 @@
+#
+#
+
+config ARMADEUS_MAX9768
+	tristate "MAX9768 Audio amplifier"
+	default n
+	depends on ARMADEUS_DRIVERS
+	---help---
+	  Custom Armadeus driver for MAX9768 Audio amplifier driver.
+	  (To wait until we are Asoc compatible)
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/max9768/Makefile linux-3.13/drivers/armadeus/max9768/Makefile
--- linux-3.13/drivers/armadeus/max9768/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/max9768/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,24 @@
+#
+# Makefile for the Armadeus MAX9768 custom driver
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_ARMADEUS_MAX9768)	+= max9768.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/max9768/max9768.c linux-3.13/drivers/armadeus/max9768/max9768.c
--- linux-3.13/drivers/armadeus/max9768/max9768.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/max9768/max9768.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,336 @@
+/*
+ * MAX9768 audio amplifier driver
+ *
+ * Copyright (C) 2009 Armadeus Project / Armadeus Systems
+ * Author: Nicolas Colombain
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/sysfs.h>
+#include <mach/gpio.h>
+#include <linux/err.h>
+
+#include "max9768.h"
+
+#define DRIVER_VERSION		"0.2"
+#define DRIVER_NAME		"max9768"
+#define MAX9768_VOLUME_MASK	0x3F
+#define MAX9768_VOLUME_MAX	63
+#define MAX9768_VOLUME_MIN	0
+
+struct max9768 {
+	struct i2c_client *client;
+	int mute_pin;
+	int shdn_pin;
+	int current_volume;
+	int shdn_state;
+	int mute_state;
+};
+
+static void max9768_shutdown(struct max9768 *max9768, int shutdown)
+{
+	if (max9768->shdn_pin) {
+		if (shutdown)
+			gpio_set_value(max9768->shdn_pin, 0);
+		else
+			gpio_set_value(max9768->shdn_pin, 1);
+	}
+	max9768->shdn_state = shutdown;
+}
+
+static void max9768_mute(struct max9768 *max9768, int mute)
+{
+	if (max9768->mute_pin) {
+		gpio_set_value(max9768->mute_pin, mute);
+	}
+	max9768->mute_state = mute;
+}
+
+static int max9768_send(struct i2c_client *client, int value)
+{
+	char msg = value & 0xff;
+
+	return i2c_master_send(client, &msg, 1);
+}
+
+
+/* sysfs hook functions */
+
+static ssize_t max9768_get_volume(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max9768 *max9768 = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%d", max9768->current_volume);
+}
+
+static ssize_t max9768_set_volume(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max9768 *max9768 = i2c_get_clientdata(client);
+	char msg;
+	int err;
+	
+	max9768->current_volume = simple_strtol(buf, NULL, 10);
+	if (max9768->current_volume > MAX9768_VOLUME_MAX)
+		max9768->current_volume = MAX9768_VOLUME_MAX;
+	else if (max9768->current_volume < MAX9768_VOLUME_MIN)
+		max9768->current_volume = MAX9768_VOLUME_MIN;
+
+	msg = max9768->current_volume & MAX9768_VOLUME_MASK;
+	pr_debug("%s: 0x%02x\n", __FUNCTION__, msg);
+	err = max9768_send(client, msg);
+	if (err < 0) {
+		dev_err(dev, "couldn't set volume\n");
+	}
+
+	return count;
+}
+
+static ssize_t max9768_get_mute(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max9768 *max9768 = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%d", max9768->mute_state);
+}
+
+static ssize_t max9768_set_mute(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max9768 *max9768 = i2c_get_clientdata(client);
+
+	if (simple_strtol(buf, NULL, 10) == 0) 
+		max9768_mute(max9768, 0);
+	else
+		max9768_mute(max9768, 1);
+
+	return count;
+}
+
+static ssize_t max9768_get_shutdown(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max9768 *max9768 = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%d", max9768->shdn_state);
+}
+
+static ssize_t max9768_set_shutdown(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max9768 *max9768 = i2c_get_clientdata(client);
+
+	if (simple_strtol(buf, NULL, 10) == 0) 	
+		max9768_shutdown(max9768, 0);
+	else 
+		max9768_shutdown(max9768, 1);
+
+	return count;
+}
+
+static DEVICE_ATTR(shutdown, S_IWUSR | S_IRUGO, max9768_get_shutdown, max9768_set_shutdown);
+static DEVICE_ATTR(mute, S_IWUSR | S_IRUGO, max9768_get_mute, max9768_set_mute);
+static DEVICE_ATTR(volume, S_IWUSR | S_IRUGO, max9768_get_volume, max9768_set_volume);
+
+static int max9768_create_sys_entries(struct i2c_client *client)
+{
+	int status = 0;
+
+	if ((status = device_create_file(&client->dev, &dev_attr_volume))) {
+		dev_warn(&client->dev, "Unable to create sysfs attribute for volume register\n");
+		goto exit;
+	}
+	if ((status = device_create_file(&client->dev, &dev_attr_mute))) {
+		dev_warn(&client->dev, "Unable to create sysfs attribute for mute register\n");
+		goto exit;
+	}
+	if ((status = device_create_file(&client->dev, &dev_attr_shutdown))) {
+		dev_warn(&client->dev, "Unable to create sysfs attribute for shutdown register\n");
+		goto exit;
+	}
+
+exit:
+	return status;
+}
+
+static void max9768_remove_sys_entries(struct i2c_client *client)
+{
+	device_remove_file(&client->dev, &dev_attr_volume);
+	device_remove_file(&client->dev, &dev_attr_mute);
+	device_remove_file(&client->dev, &dev_attr_shutdown);
+}
+
+
+static int max9768_probe(struct i2c_client *client,
+				 const struct i2c_device_id *id)
+{
+	struct max9768 *max9768;
+	struct max9768_platform_data *platform_data; 
+	int result;
+
+	platform_data = (struct max9768_platform_data *)(client->dev.platform_data);
+	if (!platform_data) {
+		dev_err(&client->dev, "can't get the platform data for max9768\n");
+		return -EINVAL;
+	}
+
+	max9768 = kzalloc(sizeof(struct max9768), GFP_KERNEL);
+	if (!max9768) {
+		dev_err(&client->dev, "can't allocate memory\n");
+		return -ENOMEM;
+	}
+
+	max9768->client = client;
+	i2c_set_clientdata(client, max9768);
+	dev_set_drvdata(&client->dev, max9768);
+
+	/* create /sys entries */
+	result = max9768_create_sys_entries(client);
+	if (result)
+		goto out_free;
+
+	if (platform_data->init) {
+		result = platform_data->init();
+		if (result) {
+			dev_err(&client->dev, "can't reserve gpios\n");
+			goto out_sys;
+		}
+	}
+	max9768->mute_pin = platform_data->mute_pin;
+	max9768->shdn_pin = platform_data->shdn_pin;
+		
+	/* set filter mode */
+	result = max9768_send(client, platform_data->filter_mode);
+	if (result < 0) {
+		dev_err(&client->dev, "can't communicate with chip\n");
+		goto out_gpio;
+	}
+
+	/* shutdown amplifier and activate mute */
+	max9768_shutdown(max9768, 1);
+	max9768_mute(max9768, 1);
+
+	dev_notice(&client->dev, "successfully probed !\n");
+
+	return 0;
+
+out_gpio:
+	if (platform_data->exit)
+		platform_data->exit();
+out_sys:
+	max9768_remove_sys_entries(client);
+out_free:
+	i2c_set_clientdata(client, NULL);
+	kfree(max9768);
+
+	return result;
+}
+
+static int max9768_remove(struct i2c_client *client)
+{
+	struct max9768 *max9768 = i2c_get_clientdata(client);
+	struct max9768_platform_data *pdata = client->dev.platform_data;
+
+	max9768_remove_sys_entries(client);
+
+	if (pdata->exit)
+		pdata->exit();
+
+	kfree(i2c_get_clientdata(client));
+	kfree(max9768);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int max9768_suspend(struct i2c_client *client, pm_message_t state)
+{
+	struct max9768 *max9768 = i2c_get_clientdata(client);
+
+	gpio_set_value(max9768->mute_pin, 1);
+	gpio_set_value(max9768->shdn_pin, 0);
+
+	return 0;
+}
+
+static int max9768_resume(struct i2c_client *client)
+{
+	struct max9768 *max9768 = i2c_get_clientdata(client);
+
+	/* reactivate the component just like before suspend */
+	max9768_shutdown(max9768, max9768->shdn_state);
+	max9768_mute(max9768, max9768->mute_state);
+
+	return 0;
+}
+#else
+#define max9768_suspend	NULL
+#define max9768_resume	NULL
+#endif
+
+
+static const struct i2c_device_id max9768_id[] = {
+	{ DRIVER_NAME, 0 },
+	{},
+};
+
+static struct i2c_driver max9768_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = max9768_probe,
+	.remove = max9768_remove,
+	.suspend = max9768_suspend,
+	.resume = max9768_resume,
+	.id_table = max9768_id,
+};
+
+static int __init max9768_init(void)
+{
+	int ret;
+
+	printk(DRIVER_NAME " v" DRIVER_VERSION "\n");
+	ret = i2c_add_driver(&max9768_driver);
+	if (ret)
+		printk(KERN_ERR "unable to register to I2C bus !\n");
+
+	return ret;
+}
+module_init(max9768_init);
+
+static void __exit max9768_exit(void)
+{
+	i2c_del_driver(&max9768_driver);
+}
+module_exit(max9768_exit);
+
+MODULE_AUTHOR("Nicolas Colombain <nicolas.colombain@armadeus.com>");
+MODULE_DESCRIPTION("MAX9768 audio amplifier driver");
+MODULE_LICENSE("GPL");
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/max9768/max9768.h linux-3.13/drivers/armadeus/max9768/max9768.h
--- linux-3.13/drivers/armadeus/max9768/max9768.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/max9768/max9768.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,37 @@
+/*
+ * Max9768 audio amplifier driver
+ *
+ * Copyright (C) 2009 Armadeus Project / Armadeus Systems
+ * Author: Nicolas Colombain
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __LINUX_MAX9768_H
+#define __LINUX_MAX9768_H
+
+#define MAX9768_FILTERLESS_MODE		0xD5
+#define MAX9768_CLASSIC_PWM_MODE	0xD6
+
+struct max9768_platform_data {
+	u8 filter_mode;
+	int mute_pin;	/* gpio for mute ctrl */
+	int shdn_pin;	/* gpio for shutdown ctrl */
+	int (*init)(void);
+	int (*exit)(void);
+};
+
+#endif /* __LINUX_MAX9768_H */
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/linux-3.13/drivers/armadeus.order linux-3.13/drivers/armadeus/linux-3.13/drivers/armadeus.order
--- linux-3.13/drivers/armadeus/linux-3.13/drivers/armadeus.order	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/linux-3.13/drivers/armadeus.order	2013-12-20 12:21:07.000000000 +0100
@@ -0,0 +1 @@
+kernel/linux-3.13/drivers/armadeus/fpga/dev_tools/loader/fpgaloader.ko
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/mxs_lradc/Kconfig linux-3.13/drivers/armadeus/mxs_lradc/Kconfig
--- linux-3.13/drivers/armadeus/mxs_lradc/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/mxs_lradc/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,10 @@
+#
+#
+
+config ARMADEUS_SENSOR_MXS_LRADC
+	tristate "MXS LRADC"
+	default n
+	depends on ARMADEUS_DRIVERS && MXS_LRADC && HWMON
+	---help---
+	  Use MXS LRADC as generic hardware monitor device.
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/mxs_lradc/Makefile linux-3.13/drivers/armadeus/mxs_lradc/Makefile
--- linux-3.13/drivers/armadeus/mxs_lradc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/mxs_lradc/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,24 @@
+#
+# Makefile for the MXS LRADC module 
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_ARMADEUS_SENSOR_MXS_LRADC)	+= mxs_lradc.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/mxs_lradc/mxs_lradc.c linux-3.13/drivers/armadeus/mxs_lradc/mxs_lradc.c
--- linux-3.13/drivers/armadeus/mxs_lradc/mxs_lradc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/mxs_lradc/mxs_lradc.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,267 @@
+/*
+ * mxs_lradc.c - driver for the MXS LRADC module
+ *
+ * Copyright (c) 2012 Eric Jarrige <eric.jarrige@armadeus.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/sysfs.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <mach/hardware.h>
+#include <mach/lradc.h>
+#include <mach/device.h>
+#include <mach/regs-lradc.h>
+
+#include "mxs_lradc.h"
+
+#define MXS_MAX_VALUE 3700 /* mV */
+
+struct mxs_lradc {
+	struct device *hwmon_dev;
+	struct mutex lock;
+	unsigned int base;
+};
+
+static ssize_t mxs_lradc_read(struct device *dev,
+			   struct device_attribute *devattr, char *buf)
+{
+	struct mxs_lradc *adc = dev_get_drvdata(dev);
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	int status = 0;
+	int ret_value;
+
+	if (mutex_lock_interruptible(&adc->lock))
+		return -ERESTARTSYS;
+
+	/* Clear the Soft Reset and Clock Gate for normal operation */
+	__raw_writel(BM_LRADC_CTRL0_SFTRST | BM_LRADC_CTRL0_CLKGATE,
+		     adc->base + HW_LRADC_CTRL0_CLR);
+
+	/* Clear the accumulator & NUM_SAMPLES */
+	__raw_writel(0xFFFFFFFF,
+		     adc->base + HW_LRADC_CHn_CLR(attr->index));
+
+	/* Clear the interrupt flag */
+	__raw_writel(BM_LRADC_CTRL1_LRADC0_IRQ_EN << attr->index,
+		     adc->base + HW_LRADC_CTRL1_CLR);
+
+	/*
+	 * Get value; this is the max scale value schedule the channel:
+	 */
+	__raw_writel(BF_LRADC_CTRL0_SCHEDULE(1 << attr->index),
+		     adc->base + HW_LRADC_CTRL0_SET);
+
+	/* wait for completion */
+	while ((__raw_readl(adc->base + HW_LRADC_CTRL1)
+		& (BM_LRADC_CTRL1_LRADC0_IRQ << attr->index)) !=
+			(BM_LRADC_CTRL1_LRADC0_IRQ << attr->index))
+		cpu_relax();
+
+	/* Clear the interrupt flag */
+	__raw_writel((BM_LRADC_CTRL1_LRADC0_IRQ << attr->index),
+		     adc->base + HW_LRADC_CTRL1_CLR);
+
+	/* read channel value. */
+	ret_value = __raw_readl(adc->base + HW_LRADC_CHn(attr->index));
+	ret_value = (ret_value & BM_LRADC_CHn_VALUE) /
+			((ret_value & BM_LRADC_CHn_NUM_SAMPLES) + 1);
+
+	/* Adjust scaling factor */ 
+	if (!(__raw_readl(adc->base + HW_LRADC_CTRL2)
+		& BF_LRADC_CTRL2_DIVIDE_BY_TWO(1 << attr->index)))
+		ret_value /= 2;
+
+	status = sprintf(buf, "%d\n", ret_value * MXS_MAX_VALUE / 4096);
+
+	mutex_unlock(&adc->lock);
+	return status;
+}
+
+static ssize_t mxs_lradc_show_min(struct device *dev,
+		struct device_attribute *devattr, char *buf)
+{
+	return sprintf(buf, "0\n");
+}
+
+static ssize_t mxs_lradc_show_max(struct device *dev,
+		struct device_attribute *devattr, char *buf)
+{
+	return sprintf(buf, "%d\n", MXS_MAX_VALUE);
+}
+
+static ssize_t mxs_lradc_show_name(struct device *dev, struct device_attribute
+				*devattr, char *buf)
+{
+	return sprintf(buf, "mxs_lradc\n");
+}
+
+static struct sensor_device_attribute mxs_lradc_attr[] = {
+	SENSOR_ATTR(name, S_IRUGO, mxs_lradc_show_name, NULL, 0),
+	SENSOR_ATTR(in_min, S_IRUGO, mxs_lradc_show_min, NULL, 0),
+	SENSOR_ATTR(in_max, S_IRUGO, mxs_lradc_show_max, NULL, 0),
+};
+
+static struct sensor_device_attribute mxs_lradc_input[] = {
+	SENSOR_ATTR(in0_input, S_IRUGO, mxs_lradc_read, NULL, 0),
+	SENSOR_ATTR(in1_input, S_IRUGO, mxs_lradc_read, NULL, 1),
+	SENSOR_ATTR(in2_input, S_IRUGO, mxs_lradc_read, NULL, 2),
+	SENSOR_ATTR(in3_input, S_IRUGO, mxs_lradc_read, NULL, 3),
+	SENSOR_ATTR(in4_input, S_IRUGO, mxs_lradc_read, NULL, 4),
+	SENSOR_ATTR(in5_input, S_IRUGO, mxs_lradc_read, NULL, 5),
+	SENSOR_ATTR(in6_input, S_IRUGO, mxs_lradc_read, NULL, 6),
+	SENSOR_ATTR(in7_input, S_IRUGO, mxs_lradc_read, NULL, 7),
+};
+/*----------------------------------------------------------------------*/
+
+static int __devinit mxs_lradc_probe(struct platform_device *pdev)
+{
+	struct mxs_lradc *adc;
+	struct resource *res;
+	struct mxs_lradc_platform_data *pdata = pdev->dev.platform_data;
+	int status;
+	int i;
+
+	adc = kzalloc(sizeof(struct mxs_lradc), GFP_KERNEL);
+	if (adc == NULL)
+		return -ENOMEM;
+
+	mutex_init(&adc->lock);
+	mutex_lock(&adc->lock);
+
+	platform_set_drvdata(pdev, adc);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "%s: couldn't get MEM resource\n", __func__);
+		status = -ENODEV;
+		goto exit_free;
+	}
+	adc->base = (unsigned int)IO_ADDRESS(res->start);
+
+	if (pdata) {
+		for (i = 0; i < pdata->num_lradc; i++) {
+			hw_lradc_use_channel(pdata->lradc[i].channel);
+			hw_lradc_configure_channel(pdata->lradc[i].channel,
+				pdata->lradc[i].enable_div2,
+				pdata->lradc[i].samples,
+				pdata->lradc[i].samples);
+			__raw_writel(0x0F << (4 * pdata->lradc[i].channel),
+				adc->base + HW_LRADC_CTRL4_CLR);
+			__raw_writel( pdata->lradc[i].mux_pad <<
+				(4 * pdata->lradc[i].channel),
+				adc->base + HW_LRADC_CTRL4_SET);
+			status = device_create_file(&pdev->dev,
+			&mxs_lradc_input[pdata->lradc[i].channel].dev_attr);
+			if (status) {
+				dev_err(&pdev->dev, "device_create_file failed.\n");
+				goto exit_free;
+			}
+		}
+	}
+
+	/* Register sysfs hooks */
+	for (i = 0; i < ARRAY_SIZE(mxs_lradc_attr); i++) {
+		status = device_create_file(&pdev->dev,
+						&mxs_lradc_attr[i].dev_attr);
+		if (status) {
+			dev_err(&pdev->dev, "device_create_file failed.\n");
+			goto exit_free;
+		}
+	}
+
+	adc->hwmon_dev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(adc->hwmon_dev)) {
+		dev_err(&pdev->dev, "hwmon_device_register failed.\n");
+		status = PTR_ERR(adc->hwmon_dev);
+		goto exit_remove;
+	}
+
+	mutex_unlock(&adc->lock);
+	return 0;
+
+exit_remove:
+	for (i--; i >= 0; i--)
+		device_remove_file(&pdev->dev, &mxs_lradc_attr[i].dev_attr);
+exit_free:
+	dev_set_drvdata(&pdev->dev, NULL);
+	mutex_unlock(&adc->lock);
+	kfree(adc);
+	return status;
+}
+
+static int __devexit mxs_lradc_remove(struct platform_device *pdev)
+{
+	struct mxs_lradc *adc = dev_get_drvdata(&pdev->dev);
+	struct mxs_lradc_platform_data *pdata = pdev->dev.platform_data;
+	int i;
+
+	mutex_lock(&adc->lock);
+	hwmon_device_unregister(adc->hwmon_dev);
+	for (i = 0; i < ARRAY_SIZE(mxs_lradc_attr); i++)
+		device_remove_file(&pdev->dev, &mxs_lradc_attr[i].dev_attr);
+
+	if (pdata) {
+		for (i = 0; i < pdata->num_lradc; i++) {
+			hw_lradc_unuse_channel(pdata->lradc[i].channel);
+			device_remove_file(&pdev->dev,
+			&mxs_lradc_input[pdata->lradc[i].channel].dev_attr);
+		}
+	}
+
+	dev_set_drvdata(&pdev->dev, NULL);
+	mutex_unlock(&adc->lock);
+	kfree(adc);
+
+	return 0;
+}
+
+static struct platform_driver mxs_lradc_driver = {
+	.probe      = mxs_lradc_probe,
+	.remove     = mxs_lradc_remove,
+	.driver     = {
+		.name   = "mxs_lradc",
+		.owner	= THIS_MODULE,
+	},
+};
+
+/* Init module */
+
+static int __init init_mxs_lradc(void)
+{
+	return platform_driver_register(&mxs_lradc_driver);
+}
+
+static void __exit exit_mxs_lradc(void)
+{
+	platform_driver_unregister(&mxs_lradc_driver);
+}
+
+module_init(init_mxs_lradc);
+module_exit(exit_mxs_lradc);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Eric Jarrige <eric.jarrige@armadeus.org>");
+MODULE_DESCRIPTION("MXC LRADC driver");
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/mxs_lradc/mxs_lradc.h linux-3.13/drivers/armadeus/mxs_lradc/mxs_lradc.h
--- linux-3.13/drivers/armadeus/mxs_lradc/mxs_lradc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/mxs_lradc/mxs_lradc.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,34 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _ADC_DEF_H_
+#define _ADC_DEF_H_
+
+/* For the leds-gpio driver */
+struct mxs_lradc_info {
+	const char *name;
+	int		channel;	/* LRADC channel */
+	int		mux_pad;	/* LRADC muxed pad */
+	int		enable_div2;	/* enable for signal up to VDDIO -50mV*/
+	int		samples;	/* oversampling factor */
+};
+
+struct mxs_lradc_platform_data {
+	int	num_lradc;
+	struct mxs_lradc_info *lradc;
+};
+
+#endif	/* _ADC_DEF_H_*/
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/Kconfig linux-3.13/drivers/armadeus/pwm/Kconfig
--- linux-3.13/drivers/armadeus/pwm/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/Kconfig	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,18 @@
+#
+#
+
+config ARMADEUS_PWM_DRIVER
+        tristate "Armadeus PWM driver"
+        default n
+        depends on ARMADEUS_DRIVERS
+        ---help---
+	  This driver allows you to control the PWM controller in the i.MXl.
+	  PWM is useful to play sound or control motors
+
+config ARMADEUS_MXS_PWM_DRIVER
+        tristate "MXS PWM driver"
+        default n
+        depends on ARMADEUS_DRIVERS
+        ---help---
+	  This driver allows you to control the MXS PWM controller.
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/Makefile linux-3.13/drivers/armadeus/pwm/Makefile
--- linux-3.13/drivers/armadeus/pwm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,26 @@
+#
+# Makefile for the Armadeus PWM driver
+#
+
+# Part executed when called from kernel build system:
+ifneq ($(KERNELRELEASE)$(KERNELVERSION),)
+
+obj-$(CONFIG_ARMADEUS_PWM_DRIVER)	+= imx-pwm.o
+imx-pwm-objs        := pwm.o
+obj-$(CONFIG_ARMADEUS_MXS_PWM_DRIVER)	+= mxs-pwm.o
+
+# Part executed when called from standard make in this directory:
+# (preferably use Makefile in parent directory)
+else
+
+ARMADEUS_BASE_DIR=../../../..
+include $(ARMADEUS_BASE_DIR)/Makefile.in
+
+KDIR    := $(ARMADEUS_LINUX_DIR)
+PWD	:= $(shell pwd)
+
+# Armadeus custom linux-3.13/drivers common targets (default, clean, etc...)
+include ../Makefile.in
+
+endif
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/mxs-pwm.c linux-3.13/drivers/armadeus/pwm/mxs-pwm.c
--- linux-3.13/drivers/armadeus/pwm/mxs-pwm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/mxs-pwm.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,597 @@
+/*
+ * MXS PWM driver
+ *
+ * Copyright (C) 2012 Eric Jarrige <eric.jarrige@armadeus.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>        /* get_user, copy_to_user */
+#include <linux/miscdevice.h>
+#include <linux/timer.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <mach/system.h>
+#include <mach/device.h>
+#include <mach/regs-pwm.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/pm.h>
+#include <linux/clk.h>
+#include <linux/sysdev.h>
+#include <linux/device.h>	/* struct class */
+#include <linux/circ_buf.h>
+#include <linux/platform_device.h>
+
+#include <linux/slab.h>
+#include <linux/sched.h>
+
+#include "mxs-pwm.h"
+
+#define PWM_MIN_FREQUENCY 1		/* Hz */
+#define PWM_MAX_FREQUENCY 12000000	/* Hz */
+
+
+#define DRIVER_NAME         "mxs_pwm"
+
+#define DRIVER_VERSION      "1.00"
+
+
+struct pwm_device {
+	void __iomem *membase;
+	unsigned int id;
+	int active;
+	unsigned int duty;	/* current duty cycle in % x 10 */
+	unsigned int frequency;	/* current frequency in Hz */
+	unsigned int period_reg;	/* value to put in PWMPR register to have requested freq */
+
+	struct clk *clk;
+
+	struct device *dev;
+};
+
+int gMajor = 0;
+static void __iomem *pwm_membase = NULL;
+static struct pwm_device *dev_table[CONFIG_MXS_PWM_CHANNELS];
+static const int div_shift[8] = {0, 1, 2, 3, 4, 6, 8, 10};
+static struct class *pwm_class;	/* forward declaration only */
+
+static void inline unregister_sys_file(struct pwm_device *pwm);
+
+
+static int get_current_pwm_clk_rate(struct pwm_device *pwm)
+{
+	return clk_get_rate(pwm->clk);
+}
+
+/* result in Hz */
+static long get_pwm_min_freq(struct pwm_device *pwm)
+{
+	return PWM_MIN_FREQUENCY;
+}
+
+/* result in Hz */
+static long get_pwm_max_freq(struct pwm_device *pwm)
+{
+	return PWM_MAX_FREQUENCY;
+}
+
+/* freq in Hz */
+static void compute_pwm_params(u32 req_freq, struct pwm_device *pwm)
+{
+	unsigned int input_freq, cycles, cdiv = 0;
+
+	input_freq = get_current_pwm_clk_rate(pwm);
+	pr_debug("input freq, %d %d\n", input_freq, req_freq);
+
+	while (1) {
+		cycles = input_freq >> div_shift[cdiv];
+		cycles = cycles / req_freq;
+		if (cycles < 0x10000)
+			break;
+		cdiv++;
+
+		if (cdiv > 7)
+			return;
+	}
+
+	pr_debug("config period_cycles: %d clock divider: %d\n",
+			cycles, cdiv);
+
+	pwm->period_reg = BF_PWM_PERIODn_PERIOD(cycles-1) |
+		BF_PWM_PERIODn_ACTIVE_STATE(BV_PWM_PERIODn_ACTIVE_STATE__1) |
+		BF_PWM_PERIODn_INACTIVE_STATE(BV_PWM_PERIODn_INACTIVE_STATE__0) |
+		BF_PWM_PERIODn_CDIV(cdiv);
+	pwm->frequency = (input_freq >> div_shift[cdiv]) / cycles;
+
+	pr_debug("period reg: %x freq: %d\n", pwm->period_reg, pwm->frequency);
+}
+
+static void setup_pwm_params(struct pwm_device *pwm)
+{
+	u32 temp = ((pwm->period_reg & BM_PWM_PERIODn_PERIOD)+1)* pwm->duty;
+
+	/* Setup duty cycle */
+	writel(((temp<1000)?1:temp/1000) << 16,
+		pwm->membase + HW_PWM_ACTIVEn(pwm->id));
+	writel(pwm->period_reg, pwm->membase + HW_PWM_PERIODn(pwm->id));
+}
+
+
+/* common setup function whenever something was changed */
+static void setup_pwm_unit(struct pwm_device *pwm)
+{
+	if (pwm->active) {
+		/* Activate PWM */
+		setup_pwm_params(pwm);
+		writel(1 << pwm->id, pwm->membase + HW_PWM_CTRL_SET);
+	} else {
+		/* De-activate after one period cycle */
+		writel(1 << pwm->id, pwm->membase + HW_PWM_CTRL_CLR);
+	}
+}
+
+
+static void stop_pwm(struct pwm_device *pwm)
+{
+	/* De-activate after one period cycle */
+	writel(1 << pwm->id, pwm->membase + HW_PWM_CTRL_CLR);
+	pwm->active = 0;
+	pr_debug("data completed.\n");
+	pr_debug("PWMC = 0x%8x\n", readl(pwm->membase + HW_PWM_CTRL));
+}
+
+static int init_pwm(struct pwm_device *pwm)
+{
+	writel((1 << pwm->id) | BM_PWM_CTRL_SFTRST | BM_PWM_CTRL_CLKGATE,
+		pwm->membase + HW_PWM_CTRL_CLR);
+	pwm->active = 0;
+	return 1;
+}
+
+
+/* /DEV INTERFACE */
+
+int pwm_release(struct inode * inode, struct file * filp)
+{
+	struct pwm_device *pwm = dev_table[iminor(inode)];
+
+	stop_pwm(pwm);
+
+	return 0;
+}
+
+int pwm_open(struct inode * inode, struct file * filp)
+{
+	struct pwm_device *pwm = dev_table[iminor(inode)];
+
+	/* Init PWM hardware */
+	init_pwm(pwm);
+	
+	pr_debug(DRIVER_NAME " opened \n");
+
+	return 0;
+}
+
+long pwm_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	struct pwm_device *pwm = dev_table[iminor(filp->f_dentry->d_inode)];
+
+	switch (cmd) {
+		/* Set PWM Mode (Tone or Playback) */
+		case PWM_IOC_SMODE:
+			printk(DRIVER_NAME ": PWM_IOC_SMODE unkown IOCTL\n");
+		break;
+
+		/* Set Playback frequency/ouput rate */
+		case PWM_IOC_SFREQ:
+		{
+			compute_pwm_params(arg, pwm);
+			setup_pwm_params(pwm);
+			pr_debug("Sample rate = %d\n", pwm->frequency);
+			pr_debug("ioctl: PWMC = 0x%8x\n", readl(pwm->membase+HW_PWM_CTRL));
+		}
+		break;
+
+		/* Set samples length (8 or 16 bits) */
+		case PWM_IOC_SDATALEN:
+			printk(DRIVER_NAME ": PWM_IOC_SDATALEN unkown IOCTL\n");
+		break;
+
+		case PWM_IOC_SSAMPLE:
+			pwm->duty = arg;
+			setup_pwm_params(pwm);
+		break;
+
+		case PWM_IOC_SPERIOD:
+			printk(DRIVER_NAME ": PWM_IOC_SPERIOD unkown IOCTL\n");
+		break;
+
+		case PWM_IOC_STOP:
+			stop_pwm(pwm);
+		break;
+
+		case PWM_IOC_SWAPDATA:
+			printk(DRIVER_NAME ": PWM_IOC_SWAPDATA unkown IOCTL\n");
+		break;
+
+		default:
+			printk(DRIVER_NAME ": unkown IOCTL\n");
+		break;
+	}
+
+	return ret;
+}
+
+
+struct file_operations pwm_fops = {
+	open:           pwm_open,
+	release:        pwm_release,
+	unlocked_ioctl:	pwm_ioctl,
+};
+
+/* END OF /DEV INTERFACE */
+
+
+/* /sys interface: */
+
+static ssize_t pwm_show_duty(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret_size = 0;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	ret_size = sprintf(buf, "%u\n", pwm->duty);
+
+	return ret_size;
+}
+
+/*
+ * Duty value can be 0 ... 1000. Without floating point you can take
+ * one position after decimal point into account. The internal counters
+ * supports 10 bit resolution, so it makes sense to support such a thing
+ * like 66.6% or 33.3% (given as 666 and 333 values)
+ */
+static ssize_t pwm_store_duty(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	long value;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	value = simple_strtol(buf, NULL, 10);
+	if ((value < 1) || (value > 999))
+		return -EIO;
+
+	pwm->duty = (unsigned)value;
+	setup_pwm_unit(pwm);
+
+	return size;
+}
+
+static ssize_t pwm_show_period(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret_size = 0;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	if (pwm->frequency)
+		ret_size = sprintf(buf, "%d\n", (u32) 1000000/(pwm->frequency));
+	else
+		ret_size = sprintf(buf, "0\n");
+
+	return ret_size;
+}
+
+static ssize_t pwm_store_period(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	long value;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+	
+	value = simple_strtol(buf, NULL, 10); /* in us */
+	if ((value < (1000000/get_pwm_max_freq(pwm))) || (value > (1000000/get_pwm_min_freq(pwm))))
+		return -EIO;
+
+	compute_pwm_params(1000000/value, pwm);
+	setup_pwm_unit(pwm);
+
+	return size;
+}
+
+static ssize_t pwm_show_frequency(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret_size = 0;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	ret_size = sprintf(buf, "%d\n", pwm->frequency);
+
+	return ret_size;
+}
+
+/*
+ * Given value (in Hertz) should be between 2 and 100k
+ */
+
+static ssize_t pwm_store_frequency(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	long value;
+
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	value = simple_strtol(buf, NULL, 10);
+	if ((value < get_pwm_min_freq(pwm)) || (value > get_pwm_max_freq(pwm)))
+		return -EIO;
+
+	compute_pwm_params(value, pwm);
+	setup_pwm_unit(pwm);
+
+	return size;
+}
+
+static ssize_t pwm_show_state(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret_size = 0;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	ret_size = sprintf(buf, "%d\n", pwm->active);
+
+	return ret_size;
+}
+
+static ssize_t pwm_store_state(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	long value;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	value = simple_strtol(buf, NULL, 10);
+	if (value != 0)
+		pwm->active = 1;
+	else
+		pwm->active = 0;
+
+	setup_pwm_unit(pwm);
+
+	return size;
+}
+
+/* dev_attr_duty  /class/pwm/pwmX/duty */
+static DEVICE_ATTR(duty, S_IWUSR | S_IRUGO, pwm_show_duty, pwm_store_duty);
+/* dev_attr_period  /sys/class/pwm/pwmX/period */
+static DEVICE_ATTR(period, S_IWUSR | S_IRUGO, pwm_show_period, pwm_store_period);
+/* dev_attr_frequency  /sys/class/pwm/pwmX/frequency */
+static DEVICE_ATTR(frequency, S_IWUSR | S_IRUGO, pwm_show_frequency, pwm_store_frequency);
+/* dev_attr_active  /sys/class/pwm/pwmX/active */
+static DEVICE_ATTR(active, S_IWUSR | S_IRUGO, pwm_show_state, pwm_store_state);
+
+
+
+static int imx_pwm_drv_probe(struct platform_device *pdev)
+{
+	int err = -ENODEV;
+	struct resource *res = NULL;
+	struct pwm_device *pwm;
+
+	if (pdev->id >= CONFIG_MXS_PWM_CHANNELS)
+		dev_err(&pdev->dev, "failed. Unknown module. Remember that this device only supports %d PWM\n", CONFIG_MXS_PWM_CHANNELS);
+
+	if (dev_table[pdev->id] != NULL) {
+		dev_err(&pdev->dev, "already in use\n");
+		return -ENODEV;
+	}
+
+
+	pwm = kmalloc(sizeof(struct pwm_device), GFP_KERNEL);
+	if (!pwm) {
+		return -ENOMEM;
+	}
+
+	pwm->active = 0;
+	pwm->duty = 500; /* = 50.O% */
+	pwm->frequency = 1000;
+	pwm->id = pdev->id;
+	platform_set_drvdata(pdev, pwm);
+	dev_table[pdev->id] = pwm;
+
+	if (!pwm_membase) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!res) {
+			dev_err(&pdev->dev, "unable to get mem ressource\n");
+			err = -ENOENT;
+			goto error_malloc;
+		}
+
+		pwm_membase = (void __iomem *)IO_ADDRESS(res->start);
+		if (!pwm_membase) {
+			err = -ENOMEM;
+			goto error_memreg;
+		}
+	}
+
+	pwm->membase = pwm_membase;
+
+	/* Register our char device */
+	if (gMajor == 0) {
+		err = register_chrdev(gMajor, DRIVER_NAME, &pwm_fops);
+		if (err < 0) {
+			dev_err(&pdev->dev, "unable to register char driver\n");
+			goto error_iounmap;
+		}
+	}
+
+	/* Dynamic Major allocation */
+	if (gMajor == 0) {
+		gMajor = err;
+		dev_dbg(&pdev->dev, "major = %d\n", gMajor);
+	}
+
+	/* Create /dev */
+	pwm->dev = device_create(pwm_class, NULL, MKDEV(gMajor, pdev->id), NULL, "pwm%i", pdev->id);
+	if (IS_ERR(pwm->dev)) {
+		err = PTR_ERR(pwm->dev);
+		dev_err(&pdev->dev, "can't create device\n");
+		goto error_platform_init;
+	}
+	dev_set_drvdata(pwm->dev, pwm);
+
+	pwm->clk = clk_get(&pdev->dev, "pwm");
+
+	if (IS_ERR(pwm->clk)) {
+		dev_err(&pdev->dev, "can't get clock\n");
+		goto error_platform_init;
+	}	
+	clk_enable(pwm->clk);
+
+	/* init PWM hardware module */
+	init_pwm(pwm);
+	compute_pwm_params(pwm->frequency, pwm);
+	setup_pwm_unit(pwm);
+
+	/* Register the attributes */
+	err = device_create_file(pwm->dev, &dev_attr_duty);
+	if (unlikely(err))
+		goto error_dev_create;
+	err |= device_create_file(pwm->dev, &dev_attr_period);
+	if (unlikely(err)) {
+		dev_err(&pdev->dev, "can't create /sys/.../period\n");
+		goto error_file;
+	}
+	err |= device_create_file(pwm->dev, &dev_attr_frequency);
+	if (unlikely(err)) {
+		dev_err(&pdev->dev, "can't create /sys/.../frequency\n");
+		goto error_file;
+	}
+	err |= device_create_file(pwm->dev, &dev_attr_active);
+	if (unlikely(err)) {
+		dev_err(&pdev->dev, "can't create /sys/.../active\n");
+		goto error_file;
+	}
+
+	dev_info(&pdev->dev, "initialized\n");
+	return 0;
+
+error_file:
+	unregister_sys_file(pwm);
+error_dev_create:
+	device_destroy(pwm_class, MKDEV(gMajor, pdev->id));
+error_platform_init:
+	unregister_chrdev(gMajor, DRIVER_NAME);
+error_iounmap:
+        iounmap(pwm->membase);
+error_memreg:
+	if (res) release_mem_region(res->start, resource_size(res));
+error_malloc:
+	kfree(pwm);
+
+	return err;
+}
+
+static inline void unregister_sys_file(struct pwm_device *pwm)
+{
+	/* Unregister /sys attributes */
+	device_remove_file(pwm->dev, &dev_attr_active);
+	device_remove_file(pwm->dev, &dev_attr_period);
+	device_remove_file(pwm->dev, &dev_attr_frequency);
+	device_remove_file(pwm->dev, &dev_attr_duty);
+}
+
+static int imx_pwm_drv_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct pwm_device *pwm = (struct pwm_device*)(dev_get_drvdata(&pdev->dev));
+
+	unregister_sys_file(pwm);
+	device_destroy(pwm_class, MKDEV(gMajor, pdev->id));
+	unregister_chrdev(gMajor, DRIVER_NAME);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+	kfree(pwm);
+	dev_table[pdev->id] = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int imx_pwm_drv_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct pwm_device *pwm = (struct pwm_device*)(dev_get_drvdata(&pdev->dev));
+
+	clk_disable(pwm->clk);
+	dev_dbg(&pdev->dev, "suspended\n");
+
+	return 0;
+}
+
+static int imx_pwm_drv_resume(struct platform_device *pdev)
+{
+	struct pwm_device *pwm = (struct pwm_device*)(dev_get_drvdata(&pdev->dev));
+
+	clk_enable(pwm->clk);
+	dev_dbg(&pdev->dev, "resumed\n");
+
+	return 0;
+}
+#else
+
+# define imx_pwm_drv_suspend NULL
+# define imx_pwm_drv_resume NULL
+
+#endif /* CONFIG_PM */
+
+static struct platform_driver imx_pwm_driver = {
+	.probe      = imx_pwm_drv_probe,
+	.remove     = imx_pwm_drv_remove,
+	.suspend    = imx_pwm_drv_suspend,
+	.resume     = imx_pwm_drv_resume,
+	.driver     = {
+		.name   = DRIVER_NAME,
+	},
+};
+
+static int __init imx_pwm_init(void)
+{
+	printk("i.MX PWM driver v" DRIVER_VERSION "\n");
+
+	pwm_class = class_create(THIS_MODULE, "pwm");
+	if (IS_ERR(pwm_class)) {
+		return PTR_ERR(pwm_class);
+	}
+
+	return platform_driver_register(&imx_pwm_driver);
+}
+
+static void __exit imx_pwm_exit(void)
+{
+	int i;
+
+	platform_driver_unregister(&imx_pwm_driver);
+	class_destroy(pwm_class);
+	for (i=0; i<CONFIG_MXS_PWM_CHANNELS; i++)
+		dev_table[i] = NULL;
+
+	printk(DRIVER_NAME " successfully unloaded\n");
+}
+
+module_init(imx_pwm_init);
+module_exit(imx_pwm_exit);
+MODULE_AUTHOR("Eric Jarrige, inspired by armadeus PWM driver");
+MODULE_DESCRIPTION("MXS PWM driver");
+MODULE_LICENSE("GPL");
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/mxs-pwm.h linux-3.13/drivers/armadeus/pwm/mxs-pwm.h
--- linux-3.13/drivers/armadeus/pwm/mxs-pwm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/mxs-pwm.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,47 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Copyright (C) 2002 Freescale Semiconductors HK Ltd
+ *
+ */
+
+#ifndef _PWM_DEF_H_
+#define _PWM_DEF_H_
+
+#include <linux/ioctl.h>
+
+#define PWM_SAMPLING_8KHZ	8000
+#define PWM_SAMPLING_16KHZ	16000
+#define PWM_SAMPLING_32KHZ	32000
+
+#define PWM_DATA_8BIT		8
+#define PWM_DATA_16BIT		16
+
+#define PWM_SWAP_HCTRL		((unsigned long)0x01<<18) 
+#define PWM_SWAP_BCTRL		((unsigned long)0x01<<17) 
+
+#define	PWM_IOC_MAGIC		'p'
+#define	PWM_IOC_SFREQ		_IO(PWM_IOC_MAGIC, 0)
+#define	PWM_IOC_SDATALEN	_IO(PWM_IOC_MAGIC, 1)
+#define	PWM_IOC_SMODE		_IO(PWM_IOC_MAGIC, 2)
+#define	PWM_IOC_SSAMPLE		_IO(PWM_IOC_MAGIC, 3)
+#define	PWM_IOC_SPERIOD		_IO(PWM_IOC_MAGIC, 4)
+#define PWM_IOC_STOP		_IO(PWM_IOC_MAGIC, 5)
+#define PWM_IOC_SWAPDATA	_IO(PWM_IOC_MAGIC, 6) 
+
+#define	PWM_PLAY_MODE		1
+#define	PWM_TONE_MODE		2
+
+#endif	/* _PWM_DEF_H_*/
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/pwm.c linux-3.13/drivers/armadeus/pwm/pwm.c
--- linux-3.13/drivers/armadeus/pwm/pwm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/pwm.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,1157 @@
+/*
+ * Driver for the i.MX PWM driver
+ *
+ * This driver is part of the Armadeus Project and is the merge of a lot of ideas
+ * found on the Web.
+ *
+ * Maintainer: Julien Boibessot <julien.boibessot@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>        /* get_user, copy_to_user */
+#include <linux/miscdevice.h>
+#include <linux/timer.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+#include <mach/hardware.h>
+#include <linux/sysdev.h>
+#endif
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/pm.h>
+#include <linux/clk.h>
+#include <linux/device.h>	/* struct class */
+#include <linux/circ_buf.h>
+#include <linux/platform_device.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+#include <linux/slab.h>
+#include <linux/sched.h>
+#endif
+
+#include "pwm.h"
+
+#if defined(CONFIG_ARCH_MX2) || defined(CONFIG_SOC_IMX27) || defined(CONFIG_ARCH_MX5)
+#define PWMCTRL 	(0x00)
+#define PWMSTATUS 	(0x04)
+#define PWMIRQ 		(0x08)
+#define PWMSAMPLE 	(0x0c)
+#define PWMPERIOD 	(0x10)  
+#define PWMCOUNTER 	(0x14)
+#define PWM_EN		(1<<0)
+#define PWM_IRQEN	(1<<0)
+#define PWM_SWR		(1<<3)
+#define PWM_CLKSRC_MASK	(3<<16)
+#if defined(CONFIG_ARCH_MX2) || defined(CONFIG_SOC_IMX27)
+#define PWM_CLKSRC_IPG	(2<<16)
+#else
+#define PWM_CLKSRC_IPG	(1<<16)
+#endif
+#define PWM_CLKSRC_32K	(3<<16)
+#define PWM_REPEAT_MASK	(3<<1)
+#define PWM_HCTR	(1<<20)
+#define PWM_BCTR	(1<<21)
+#define PWM_FWM_3	(2<<26)
+#define PWM_FIFOAV	(7<<0)
+#define PWM_FIFO_EMPTY	(1<<3)
+#define PWM_FWM		(3<<26)
+#define PWM_REPEAT(x)	(((x) & 0x03) << 1)
+#define PWM_CLKSEL_MASK	(0)
+#define PWM_PRESCALER_MASK 	0x0000FFF0
+#define PWM_PRESCALER(x)	(((x-1) & 0xFFF) << 4)
+#define PWM_PERIOD(x)		((x) & 0xFFFF)
+#define PWM_SAMPLE(x)		((x) & 0xFFFF)
+#define PWM_INT		MXC_INT_PWM
+#if defined(CONFIG_ARCH_MX2) || defined(CONFIG_SOC_IMX27)
+# define PWM_MAX_DEV	1
+#else
+# define PWM_MAX_DEV	2
+#endif
+
+#define PWM_MIN_FREQUENCY 1		/* Hz */
+#define PWM_MAX_FREQUENCY 1000000	/* Hz */
+
+#else
+#define PWMCTRL		(0x00)
+#define PWMSTATUS	(0x00)
+#define PWMIRQ		(0x00)
+#define PWMSAMPLE	(0x04)
+#define PWMPERIOD	(0x08)
+#define PWMCOUNTER	(0x0C)
+#define PWM_EN		(1<<4)
+#define PWM_IRQEN	PWMC_IRQEN
+#define PWM_SWR		PWMC_SWR
+#define PWM_CLKSRC_MASK	(1<<15)
+#define PWM_CLKSRC_IPG	(0<<15)
+#define PWM_CLKSRC_32K	(1<<15)
+#define PWM_FWM_3	(2<<26)
+#define PWM_FWM		(3<<26)
+#define PWM_HCTR	PWMC_HCTR
+#define PWM_BCTR	PWMC_BCTR
+#define PWM_FIFOAV	PWMC_FIFOAV
+#define PWM_REPEAT_MASK	0x0000000C
+#define PWM_CLKSEL_MASK	0x00000003
+#define PWM_REPEAT(x)	PWMC_REPEAT(x)
+#define PWM_PRESCALER_MASK 	0x00007F00
+#define PWM_PRESCALER(x) PWMC_PRESCALER(x)
+#define PWM_PERIOD(x)	PWMP_PERIOD(x)
+#define PWM_SAMPLE(x)	PWMS_SAMPLE(x)
+#define PWM_MAX_DEV	1
+
+#define PWM_MIN_FREQUENCY 2       /* Hz */
+#define PWM_MAX_FREQUENCY 1000000 /* Hz */
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+#define DRIVER_NAME         "imx-pwm"
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+#define DRIVER_NAME         "mxc_pwm"
+#else
+#define DRIVER_NAME         "imx27-pwm"
+#endif
+
+#define DRIVER_VERSION      "0.81"
+
+
+struct sound_circ_buf {
+	char* buf;
+	int write; /* == head */
+	int read;  /* == tail */
+	int size;
+};
+#define MAX_SOUND_BUFFER_SIZE (16*1024) /* !! Should be a power of 2 !! */
+
+typedef struct timer_list timer_blk_t;
+
+typedef struct timerStruct
+{
+	timer_blk_t	*timer_blk_ptr;
+	int     period;
+	void    (*timer_func)(unsigned long);
+	int     stop_flag;
+} pwm_timer_t;
+
+struct pwm_device {
+	void __iomem *membase;
+	unsigned int irq;
+
+	int active;
+	unsigned int duty;	/* current duty cycle in % x 10 */
+	unsigned int frequency;	/* current frequency in Hz */
+	u16 prescaler;
+	u16 period_reg;	/* value to put in PWMPR register to have requested freq */
+
+	int     mode;
+	int     nbbytes; /* count 4 bytes write occurence to FIFO */
+	int     dataLen;
+	u16     sampleValue;
+
+	wait_queue_head_t write_wait;
+	wait_queue_head_t exit_wait;
+
+	struct sound_circ_buf circ_buf;
+	pwm_timer_t timer;
+	timer_blk_t timer_blk;
+	struct clk *clk;
+
+	struct device *dev;
+};
+
+int gMajor = 0;
+static struct pwm_device *dev_table[PWM_MAX_DEV];
+static struct class *pwm_class;	/* forward declaration only */
+
+static void inline unregister_sys_file(struct pwm_device *pwm);
+
+/*
+struct fasync_struct *ts_fasync;
+*/
+
+/****************************************************************
+ * Circular buffer handling for sound playing
+ ***************************************************************/
+
+static inline u8 get_byte_from_circbuf(struct sound_circ_buf* abuffer)
+{
+	u8 b = abuffer->buf[abuffer->read];
+	abuffer->read = (abuffer->read + 1) & (abuffer->size - 1);
+
+	return b;
+}
+
+static inline u16 get_word_from_circbuf(struct sound_circ_buf* abuffer)
+{
+	u16 w = *((u16*)(&(abuffer->buf[ abuffer->read ])));
+	abuffer->read = (abuffer->read + 2) & (abuffer->size - 1);
+
+	return w;
+}
+
+static inline void put_byte_to_circbuf(struct sound_circ_buf* abuffer, unsigned char abyte)
+{
+	abuffer->buf[abuffer->write] = abyte;
+	abuffer->write = (abuffer->write + 1) & (abuffer->size - 1);
+}
+
+static inline void increase_circbuf(struct sound_circ_buf* abuffer, int count)
+{
+	abuffer->write = (abuffer->write + count) & (abuffer->size - 1);
+	pr_debug("Added %d bytes to buffer, now write is in pos %d\n", count, abuffer->write);
+}
+
+
+static int get_current_pwm_clk_rate(struct pwm_device *pwm)
+{
+	if ((readl(pwm->membase + PWMCTRL) & PWM_CLKSRC_MASK) == PWM_CLKSRC_32K)
+		return 32768;
+#if defined(CONFIG_ARCH_MX2) || defined(CONFIG_SOC_IMX27) || defined(CONFIG_ARCH_MX5)
+	return clk_get_rate(pwm->clk);
+#else
+	return 8000000; 
+#endif
+}
+
+/* result in Hz */
+static long get_pwm_min_freq(struct pwm_device *pwm)
+{
+	return PWM_MIN_FREQUENCY;
+}
+
+/* result in Hz */
+static long get_pwm_max_freq(struct pwm_device *pwm)
+{
+	return PWM_MAX_FREQUENCY;
+}
+
+/* freq in Hz */
+static void compute_pwm_params(u32 req_freq, struct pwm_device *pwm)
+{
+	u32 input_freq, divider;
+
+	input_freq = get_current_pwm_clk_rate(pwm);
+	pr_debug("input freq, %d %d\n", input_freq, req_freq);
+	divider = ((input_freq*10)/req_freq+5)/10;
+	if (divider/65536) {
+		pwm->prescaler = (divider/65536)+1;
+		pwm->period_reg = input_freq/(pwm->prescaler*req_freq)-2;
+	} else {
+		pwm->period_reg = divider-2;
+		pwm->prescaler = 1;
+	}
+	pwm->frequency = req_freq;
+	pr_debug("period: %d prescaler: %d\n", pwm->period_reg, pwm->prescaler);
+}
+
+
+static void write_bits(u32 bit, u32 mask, void __iomem *reg)
+{
+	u32 temp;
+	temp = readl(reg) & ~mask;
+	writel(temp | (bit&mask), reg);
+}
+
+static void setup_pwm_params(struct pwm_device *pwm)
+{
+	write_bits(PWM_CLKSRC_IPG, PWM_CLKSRC_MASK, pwm->membase + PWMCTRL);
+	/* Setup prescaler */
+	write_bits(PWM_PRESCALER(pwm->prescaler),
+				PWM_PRESCALER_MASK, pwm->membase + PWMCTRL); /*| PWMC_REPEAT(3)*/;
+	/* Setup period */
+	writel(PWM_PERIOD(pwm->period_reg), pwm->membase + PWMPERIOD);
+	/* Setup duty cycle */
+	writel(PWM_SAMPLE((u32)((pwm->period_reg * pwm->duty) / 1000)),
+				pwm->membase + PWMSAMPLE);
+}
+
+
+/* common setup function whenever something was changed */
+static void setup_pwm_unit(struct pwm_device *pwm)
+{
+	if (pwm->active) {
+		/* Activate PWM */
+		write_bits(PWM_EN, PWM_EN, pwm->membase + PWMCTRL);
+		setup_pwm_params(pwm);
+	} else {
+		/* De-activate */
+		write_bits(~PWM_EN, PWM_EN, pwm->membase + PWMCTRL);
+	}
+}
+
+/* timer */
+static int create_timer(pwm_timer_t *timer)
+{
+	init_timer(timer->timer_blk_ptr);
+	timer->timer_blk_ptr->function = timer->timer_func;
+
+	return 0;
+}
+
+#if 0
+static int start_timer(pwm_timer_t *timer)
+{
+	timer->timer_blk_ptr->expires = jiffies + timer->period;
+	timer->stop_flag = 0;
+
+	add_timer((struct timer_list *)timer->timer_blk_ptr);
+
+	return 0;
+}
+#endif
+
+static int stop_timer(pwm_timer_t *timer)
+{
+	timer->stop_flag = 1;
+	del_timer_sync((struct timer_list *)timer->timer_blk_ptr);
+
+	return 0;
+}
+
+static void stop_pwm(struct pwm_device *pwm)
+{
+	write_bits(~PWM_IRQEN, PWM_IRQEN, pwm->membase + PWMIRQ);
+	write_bits(~PWM_EN, PWM_EN, pwm->membase + PWMCTRL);
+
+	pwm->sampleValue = 0;
+	if (pwm->mode == PWM_TONE_MODE)
+		stop_timer(&pwm->timer);
+
+	/* Can release file now */
+	wake_up_interruptible(&pwm->exit_wait);
+
+	pr_debug("data completed.\n");
+	pr_debug("PWMC = 0x%8x\n", readl(pwm->membase + PWMCTRL));
+}
+
+static void pwmIntFunc(unsigned long unused)
+{
+//    u32	period;
+
+	pr_debug("pwm sam int\n");
+
+//     if (gWriteCnt > 0)
+//     {
+//         PK("<1>PWMS = 0x%4x\n", (u16)_reg_PWM_PWMS);
+// 
+//         // 96M/128/2/period
+//         period = *writeBufPtr16++;
+// 
+//         if(period > 0)
+// //			PWMP = 96000000/128/12/2/period; //96000000/128/2*11
+//             PWMP = 66000000/128/2/period; //96000000/128/2*11
+//         PK("<1>PWMP = 0x%4x\n", (u16)PWMP);
+//         PK("<1>PWMCNT = 0x%4x\n", (u16)PWMCNT);
+// 
+//         StartTimer(&timer);
+// 
+//         gWriteCnt--;
+//     }
+//     else
+//         StopPwm();
+
+}
+
+static int init_pwm(struct pwm_device *pwm)
+{
+	/* Software reset */
+	write_bits(PWM_SWR, PWM_SWR, pwm->membase + PWMCTRL);
+	udelay(10);
+	/* Activate & de-activate PWM (seems to be necessary after a reset) */
+	write_bits(PWM_EN, PWM_EN, pwm->membase + PWMCTRL);
+	write_bits(~PWM_EN, PWM_EN, pwm->membase + PWMCTRL);
+
+	return 1;
+}
+
+
+/* /DEV INTERFACE */
+
+int pwm_release(struct inode * inode, struct file * filp)
+{
+	struct pwm_device *pwm = dev_table[iminor(inode)];
+
+	/* wait unit gWriteCnt == 0 */
+	interruptible_sleep_on(&pwm->exit_wait);
+	if (pwm->mode == PWM_PLAY_MODE) {
+		/* disable IRQ */
+		write_bits(~PWM_IRQEN, PWM_IRQEN, pwm->membase + PWMIRQ);
+	}	
+	write_bits(~PWM_EN, PWM_EN, pwm->membase + PWMCTRL);
+
+	if (pwm->circ_buf.buf) {
+		kfree(pwm->circ_buf.buf);
+		pwm->circ_buf.buf = 0;
+	}
+	printk(DRIVER_NAME " released, 4 bytes FIFO usage: %d\n", pwm->nbbytes);
+
+	return 0;
+}
+
+int pwm_open(struct inode * inode, struct file * filp)
+{
+	struct pwm_device *pwm = dev_table[iminor(inode)];
+
+	pwm->circ_buf.buf = 0;
+	pwm->dataLen = PWM_DATA_8BIT;
+	pwm->nbbytes = 0;
+	/* Init PWM hardware */
+	init_pwm(pwm);
+	
+	pr_debug(DRIVER_NAME " opened \n");
+
+	return 0;
+}
+
+static int pwm_fasync(int fd, struct file *filp, int mode)
+{
+	pr_debug("in pwm_fasyn ----\n");
+#if 0
+    /* TODO TODO put this data into file private data */
+    int minor = checkDevice( filp->f_dentry->d_inode);
+    if ( minor == - 1)
+    {
+        PK("<1>asp_fasyn:bad device minor\n");
+        return -ENODEV;
+    }
+
+    return( fasync_helper(fd, filp, mode, &ts_fasync) );
+#endif
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+int pwm_ioctl(struct inode * inode, struct file *filp, unsigned int cmd, unsigned long arg)
+#else
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,7,0)
+long pwm_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+#else
+int pwm_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+#endif
+#endif
+{
+	char *str=NULL;
+	int ret = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	struct pwm_device *pwm = dev_table[iminor(inode)];
+#else
+	struct pwm_device *pwm = dev_table[iminor(filp->f_dentry->d_inode)];
+#endif
+	switch (cmd) {
+		/* Set PWM Mode (Tone or Playback) */
+		case PWM_IOC_SMODE:
+		{
+			pwm->mode = arg;
+	
+			if (pwm->mode == PWM_TONE_MODE) {
+				/* create periodic timer when tone mode */
+				pr_debug("PWM Tone Mode.\n");
+				pwm->timer.timer_blk_ptr = &pwm->timer_blk;
+				pwm->timer.timer_func = pwmIntFunc;
+				create_timer(&pwm->timer);
+			} else {
+				pr_debug("PWM Play Mode.\n");
+			}
+		}
+		break;
+
+		/* Set Playback frequency/ouput rate */
+		case PWM_IOC_SFREQ:
+		{
+			/*int clock = get_current_pwm_clk_rate(pwm);*/
+			/* Disable PWM */
+			write_bits(~PWM_EN, PWM_EN, pwm->membase + PWMCTRL);
+
+/*			if(!( (clock >= 16000000)  && (clock<17000000))){
+				printk("audio playback works only with a 16MHz input clock %d!\n", 
+						get_current_pwm_clk_rate(pwm));
+				break;
+			}*/
+			write_bits(PWM_CLKSRC_IPG, PWM_CLKSRC_MASK, pwm->membase + PWMCTRL);
+#if defined(CONFIG_ARCH_MX2) || defined(CONFIG_SOC_IMX27) || defined(CONFIG_ARCH_MX5)
+			write_bits(PWM_PRESCALER(2), PWM_PRESCALER_MASK, pwm->membase + PWMCTRL);
+#else
+			write_bits(PWM_PRESCALER(1), PWM_PRESCALER_MASK, pwm->membase + PWMCTRL);
+#endif
+			switch (arg) {
+				case PWM_SAMPLING_32KHZ:
+					/* REPEAT = 0 => divide by 1 */
+					write_bits(0, PWM_REPEAT_MASK, pwm->membase + PWMCTRL);
+					str = "32Khz";
+				break;
+
+				case PWM_SAMPLING_16KHZ:
+					/* REPEAT = 01 => divide by 2 */
+					write_bits(PWM_REPEAT(1), PWM_REPEAT_MASK, pwm->membase + PWMCTRL);
+					str = "16Khz";
+				break;
+	
+				case PWM_SAMPLING_8KHZ:
+				default:
+					/* REPEAT = 10 => divide by 4*/
+					write_bits(PWM_REPEAT(2), PWM_REPEAT_MASK, pwm->membase + PWMCTRL);
+					str = "8Khz";
+				break;
+			}
+			pr_debug("Sample rate = %s\n", str);
+			pr_debug("ioctl: PWMC = 0x%8x\n", readl(pwm->membase+PWMCTRL));
+		}
+		break;
+
+		/* Set samples length (8 or 16 bits) */
+		case PWM_IOC_SDATALEN:
+		{
+			pwm->dataLen = arg;
+			if (arg == PWM_DATA_8BIT) {
+				writel(0xfe, pwm->membase + PWMPERIOD);
+				str = "8bit";
+			} else { /* if(arg == PWM_DATA_16BIT) */
+				writel(0xfffe, pwm->membase + PWMPERIOD);
+				str = "16bit";
+			}
+			pr_debug("Data Length = %s\n", str);
+		}
+		break;
+
+		case PWM_IOC_SSAMPLE:
+			pwm->sampleValue = arg;
+		break;
+
+		case PWM_IOC_SPERIOD:
+			if (pwm->mode == PWM_TONE_MODE) {
+				pr_debug("PWM period = %d\n", (int)arg);
+				pwm->timer.period = arg/12;
+			}
+		break;
+
+		case PWM_IOC_STOP:
+			stop_pwm(pwm);
+		break;
+
+		case PWM_IOC_SWAPDATA:
+			if (arg & PWM_SWAP_HCTRL) { /* Halfword FIFO data swapping */
+				write_bits(PWM_REPEAT(1), PWM_REPEAT_MASK, pwm->membase + PWMCTRL);
+				write_bits(PWM_HCTR, PWM_HCTR, pwm->membase + PWMCTRL);
+			} else {
+				write_bits(~PWM_HCTR, PWM_HCTR, pwm->membase + PWMCTRL);
+			}
+		
+			if (arg & PWM_SWAP_BCTRL) { /* Byte FIFO data swapping */
+				write_bits(PWM_BCTR, PWM_BCTR, pwm->membase + PWMCTRL);
+			} else {
+				write_bits(~PWM_BCTR, PWM_BCTR, pwm->membase + PWMCTRL);
+			}
+		break;
+
+		default:
+			printk(DRIVER_NAME ": unkown IOCTL\n");
+		break;
+	}
+
+	return ret;
+}
+
+ssize_t pwm_read(struct file * filp, char * buf, size_t count, loff_t * l)
+{
+	int ret = 0;
+	struct pwm_device *pwm = dev_table[iminor(filp->f_dentry->d_inode)];
+
+	if (readl(pwm->membase+PWMIRQ) & PWM_IRQEN)
+		ret = 1; /* no data */
+	else
+		ret = 0; /* processing data */
+
+	return ret;
+}
+
+static ssize_t pwm_write( struct file *filp, const char *buf, size_t count, loff_t *f_pos )
+{
+	int ret = 0;
+	int remaining_space = 0;
+	struct pwm_device *pwm = dev_table[iminor(filp->f_dentry->d_inode)];
+	struct sound_circ_buf *circ = &pwm->circ_buf;
+
+	if (count > MAX_SOUND_BUFFER_SIZE)
+		count = MAX_SOUND_BUFFER_SIZE;
+	/* First time, allocate the double buffer */
+	if (!circ->buf) {
+		circ->buf = kmalloc(MAX_SOUND_BUFFER_SIZE*2, GFP_KERNEL);
+		if (!circ->buf) {
+			goto out;
+		} else {
+			/* Initialize circular buffer */
+			circ->read  = 0;
+			circ->write = 0;
+			circ->size  = MAX_SOUND_BUFFER_SIZE*2;
+		}
+	}
+	pr_debug("write %x, %x, %x\n", readl(pwm->membase + PWMCTRL), readl(pwm->membase + PWMIRQ), readl(pwm->membase + PWMSTATUS));
+
+	/* If there is enough space at the end of the buffer for all data in one copy, do it */
+	remaining_space = circ->size - circ->write;
+	pr_debug("Remaining space to end: %d, must write: %d \n", remaining_space, count);
+	if (remaining_space >= count) {
+		// Get data from UserSpace
+		if (copy_from_user(circ->buf + circ->write, buf, count)) {
+			ret = -EFAULT;
+			goto out;
+		}
+		increase_circbuf(&pwm->circ_buf, count);
+	/* if not enough space, then */
+	} else {
+		/* Do it in 2 times */
+		if (copy_from_user(circ->buf + circ->write, buf, remaining_space)) {
+			ret = -EFAULT; goto out;
+		}
+		increase_circbuf(&pwm->circ_buf, remaining_space);
+		if (copy_from_user(circ->buf + circ->write, buf, count - remaining_space)) {
+			ret = -EFAULT; goto out;
+		}
+		increase_circbuf(&pwm->circ_buf, count - remaining_space);
+	}
+
+	if (pwm->mode == PWM_PLAY_MODE) {
+		/* Enable IRQ */
+		write_bits(PWM_IRQEN, PWM_IRQEN, pwm->membase + PWMIRQ);
+	} else {
+		writel(pwm->sampleValue, pwm->membase + PWMSAMPLE);
+		/* set prescaler to the max */
+		write_bits(PWM_PRESCALER(0xffff), PWM_PRESCALER_MASK, pwm->membase + PWMCTRL);
+		/*writeBufPtr16 = (u16*)gpWriteBuf;
+		gWriteCnt /= 2; //input size is 8bit size, need /2 to get 16bit size
+		StartTimer( &timer );*/
+	}
+	writel(0x00000000, pwm->membase + PWMSAMPLE);
+	write_bits(PWM_FWM_3, PWM_FWM, pwm->membase + PWMCTRL);
+	/* Enable PWM */
+	write_bits(PWM_EN, PWM_EN, pwm->membase + PWMCTRL);
+
+	/* Calculate how much space is left in buffer */
+	remaining_space = CIRC_SPACE(circ->write, circ->read, circ->size);
+	pr_debug("Space left: %d\n", remaining_space);
+	if (remaining_space < count) {
+		/* Pauses user app until interrupt handler has consumed some data */
+		interruptible_sleep_on(&pwm->write_wait);
+	}
+
+out:
+	pr_debug("out pwm_write PWMC = 0x%8x ----\n", readl(pwm->membase + PWMCTRL));
+	return count;
+}
+
+struct file_operations pwm_fops = {
+	open:           pwm_open,
+	release:        pwm_release,
+	read:           pwm_read,
+	write:          pwm_write,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	ioctl:		pwm_ioctl,
+#else
+	unlocked_ioctl:	pwm_ioctl,
+#endif
+	fasync:         pwm_fasync
+};
+
+/* END OF /DEV INTERFACE */
+
+
+/* /sys interface: */
+
+static ssize_t pwm_show_duty(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret_size = 0;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	ret_size = sprintf(buf, "%u", pwm->duty);
+
+	return ret_size;
+}
+
+/*
+ * Duty value can be 0 ... 1000. Without floating point you can take
+ * one position after decimal point into account. The internal counters
+ * supports 10 bit resolution, so it makes sense to support such a thing
+ * like 66.6% or 33.3% (given as 666 and 333 values)
+ */
+static ssize_t pwm_store_duty(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	long value;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	value = simple_strtol(buf, NULL, 10);
+	if ((value < 1) || (value > 999))
+		return -EIO;
+
+	pwm->duty = (unsigned)value;
+	setup_pwm_unit(pwm);
+
+	return size;
+}
+
+static ssize_t pwm_show_period(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret_size = 0;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	if (pwm->frequency)
+		ret_size = sprintf(buf, "%d", (u32) 1000000/(pwm->frequency));
+	else
+		ret_size = sprintf(buf, "0");
+
+	return ret_size;
+}
+
+static ssize_t pwm_store_period(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	long value;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+	
+	value = simple_strtol(buf, NULL, 10); /* in us */
+	if ((value < (1000000/get_pwm_max_freq(pwm))) || (value > (1000000/get_pwm_min_freq(pwm))))
+		return -EIO;
+
+	compute_pwm_params(1000000/value, pwm);
+	setup_pwm_unit(pwm);
+
+	return size;
+}
+
+static ssize_t pwm_show_frequency(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret_size = 0;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	ret_size = sprintf(buf, "%d", pwm->frequency);
+
+	return ret_size;
+}
+
+/*
+ * Given value (in Hertz) should be between 2 and 100k
+ */
+
+static ssize_t pwm_store_frequency(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	long value;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	value = simple_strtol(buf, NULL, 10);
+	if ((value < get_pwm_min_freq(pwm)) || (value > get_pwm_max_freq(pwm)))
+		return -EIO;
+
+	compute_pwm_params(value, pwm);
+	setup_pwm_unit(pwm);
+
+	return size;
+}
+
+static ssize_t pwm_show_state(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret_size = 0;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	ret_size = sprintf(buf, "%d", pwm->active);
+
+	return ret_size;
+}
+
+static ssize_t pwm_store_state(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	long value;
+	struct pwm_device *pwm = dev_get_drvdata(dev);
+
+	value = simple_strtol(buf, NULL, 10);
+	if (value != 0)
+		pwm->active = 1;
+	else
+		pwm->active = 0;
+
+	setup_pwm_unit(pwm);
+
+	return size;
+}
+
+/* dev_attr_duty  /class/pwm/pwmX/duty */
+static DEVICE_ATTR(duty, S_IWUSR | S_IRUGO, pwm_show_duty, pwm_store_duty);
+/* dev_attr_period  /sys/class/pwm/pwmX/period */
+static DEVICE_ATTR(period, S_IWUSR | S_IRUGO, pwm_show_period, pwm_store_period);
+/* dev_attr_frequency  /sys/class/pwm/pwmX/frequency */
+static DEVICE_ATTR(frequency, S_IWUSR | S_IRUGO, pwm_show_frequency, pwm_store_frequency);
+/* dev_attr_active  /sys/class/pwm/pwmX/active */
+static DEVICE_ATTR(active, S_IWUSR | S_IRUGO, pwm_show_state, pwm_store_state);
+
+
+/*
+ *  PWM interrupt handler (used in Play Mode only)
+ */
+static irqreturn_t pwm_interrupt(int irq, void *dev_id)
+{
+#if !defined(CONFIG_ARCH_MX2) && !defined(CONFIG_SOC_IMX27) && !defined(CONFIG_ARCH_MX5)
+	u32 status = 0;
+#endif
+	int remaining = 0;
+	struct pwm_device *pwm = (struct pwm_device *) dev_id;
+
+	/* Acknowledge interrupt */
+#if defined(CONFIG_ARCH_MX2) || defined(CONFIG_SOC_IMX27) || defined(CONFIG_ARCH_MX5)
+	write_bits(PWM_FIFO_EMPTY, PWM_FIFO_EMPTY, pwm->membase + PWMSTATUS);
+#else
+	status = readl(pwm->membase + PWMSTATUS);
+#endif
+	remaining = CIRC_CNT(pwm->circ_buf.write, pwm->circ_buf.read, pwm->circ_buf.size);
+	if (remaining <= 1024 && remaining > 1021) { /* TODO make it better (I think a test each consumed sample is the only accurate solution */
+		/* Can accept new data now */
+		wake_up_interruptible(&pwm->write_wait);
+	}
+
+	/* End of sound buffer */
+	if (remaining < 3) {
+		if (pwm->dataLen == PWM_DATA_8BIT) {
+			while (remaining) {
+				writel((u32)(get_byte_from_circbuf(&pwm->circ_buf)), pwm->membase + PWMSAMPLE);
+				/*pr_debug("(%d) pwm_int: PWMS = 0x%8x\n", gWriteCnt, PWMS);*/
+				remaining--;
+			}
+		} else { /* PWM_DATA_16BIT) */
+			while (remaining) {
+				writel((u32)(get_word_from_circbuf(&pwm->circ_buf)), pwm->membase + PWMSAMPLE);
+				/*pr_debug("(%d) pwm_int: PWMS = 0x%8x\n", gWriteCnt, PWMS); */
+				remaining--;
+			}
+		}
+		stop_pwm(pwm);
+		goto end;
+	}
+
+	/* Put sound samples in FIFO */
+	if (pwm->dataLen == PWM_DATA_8BIT) {
+		writel((u32)(get_byte_from_circbuf(&pwm->circ_buf)), pwm->membase + PWMSAMPLE);
+		writel((u32)(get_byte_from_circbuf(&pwm->circ_buf)), pwm->membase + PWMSAMPLE);
+		writel((u32)(get_byte_from_circbuf(&pwm->circ_buf)), pwm->membase + PWMSAMPLE);
+#if defined(CONFIG_ARCH_MX2) || defined(CONFIG_SOC_IMX27) || defined(CONFIG_ARCH_MX5)
+		if ((readl(pwm->membase + PWMSTATUS) & PWM_FIFOAV) == 3) { /* TODO: verify if needed */
+			writel((u32)(get_byte_from_circbuf(&pwm->circ_buf)), pwm->membase + PWMSAMPLE);
+		}
+#else
+		if ((readl(pwm->membase + PWMSTATUS) & PWM_FIFOAV) > 0) { /* TODO: verify if needed */
+			writel((u32)(get_byte_from_circbuf(&pwm->circ_buf)), pwm->membase + PWMSAMPLE);
+		}
+#endif
+	} else { /* PWM_DATA_16BIT) */
+		/* TODO: put good value in PWMC_BCTR to auto swap bytes if needed (do it at write or ioctl) */
+		writel((u32)(get_word_from_circbuf(&pwm->circ_buf)), pwm->membase + PWMSAMPLE);
+		writel((u32)(get_word_from_circbuf(&pwm->circ_buf)), pwm->membase + PWMSAMPLE);
+		writel((u32)(get_word_from_circbuf(&pwm->circ_buf)), pwm->membase + PWMSAMPLE);
+		if ((readl(pwm->membase + PWMSTATUS) & PWM_FIFOAV) > 0) { /* TODO: verify if needed */
+			writel((u32)(get_word_from_circbuf(&pwm->circ_buf)), pwm->membase + PWMSAMPLE);
+			pwm->nbbytes++;
+		}
+	}
+
+end:
+	return IRQ_HANDLED;
+}
+
+static int imx_pwm_drv_probe(struct platform_device *pdev)
+{
+	int err = -ENODEV;
+	struct resource *res;
+	struct pwm_device *pwm;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	struct imx_pwm_platform_data *pdata = pdev->dev.platform_data;
+#endif
+
+	if (pdev->id >= PWM_MAX_DEV)
+		dev_err(&pdev->dev, "failed. Unknown module. Remember that this device only supports %d PWM\n", PWM_MAX_DEV);
+
+	if (dev_table[pdev->id] != NULL) {
+		dev_err(&pdev->dev, "already in use\n");
+		return -ENODEV;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	if (!pdata) {
+		dev_err(&pdev->dev, "platform data not supplied\n");
+		return -ENOENT;
+	}
+#endif
+
+	pwm = kmalloc(sizeof(struct pwm_device), GFP_KERNEL);
+	if (!pwm) {
+		return -ENOMEM;
+	}
+	pwm->active = 0;
+	pwm->duty = 500; /* = 50.O% */
+	pwm->frequency = 0;
+	platform_set_drvdata(pdev, pwm);
+	dev_table[pdev->id] = pwm;
+
+	pwm->irq = platform_get_irq(pdev, 0);
+	if (pwm->irq < 0) {
+		dev_err(&pdev->dev, "no interrupt defined\n");
+		err = -ENOENT;
+		goto error_malloc;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "unable to get mem ressource\n");
+		err = -ENOENT;
+		goto error_malloc;
+	}
+
+	if (unlikely(!request_mem_region(res->start, res->end - res->start + 1, DRIVER_NAME))) {
+		dev_err(&pdev->dev, "mem region busy\n");
+		err = -EBUSY;
+		goto error_malloc;
+	}
+	pwm->membase = ioremap(res->start, resource_size(res));
+        if (!pwm->membase) {
+                err = -ENOMEM;
+                goto error_memreg;
+        }
+
+#ifndef CONFIG_ARCH_MX5
+	/* Register our char device */
+	err = register_chrdev(gMajor, DRIVER_NAME, &pwm_fops);
+	if (err < 0) {
+		dev_err(&pdev->dev, "unable to register char driver\n");
+		goto error_iounmap;
+	}
+	/* Dynamic Major allocation */
+	if (gMajor == 0) {
+		gMajor = err;
+		dev_dbg(&pdev->dev, "major = %d\n", gMajor);
+	}
+#endif
+	err = request_irq(pwm->irq, pwm_interrupt, IRQF_DISABLED, DRIVER_NAME, pwm);
+	if (err) {
+		dev_err(&pdev->dev, "can't reserve irq=%d\n", pwm->irq);
+		goto error_chrdev;
+	}
+
+	/* init wait queue */
+	init_waitqueue_head(&pwm->write_wait);
+	init_waitqueue_head(&pwm->exit_wait);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	/* init gpio */
+	if (pdata->init)
+		pdata->init();
+#endif
+
+	/* Create /dev */
+	pwm->dev = device_create(pwm_class, NULL, MKDEV(gMajor, pdev->id), NULL, "pwm%i", pdev->id);
+	if (IS_ERR(pwm->dev)) {
+		err = PTR_ERR(pwm->dev);
+		dev_err(&pdev->dev, "can't create device\n");
+		goto error_platform_init;
+        }
+	dev_set_drvdata(pwm->dev, pwm);
+
+	/* Register the attributes */
+	err |= device_create_file(pwm->dev, &dev_attr_duty);
+	if (unlikely(err))
+		goto error_dev_create;
+	err |= device_create_file(pwm->dev, &dev_attr_period);
+	if (unlikely(err)) {
+		dev_err(&pdev->dev, "can't create /sys/.../period\n");
+		goto error_file;
+	}
+	err |= device_create_file(pwm->dev, &dev_attr_frequency);
+	if (unlikely(err)) {
+		dev_err(&pdev->dev, "can't create /sys/.../frequency\n");
+		goto error_file;
+	}
+	err |= device_create_file(pwm->dev, &dev_attr_active);
+	if (unlikely(err)) {
+		dev_err(&pdev->dev, "can't create /sys/.../active\n");
+		goto error_file;
+	}
+
+#if defined(CONFIG_ARCH_MX2) || defined(CONFIG_SOC_IMX27) || defined(CONFIG_ARCH_MX5)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	pwm->clk = clk_get(&pdev->dev, "pwm_clk");
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+	pwm->clk = clk_get(&pdev->dev, "pwm");
+#else
+	pwm->clk = clk_get(&pdev->dev, "per");
+#endif
+	if (IS_ERR(pwm->clk)) {
+		dev_err(&pdev->dev, "can't get clock\n");
+		goto error_file;
+	}	
+	clk_enable(pwm->clk);
+#endif
+	/* init PWM hardware module */
+	init_pwm(pwm);
+
+	dev_info(&pdev->dev, "initialized\n");
+	return 0;
+
+error_file:
+	unregister_sys_file(pwm);
+error_dev_create:
+	device_destroy(pwm_class, MKDEV(gMajor, pdev->id));
+error_platform_init:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	if (pdata->exit)
+		pdata->exit();
+#endif
+	free_irq(pwm->irq, pwm);
+error_chrdev:
+	unregister_chrdev(gMajor, DRIVER_NAME);
+#ifndef CONFIG_ARCH_MX5
+error_iounmap:
+#endif
+        iounmap(pwm->membase);
+error_memreg:
+	release_mem_region(res->start, resource_size(res));
+error_malloc:
+	kfree(pwm);
+
+	return err;
+}
+
+static inline void unregister_sys_file(struct pwm_device *pwm)
+{
+	/* Unregister /sys attributes */
+	device_remove_file(pwm->dev, &dev_attr_active);
+	device_remove_file(pwm->dev, &dev_attr_period);
+	device_remove_file(pwm->dev, &dev_attr_frequency);
+	device_remove_file(pwm->dev, &dev_attr_duty);
+}
+
+static int imx_pwm_drv_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	struct pwm_device *pwm = (struct pwm_device*)pdev->dev.driver_data;
+	struct imx_pwm_platform_data *pdata = pdev->dev.platform_data;
+#else
+	struct pwm_device *pwm = (struct pwm_device*)(dev_get_drvdata(&pdev->dev));
+#endif
+
+	unregister_sys_file(pwm);
+	device_destroy(pwm_class, MKDEV(gMajor, pdev->id));
+	free_irq(pwm->irq, pwm);
+#ifndef CONFIG_ARCH_MX5
+	unregister_chrdev(gMajor, DRIVER_NAME);
+#endif
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+	kfree(pwm);
+	dev_table[pdev->id] = NULL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	if (pdata->exit())
+		pdata->exit();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int imx_pwm_drv_suspend(struct platform_device *pdev, pm_message_t state)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	struct pwm_device *pwm = (struct pwm_device*)pdev->dev.driver_data;
+	struct imx_pwm_platform_data *pdata = pdev->dev.platform_data;
+#else
+	struct pwm_device *pwm = (struct pwm_device*)(dev_get_drvdata(&pdev->dev));
+#endif
+
+	clk_disable(pwm->clk);
+	dev_dbg(&pdev->dev, "suspended\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	if (pdata->exit())
+		pdata->exit();
+#endif
+
+	return 0;
+}
+
+static int imx_pwm_drv_resume(struct platform_device *pdev)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	struct pwm_device *pwm = (struct pwm_device*)pdev->dev.driver_data;
+	struct imx_pwm_platform_data *pdata = pdev->dev.platform_data;
+#else
+	struct pwm_device *pwm = (struct pwm_device*)(dev_get_drvdata(&pdev->dev));
+#endif
+
+	clk_enable(pwm->clk);
+	dev_dbg(&pdev->dev, "resumed\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	if (pdata->init())
+		pdata->init();
+#endif
+
+	return 0;
+}
+#else
+
+# define imx_pwm_drv_suspend NULL
+# define imx_pwm_drv_resume NULL
+
+#endif /* CONFIG_PM */
+
+static struct platform_driver imx_pwm_driver = {
+	.probe      = imx_pwm_drv_probe,
+	.remove     = imx_pwm_drv_remove,
+	.suspend    = imx_pwm_drv_suspend,
+	.resume     = imx_pwm_drv_resume,
+	.driver     = {
+		.name   = DRIVER_NAME,
+	},
+};
+
+static int __init imx_pwm_init(void)
+{
+	printk("i.MX PWM driver v" DRIVER_VERSION "\n");
+
+	pwm_class = class_create(THIS_MODULE, "pwm");
+	if (IS_ERR(pwm_class)) {
+		return PTR_ERR(pwm_class);
+	}
+
+	return platform_driver_register(&imx_pwm_driver);
+}
+
+static void __exit imx_pwm_exit(void)
+{
+	int i;
+
+	platform_driver_unregister(&imx_pwm_driver);
+	class_destroy(pwm_class);
+	for (i=0; i<PWM_MAX_DEV; i++)
+		dev_table[i] = NULL;
+
+	printk(DRIVER_NAME " successfully unloaded\n");
+}
+
+module_init(imx_pwm_init);
+module_exit(imx_pwm_exit);
+MODULE_AUTHOR("Julien Boibessot & Sebastien Royen, inspired by a lot of other PWM linux-3.13/drivers");
+MODULE_DESCRIPTION("i.MX PWM driver");
+MODULE_LICENSE("GPL");
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/pwm.h linux-3.13/drivers/armadeus/pwm/pwm.h
--- linux-3.13/drivers/armadeus/pwm/pwm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/pwm.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Copyright (C) 2002 Freescale Semiconductors HK Ltd
+ *
+ */
+
+#ifndef _PWM_DEF_H_
+#define _PWM_DEF_H_
+
+#include <linux/ioctl.h>
+
+#define PWM_SAMPLING_8KHZ	8000
+#define PWM_SAMPLING_16KHZ	16000
+#define PWM_SAMPLING_32KHZ	32000
+
+#define PWM_DATA_8BIT		8
+#define PWM_DATA_16BIT		16
+
+#define PWM_SWAP_HCTRL		((unsigned long)0x01<<18) 
+#define PWM_SWAP_BCTRL		((unsigned long)0x01<<17) 
+
+#define	PWM_IOC_MAGIC		'p'
+#define	PWM_IOC_SFREQ		_IO(PWM_IOC_MAGIC, 0)
+#define	PWM_IOC_SDATALEN	_IO(PWM_IOC_MAGIC, 1)
+#define	PWM_IOC_SMODE		_IO(PWM_IOC_MAGIC, 2)
+#define	PWM_IOC_SSAMPLE		_IO(PWM_IOC_MAGIC, 3)
+#define	PWM_IOC_SPERIOD		_IO(PWM_IOC_MAGIC, 4)
+#define PWM_IOC_STOP		_IO(PWM_IOC_MAGIC, 5)
+#define PWM_IOC_SWAPDATA	_IO(PWM_IOC_MAGIC, 6) 
+
+#define	PWM_PLAY_MODE		1
+#define	PWM_TONE_MODE		2
+
+struct imx_pwm_platform_data {
+    int (*init)(void);
+    int (*exit)(void);
+};
+
+#endif	/* _PWM_DEF_H_*/
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/test/Chimes.raw linux-3.13/drivers/armadeus/pwm/test/Chimes.raw
--- linux-3.13/drivers/armadeus/pwm/test/Chimes.raw	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/test/Chimes.raw	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1 @@
+~~~}~}{~{}y|~xw~|z|x|vw|}~{yv{v|x|}vw}|x{w{vz{}zyx{w}z~~|wy|x|y}w{~{yzy{w}}|{xz|x}~}|~~x{|y{|~}x}~{{y}~|x|~{|{}~x}~~y~{|{{~|{~}}vwxz|wxxzzywy}zxzwy|{y|~w{{}w~{t~x}w}zt|{zxx~xzvy{|yyvx~}y}~x~~~zwyv}zx{y~y{y|}}w{~x~}w{x}~}v~~z~xzy{}zw|z}y{{~}|w|||}||w}}z}}y|~z~|w}}}}{z}z~{{xz|zzwz{|||{}w{{~xxxxz~|y~~z~}{~zyvyy}xwzy~}}{yz{}y~xuyx~|~z{~x{}~xy}{|}z{}}{~~y{}z~}}|x|||z||~|z~yz{x~x}x~{~}{~|~~~}}||x~|}~|{|w~~}z~|u~{}~|{vy~z~}x~~z~~y|{{|{w|{yz|}}x{|~~~}}~z|~}{z|z~~y}yy}{z}|y~~yy~z{|xzwx|~z}}|vywwzw{|xyxszw{}xwzuyyzyw~~vy||z~zx~~sx|{xt{uv|}u}v{wt|{~tvxt}~w{~vv}pw~}}~}tx|szzyuw|wv}{z~|vv}wx{{}}~xvz}xuz}z~|~zw~~uz}{{~w|}{v|~xw~wtx~z~{}{zzuzzx|~~}~~xs{|vv}zy|~|y|{y~~{{~wv|}{~~}zw{}rr|~uy~}}}~yrzzw}{~}~~|w|{ww~{y}~|w{}}}~{y|~|x|~}y{}~|yy||z~}~|~~z~}}}}yy}~~}~{{|}{~}~~|x{~~z|||yzz~|~~|v{~~|zzzy{~}zy~x~}w{}}}y}~|{y{~~}}}{}}z}{}{~|}}x~{|~{|zxz}|}wyx|~~~~s{y{}}}u|x}}~}{v|y|~xuyv~}st}z~~|~xzw|~|~}s}|u|~||{r~uz|~|~}v~{y}~xuyz}{zyzww~}z||{wx}~}y~{w{}zw|{}|z|~ww{~{y~|wz}}|yzxx~||}|~~xx}}~|xx}~xw}zy{y}}{yv|}}|{|xx~yzw}}w~yzz{~~zx|}}y{xyy||vz|}}z|yzz~z~y{}}z~xy{|}zz~}~yy{y{||w|}||~yy{z}|~~zy}|~yx{}|}x{~{|{|}yz~|~|y}|}}{z~~y~}}|{}~}~{{y{~}}|~|z~|y~}y{{z~|}}~}z~}{{|}x|~~|}}y{}zz{{~~|{}}z}}zy~~{~}zy}|z|||}}zwz}~~}|w{~|{~yy~}|}~xx~{}}{~}zy|}|yx{~||~|{{{~|~}zyz|z}{x{~{}}yz}}{|{|~~}{{}z|~~z}}z|~}}~~|z|||~}~{z~{|}~zz|~~~~zx|}{~~z{}{z~~~{{}}}||}z}{||w{~z~~|z||z}~}yy}}}{||{}x~~zx{||}|~{}}y}~}}}zw}~}}}~~y}zz}{||}|{}|y|}~~{|~}}~{}{wz}~{wx~~~|}}{}}|}{|||}zzy~|{~~~}}|y|~{y{}y|{x|~{{||}{}~{xy~{{{z|~xy}}z~zx|}|{~~y|}{|~zz|~}|y|~zw|{x|}{~|y{~~|yz}{z~}|yy{w{~|}}y|~yzy{|}}zyz~~|~|w~v|}y~v}|y{|}}y~x}|v{}zx}xx|{|||u~z||}||y{v{}y}}zv}{||}yzwxu|~x~~yw~y}zzwzwu~{x}vzzx}{x|wx{}{}}~tz|y||z|y|u|}~~u}~}u|{z{{}xx{uyy|yu~{}{|xz}{wx{xuv~z~{zw}zy}zyyy}}x~}z{~}x~xy|~xz}~z~|z|zz~{{vz{~~w~}}y|y{{|{w|~xy~|u~}z{y{{|}x|wz{v~}}{}z|}z~}}y~yz~{xz||{|~{~|z}}{|~w||}~v||y{~}{w}~zzzx|~zu~{}y~}wx~z|zy|}xy~{~z{~~wz~~}w{{~zzv|||y|~{u|yw|{~{zv~z||xxt~yx{{}xwy{}xxvuww|~|yx|~{|w{|uz|xy{zyy}{yv|}uzzvz}~yyy||zx~zw~|xy}||zzzzyyyx~zxz}zy{}xzy{~z|~{zx{~~{}~~{{|z{}{y~~}|yz|}~z}xx{|||||~z|}|~}|}z|~|y|}{}~}}|}y{{~}{}z}~|z{}~}{}~yy|~z{}|}{z{}|{|~|y{~}z{z}|{y{|||}}zyz}}{|{~|{|}~}z|||yy|~z{~~}y{}}|{|}zy{~~}||~}}}{z~}}|{~|z{||}}~~|}~~}y{~|}|}~|~|z|}}|{}~~~}}|{}~{{~}~}~y{}|||~|{}|z~{|||}~{|}{{{}}{|{}{y~~~||||}{{|~~|}}}|}yz}|~|~{}~zz~~}|{}~~}w{}~z~}}~yz||~|}~~}}{z~|~{~{~~z|~}~}{|}|~|{}|||}||zy~~~~|}|}}~~|}~|{}|}|~{z||}}}~~|||~}||{}}~||~||~}}~|}~||}~~||||}~}{|}|}}{~~~}zz|~|||}~}~}{~||{{}}}{{}|||~~|}{z~}~|{}}|z||{{}~~}z{~}~||~|}{y}}{}~~}}}{}}|}|}}}yy~~~}{}~}}{{~|}~|~}|}z|}|}}}~~}|{}~|{}~}||{z~|}~||}~~}}}}}{{}}|}}{z~}{~|}~}}||~~}z{~}|}|{~|z~~|~~~~}||{|}~~z|}~||~z{~{}}~~|}~~|{|}|~}~~z|~|~{{~}}|~}|}~|z~~~}{}z~|}~|~}|~~}}}}|}}}||~||}{~~~{{~||}~}}}}~{|~|}||}~}{}~|}~~}|~~}{z~|}~{~~}y{}~~|||~}}}|~}{~|z~{x{}~~|}}~~}}||}}zz~{z}}}}{|}~|{|~}}{}~zy|~|{|}~}}}|~}}|z~}y{}~~|}~~~}{z~~}{z}~|y}|z|}~}|{~|}|}}~{z}~|{}}~~|||~~}|{}~~{z~~{{~}~}||}~}}{}}z{~}{|~|~~||}~~}|||~}z}~~z|}|~}}}~~||{}~~|y|~~}{~}|}~}~~~}}|{}~~{|}|~}}~||~~}}~~}|{{~}}}|}~}~||}|}~}}{{|}~~|{}~~~|~~|||}~}|{{|~}|}~|}~~~}||}~~|{{}~||}~~|~~|}}|||}{{|}~|||}~}~~}|zz}|{|}~|{{}|}~~~~|z|~|z{}~{{|}~}~~~~{y{~~z{}~||||~~}}}}z{~~}|}}~{{{|}}~~~|{|~~|{|}}{||}~}~~~~~|z{}~|}}}~}}{{~~}}~~~{{}}~}}{}~}|{~~}}}~~~{{||}}~}||||}~}|~~~{{}~~|}}}~|}||~~~|}~~}{|}}~}~}}}|}|~~}}{~~}|}|}}~}||||~}|~}~}|~|~|~}~{}}|~}~}}~~~{}~|~~|}}{}}}}}{}}~|~}{~|~|z}|~}}~}~|}|~}}||~~|}~|~|~~}}~{|}~~{~}{}~}~z}~~~|}|~|}}{~}{~}|}|~~||}}|}{z~}|}|~{|{|}}|}|}~~|}}}}z}~|~}}}|}|~~~{}|~~|~|{~~||}|}~|~~|}}|~~||~}~}~}}|}||~|~}~}~}~~~}{~~~|~}|~|}~~}}||~~~}}~}~}}~}~~|}}}}}}}|~}~~|}~}~}|}~|~}~~}}}~~~|~~}~}}~~}|~}~}}}~~~}}~}}~}~~~}}~}~~}~~~~~}}~}~~|~~~|~~}~}}}}~~}|~~}~~}~~}~}}}}}}~~}~}}}}~~~}}~}}~}~~~~~~}}~}~~}}~~~~~}}~}~~}~}}~}~~}~~}~}}}~~}}~~~~~}}}}~~}}}}~~~}}~~~}~~~}}~~~~~~}~~~}}~~~~~~}}~~~~~|}~~~~}}}~~}}|}~}~}}~~~}}~~}~~}}}~}~~~~~~~}~~}~~~~~}|}~~~~}}~~~~}|}~~}}}}~~~~~~}}~~}~~~~~~}}~~}~~~~~~~~~~~~~~~}}}~~~~}}~~~~~}~~~~~~~~~~~~~~~~~~~~~~~~}~}}~~~~~}}~~~~~~~~~~~~~}~~~}|}~~~~~~~~}}~~}}~~}~~~~~~~~~~}~~~~~~}}~~~~~~~~~~~}~~|}~~~~~~}~~~~}~~}~~}~~}}~~~~~~~}}~}~~}}~~~~~~}~}}~~}~~~~~~~~}}~~~}~~}}~~~~~~~~~~~~}~~~}~~~~~~}}~~~~}~~}~~~~~~~~~}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}~~~~~~~}~~~~~~~~~~~~~~}~~~~~~}~}}~~}}~~~~~~}}~~~~~}~~~~~~~~}~~~}~~}}~~~~~}~~}}~~~~~~~~~}}~~~~}~~~~~}~~}~~~~~~~~~~~~~~}~~~}~~}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\ No newline at end of file
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/test/KDE_Startup_2.raw linux-3.13/drivers/armadeus/pwm/test/KDE_Startup_2.raw
--- linux-3.13/drivers/armadeus/pwm/test/KDE_Startup_2.raw	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/test/KDE_Startup_2.raw	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1 @@
+~|}{wy}~~}}wi`gwwy}wsqsvxustvvpkq~zridhu|~~{{wx~}}yz~usqmqyyttvxwwy}yqu|rpvz||}{y||wx~uprtzxqpsx}{x{}{y{{upmpwzz{~~ytv}~|toqwxwyzz|}{}yuwz~{wwz~~||~~~ytqswz|}wsvz|{{~~~~}~vqruwy{|}|vuwz|||}}}~wrpswyyy|~}~{ww|}}|xx|}}~}xvz}}~xrqsvwwy{}}|}{ursvvvx{}~~~xstx{|}~}~wrruwwx{|}}}~}usvyz{~|z{}wvxzz|~ysrvxwxy{|}}}~wqpsvwy{~|vsuxyz||}}|}~upptvvwy|}}}~zvw{~zy||xz||{|}~~}}~|vrsvxy{~}wssvyyz{{{{|~yrqtvwwy|}~~ztqtwxy|~~}|~yuwz|}~|}}|~yusuxyy{{{{{|~}vrqssstuuvwx{~{vuw{}~|vqpqsssuwxyz|}xvy|}~~|wuvwvvwyz{{}~ytrtvwx{}}|{zy{}~}zwuuwxyz{||}~}xuuvwwvvvuuwz|}xvvyz{}|wtvy{|~~}|zwttuuttuwwyzz|}~~~}zxvvvvvwxyzz{}|ywvwwvxzzzzz{|~~}{xvuwz|}|zxxxyz{zzz{{{}~~|zxwvwxvttuuvwxz|}~|ywvwxyyz|~|xutstvvwyyyyyyyz}~~}{yxwvuuuuwz}}||zyxyz{||}~~{wvvvvvwwvvvwxyyzywusqqtwz}~~~~}{ywvtrsrrrsuwz|}{zxuttvxz|}~}{}yswxru|smpwzzxtokoythfp|{oden|ypjkr}wnls~xqot~}rjhlv|tkjr}~z||usz|vx~ww|{slkqvxyvqkinw~~wqpsxzxwtppw}wux}}ztrw}}xrlkqy}~zskgjs{~|xsnns|~yy}{|~zwyvpotz}~{wvy~xohglrvxwtpory~xtrtx{}|xutv|}wux{|{wqljmsz~}ytpoty}~~{wuw}~~{uppsx{|zurqsy~~yqjikptvvrnnrz{uqruy{}|zxy~{tppruwuqnnpv||wqpsvxyyxvsty|z~}}~ytqqsuwyzxvwz}~zvpjilquvusporx~|wrqsv{|yy{{snnoppppnllpuyyxvtrsuwxyxwxz~~zxy{{}}zwtrtwxwtokjlorttsqprvy{zwsnmptwy{zwtux||vrqsvyzxursv|~wrprtwz{{yxz}}{|{xwx{~~zurtwz||zusux{{|{zyxy~~zxy{}~~wpmmnpstspmklnopqoligimprrqppqv~~ywz}zyz{|}zwtqquxzytpmmotwwuroljkloqpnlnqsuutpljlpuwvsnkjmquvurpoorvxyvrmlnty~~|{~}~}yyyyzxtnheglpuwuqkgfgkmnnmmnorw|~}zxxz}}|~~}~~~}zwvuuvwwvtpmklosvwtqnosx{}{vqopv~|yxy{|~|xvwz}|vrqrtvwwspnoquz}}{wsrswyyxuspqtvxxtonnnnoppnlihhikmoqqrttrqpnmosy{wusqponnnoruvsrpljhijllklnoqtw{}{yyyyzzyxvssx}{vsrqqqrstttuwxwvrmmnnquwusrrtvxyyxyz}unmrz}vokkoqmgb^`ipplhddhmnmnopruutttttwtpsxxtosn`_dmsztjkrtomlgcdipzypoxtrw{{wuty|ulggjjhnrqrstvwvw{ztkb^^billptvz{pigfhkkjmrxrhfnv{~yvsppv}yvz}~yojkpwytldZV[bhkmnllooopqplkkhjs{zrlkqwzyxvvuvuoidchpttsqonqplhc_agpy~wv|{yy||yvwxy|}wqmjgghfddhltzytoh`]`fjouwwwuqoqtwz|zyy{~rf__envyzxtqpokhhgglpqrsuvwwwvvwy}yx|wqlkoqppqqrtsoliggjlllmopppkfb_`fnv{}}|{wpklnoprsqnmmquuojgfglqttqkhjotx~~{yy{~|}~{wwwy}~xmd][\bipspljkjgegihgijmrvxyxuqonptvvvurpqsvxy{{zzyuplijnqmihdbcgkoqqqsuwx{{|~}upnoprrpoooqqqolhecdgiihfcdgjmrw{|{ywvvw{}{wsqppqsrnljhjmnlkjjkjgegkpuy{||ztonoqty~zxwvtsqonmnqqqsttuvwuqkhhiiijkiebcfikmorstsstuvvtqnmpv{|zwtohddeeegknpppqqqqqsttvy|}}|}~}}~|}}}|yvrlhikljgfhggggedefiiggimqsuvvusqonkkntz{xwwwwuvxwsnllmmmmjc__acegilmnooprtwz}|yyyxyzxtqonquvurnkigdddeffefggjnnlmnnnooqtuusqppqstrqqqqtspmkhhijhhijmoljklmnnmnpquwx{~|wtqqsssstuuqprsrqomllkjifddddefdehjlmkmpqrttsux{|{xtqooppnljgfeehkmnoonnnotwvtutsttv|}}~{xursvvrmjihikmmkfccccdfijihhjllmpsqnlkkgcciqvxz|}|zvrrssqibaaadfhgcbcflqrrpnnsz{urnhehpwzzvqmnu{}si`XX`kuzyvvuu{~}}vporqopruvuv{|{zvrqqnnpojc^^bhlkgb`bfkmjfcbbbdipy~|yvw|zutvy{xria]^bgklje_\ZZ^ba__aba_aglmligilnnlhb__aa_^]]_fmpqokhjmnoprrrtw{wpkfcdeeeggffd`^\\^beec]Y\bioqolihilopqqpmhfhlry~|xwy{}zsnjjlorqnjgedddegggjnnlkknrw{~}xvvy~|xttx{{zwrpnifgfeintvvusqnkjjhffhmooqruuspnmmpruwvnd`adgihd_[\`aa`_^[ZZ]`djptwwxy{~upoorwwtpmkkkiea]YX[^bedb_]]]_`befeffcbekoqrrssv|~{ywusqomotxzzvqlhikkihea_^`ejmnoooprsv{}ysnnopomhd`_`cdda__aehkkjg`[ZXTU`jmooqofdpywninldflpojijjjkia\`jkd`bfghqwxxwy||{~}ytojhgefhmqqpolihhhfdb`\[]acegijigfgikmnmkifejquspljjjkoqnieb_][[^bgihjklorttsrrtzztoljjlnpqokigecbbcca`aaabdfjjghlnprsttroomiedegknqpomkjlmhca]YXZ\bfggjkjhghjklmoqtx~}{yuronnnoljijjjkmmkhedb^Z[_abbb`acefhgcaccdglpruvvxywrpnkheca_^adefdccdfhloooppqojgjpw}}vqqssrrpnlihhfb]\][XY\`bddcdb`_bddb`bddflruuspoopruxwsqnkgcabcfgggfgilmlf_][Z\aiptx|~}|~}{{}{vsrqnida^]]_beffffedcehjjjmmjgefiklllllnrvxuojfdcdhmpqnkhc]Z\_aa`a^QIIQ\ca\akr{~tlehv~tlihhkmmlmnmlpuy|~}vkffgijjg_WQT\acfjliggc^ZVYcijfcdhpvx{|{wuwywvwyzwpg^WW_hjgea__cimnnmmotz~zusrsttusoiehkkllmnnmh`YVVWYZXUUW^hnnlkjkosssqqsvuromkmqspljhefhjkkjhilje`YW[_bbbcehjosqopsy~|zwsqonmpsurnmorsqmhfghfa^\ZY]bggdcbaadfedglrwwutssuvussqlihea\Z[_abdc`_adgfcbfjpuxyyurtwvx{~wqkebceffedeedb_[[]`cd_ZXX[afhjljghigd`aglnqsvz{zyxrkecfjjffdb``^\\ZY]acccdcdhmooqrsuy||{vpkhgjkjkklmlibYSPQTXZ[^chjlopnnnoqqnkjijmmkklnqsrpnlhffdbbcccegea][[ZZZZYY\bhlpsvz~}}|zxwwusqomlmmmhb[XZ\[ZWUTV\afijkihgedfjlptwutuy~~{uplhhjmmlklmnljiheca]VQOPW^abb````cgilry~vniilpsttsrqokgeddc_[YYY\`adea]]]^adefilmoqsuuwwtlc\WVX\]\[YWWXZ\]___`_]]`cfhhghmsx~}|}wqnmmmlifc_][\]]\ZXWVWY[]acc`^\[]_aba`_^_bfkorvz{}}{ywvvtmfdhnrssqlcZTRSVY^bgkmnpqqsuvtqpsx~|vqnmnoomjfb^\\]\\^`acgikmmkhd`^bipuxywsnkjklljjjigfca```_\ZZXUUVUTQMKMQV[]adffgikou{~~zwsqqqttqpqqmhc`_^^`bb`[URRTVZ^beghhighknnnlmpqrttqkgdcegghhhhiklkjjie_[YY[^ahmnljknpprtvz}ztqpnkkjlnonjeba`]]^_`abcdffghgedbbdfimppqssqomlkllighif_]]\]^\ZWXZ[\^^`cfgghihgikkmnoswy|wlc__dnttnhc\UU^hh`XXXRQVajosog`[_fmu{sgajwxz}ui^X\aa`_^YW`ifZSPJC?BM\fge`a`[WZgv{tolhfhjhikiaWUY`ca]VOMNRYfrz~~uibelqqonmlms|}xsjb^_dmvyvoe\WUVZbikje_YWX\\XTPRZaiqxz{{{zrpruy}~{wpga]]^]YVUX^cedb^ZXXWZbkqrolje``benx~}vompsqkd]ZZ]`fkkgc^UOPV`ffa[WVY`gmqrqpprw}{z{{zvne^XU[gqvtmf`YTUY_effec``cghc[XZ`isxzzywtqmjjloqnjhea^]^`behhc]\^aa_]\ZWWY[^chkhegq~|vqpsw}{uqpomhb_^]`dfefhgaYUTXailljhfefiloqqqolkmstoiffgggfecba_][]begga[ZYYZ^chov|yuuy|wpieca``_^\YUSRRUX]`a`_aehhgffeddegknonlknu{}|xqmjgimqrqokfaZVTTTSRUWZ^aa``_^`diou|~}}zwsnmnrtqlhdba`a`]_``__abfihhga^`a`ciosuvtqnlmoqrrnjgfdccc^XSQSX^dijgb[VUVZ_dfhjknty|zyyz~{tpopsuuqmfa_`cgkmigd_ZZ]__`aa`beijjlkifdglnquwurmhd_\^djnqpmjjhfc`^[VVY\_ceee`[Y^fov{{xurolljeb`\ZXVUTQNPTYafhihd`_^`ejmpssrrsvwuplklpstvvsmgb]ZZ[\[ZYWUSQOOQUY^acehknruwxwwyz~{yxxwutqmjeb_\[]`cgiiiihgeb_^^abcdeedc_[\^djostutsqpqponkifeegihe`]ZWVX[^_`ab`_bglooppqtvw}~xrolkkmnonkgd_YX[_aa_^__\]`bcddcdfimqrqmjgecehijllie`_cgjkjigedccdfeca^\]`eijkkkmpuzyuutvtmd^]]_flmfa_\YXZ\WLIR`jqtqha`ehmuzuh\YamxykeglrzxdSMQZfrugTJKQXcqvnb^agq~z{~l[YWbqtyuf_blyoihdgjqvk\T[hr~wog`bmvvl_]`aiy}pg`ZW\_YMDFLNVdid]XX[aikiaXRPTbs}}zxsrx}qlgdgklf^\aekppg[OGFLTTOIIMQV`knjaXUX[bjlg]VYbn{wngglkgea]WU\eig`\\\`fmtrjfgkowztj^Y^gnlcYSQRW^c`ZTRSSX^aehknrx|}ysnfbfknonkggku}xtqqpmbUOR[emrph_WTUY[]^^ZVZet{tprw~xplntwvsng_[]bd_[ZZZ\ckokaZXVU[eosqommpvwtne[TV[\YXY[]]bjnle`abcdggc^\\`iw}y{|ysmha\^fklkgc`]]ada\[\^bfiiiiggghhhhjifejry{yvsomrz|voljhjigeabfknqog]TMMSXY\_acejox}~~vqosvsjZNPVXY]eid`_bffffdeggffikg^ZZ\aiqvzyxywuy{zwspoqpolidacddd_XVWWX^hoppqruz~}wqoqvwsnjgddgjkihhgimpoic^ZZ[]`dedb`bhnppomhddksvuutsqrvxxywrnnnlkjfa\YZ\\\_bbdipw~~}~zvvwuqlgb`cfikigd_YZ]]\^bdefkquwwuqprstsrpmiijlnoolkjkquutrpmmnkid`_]^cilqsqnnnpv}}vrnjjmmjhfddhnrtspmkihjmlhc^ZY\beeeedeglrwxvsompv{~ytpnkhfdeedgjiimrsrpppooprtx|~|xtsuz~yupljifbbefgloqqpomjfdb`^]^_bgmppolgeglpuxwvurs{|unmoruxxtokgfehlmlljjlmnpqojikouy}zqnqrtwvsojecbaca]]`afkmnqtttutsrqomlllkhffgjmmnt{wtsqokfdhpwxqbSMOXgrsqqor|vnklqxzwvvskc_Y[emvxoaTQWaiha]\bowgbbccejv|zyyxy|}xqkkqvwvwtolnry|wnhbaiqqlebemvzuoloy~vpnljd`clvzrruvslebekqttmhjpv}~~~}~}}wrs|zplmt~~tlhhlpmfbdgipx{z{}xuu||y|{zyvtw|}ytoqy|{{wrrv|~{wtrtzxuuxzzxtqsx~yx}yw{|sjfhlr|~xw{|{yvx|}{yyyusuutv}~~zuvy~yy}}}~xuwwqlnu|{uqqv~~}wqlkry{{|yxyx{{yyz}|yxy~{wuspos{|vv||vsruz~~|yvw{}wtuyzyzyrtx|}{wtxxuwz|ytuxxvvz{yzzz|wsvz}~zqorsqsx~~}}|}~{xxtoot}~wuz~|}~zsorwwwy}~}~vsrqpryyz~|vx|}wxxuooywrw|xw}xwrw~~{ustxyyzuklu{yutu{{wx}}xx{~}||}{wsrrswvrqv}~}uprx~yssuvx~~}ytu|}uw}~~{vplnrttuyztpopqrx|z{|{}}wolms|zqqw{{z{|~~}||zvv{~|yy}~|}zx}}}~|{{yx|ztsvz{{{|~|zzz{zzxtrv|xvtuy{||zwvy||~{xz|}~}|yvusqpu}|z{|xutqpruvvz~{yz{zz}}~~{yz~~|xtpqu|}xuuz}||}|}|zz}~|xuux{}|z||xvvy|}}}~}{{|}~}}}}}||{|}|zxy{ywutv{|{zwuwz|~~~||{yyzyxxxxwx{~{|~|zxuvyzywv{~|ywxzzy{~~{y{~|yxz|{{{|{yvuw{|{zz{|}|yuxzwz}}}|{{z|~wqqvz}zurt{{vpns~{xwwy||zyxtqsy}}~{~zvvz}|zuropty}|wwz{utuzztrruxyyxy~~~{}~wvzxpnsvx~zwy~}zv{zvtw~{|}xvyzwxwyzz|yw{yztsspuz|{tu{}yqnow|yxwyzz|zvvsv~{utsrwzy||xw|}}|xuuvw|}{yz}}{yz~~yyz}~zuttstsrsty~yvwwvvvuvw{{vvw{}~~vomptxzyz~|{zyxwvwz}}~~yy{}~|~~xutsuy}~}|~|{xuvvvuuussuutttux}~~{xvtrqrrpqv|}~{zz|~xtrrtvwx|ytsuy||zz~}}ywvz~}||zwsolow~~z{~}zyutvyyxxz|~|yyxwxwwz||{ywvwzyxzzyxy{|~wssqoquz}yx{~}}}}|{z{zy{~~z~~}yzzywqy}z~}xurpomot{}yupprwyxxyxuuwxvtx}~}{zvrsvxxuux{~}{yz{|~}z{~~{z||{{zy{~~~~~|}~zxvuvttvx{|zvokouy{z{}~}{wuuvyz|||}}}{xyzxvuvwxyxvuvy}~}|}~yyzzxvvvutrqqtz~yx{~~{wwxwvuvwy{{{yustuvwxz{{yvuwxz{z{{{~~|{~{xvuy}zwvuvwwyzz{{zxusuvvuwz}}{xutux{}~~}~~||}{xutuvvurqqtwyz{}zvtttvvuvurpnmnpv{~ytqtxz{}|zyxvtqoruxywtrqrttuvxy{||zwvy~}}zvtvx|{vtuutttwyxwupmnpqqpqvz{xvvvx||xwwxxutv{~yy{~~{zzyvsqqqqnlklptxz{|~zusuy}|wljo{|yupprstrpolgflvxrpquyyvroljklqzzqourilvxtqqswxuohb`gtzk_\blsvxyyxy||wst|wqsz}wutx}|ysjgnzylfipx{}~{xvvvuvxxwskhlx~torvyzzyvqopquz~}wqot{wnkoywomnqtvwvtqor}wuv{}zypou}vja^cltwvurnnqsssuvsnjils{zrlknu||ywwy|~{tqszxuuw{}}yuronorv{|xrkgjqz}volow~{yyyyy{{wy~~yw{|vrpooruwurkggkquyxsmhefkprstuvxy{}}~|z{|xx{~{xvvx|~ztonrx|skfiouxyxvttuxz}}|~}zwvvwyxtngdgnv{}{unjjnsvyzzvqmlklnprspoosx~~xttvzyvwz~}xtqqrtutqnkhghkpuz}|yvv{{|}z|ywtf`o|xnjspdediuzvpopqkbnxgdqzpr}z{z~~rq~ypu~}z|{yz}wryyy~~wtvwqhhmoqxzrmprqt{}~~zwxxwspomjjjklmoqqnljklorsrqnijmmllmoqruwwxz|{xx{}|yvtvwxvrqswzzzvpidbehlpsuxxwwxz}~}{zxvvuusnkjmpruvsmgddefijjklllllnpqtxwx{~{wx{~|yvw|}yxyz{{wrnnqtvwwuqmigfghkosuttuy}~|{|||zyxxwvvuqkebcgkmquwusqnmklpsttrqrsuwwuqmnpty{}~}{zzzyz}~|xwxxxxxxwtrpnlmnoqrrqooruxz|{z{|~~~~zvsqqrsuvvusolhfegjosuusqonmkiggjortuvuttuxz{~~~{xvvx{}~}|zwvvvvz|{ywtqqrtvuqnkjiknrvz}~}{{|{usstxxqpv~xmjmrtuvuuwyzxuuvurpmkknpoopmheirz{wtstvz{tppt~}{}~|zzyxvtttrmd]XX^hptsqlebcfiknqv}{wvvx}}ywtrqqplgb]YZ]`chjheccehhd_ZX\eouwvtqquxxuuwz~~|}~{vrsy~ztonqwywusqonprpmjknptzyqkknsutqmhefjnonnopsy|ysmgdcgmqsuxxvuwxvsqpmmry{tsuwxwspnosz|yusokkorssrpnmnqtvwvuqllsw{~~ysmhhmu|~{wqkggggeccbabegea`_]]`fjigfddflrvwxvrsx~|z{}{{~~{xvvwuqkfaadiorsqliilopooruyzvuw{~{vrqrrolhb\[^cgjkkifgikifbabeinqqokhgimprstssuz~|~}}|xsporx}~zvrnoqsuuvvvwx|}zxvsqszzwvuvuroljkmqqnkfccdffedb`achmnnkgc^]`ejmosuvwz|}|yuuy{{~~}{{|~zwtsvy{||zwuvvvspommqx}~|}zvrqruy{{yvromkihghihiihfc_[Y[`ejlmlkhilpqqpoorux|}zxxwwz{zzz||{xsnkknppomigilostvwvwz|}|}|wqnnnooppnllkkigda]\^acfhihffhjllllmprtwxxvsqpruxz|~}|}~}zxvutsqnjhjnsvwxwtsrrtwxxvwz|~{xtqnljhec`_aeillkhgeddfilljhhikmnonljhikostssvx||{|~|{zxwtpooopsttrommpsuutsssstuvwvtsv|}{||ytpmllkjlnonmmoqnlifeeccdfea^[Z]adhlonmlmnprsttvx{}{{{{{{{}~}xsqprtttusqomlmmmmnorstux|~ywtv{|~xskbYVX^fmleejmsvpaUSV[beedfiltztnmjhnttronmmprsv|z}{{}zwttxwwkhpnf]UTXds|}qihkryzy{|pechntyxqighiicWNNOQZfjjkkfdggdbdhkjggjpvz}|uprvwxzyvy|{~}xvutvvqlklklmmmoponh`\^els{xywpopqojhihhkkiijifda[VWZ^bcbchmpqlcZUW[`egfhmu||wtrt{~}|zwwxz||xpgbelsxxrkffimomlmqw~}ytolihiklmjd^^djpqlebcglmi`ZX[aiorqonnnkf`^`dinrux|~~|vqprtx{{z{|xwy~|uomprtsqoonooopqrtuwxwx~tjfgjllga`_`cb_\YXZ]ab`^^_ab`_aekmnnmnsvxyuniils{~}~||}~|yuqmhdbabejosqlgejry|{wvz~~{urqqrqoljhdaa``begifa__aglnmiedegijkjhknqrqnlkkmnopooqrtvuw|{vuvusrokklorqmiffhiihffhmty}}zzz|{tmkjgec`\[[]]\YX[_``^XRQTY`fjiedfffefikmooooosvwyzyyy|~ytqprtuuuutromjijkllkkmorvxxy{zsnieefffgghijiea^\][XXZZ\`dfedfikjjiecgmrsqonlnruutttspqrqprvz||}}|{ywsmjijlmonigjotusqpqsw{~|||{xurnllkiea`^\\\[YWW[^_`^ZWWY\_adfhlorsstuvxwwvrrtwy{|~~|uolkigc`aabeghghkmqssttsv{{wsqppnkfa__]ZWTRRTXZ\]\]_abbaa`acdccdhlopqponorvxxurswz||}}~~{yz}}}||}{wutrqpnmklosx||yvux{~~yskhiie]WZdkleXOOTX]`\X]cd^TMT`ee`Z^my|vi`cluxsuurokisxmnvzvyxricdmwxrkhmuvsme`cryuy~ogghigb\^iuvm_SOPTWSOS[_[SQW]aa_]_htxsf[[cnw~wruy{||y|{x}zyxtj_]dlookglu{wmc`cgnw}vtuy|~}tia__\YRIGP[`]TMNTY__]^cig_ZZblqrqnqvyvj_\_fox|~|vssolkiirvprvwxxtuxunfchrz{wqpxsiggjqy}rrux|~zqjc`b`[WPMR\dd^VTWYYZ[\`daYROU\`bdgmwznhjnu{zxtolhdgq|wtuxz{|ywxtle`cmuwvrpu}}tlkotz|xusttw}wolljd_XQT^cb\TNOQSTVWX\_ZPMQX`eghlt{|vmgjortuvx{}ywyzzxusv{{~~|{xrha`chllijow}}wplptvy}|zz|~~~|wphcddb\TPQV[ZTNKMRVYZ\^bdc_[[_cgfbcirwvqkimopsvy~zwutv~|trtwxxwtuwvqkinttqlimtz|yqlklotx||zyvqlga`_YSNKLT[^[WSQQRRRTW[^^][Y\`bb``gr|}wrpty|}~|yxxwsomow~}ytux{{{z{{yuqopsrokhjpvxuplknsv{~|zy|~ysmjkid_ZY\aca\WTSSQPOOSUTRQRW\`aaekpvwusqruwxyz~zyzzxvux~{|{zywvvspkghlnlhfhlqtsqqqrqqsw|{unkjgc_ZWY\][XVTTTUTSVWZ\[XXZ^```diotvuojiknpqqv|~}}~|||}~{xwvtsqpruwuplkntvtqmjihhjmry}{{|{xslhfd_ZUQRX[YYXUTTTTUTTTTSPPSY]__aelsuvustxzzyz||xx{~~{yxy{{}||}}yrmlkmnljkosvtplhghikpw}||}~~{vropsrlb]\\[YUSTTUWVUTRQOLNQOLJMWdosvyxusrrpnmqx{zy|}{pn{~z}|{tqlc_dicY^e_`lvwsuzwx{x{}}}xtogfd]`ed_YUTU\_WQRUXYX]]YZXSU[`gmqtutpnssnptvtqqvx{~~~|{z~}}~|~zvuvuqooooppmnnmlmmnquxz{}}xsmf`\[^_\ZWVWVXZXTRSUSQPNPTRRTX`glmljiilrwwvsqnkmqsvutuuvy}|vsux|}zywtrmlosxxtpmlnptxwuwz~|{yuqmjiigea_]YVYY[[WUSNLJLPPNMOVaglonmlkmonmlmqqqtw{~~~}z{~}~~}}|||}{wurmlprpnmnnopqqrqoqssqsy|yvuqhbbccbaa_\^aa^XSTUSPNQTTROPTX]cjqvtrqnjhgjnnmpv}}|}{|||~zsqrrqoppnnppqrponoqsw~||ztlda_^^[[^a`^][XVTSQPMKLPSTTUY_ejnprtvw{{uponllmnrvy{||}~~}zz|}}}}|yunjkmoqstttvxxwtsuxz|||yyzzwqjeb_]\[YWVXYXVRNJFFJMOQQRTV[chmqqtwwusqprttstvy~~|{~~~~|yxy{|~}ytniggghknqsuuvwvuuuvuv{}yvutpkfaaddcb`aa^[ZYUQPQQQPRVXUVYZZ\biqwywtrrqqrutqoptz}}}}{z|}}}}|{{|}}{wqljihjmopoptwyzxxyzy|~}~~|xqkfa][]][YWWWWWVVTQPNMLLNTZ^_`cdgjlosvy{|||zywuttuxyz{}~|xxz|}~|}{z{zyxurmijmpstrqoosuvxzzz{}~|ywromiec`][XUSRTWWXXUQNKJLMPTVXY[^`bfmswyyxvuwz|}||}|}~~}|}~}}{ywvwwuqomljjjhillnppqrrtvvy{|}xustspmigd\VOHJOOMMOPQU[]ZXVSU`f_VVapyyu||xz{yokszxnhmmkmsztmw}qfltxnlghr}{op}xxsjoy|~{z|ysssqmga]XRPSURMGGJLLMOMJKRWXXVRRXcjghpyzqkpz~{usw}|zupnnkfegjligiovxvpihkpuvwy}~}xqnoqutlfd_]^ZWURRTXYTQRSVYZXUSUYZZ\]^`cfjnqtvqmorrrrqqtz{}|yz~~|xtqqmjhffhlpqrsuxvpnoqtvzyusooommmjdbdfeb]XUUTSTSSSUVVTRQSWZZWW\dlquvw{zurqrsuvwz|zvtssrrprux{|}~}}{z{|}|{zwqmnrwzxsrtx}}zzyz~xutpmljihgihb^^__[VSOMOSVURQQQORW[`ehfbbhloqw~{vsutollpvz~~~}{yvwz}~zvwxvsnlljmqooqtwxy}zrkgfioonnica^XSNMQTVYZYWSTX[\\\]`db_^`eltxyywxzxwxz{yvux~|vuuwz{|zvsrtvvtrtvwvqjiloty}|z{|qjfdfdbceefdbbcb`][\\YUUVY\]^__^^aa___`elswyx{zwxuqnnsy}zxvtux|~}~}ywwxxxz{yvspnpswwvx}zrljlmjffghigdcbbca]WRQRSUWWVVX[\]begjnpqpruvwz~zvvsmknsx~|wvwvvvwvstvwvtrpnnrtvy{}}vrpkedeghikkifb_ZTTWXY]^]\]_`__`bdefgggjnrttvyzz{||{z}}zyy{}zvutstttuuvwwvuwz{zyxwxz|~ysnjiea_`bdegiiihhgec`^\ZZ\^`acdffcbbcfhmuyzz{|~}zxwurpprvz|~~}}}}~~~|zwwxyxwvwwwxz}~|wtrpnmnnkiijkjigedfgbZVX[^^[[]]\YXZ^djptvx{|}|xtvy}|{}~|vqu~wqsw~{z}uc^`bkidnw~x|ypgehjhc_bfhd^YX]b`]_acehid[V[gmlihmuzwsronqv{|wrv}}wtx|~}z{~ztsvxwyz~xqry~xmijnpokhghgbZSQSY_`]\]bjlihjlmljhilpssnjjntyz||y|}|wrpswz{zxwxzyvsonorssrqqppkffikoqprx~}}xxwusrrsuuqibaabcb^[\`dc^Z[_bdggfeehigdglrwyz{}~~{xxxwwwutuuuroorwyyy{~uprux{{}zvx~|xx|~~||ztswxwwuutrqnhdehkjijmpqpnllossqrstuusnghntxyz||xz~}{z{~~|{xtrtvwxy{{~~xtuxzzyz}~|}~}zxwy{~~}uooruvttuvvvuronptuuuwy{}{xuuxzzxvvxywtqrvy{}~}}{wsqrtuvtporx|{z|~xz{wu}}|||~~vrty{yz{|}zxvsuwvvwz{z}{vsuvxxtpqtwwvuvyz{|zxvx{|zwux~|zzxutuxzzzyxy|{{~|}~|wuw{~|||zwuuwxwustx}{z{|{yvsstusqqtwz{{yyyzywwxzzwrmklptwz}~{{}}zy{~}|{~}{{~~{z|{xttwyyz|}}~|yxxz{zz{|}yurprvwvxz{|{wuuvwwwuttttrppsvz~~~~{vsrsvy|{{}~~{z{}~~~~{{}~{{||{{||}~~zvttvxyzzzz{|ytppqrsqprtvwutvyzzzyxxz|{zz}}{yywutuw{}|zz||~~ywx{}}|~|zz|}~}{z|~~}}~~|yxxzyvsqpppppqsuxyxwvuvwwwxxxwtrqpqtv{}zyz{|}~}~~}{zz}}||}}{zvsttuy}xlks}||zy{~sosvx|~|snklmnsyysmjjlns|{wz|yxwxxrmjjmnqvz~|ww}zvux}ztqruv{}wronnlidejkknt|zursx|wqqw{{zyvsrqrruwxxrmlmnruvusqrqqtwz{{{|z{}zwvy~{yy|}xspqvz~~}yrkgijknrwzzwspmmnomkjheeimrx}~{yyz{~{yyzz{{{zxxz{{}~~zwuutx}zyvvx{zusux~}}}|||xxz{}|wpklmmnrx}~|zyy{}|yvtqnnpsx|~~{vrqpnnlihjlpux}}yz~~}}}}||{y{|{xtqpoqw|}}{zxwwyz|{utsqqsvz}}}}|~~{yyz{}~|ywxwwuqmmnprsvyxwurommorqnmnoqtx||zx}}ytoryuopswtsxwtz~xv|xnr{xvzytprwrovwtuuuury|~}z}}}|}~~zy|vzz}|y|sntpovqqrlrurxwu}xwyy|xzowuosrv{w}~|z{{~}|}ywvoopmpqpsrsvrpqortsvttyxz{x{{wywtursxwyzwyzy~~}{|~|||{yyzxwxvwxvvvsutqrpsutx|{||{zy{}{|~~~ztrrqsvy{|~}zyzyxwspppqqquvwxvtqoonmnmnqsv{~}|zwwutuvyzxz{{~~~zvutvz|~}{xspolklnqsvxvuvwyyyz||~|zvuwz|}|||{xvvuqmjfejnquy||zxvtsqnpqoorv{~}{{zwwz{zzzz|~~zuqmmrwyyxxxxy{ywwupmkknsuuwyxvvuttuuux~zvssx}~zz{ywuokkmqrpmmrw|zxzyusvvojkt~~xw{vpv}{{~~rmq{{wwutz|tnmoqsxxrjhjlnswtmhgjouywojjkijs~~z~vmkowxqolklgb_^_bju{vtqrvxuojmuz~|}zvyzxvvyzussvy{yqifeegjlmkkigjpvvqjfgipz|vvwwx}}vqnkmw}wtstxywl`]^_dlvzyvutsswxsmkjks}yvuuw}zwy~~zzyz|||zwttv{{tqnotxzunjiijmrqkeb^^cjqsniikoty{|~|wttsu{~{wusrswyuoga`binqtuwxyy{{wronnorwywsrtw{|xuuw{~~}yuty{yxy|~~|ywutuvutoiedgkopmjiijkoqrqnlmptx{zxx|}wsqrvyyyvsstuvwwuqmjikoqpmllnqvzzuplkloqsrolkkmry~}zxxz}~|z|zvuz~{wuvy{{|zvrj`[]dge_\^bfkqvwwwvqqx~|z~{}zv|smw}uuxukefjoojechlfdkpnd_fmnovzywtqt{~z}}~~}|{}}xvz~}vrty~~yursqmlmlhcdiovvqnnponprqooquy}yxz~}zvtsruxzxvtqsvxyywsqonnppoonjfhkosromnonorsuwy|}{xvtty|wtsrqrqmkiggilorqnmmklmllmlkkou{}yurpprttrnmkknpqromllnoorsrrsrrruxxywtttsrsvyz|}~}}~{ww|~}ytqkghjigeb``a`bglmllllmoonoonrvwx~zurpoquvvvvtssrqstqoqrqpopqrstttrqrrqrssttsruy}~~|~}}{yy{}~}yvromllljgedcb`_`bbdghhjjjkmpruxz}{vuttusooqtvywoklmoqpjdfikorqqvzyyytjflsx}}wsw~~xxqhggjortmddeegcYQJJP[b[OMNQY_aadijjotvux}|{oimpmje]Z`iprrng]Y^cc][]_beglnlmpspiaYYakrwxxx{~||}}wsporqia`flonhaXUY]\XSPRX]bfffjquwxuopx}{|}ztopv{|{voheefeb_^`dikjfefgfeb[RRW]cfeefhmqqnkknqrtutu||uttrqojdchmrwvoheddgighkpuy|{z}zsomnpqpnlmt||vqoquvsonqwz{~}xtuxyulggiovz|{z{z{|ytsvz{zxvuw|}zy{||{{yvw{}~{yxz|{xsoljikkhgiloqpnljjnrrooqw}zvrmjlnopnnpsutrommnonmlmotyzzzwsqrttrmjkptwyyyxwwwuronruuuuvvw{}}}||}~|{}~}|xrmjjjkkecfghiifdfhjllmpu{}~}}~~zwutttplloqrtsokhjnonkmnoqpmlkigffeb_^`ejostsrtutrsw|~~~}zvrmjihea_][[\[YXVVZaeddefilknssuy}{{xuqljjllid`accdcca`bhkjikorrstsqortuwvsqrv{~zxx{}~~}|~{xxyxvspkgedcb]XXUTVZ]\[^ejlnquwxyz{z{}||zwvtpprsplgccegjmkggijmnooppmlkijmmlnnjiilpuwuuvtvy|||~~{xutsroljihgc_ZTQNOSTSRSU[cjoonmmptw{{xvvusqnmlkhca__adeca`bgmsvvtqonptwvutrsvwyzzxwwvwxz|||zxww{~zxx|~}|~ytqnloqpokgda]XVUTUWYXX[ahquuvvxz~zxvv|zqgdefddcbefffddikmmhgfcdlssrlfjtz~zroklqpqpjlwxotwi`]dlppniaZ\]YSIA;:AKOR[cgjlnolmsy}}yv}}xuronptvtmbXZdmsqi_TMNWclruvwwxyxxz{{ysoqy|urt|{rliknoqv}}uprx|}{vqqxzursv}|umfbfnstpg]SNPW_cdfhjov{~yrpu}|yrnorqojd__ckold]WTW_jnlkiggjnquxxurkgefkqvxwsrtvwxwqifiot{}zrkfc^[ZVRRV_ghaXPGDJS[_``bflt||vqmg^Z]eqxupib\\`cfgfehmswwvutstsrpoqvxvtsqonry{zyvuutpmot|~zxvrojd]YSOTZ^``^\\[Z]_]XTU^kw{upmlkheeehjga^]^chjib\YXZ^dknortsnighkosvyxuuy}{wwvw|~|}yoha]ZVTUW\][YZXUTVZ__[Y[_emuz}~|y{xsog`^`cbcigaegecb`\[biikpqmmqpmpuv{ztnquuwzxuwwutsuv|}vrqlkkgaZTQLLRTVZ\_cdec\Z]djow|~|yvppuvsoid`][[[\_`dhfdbbabceedcfjmnqqruvwyz|{wutuwvvusuwy~|yxywtrnieda^ZUQQOMOUXY[\\\^_adglqrqsw||ywvvuttvvvtnf_ZXXZ^^^`aba^]]`eiiihffkppoqtx|zuuwwwwuwzz|}{vrokgeeehf^WQNLKMQUWYZ[`cddejnqsux}}zwrnnnpqomg`\[\\[YWX\_cfeegijhillmoqttuuvx{}}{xxzxvusrqoptx~wqmljhfcbc_\YUQPSUVXYXVW\`cgkmnrv{}||ywvuqmllmpqpmhb^^`cb^Z[_cgffgffjquqkiklmrwzvw|zvvz~n^dsyz~|||~wrroic[SKIOQIKPF>AKUTTWX^aekigjns}|sokgffgd_`emuywmc_`dccfjmpw}~}~~xtssx~|soqwywtsonmhggfgkoqtttvy|vronljfbb]_ehg_USUVWYZ[]_dknpsuu{~}wrrokgdbcfkpsqkd^]^\[Z[_ba`aaceeeeffcbabiosuuttvy~~~}|~}|}~{yxtpkfb]WQNLMNORUVQMOQUVUX\afjnprw}yrligecbb``bdecbccdddcdeefhighmqsspmlnrw|xvxz~~}zz}xuuuvvqlg`YYZWTRPPPSWZ[\]`bdfjlnoqu{~{xvvtpmhb[Z]`b`_bcdcbba_`bcfhilnopopqtx}~yuuz~xwz~~{xwusuxx{}~}|}|yxz~}xrjjmkie[UW[^_^]`hmpssssssrsx}}{yxxusoib[VSSRQSVX[]`flqstsoklpvxwwvrnnruutrrrnhddjoomlkmoqtxz}~|uoighe`^[VTPLHEGHGIKMQW`inoppsw|}zxvsrtsnjf^XWWUSQOQV[^bdcbbcegikmnoponqvyzz||xvvuwyy{~{wwx{~~}~~~~wqokgffc]XTQPONLJIGFHKRX\_eijlqv{||{yxwtpkfb`]XUUTTTUUVY]`dfefijkopoqrsw}~}||zwvwxy}~zy}{tomjhfa\XWWUPNPPNLJLOQSW^behjmt{~|{yxvrmhffdca^\ZXTUYYX\bdfgedhjkmnnmnsvx||xwvstvxy{|}}|zyz}}yurolgb^ZWVVUTUTQMMPPNPVZ[[^gnruz|uqruqg^`c_XW[[SIGNWXW]jsndenmeixyps{~{}{y}~|x}qrx{uxteZ_kaVZcfO:@FD;6BKJE<9ETUMXt|qhl|~yxouvlejqsiWPSUPKR[YLADOTTYjsl_Zageeo|~ujfjnt}~wx{zy{}ypf`bhh`RNRRQU[^TGBGJEEMWYROQW]dr}rige^[`d_QGHLORW^c`WRSVVW_fibYXZ`dfknnh`cijgfmturqqqppw{upmmqocXTTVXZ_c^SNNPTWZ^`_[\afmv||}tljlkikje^Y[cjotvvuqnmllnqswvqmnqppw}}zsnnnmqw|}yurompw~|}~~{z{}|vsplihdb_ZYZ\\[\][USV\]]`dgfcehmt{~||zyupkihebba_]YY^bejmqsqpppnnqrtxytrrrtwxvpmkjkmpw}{soomlpv~~~wuqljjjfca\YVUW\\WWWVWWV[`bbbcdhqz~|{{ytpkfdbbb^^^YU[acgkjhfc_^_aeiigfdaadfeefcchkosvxyzz}~~|uomigfa\YXVTTSSSPNJHIJKMRUVVVZ_goz{ywurpmheb^\[ZZ[YUVXY[^`cghjhfghikjjmoppmkkjjknpqsqqtxzyxwvwz~|tolgde_WVXURSRPQNLPSPOQPQW[`fhinv~}xvrmjifbbca^\][YXXYWY[]acfhgd_`ehhjkihhhebgnqqu{{xwx{}~yuqjfc_\YVUUUTSQPONNLKJJLOTY^bdfjpx|xxwpnmlmkiedfdaa_]^`__`afkoopssrststuuusrsrsw{{zzytpoprrrsuwyz}zvslgc_\[ZXYYWUROLMOPSURRW\_cimppsx}{rc`kuskjkjghrqc\ZYUV_inmptsrv~vpoi^]ittpstjaoxsg_tzv}wqzniupbZSS^degbUGI[d_VPKCBMY\VV]`agr}}|w{xibbluqnrpiju~|sqpllntwrllppu{xz|}}wokhcbqzpf``mvsohba`m~}y{}umibXV\cc_ZRLOY`^XSSSRZfmliinrxypknrrkfc[Y`mwwvurnov{xldc^]grvqiefgirywk`YUW[fsutwxsr~|rio~}vomrz{tlkiehputqme]Z[ab^_`]Z_hsrga]ZYbnrlcafmyz|~zwurnqwwstyxtw}vqgefhoqngbcfn}ynic_hswyxwyz~ytszyz~~{{|www{|xxxpjkmfZSWZXY_dc_^\VYellh_[]crxponkefjjdbcdktxvmjlkeerxwohgeck{~ynhkpusmlnrx~y~y{}{xuqszxqorojloqk`YUVZ_ba^\^bbhpvwqidbaiw|wy{nhqwrs|teozvx~ngto_k{tjmj`Y_g`etleqrjltvhdtnfx{z}yyxv|~|}|zurprspt|vhfgb`eg\RRQOVejilnhehgeluwu{{wtokmrqjkppqvzzuqmjimsy~{trqolqvqmlptv{}xssoloqv}}xontvy}|{siklehmnnmosomqplh]XZZ`gnromqsmntqlijmpy~ytooqnlmmswx|{popmosqqpnmlllkmicdhknouyssxutz|wxuv}~yvnlnmljjlmorrqtm_TQPLPXZ]`aeilrtqqnkot|~{xuqieglpwz{yuxywyyyxxyw|{tqtvv{}}~yz|vutvxy~}|}~{{}{uoqx|~~vuurpqrrqtuw{~xsvwsruyyxxyz~}~~|~~{zworwuwzecrtu}{wxyvzqgvn\jos~t||uuq}xvbcq{{utt~xidyh^kijh^[^jpmx|uxwagiW]uzxwl|~y~wskoyw}tp{yqcgy~{~qwymt|{}rrvpnz}tw}ynpvkdd`aly{{}zw|zomjejwyszye_ilfecbfs}|}~{~wxvz|xqtxtryvjmwxx}wx|~~~rttvy}~yywt|}}~}z}ym`akjdiqkfqxrrwtqy~|~|}}|~xpw{tqqpq||ytz|uv{ztqtustuv~|zx~~|}z||~zu}}{zvxyutx{vyzplgjqnntzvow~~~~~~}}{u|yurtyvqrsqu{}xt{~zrtusqyy~~|~~|wxz~~}|y|~y{z|{{yuy{{~||}zwtuxvv{}x||y{uzuuzvbqwpvoorws}}}xpvwfz~~}{~|wr}{swyxzz~||~~tjlqrps{ws||xssv||{{z{{}|~~|wzzzy|y||||{sswxuz}vuxvsussy~|zyyy||zy}{}{wwpstuy}~~{}|~{||}{|~~|}z{||||~zwxutxwy{|~}~xvyzywx|{z{{xwxwyyz}xwy~{|}{z~~~}|}|{{yvruzyxvvyuqrruusw|}|yx{|zvqsutvyz{}~|}{y|}~~{zzy{ztnpplnuvuz}{ywyy}||}|{}~yw{yy||yx{|wuvuuxzxyy||}~|xuuvuvwwwy|}~}~}}wrxz{{wxxw{~~}||}~}vrvy|}~{|zvww{{y}}xx||~|xyytrw}}{}~~xw~wtrvwqsppv~~~|{{|}~yuqotxwv~~zus|{{yq{~wtzy{~tr{wts{yxzzifjmz|tngbhsolkbdrvomnlt|yvtpovxy~{{}wvwy}|}}vt{sknontwmih_aopkoqmtyofbbo}|xrhjx}{}yot{us{||}}wjkwvvyvpuxoomhnvuqsocbefjjgji`djhqxvsnjhp}}yzzx}z{xy~{|x~{zx{xonu}rptqosrlv|uw{xuvyyvomsqqxy{zw~tv}~yy{tuzutzxrqmhlnlmngbkojifehkihe]akpv}zw}~|{ux~}zy~}uqtuvyupnnlosqtywxxpospnuslnsrrvwzwu{}}|||}|y~~xwxqlopnnhbhnlqsklompqihotqnlgjqsz}z|yx}~|y~yronmpmjorsxvnpuuxzvv{wswtr{{yyut|{|~~{|w|{~}|}|yxww~~zx}~~{vqu{{xxwsuytrxxsroknoptpknnklpnjrwqpnhmtsx}{}yzwvx}~~urutuxvtx{zztjkqqt{{trqnnonrvutwroqu||y{zuv|||~|{{}z~}}|}xqtuprwrqunjstvysnprljsqnwxsqjhortzzusttx}zx}}wwyxw|~|}~z}~}{wqnptuy|zxxwsvvtwsopommpopqkkqtrmnpsz{xxtpty{|}}~~{{}{wwyz||yz}xvvnmpqpqvuqrljpqnprnmljltwvutrtuuvuty~}{xusyzwytoqrrrpmhhklnpprsooqnnsvz}{zzwvvy~{x}tnlrywsspgdoqhilifggc]XZaklc\UMQ_iiggdbgmooolox|xv|||}}}|}}wnjhintwvrlfepyxrppkgmqpnnnosutvzz|yrme`fqz{~y{~yust}|uwtlmsrjc^[^cea\UOPUY]`cdddfgggdimjfglmu~vngkx~z{z{zskhkpsvyyvvwwzzxusngd`_cipvvupfdnuuqptwy~zwurstpoqolifdfhffe_YUW]_]\[[\`gilmjlmigjhdhnsy~}}}{umlmpppomieehhggdachkhd_Y\^]cgfggkmgfloprry}|~}zvsuyxvsolghkkhb_abcca`a\TSWWW[^bggdcdhnportpqxzojjijmmmnnlklmnlkmmjfghgfda`^Z_hnspnmjhjnoljkosv{{|~~~}yx}~{uoic`a``a`_[XZYVUSQPRWXZ\Y\`^ahiedisy|~~|{z||xwxxutxzzyvwz{ywupieddhmmmliigimoqqopvvsw{~yyzzxwrljfcfljdb`\[ZXVROJLSTWZ_c`^]]___bfilllosx}~{}~wsuxwwyxyxuqmgdeddecefeikhfggcchlpv{}|}~}|xv{|{yvxvtx}}|~~{wvurpkjjdceeilmlh_RNOOQSWZ[[ZVSSY`dfglrtx~}|wrqsx{|xwxz|{vutuw{~}{|||{wsmfb_[]ahosttpiefikmrvy|}|{yy}|zxutrnmrutuvutvvxz{~zslijlmkjljd`[SNONNQSSZ^[\_`]Z^djov~|wx{vswumptrruy{}|xyxuux|}zpgfjkjifhmnmmlh^\chjov|{yuqtxz|xrljmpqstnklntyzvsvzxuyzrpphfllovp^TRRSVURPS[adghddgb^aciy{{xy|vsmlsxtjd`bpxttslmw~~zz~}uoihmnkmkejrolllprmjikw|xjdcdmsk`YZbkoprojrxvwvquzriigdioleb]XZYUTONVZ[\[[becinmr|}yy{~wpliiornjeafmkhlopvxuv{~|{~ysnjnqmkhbaiqttvsrurnorw||{|||wx~ztslfijd]WY^adghjortzzvtupe`]\aeaZUSSUWWUTTSVY\^_gnlhgfit~yumgiib\XQOYcejljhkptw{{tyyqqqnmolggiginpu}|wuux{~|ww{{z{ukeffeig^WSTZafikifghikkntoheb^^`a]WUVWXXYYXZ^dhimqrnlrvx}}}wrkghf_[XUV_efjmjkptv{|{|yutrljmqtwtjcehjnsuxyvvx}}vomkieb^WTSU]cfgd_]]^agggf`\[\[XZZWXYYZZXURTTV^ceinruxyy||~~}|zwsnkljeeeb^_decegefihiotx|}||yvpllnmnrvsononmosy}~}zuruwtonle_[YZYWW^a]^bdbcffhifdc^ZYVTTTQQVYZXXZ[YWYadgow}~zwttrmkkhc_]\\\^ca^dga`c`[^bgnolmpomqvusuvspoqsrrutty~{wsrrspkjjfeedda^]^``ciihgedcdghb\[WRQNNRQONNLMSY]dhhhks|~yxyxxwqjifdc`__ZVXZZ^fknojfdbcggdehhikloqqppomotvyyy{{{~|{{|wlgebbca_^^^\]^]chihe`ZVWZYYYTPNNOLGGHIIKOTSUX]gmpsux}}{wrrpjjlligb__aed^[^djmlgda^\[WUW[^eigaYYblquurtxwux{|yomolknlkkg`ZSORVW[dfglidedca[VTSPSTKFC95=BAFNQW]ZXZZ^lz~vrsoiiimsphaWPSXW]hmqqiee_VX]^^]\bdadiklmkiovz~~{{~yxpjkkjhffjjea`^ZVUSW^enqkgaUPTY]]YWWPHGD>>@@BGJNV[[`ghhjovyukdeefijgdb\XYXVROQU[cilkicZZ\ZZYXY[[\\ZY^bcjqsx}|zy~tqqoonlkgb]^]UQRRTW^dffa^][]\YXVWXVTROICBAACHLQWWXZX[enuz}|xurmgedbccb_XQNOPQTW[][YXYWUVVUUVUROUZYYZ]cioty}yusrqkeb`ab]ZYUSSQOQTU]feaaddaaa`^YWSOLHC????CHIJMRW^ccfmrv|zuqljid`]YVSPOONLLOSZ^]`ec^^][[YVZ[UTZ^`chlprpruuyzz}~}wpmnkfcec_``]WTUXWTU\^^bc```]YXWTTQJEC?<99<=?CHLOV]bdkuyx}|zwsoljedda_^ZTRPMMLJMTX\dknkihfb\Y[[WQPSWY\cikoqqtvvw{~}xtqligc`]YVTQOONOTVY_bb`\VVWVSRSSOKKKFCBAABDCGMOS[_ahr{~{zvpmlkieabcb`_\XXWWZX[dggfea\ZXWVTRQNJIMPS[`ejlpwz|~{zupppnic`_][YWRMMNPTW\cgfec]Z[ZXWVSNJGED?=>=<<>DJNPTXY`kszyvy{unigd_ZYXUTTUXZ[agifd_VQRPOOPRQNKJOV^fklostsuyxwyz}~zrnmpokheca^ZUW]acddcbddc^VOLLLJGGJMHEEA=<<@DFEEKQUZ^bityqnooplebb_YVUTW\afgcadc^ZUQOPQQOKJKHGNSUY`gmpqvzz{|xsw{zxpmrrnjb``XSSTRTZ_ab``b_WQJBCGGGEABDAAFEBDECEHHLSUVZ[^jv|uppsurnigc\W[bdfhilligea]YOECDEDBBDFFKTVW^gnrrstssvxxy}zqkjnmggiea[VY][\bffca_ZSPOLKKHFGHEBEFEE@:;?ADIKLOPQSW]gt|}zuqrrnmlf_\_ba^]\]bfdaa\TOKGEFIHGCAFNW`fhikou{}zyzytposyxrnjkmkhe`\^acge_^begf_XSMG@;;@AACA?CHGDECABFIKOQRTVZ\]coy~~wqmkkjihedhlnrpiedca]\YTMGE@:<BDFPW[abaccccceinnlmlmsrpuy{}yunklkjlmkjigea\[ZXWUPJGE@<;9:943<DFFGGE?=BFLTWXYVUX\`gnqv|zwtqkcdiputsspg_cda`_YND<54438>BJQX[\`db__][]cglomlonmt|~ysoljkhdhkmqppqojc^\WSROIB<741/15<@BEB@CCAAAADIKLQTTYaehmpvzsprrpu{|}wnmkfc_ZWSMHEA<9:>A=>IQU[_]^_ZUVVZ_`ekibcfimpps}~ytrminwz}|vqnidb_\[WRLA83.-+'!%*/46:ADEDA>CJMRWWWYZ\enr||usslipw|zuwvoe\VWVSPKC?@AADDCFLOPOKKNKJLG@?FMTY[_fgegmr{~yyxuz|xrkd[SOOPLHB<<7-&#"%+27989=AEIKMQUVUVXWZ]`cdgp{|vvst|~yvrlc[[[VQNMMLHCB<3268:?BDFHFFHILQSTTSSUYaint}~{ztot||voiaZYXTNF>93,'&%%)+*-136:==:8:BHLMMQPKNV]agr{}{z|qdYSTSPOQPIA::=<;=?:447=DECEILOSUUTPMOTWWZgt{~~~yrka[XWTNF>5,##%""%'-36;@DFILKIIHHJLRZclw~~}{upke_[WSQKFFE>=?>@DDA>>>AB?>@DJNOMKIFEHLXbhpuy|}~}slg`[WOG@:2.*%&)'*--*),16<>?CFKOQPNMKIIGNX_hmnquz~xrlhe_WQMMKFB@ABA@?<548:@HGEHIKPRNJGA>ADM[elrusv~|sjb]WQJB80+''*(*01,(*08>>==<9::=@A?>>?DMWahlmmntwy{sf\WMEB<:<;:?CACHG@<99>??EHGIMMLMJEB=>EJOX^_cilqww|~}xnf_VNGA;741..,'&'&%)/0/1469<=??:7657@LT[abcgjqy~~{yqhbYRI>89;@JQOLKGBCHIFDB@@@?>@B?:9548AJQX\]^`gosu}{si`ULJD<9402797651.-.-,/5;==<:9956;<<?DHNTTVZ_kstw~|ysi\PLIGFAADDDBBA?BEDBABDEFDCB@;656:>>AIOQRSWantwyz{|xsl_SMGBCDCA@>:52/269=?:5111/00/..0147>JSXYVY_gs{tlf]VSMFCC@@@CJMMMIEFNUTSNED>6698:BGB;32<DDFLOU`eirvzxj`ZXTOMPSQE70/...,),356831672/,+058<A?>AFMTZait}}ywx}~vle`XPJHJNSNDAACFGGJTZWSI;1-..-*')+/57:=BDABIPYakstrnnx}qe^\XPIEEGJHB><7.+/4;ACA;3-+-15549<<>?=>AACHNU`hox{{~rfb__`[UTTQNKJJGBA@?CGILKD<93./0/245=C@AEEEJPU^fknnnoopw}}}skd_\YWTSSRLFEC<647998:<:5/($''! #'0:>?BEBAHQYbnvwvw{vkc_XRNJLSSONQRNHFJKJLMJC;41576544;DIMQQOLGEHLS`ilmmnqtx~xrkeba`\ZY\`_ZULA83.*.6;95.(*/11015:<<;@HLLMQY`jv{tngc`^^ZWY\^[Z\\XQMKGJOPPI?8530002>GJIHIOVSPSWY`glpooquy}wmd]TRURU\^^\VPOJ>96104751//01159:AJLIEFMQMKS\dnx|snh`Z\__fppkd__^VKEEC@@?<968769>BFMTTSPOUWSTW[cmvvttsuwvu|}wqjb]VPV_ellfaa^UOG?CE@><65:=95228<>DHIMONPVUXfr{}usohb[TW`fgjjec`WPIGLOLFB??EIIIIIOVVWY[\\YWXRPYaflqqqvwrpqyyuoiecabgmnmmmlid]QHE@;;98::778548>CHMPTVTU\`djpx~{skaZVX]diklnke`\YWWUSPMMNSVQNRQLHFCHV^]ZWSSVX[bjnuwttrr{}{qeba_dfbdmpolaUSNGFGDCE><@:8BFCFHEHT[ab\[]]^dls}~~ztrhafhejmhiprrnaVUPJLPT[_[ZZSMMMMPNKPUZ__\[[Z_hlnrsv{vmnv|xuqh`difkonpssoli^UQNPRRQONICB?<=?EKMMKR[[YTQU_lrxz||zrifhhgpwwtojjj_PLKMS[`cca_`^UPPQSUWWW]b^ZWSS^mtwumlsqmqw||ztttmjkioxyx{{wxp_VSMNW^[WOHHE>;<?CDACKOU]\YVS[hs|xpnkgghilqqoprtukZQPSYcgdild__YTURMONHKSUUSOKMRWcklpprtomu|ypmorttvxwuvwzwi]XUSX]\YZWRPH?BIKIB@HS[\ZXY\`ejrz}}vqngdjrxyqpx{|}xkcb^`d`afd_\YRPRNNPJHLQW]ZOKSZ^acjsvtuxtrw~|xronjjotwxwux|zul`ajkdaa[WWTQOIDFHEDFFMX[XUQT\gpswwvz~|xy{|yxtqsvyxxyzzupi`[_fgii\UXWUWURSSQSXVWcd[WSKQ^aepoilomnpqt}tpuuw{vsxyzzshgkhhdUKJFBGG?BFDIQRV\\Z_\V^hkt{vv}yttttssuxxw{~|{yusqlhffie]ZXZ\VRTTNKPXYXWQMOPPTY^ekklqtrrx{{}zyzxx|}{{zvqqrkcb`ZRLKLGBDIKJMSZ`bd_XY^b_]bjolluzwxyxz||||yy{zumggdZTX[[[_^\ZVW\bfcZX[\]^_clppw}yv|~}|~ywzyunfccafmpqmkknoifhjljhfceknmosstz}~xu~ywxyvmefjjmpomlknttmkljkpolkijmfdlrw~ysrv~z|}||y{~{y}}xmgjkpwyvngirunjjie`^bgklnniimqy|~~{z}~zwvux~}}w}ypmmnv{zxslotnfilnojgghlmkigfioqos{{~|~zvvy}||zupnorsnhjnruwtjgorpljmqqmiebhqux|||}{~}xvx}{wtv~zoikqutpgeijkpmfdihdbaistrnd`fms|~|y{ywwrnnou~~ylkmr}zxtuztlorrrlcchhilhe`]epx||z}vnnns{z~z{yrjb_enpllqppsrolntxyxtsssqldbhpwyzz{~vy{{{zwqlijv~ssynedltxvsrtrnsxngkmlllmnnnokbao~|xyxtpkc\_m{|y||ytja_et}|zxvvwyzwsuwphnqoqmd[UWcu}}yohdfq~|||}ti]YX_oxwz|yxvx~~{ywokqx{}yokhfr}x~}zxqkiimwxqos}zqhbagpuutyzuronoqrledkstnfcdelryvqh_bku|{yzxyrkgdflpoox{yvqptzxtnfehnvtou~zrnljp}||~{x|~~wvpgfffjgablx}zumkjhmtvtojjprv}}zz}|wonnrxww}|}}xuzzsljosuslhgju}umcempqtrpnnostux}zz}}yqotsmilv|z}~xspkjoplikosyzw{xmfegfjosspqqnnmnx|}}~}wuux{|~}~~wwxwxuonmlhehlotxy}{sprpmsxx{}wtstxz}}zz}}|{ww{~{wz}zx|}~~{vtu{zyutx{|}{ummnllpuvy~{wrgbehijpsrx}}|yy{|}}xxzwrtz{zyy}}wy~~}}xomopv{{ywunllmw|qonpuvxyursuqosux|~}yuwyz{z|||xz}}}}{{xvsssqnprolifdhqzxpmjksy{|wuw|~yzyx}~|y~~|||vwzz{~}~}}{uxyvvtqmiluzvpquuusqtz|}}{{{|{z{}{{xuwyvwzvv|}~{zy{{z~{{}}zuqsvy|}zvtnlpsv}wolpruyxvwyz|{z|~}{zvv}}{yz~~|}}~|||z|{vvuprxvrqooqty}zxxxyxxxy~|{zz|{}zz}|y|}|yvz}yvwzzwux}~}~|||{|{{zxvrnnpsuspotxwplorrststw}}~{y{}|{{y{{z~}|zzxx{yxywuwzzzztptx|~wvwvwtompwz||z|}}|~}~~}zxy|}~{z{}zyywx{yvtqquzyutsswwwywu{{uoouvuyzyy|~}~}|}}||~yy|~{|zwx|z{}zx}~|{zxvy~~{zzyxvx~~}~{xvsrvvrsx~|}yxyxxxz~{wxz{|~z||yyzxwxvtuw|{wx|}{{}~~}{xvvsoorsrv{~}}~~}}}||~~|z|~|ywuuuuuwzxx{zx}~~~~{wttvyz~~}~}|}}~~zyyxx{|||||}|yxxy||{{}}{yzzzzz{|{{|z|yustutsrqqrtvy{|~}}|yvuvyz{||~~}{{{xxwvvwuuwx{~|~{yxvttsrttuz}|~}zwvx}}z|}|}}|z}||}zxwtrrppsx||xx{zxxutwwxyvtv|zzzz}{vty~}{{zxwvx{~~}}|ywtpry}}~~~|{yuvyyxxvvz~}xvvutrrvz|}xwxx{~~||~~}|yy{zwutvz~}zxzzwvupnpqrtvy{{}~|zwtstwz|~~}}|}|yz{{|~|yvvusrsuwy|~{xvttvxyyy{~}}|zwuuvwx{~~|zyywuuwyyxy{|xvuvwwwx{|zxvvvuuusruxz|}}}|zyyvttuutuw}}ywy|{zyyz~}~}}~{wxxxz{||zyxvwwttwyyxwy}~}zvvvvuuuvz}|||}|xxzz{z{|}|{{|z{|ywwwwwwy|zxwvvtsuxz{yy{}~}|zz{xvvuvvvx{~{{{{zyz{{zwvy{~~}}||{zzzzz|||zywvvvwy|~}|}~|{yxwvvvuusqsw|~{yz~}zxwxy}}{|}}{yxxy{|{|}}}~|yxuqqrsw{{ywy|~|yvvxyxwustw|{xwy}}{{|~~~}{xxwwyzzzyxz~~}{wttw{~|z{}~|yvuuwxyyxxy{~|zwwyz{zwwy|~}|zyyz|~}}}}~{xwusqqsvy}~}}zxvtsssttstvvy|}||{{|~~~~}zxxxxyxxz}|zwtqrstvwy{}}}~}{{zxwxz{{zz{|}|{zzzzz|{ywwwxxwvxz|}}~}yvuuvvx{~~{ywwxxwuvxz{|}~}{{|zxxy{}|zz{|{zz~~{yvuvvvwx{{yyyzxuuvwwxz{~~~}{{|}~~~|ywwxyyyyz|~~{xvvvvvuvx{}}{{{yxwxyxyz{|}~~}}}||~|yyyyyxwxyz|~}|{zzxxyz|~~||}|{zyyzyz||}}}{yyzz|~~}z{}}{zz{}}}~||zzzzyyz{}~~~|||ywvuuvuvxy|~}}~~}|{{{{zyyz|}~~~|{zywvwxyz||~~~}|{{zyxy{}~~~}}}}}~~}}|{zyxxwyz{}}}}}}}|||{|}~~~|{zzzyxxwwxz}~||||}~~~~}}}~}}}|}~~~~|{z{|}||{{{}}{{zyxwwxy{}~||}~}}}}}|{{{{||||}~~}|{||{zyyz|}~~~~}|||}|zxxxz|~}|}~~}|{||||||}~}}}}~~}{{|~~}|||||{zyy{}~}||}}~~}~~~~}~~}}}}}}~~~~}|{z{}}{{{{zzyxxy{|}~~}}}~}{{}~~~}}}}~|}}}}}}{z{|~~~~~~~~|{z{}~~~~}}~~~~~}}}}~~}}}~~~||}~~~}}}~~~~}~}|{{||{zzyz|~~~~}|}}}}}||||}~~}}||{{{|}}}}~~~~~~}~~~}}}~~~}}}~~~}}}}}~||}}~~}}}~~~~~}||{{||}~~~~~~~~~~~~}~~}}}}}~~~}}}}|{{{|}}~~~~}~~~~~~~~~}|}~~~~~~}~~~~~~~}|{{{||}}}}~~~~}}~~~~~~~~~~~~~}|||}~~~~~~~~~}}|||}~~~~~~~~~~~~~~~~~~~~~~}}}~~~~}~~~}}~~}}~}}||{{{|~~~~~~~~~~~~}}||}}~~~}}}}||}~~~~~~}~~~~~~~~~~~~~~~}}~~~~~~}}}}~~~}}}||}~~~~~~~~~~~~}}~~~~~~~~~}}}}}||}~~~~}~~~~~~~~~~}}}}~~~~~~}}}~~~~~}}}}~~~~~~~}~~~~~~~~}~~}}~~~~~~~~}}}}~~~~~~~~~~~~~~~~~~~~~~}}}}}~~~~~~~~~~~~~~~~~~~~~~~~~}~~~~~~~~~~~~~~~~~}}~~~~~~~~}}}}}}}~~~~~~~~~~~~~~~~~~~~~~~~~~}}~~~~~~}}}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\ No newline at end of file
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/test/MX1_def.h linux-3.13/drivers/armadeus/pwm/test/MX1_def.h
--- linux-3.13/drivers/armadeus/pwm/test/MX1_def.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/test/MX1_def.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,94 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Copyright (C) 2002 Motorola Semiconductors HK Ltd
+ *
+ */
+
+/******************************************************************************
+
+ C   H E A D E R   F I L E
+
+ (c) Copyright Motorola Semiconductors Hong Kong Limited 2001-2002
+ ALL RIGHTS RESERVED
+
+*******************************************************************************
+
+ Project Name : DBMX1 System Test Program
+ Project No.  :
+ Title        :
+ Template Ver : 0.3
+ File Name    : MX1_def.h
+ Last Modified: Nov 14, 2001
+
+ Description  : Definition header for DBMX1 silicon.
+
+ Assumptions  : NA
+
+ Dependency Comments : NA
+
+ Project Specific Data : NA
+
+******************************************************************************/
+#ifndef MX1_DEF_INC
+#define MX1_DEF_INC
+
+/*************************** Header File Includes ****************************/
+/********************************* Constants *********************************/
+/******************************** Enumeration ********************************/
+/****************************** Basic Data types *****************************/
+/************************* Structure/Union Data types ************************/
+/********************************** Macros ***********************************/
+#define PLL_BASE				0xf021B000
+#define PLL_CSCR				(PLL_BASE)
+#define PLL_PCDR				(PLL_BASE+0x20)
+
+//
+// ;---------------------------------------;
+// ; GPIO - PTA                            ;
+// ; $0021_C000 to $0021_C0FF              ;
+// ;---------------------------------------;
+#define PTA_BASE_ADDR           0xf021C000
+#define PTA_DDIR                PTA_BASE_ADDR
+#define PTA_OCR1                (PTA_BASE_ADDR+0x04)
+#define PTA_OCR2                (PTA_BASE_ADDR+0x08)
+#define PTA_ICONFA1             (PTA_BASE_ADDR+0x0C)
+#define PTA_ICONFA2             (PTA_BASE_ADDR+0x10)
+#define PTA_ICONFB1             (PTA_BASE_ADDR+0x14)
+#define PTA_ICONFB2             (PTA_BASE_ADDR+0x18)
+#define PTA_DR                  (PTA_BASE_ADDR+0x1C)
+#define PTA_GIUS                (PTA_BASE_ADDR+0x20)
+#define PTA_SSR                 (PTA_BASE_ADDR+0x24)
+#define PTA_ICR1                (PTA_BASE_ADDR+0x28)
+#define PTA_ICR2                (PTA_BASE_ADDR+0x2C)
+#define PTA_IMR                 (PTA_BASE_ADDR+0x30)
+#define PTA_ISR                 (PTA_BASE_ADDR+0x34)
+#define PTA_GPR                 (PTA_BASE_ADDR+0x38)
+#define PTA_SWR                 (PTA_BASE_ADDR+0x3C)
+#define PTA_PUEN                (PTA_BASE_ADDR+0x40)
+
+//
+// ;---------------------------------------;
+// ; PWM                                   ;
+// ; $0020_8000 to $0020_8FFF              ;
+// ;---------------------------------------;
+#define PWM1_BASE_ADDR          0xf0208000
+#define PWMC1                   PWM1_BASE_ADDR
+#define PWMS1                   (PWM1_BASE_ADDR+0x04)
+#define PWMP1                   (PWM1_BASE_ADDR+0x08)
+#define PWMCNT1                 (PWM1_BASE_ADDR+0x0C)
+#define PWMTST1                 (PWM1_BASE_ADDR+0x10)
+
+#endif
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/test/Makefile linux-3.13/drivers/armadeus/pwm/test/Makefile
--- linux-3.13/drivers/armadeus/pwm/test/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/test/Makefile	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,14 @@
+
+
+OUTPUT = .
+
+all: testtonemode testplaymode
+
+testtonemode: testtonemode.c PWM_def.h MX1_def.h
+	arm-linux-gcc -o $@ $<
+
+testplaymode: testplaymode.c PWM_def.h MX1_def.h
+	arm-linux-gcc -o $@ $<
+
+clean:
+	rm -f testtonemode testplaymode
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/test/PWM_def.h linux-3.13/drivers/armadeus/pwm/test/PWM_def.h
--- linux-3.13/drivers/armadeus/pwm/test/PWM_def.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/test/PWM_def.h	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,43 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Copyright (C) 2002 Motorola Semiconductors HK Ltd
+ *
+ */
+
+#ifndef PWM_DEF_H
+#define PWM_DEF_H
+
+#include <linux/ioctl.h>
+
+#define PWM_SAMPLING_8KHZ	8000
+#define PWM_SAMPLING_16KHZ	16000
+#define PWM_SAMPLING_32KHZ	32000
+
+#define PWM_DATA_8BIT		8
+#define PWM_DATA_16BIT		16
+
+#define	PWM_IOC_MAGIC		'p'
+#define	PWM_IOC_SFREQ		_IO(PWM_IOC_MAGIC, 0)
+#define	PWM_IOC_SDATALEN	_IO(PWM_IOC_MAGIC, 1)
+#define	PWM_IOC_SMODE		_IO(PWM_IOC_MAGIC, 2)
+#define	PWM_IOC_SSAMPLE		_IO(PWM_IOC_MAGIC, 3)
+#define	PWM_IOC_SPERIOD		_IO(PWM_IOC_MAGIC, 4)
+#define PWM_IOC_STOP		_IO(PWM_IOC_MAGIC, 5)
+
+#define	PWM_PLAY_MODE		1
+#define	PWM_TONE_MODE		2
+
+#endif
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/test/TEST8.H linux-3.13/drivers/armadeus/pwm/test/TEST8.H
--- linux-3.13/drivers/armadeus/pwm/test/TEST8.H	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/test/TEST8.H	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,6971 @@
+
+/*
+Total number of byte read : d998
+*/
+const unsigned char data[] = {
+
+
+	0x52,0x49,0x46,0x46,0x90,0xd9,00,00,
+	0x57,0x41,0x56,0x45,0x66,0x6d,0x74,0x20,
+	0x10,00,00,00,0x1,00,0x1,00,
+	0x40,0x1f,00,00,0x40,0x1f,00,00,
+	0x1,00,0x8,00,0x64,0x61,0x74,0x61,
+	0x6c,0xd9,00,00,0x80,0x88,0x9f,0xce,
+	0xbd,0x9f,0xa2,0xc8,0xbf,0x98,0x86,0x8b,
+	0xa7,0xa7,0xa1,0x95,0x98,0x98,0x90,0x82,
+	0x88,0x91,0x92,0x83,0x80,0x81,0x79,0x68,
+	0x5f,0x6a,0x71,0x6b,0x64,0x6a,0x6f,0x65,
+	0x59,0x58,0x64,0x61,0x57,0x55,0x62,0x64,
+	0x51,0x46,0x57,0x68,0x5a,0x46,0x50,0x66,
+	0x5f,0x49,0x4b,0x61,0x61,0x48,0x4b,0x67,
+	0x6b,0x51,0x4a,0x64,0x74,0x63,0x4e,0x62,
+	0x7a,0x70,0x58,0x62,0x80,0x80,0x65,0x61,
+	0x83,0x91,0x78,0x69,0x81,0x9b,0x8d,0x74,
+	0x81,0xa2,0x9c,0x7f,0x82,0xa4,0xaa,0x8c,
+	0x7f,0x9e,0xb1,0x96,0x80,0x92,0xb1,0xa1,
+	0x7e,0x84,0xa6,0xa5,0x80,0x7b,0x94,0x9f,
+	0x80,0x69,0x82,0x9d,0x80,0x5b,0x67,0x8a,
+	0x81,0x5e,0x55,0x75,0x7a,0x56,0x4a,0x69,
+	0x7a,0x5b,0x41,0x55,0x74,0x66,0x47,0x4c,
+	0x71,0x71,0x4e,0x48,0x6b,0x80,0x63,0x4e,
+	0x66,0x82,0x6c,0x57,0x67,0x89,0x7f,0x5b,
+	0x5a,0x83,0x90,0x6f,0x67,0x8e,0xb2,0xa7,
+	0x96,0xa8,0xb6,0x88,0x52,0x62,0xa5,0xb1,
+	0x92,0x8e,0xb9,0xcc,0xa7,0x8a,0x8a,0x89,
+	0x71,0x65,0x87,0xa9,0x99,0x66,0x5e,0x7d,
+	0x78,0x4e,0x40,0x5f,0x77,0x5c,0x41,0x59,
+	0x7e,0x6d,0x4a,0x56,0x7d,0x7f,0x59,0x54,
+	0x7c,0x90,0x6e,0x59,0x7c,0x9d,0x88,0x6c,
+	0x82,0xa9,0xa7,0x83,0x8b,0xb8,0xc4,0x9f,
+	0x96,0xbe,0xd6,0xbb,0xa0,0xba,0xdd,0xca,
+	0xa3,0xad,0xd3,0xcc,0x9f,0x95,0xb8,0xbf,
+	0x95,0x79,0x96,0xa8,0x87,0x61,0x70,0x90,
+	0x7f,0x52,0x56,0x7a,0x7d,0x55,0x4b,0x70,
+	0x88,0x69,0x52,0x71,0x96,0x87,0x68,0x79,
+	0xa6,0xa7,0x83,0x86,0xb2,0xc1,0xa1,0x8f,
+	0xb5,0xd0,0xb5,0x97,0xab,0xcf,0xbd,0x96,
+	0x99,0xbd,0xbc,0x92,0x80,0xa4,0xb1,0x8b,
+	0x6d,0x85,0xa1,0x84,0x5d,0x6a,0x8d,0x83,
+	0x59,0x57,0x7f,0x8a,0x66,0x55,0x7e,0x9e,
+	0x88,0x70,0x89,0x99,0x6f,0x57,0x5a,0x88,
+	0x96,0x74,0x72,0xa0,0xbb,0x9c,0x8d,0xae,
+	0xc3,0x88,0x64,0x7a,0x98,0x97,0x6e,0x72,
+	0x99,0x9f,0x71,0x63,0x82,0x93,0x6f,0x4f,
+	0x66,0x83,0x6b,0x46,0x4f,0x73,0x6b,0x46,
+	0x42,0x67,0x72,0x51,0x41,0x63,0x7e,0x69,
+	0x4f,0x68,0x8e,0x86,0x67,0x73,0x9d,0xa5,
+	0x84,0x83,0xa9,0xbd,0xa0,0x8c,0xaa,0xc6,
+	0xb0,0x93,0x9f,0xbe,0xb4,0x8c,0x8a,0xa7,
+	0xaa,0x81,0x6f,0x8a,0x96,0x75,0x58,0x69,
+	0x82,0x6d,0x4b,0x50,0x71,0x6c,0x4c,0x47,
+	0x69,0x78,0x5b,0x50,0x6d,0x8b,0x7a,0x67,
+	0x7b,0x9f,0x9d,0x83,0x8e,0xb1,0xba,0xa3,
+	0x9a,0xbb,0xcd,0xb8,0xa4,0xb7,0xcf,0xc0,
+	0xa4,0xa9,0xc1,0xbc,0x9d,0x93,0xa7,0xae,
+	0x90,0x7c,0x8a,0x99,0x85,0x6b,0x72,0x86,
+	0x80,0x68,0x68,0x81,0x8b,0x7d,0x7b,0x96,
+	0xa5,0x91,0x57,0x4b,0x77,0x63,0x53,0x60,
+	0x7b,0x8a,0x7f,0x80,0x98,0xaf,0xab,0xa3,
+	0xa9,0xa4,0x70,0x63,0x66,0x5f,0x64,0x58,
+	0x54,0x60,0x6e,0x60,0x50,0x56,0x63,0x5d,
+	0x4a,0x46,0x55,0x5a,0x46,0x3e,0x4d,0x58,
+	0x4f,0x41,0x4d,0x60,0x5f,0x52,0x59,0x6e,
+	0x75,0x6d,0x6b,0x81,0x93,0x8a,0x84,0x92,
+	0xa8,0xa7,0x98,0xa0,0xb3,0xb9,0xa8,0x9f,
+	0xb2,0xbc,0xab,0x9a,0xa4,0xaf,0xa4,0x8c,
+	0x8d,0x99,0x97,0x7b,0x72,0x81,0x83,0x6e,
+	0x5f,0x67,0x76,0x68,0x52,0x59,0x6e,0x6a,
+	0x57,0x56,0x6f,0x77,0x68,0x5f,0x77,0x8b,
+	0x81,0x73,0x83,0xa0,0x9e,0x8c,0x93,0xaf,
+	0xb7,0xa4,0x9d,0xb7,0xc5,0xb4,0xa4,0xb3,
+	0xc7,0xbb,0xa2,0xa6,0xbd,0xbb,0xa1,0x99,
+	0xaf,0xb6,0x9c,0x88,0x9a,0xac,0x98,0x80,
+	0x8a,0xa6,0xa2,0x88,0x8d,0xab,0xb3,0x94,
+	0x78,0x69,0x68,0x6f,0x54,0x55,0x6a,0x6a,
+	0x54,0x65,0x86,0x92,0x7a,0x80,0x9d,0xaf,
+	0x92,0x74,0x64,0x66,0x6d,0x50,0x47,0x5b,
+	0x5b,0x41,0x45,0x5f,0x69,0x4d,0x42,0x5a,
+	0x6a,0x54,0x40,0x4f,0x68,0x5c,0x42,0x49,
+	0x68,0x68,0x4f,0x4b,0x6c,0x79,0x64,0x59,
+	0x71,0x8c,0x80,0x6a,0x7c,0x9c,0x9a,0x82,
+	0x84,0xa6,0xb0,0x95,0x8b,0xa8,0xba,0xa5,
+	0x8c,0x9e,0xb8,0xab,0x8b,0x8f,0xab,0xa8,
+	0x85,0x7b,0x93,0x9d,0x7f,0x66,0x7c,0x8e,
+	0x79,0x59,0x63,0x7f,0x78,0x55,0x52,0x73,
+	0x7b,0x5b,0x50,0x6e,0x83,0x6e,0x58,0x6f,
+	0x8f,0x87,0x6c,0x77,0x9f,0xa2,0x87,0x84,
+	0xa7,0xbb,0xa1,0x91,0xaf,0xc7,0xb8,0x9b,
+	0xad,0xcc,0xc4,0xa2,0xa4,0xc2,0xc7,0xa5,
+	0x97,0xb1,0xc0,0xa6,0x8d,0x9e,0xb6,0xaa,
+	0x8a,0x91,0xb1,0xb1,0x95,0x90,0xaf,0xb5,
+	0x89,0x5b,0x56,0x82,0x75,0x54,0x4d,0x6c,
+	0x6b,0x54,0x5d,0x84,0x91,0x79,0x77,0x93,
+	0xa9,0x88,0x66,0x52,0x61,0x6c,0x4c,0x46,
+	0x50,0x53,0x36,0x38,0x54,0x62,0x49,0x3c,
+	0x52,0x65,0x55,0x3d,0x4b,0x65,0x5f,0x45,
+	0x47,0x66,0x6b,0x52,0x4b,0x69,0x7d,0x69,
+	0x5b,0x73,0x8e,0x86,0x6f,0x7e,0x9e,0x9e,
+	0x87,0x88,0xa6,0xb3,0x9a,0x8f,0xa8,0xbc,
+	0xa8,0x92,0x9e,0xb9,0xad,0x8e,0x91,0xaa,
+	0xa9,0x8a,0x7c,0x93,0x9d,0x81,0x6a,0x78,
+	0x8c,0x7c,0x5c,0x62,0x7c,0x77,0x58,0x52,
+	0x6e,0x79,0x5f,0x4e,0x68,0x7f,0x6f,0x59,
+	0x6a,0x89,0x85,0x6d,0x73,0x96,0xa0,0x88,
+	0x81,0xa2,0xb6,0xa5,0x93,0xa8,0xc6,0xbb,
+	0xa2,0xaa,0xc9,0xca,0xab,0xa6,0xc3,0xcc,
+	0xb1,0x9d,0xb4,0xc5,0xb2,0x96,0xa1,0xbb,
+	0xb5,0x95,0x98,0xb2,0xbc,0x9f,0x96,0xac,
+	0xb7,0x8f,0x64,0x52,0x82,0x84,0x6a,0x62,
+	0x65,0x70,0x53,0x59,0x76,0x89,0x77,0x6f,
+	0x7e,0x93,0x70,0x4b,0x37,0x61,0x6d,0x4e,
+	0x4c,0x47,0x4e,0x35,0x30,0x45,0x58,0x48,
+	0x39,0x47,0x60,0x57,0x42,0x47,0x61,0x64,
+	0x4b,0x49,0x62,0x6e,0x5f,0x50,0x67,0x7e,
+	0x73,0x62,0x6d,0x8d,0x8d,0x77,0x7a,0x98,
+	0xa5,0x91,0x86,0xa1,0xb5,0xa7,0x92,0xa3,
+	0xbd,0xb5,0x9b,0x9c,0xb7,0xba,0x9d,0x90,
+	0xa7,0xb3,0x98,0x7f,0x90,0xa2,0x8e,0x70,
+	0x74,0x8b,0x84,0x65,0x5b,0x75,0x7c,0x5f,
+	0x4e,0x65,0x78,0x63,0x4e,0x5b,0x7b,0x72,
+	0x5a,0x5e,0x7f,0x88,0x72,0x68,0x88,0x9b,
+	0x8c,0x7b,0x90,0xae,0xa8,0x91,0x9a,0xb8,
+	0xbe,0xa3,0xa0,0xb9,0xc9,0xb2,0xa1,0xb3,
+	0xcb,0xba,0xa2,0xa8,0xc1,0xbc,0xa3,0x9e,
+	0xb6,0xbd,0xa5,0x97,0xac,0xbb,0xad,0x94,
+	0x9f,0xad,0xa1,0x73,0x60,0x6b,0x8c,0x77,
+	0x6e,0x81,0x78,0x66,0x53,0x67,0x7f,0x7b,
+	0x67,0x6c,0x7d,0x75,0x4e,0x37,0x58,0x78,
+	0x5a,0x55,0x48,0x59,0x46,0x36,0x3b,0x58,
+	0x56,0x43,0x41,0x58,0x62,0x51,0x42,0x57,
+	0x68,0x5c,0x48,0x56,0x6c,0x6b,0x56,0x58,
+	0x72,0x7d,0x6a,0x61,0x7b,0x90,0x83,0x72,
+	0x85,0xa1,0x9d,0x89,0x8f,0xae,0xb4,0x9f,
+	0x98,0xb3,0xc3,0xb1,0x9d,0xaf,0xc3,0xb8,
+	0x9b,0x9e,0xb6,0xb3,0x91,0x87,0x9c,0xa2,
+	0x87,0x6c,0x7b,0x8d,0x78,0x58,0x5d,0x74,
+	0x6c,0x4e,0x46,0x62,0x69,0x50,0x3f,0x59,
+	0x6f,0x5f,0x4a,0x5c,0x7b,0x7a,0x63,0x69,
+	0x8b,0x98,0x84,0x7d,0x9c,0xb5,0xa5,0x96,
+	0xa8,0xc7,0xc2,0xa9,0xaf,0xca,0xd1,0xb8,
+	0xaf,0xc7,0xd3,0xbf,0xad,0xbb,0xcc,0xc3,
+	0xaa,0xad,0xc1,0xc1,0xab,0xa4,0xb5,0xc0,
+	0xaf,0x9f,0xa8,0xb4,0xa2,0x86,0x73,0x72,
+	0x67,0x7b,0x7a,0x86,0x99,0x6e,0x5e,0x63,
+	0x73,0x6b,0x5d,0x5a,0x5e,0x4a,0x2f,0x3b,
+	0x66,0x59,0x63,0x47,0x3e,0x41,0x38,0x2f,
+	0x34,0x41,0x43,0x3b,0x3a,0x47,0x4d,0x46,
+	0x43,0x4c,0x54,0x52,0x4c,0x51,0x5a,0x5d,
+	0x5a,0x5e,0x66,0x6d,0x6c,0x70,0x78,0x81,
+	0x83,0x87,0x8e,0x95,0x9d,0x9f,0xa3,0xac,
+	0xaf,0xb5,0xb7,0xb9,0xbc,0xbe,0xc2,0xbf,
+	0xbd,0xbc,0xbb,0xb8,0xb1,0xad,0xaa,0xa4,
+	0x9c,0x90,0x8d,0x8a,0x7f,0x72,0x6e,0x6c,
+	0x65,0x58,0x52,0x54,0x55,0x4a,0x42,0x49,
+	0x51,0x4d,0x44,0x4c,0x5b,0x5e,0x56,0x5c,
+	0x70,0x79,0x76,0x74,0x88,0x9b,0x97,0x91,
+	0x9f,0xb5,0xb6,0xaa,0xaf,0xc4,0xc9,0xbd,
+	0xb5,0xc5,0xd1,0xc4,0xb5,0xbd,0xcc,0xc6,
+	0xb2,0xb2,0xc3,0xc5,0xaf,0xa8,0xb5,0xc1,
+	0xaf,0xa0,0xab,0xb8,0xb0,0x99,0x96,0xa1,
+	0x97,0x76,0x5f,0x6a,0x8a,0x95,0x6e,0x8b,
+	0xa0,0x80,0x63,0x56,0x5f,0x53,0x34,0x2b,
+	0x53,0x71,0x4e,0x56,0x60,0x60,0x53,0x38,
+	0x3b,0x4e,0x53,0x3f,0x39,0x50,0x5d,0x4d,
+	0x40,0x4f,0x63,0x59,0x47,0x4e,0x66,0x67,
+	0x54,0x50,0x68,0x76,0x65,0x5b,0x6e,0x84,
+	0x7e,0x6c,0x78,0x94,0x98,0x86,0x85,0xa3,
+	0xb1,0x9e,0x97,0xab,0xc2,0xb7,0xa3,0xac,
+	0xc7,0xc4,0xaa,0xa4,0xbe,0xc1,0xa9,0x94,
+	0xa5,0xb3,0x9d,0x7f,0x86,0x96,0x8e,0x69,
+	0x63,0x77,0x79,0x5b,0x47,0x59,0x68,0x54,
+	0x3a,0x46,0x60,0x59,0x40,0x41,0x61,0x6a,
+	0x54,0x4d,0x6a,0x81,0x74,0x64,0x79,0x9a,
+	0x99,0x83,0x8b,0xad,0xb8,0xa2,0x9b,0xb8,
+	0xcc,0xbb,0xa8,0xb9,0xd2,0xca,0xaf,0xb4,
+	0xce,0xcf,0xb5,0xaa,0xc1,0xcd,0xb9,0xa2,
+	0xb2,0xc6,0xba,0xa1,0xa4,0xba,0xb9,0x9e,
+	0x94,0xa2,0xa3,0x84,0x64,0x68,0x7b,0x8b,
+	0x8a,0x70,0x96,0x9a,0x6b,0x4d,0x4b,0x42,
+	0x2d,0x34,0x5d,0x56,0x58,0x57,0x4c,0x58,
+	0x4b,0x34,0x30,0x44,0x49,0x3a,0x33,0x42,
+	0x52,0x49,0x39,0x44,0x58,0x54,0x44,0x46,
+	0x5a,0x61,0x53,0x4e,0x62,0x71,0x67,0x60,
+	0x6d,0x82,0x80,0x77,0x7e,0x95,0x9c,0x93,
+	0x92,0xa9,0xb6,0xae,0xa9,0xb6,0xc8,0xc4,
+	0xb6,0xbe,0xcc,0xcd,0xbc,0xb8,0xc3,0xc5,
+	0xb3,0xa7,0xab,0xad,0xa0,0x8b,0x89,0x90,
+	0x81,0x6e,0x65,0x6b,0x65,0x54,0x48,0x4e,
+	0x50,0x46,0x39,0x3f,0x49,0x46,0x3c,0x43,
+	0x50,0x55,0x4e,0x53,0x63,0x70,0x6b,0x6f,
+	0x7e,0x8c,0x8e,0x8e,0x9a,0xa7,0xaf,0xa9,
+	0xaf,0xbe,0xc4,0xbe,0xbf,0xca,0xce,0xca,
+	0xc6,0xcb,0xcf,0xcc,0xc6,0xc5,0xcb,0xc9,
+	0xc0,0xbd,0xc4,0xc3,0xbc,0xb6,0xba,0xba,
+	0xb3,0xa9,0xa6,0xa3,0x8d,0x74,0x66,0x65,
+	0x70,0x90,0x90,0x6b,0x77,0x80,0x65,0x4e,
+	0x34,0x2e,0x44,0x61,0x42,0x39,0x5a,0x5e,
+	0x56,0x44,0x35,0x2f,0x32,0x30,0x2a,0x2a,
+	0x34,0x36,0x32,0x33,0x3c,0x41,0x3e,0x3e,
+	0x45,0x4d,0x4d,0x4b,0x50,0x5c,0x60,0x5d,
+	0x63,0x6f,0x77,0x77,0x7a,0x86,0x92,0x94,
+	0x94,0x9f,0xad,0xb0,0xae,0xb7,0xc2,0xc6,
+	0xc1,0xc3,0xcc,0xd1,0xc9,0xc3,0xc8,0xcc,
+	0xc2,0xb5,0xb4,0xb7,0xae,0x9c,0x94,0x95,
+	0x90,0x7d,0x71,0x70,0x6e,0x60,0x50,0x51,
+	0x53,0x4b,0x3d,0x3a,0x46,0x44,0x3a,0x38,
+	0x47,0x4c,0x48,0x47,0x53,0x64,0x61,0x5e,
+	0x69,0x7a,0x81,0x7c,0x82,0x95,0xa1,0x99,
+	0x9c,0xaa,0xb9,0xb3,0xb0,0xb7,0xc7,0xc6,
+	0xb9,0xbc,0xcb,0xcb,0xc1,0xba,0xc5,0xcd,
+	0xc0,0xb5,0xbe,0xc6,0xbf,0xb0,0xb0,0xbc,
+	0xb7,0xa3,0x9c,0x9f,0x9a,0x80,0x6c,0x6a,
+	0x70,0x74,0x86,0x91,0x76,0x70,0x76,0x6a,
+	0x64,0x51,0x42,0x4d,0x6e,0x5e,0x3f,0x51,
+	0x68,0x6e,0x5d,0x44,0x3d,0x46,0x46,0x34,
+	0x31,0x40,0x47,0x3c,0x35,0x41,0x51,0x49,
+	0x40,0x47,0x5a,0x5a,0x4e,0x50,0x64,0x6d,
+	0x63,0x5f,0x72,0x83,0x7c,0x74,0x84,0x97,
+	0x99,0x8f,0x97,0xad,0xb4,0xa9,0xa9,0xbc,
+	0xc9,0xbf,0xb7,0xc4,0xd2,0xc9,0xb8,0xbb,
+	0xca,0xc3,0xb0,0xa8,0xb3,0xb1,0x9c,0x89,
+	0x90,0x93,0x80,0x71,0x6f,0x6f,0x60,0x54,
+	0x50,0x51,0x4e,0x48,0x3f,0x3b,0x43,0x43,
+	0x3d,0x36,0x46,0x5c,0x65,0x6e,0x7a,0x8b,
+	0x8c,0x87,0x88,0x95,0xa4,0xab,0xb6,0xc7,
+	0xd4,0xcf,0xca,0xd0,0xd5,0xd0,0xc5,0xc7,
+	0xcc,0xc8,0xbd,0xb9,0xc0,0xbf,0xb5,0xae,
+	0xb2,0xb3,0xaa,0xa1,0xa5,0xa5,0x9f,0x96,
+	0x93,0x98,0x95,0x88,0x86,0x89,0x87,0x7d,
+	0x77,0x78,0x7c,0x71,0x6a,0x69,0x6e,0x68,
+	0x5e,0x5c,0x60,0x5e,0x56,0x4f,0x55,0x55,
+	0x4c,0x46,0x4b,0x4d,0x47,0x40,0x41,0x46,
+	0x44,0x3b,0x3c,0x41,0x41,0x3c,0x38,0x3f,
+	0x42,0x3c,0x3a,0x3c,0x44,0x40,0x3e,0x3e,
+	0x46,0x47,0x43,0x43,0x4c,0x4e,0x4c,0x4c,
+	0x51,0x59,0x57,0x55,0x59,0x62,0x63,0x5f,
+	0x65,0x6b,0x70,0x6b,0x70,0x75,0x7b,0x7a,
+	0x7b,0x7c,0x8c,0x5e,0x61,0x7d,0xb6,0xa4,
+	0x7f,0x75,0xad,0xbb,0xa2,0x67,0x6e,0xac,
+	0xc9,0xaa,0x79,0x8c,0xbb,0xbc,0x89,0x77,
+	0xa0,0xbf,0x9d,0x6d,0x71,0x9c,0x9c,0x6c,
+	0x4f,0x74,0x94,0x78,0x49,0x4b,0x76,0x7f,
+	0x51,0x34,0x53,0x7c,0x69,0x3c,0x37,0x64,
+	0x7a,0x62,0x42,0x5c,0x83,0x82,0x5d,0x5b,
+	0x82,0x9d,0x80,0x60,0x7e,0xb0,0xae,0x80,
+	0x7c,0xaa,0xc7,0xa8,0x83,0x98,0xc8,0xc6,
+	0x99,0x8f,0xbc,0xd4,0xb5,0x8f,0xa3,0xd3,
+	0xd1,0xa2,0x92,0xbc,0xd8,0xb9,0x91,0x9d,
+	0xc8,0xc2,0x8e,0x77,0x95,0xa7,0x83,0x56,
+	0x63,0x92,0x97,0x72,0x6d,0x98,0xb4,0x96,
+	0x66,0x6d,0x94,0x95,0x69,0x58,0x82,0xaa,
+	0xa1,0x7f,0x91,0xc7,0xd0,0xa5,0x8d,0xac,
+	0xcb,0xb2,0x80,0x82,0xaa,0xac,0x7b,0x5e,
+	0x79,0x97,0x7c,0x50,0x50,0x78,0x81,0x58,
+	0x40,0x5f,0x83,0x74,0x4f,0x52,0x7f,0x8e,
+	0x6d,0x59,0x74,0x9b,0x92,0x70,0x76,0xa2,
+	0xb5,0x99,0x83,0xa2,0xc1,0xb2,0x78,0x6a,
+	0x9c,0xa8,0x81,0x5b,0x74,0x96,0x90,0x6e,
+	0x70,0x8e,0x95,0x65,0x3c,0x5d,0x73,0x61,
+	0x40,0x42,0x62,0x78,0x65,0x54,0x6b,0x8c,
+	0x88,0x6c,0x6d,0x89,0x9a,0x7e,0x63,0x70,
+	0x89,0x80,0x5d,0x59,0x79,0x8d,0x79,0x66,
+	0x7d,0xa3,0xa2,0x87,0x80,0xa1,0xae,0x91,
+	0x71,0x7b,0x95,0x8b,0x65,0x5c,0x7c,0x90,
+	0x79,0x63,0x76,0x9e,0x9c,0x7b,0x72,0x96,
+	0xa8,0x94,0x7c,0x9b,0xab,0x8e,0x63,0x5c,
+	0x87,0x98,0x7d,0x59,0x63,0x86,0x83,0x62,
+	0x65,0x8d,0x7f,0x59,0x3a,0x58,0x85,0x89,
+	0x6a,0x65,0x8b,0xa8,0x94,0x74,0x83,0xa4,
+	0x9e,0x6e,0x58,0x6f,0x7b,0x5d,0x39,0x46,
+	0x6d,0x76,0x5e,0x62,0x8e,0xb4,0xaa,0x96,
+	0xa7,0xc7,0xc1,0x9b,0x87,0x93,0x9b,0x7b,
+	0x5a,0x5f,0x78,0x7c,0x63,0x61,0x80,0x9a,
+	0x8e,0x81,0x8f,0xaf,0xb2,0xa5,0xab,0xc1,
+	0xa0,0x85,0x68,0x78,0x8c,0x87,0x6d,0x63,
+	0x71,0x79,0x68,0x5e,0x6e,0x8e,0x72,0x44,
+	0x46,0x58,0x75,0x6b,0x70,0x7e,0x96,0x95,
+	0x8e,0x8e,0x9d,0x9c,0x88,0x75,0x73,0x72,
+	0x61,0x4b,0x48,0x56,0x5d,0x55,0x5e,0x78,
+	0x91,0x97,0x9a,0xa9,0xbe,0xbe,0xab,0xa3,
+	0xa5,0x9f,0x86,0x71,0x6f,0x79,0x6f,0x62,
+	0x64,0x77,0x84,0x7f,0x7d,0x8f,0xa6,0xa7,
+	0x9f,0xac,0xc9,0xc5,0x8a,0x80,0x7d,0x8e,
+	0x84,0x70,0x6e,0x7d,0x7a,0x63,0x5b,0x6b,
+	0x81,0x7f,0x67,0x45,0x5e,0x59,0x52,0x55,
+	0x75,0x8e,0x8a,0x7d,0x88,0xa6,0xa4,0x8a,
+	0x79,0x84,0x8a,0x70,0x4e,0x4b,0x62,0x5f,
+	0x48,0x47,0x66,0x85,0x83,0x7c,0x93,0xb7,
+	0xc0,0xa7,0xa1,0xb0,0xb9,0x9e,0x7b,0x77,
+	0x8a,0x81,0x62,0x55,0x6d,0x84,0x77,0x68,
+	0x77,0x9b,0xa2,0x8e,0x8e,0xaf,0xc9,0xba,
+	0x80,0x82,0x94,0x92,0x79,0x69,0x81,0x8b,
+	0x78,0x57,0x60,0x79,0x82,0x68,0x66,0x66,
+	0x70,0x60,0x3e,0x58,0x7f,0x8d,0x75,0x71,
+	0x92,0xac,0x98,0x7a,0x7e,0x96,0x91,0x65,
+	0x4c,0x61,0x72,0x5b,0x3c,0x4a,0x75,0x84,
+	0x70,0x6e,0x97,0xbd,0xb3,0x9a,0xa1,0xc0,
+	0xc1,0x97,0x7a,0x8a,0x9a,0x81,0x5a,0x5b,
+	0x79,0x86,0x6c,0x5e,0x7c,0xa5,0x9d,0x88,
+	0x94,0xc4,0xd7,0xb6,0x7a,0x8e,0xa6,0x8c,
+	0x6d,0x66,0x88,0x91,0x73,0x58,0x68,0x88,
+	0x83,0x65,0x66,0x76,0x6a,0x5c,0x3a,0x4e,
+	0x79,0x7e,0x68,0x6a,0x8e,0xa8,0x90,0x77,
+	0x82,0x9a,0x92,0x6a,0x57,0x6a,0x77,0x5f,
+	0x41,0x4e,0x73,0x7c,0x69,0x67,0x8f,0xb1,
+	0xa7,0x90,0x9d,0xbd,0xbc,0x99,0x81,0x92,
+	0xa1,0x88,0x64,0x65,0x82,0x8a,0x6e,0x62,
+	0x82,0xa3,0x9c,0x8a,0x95,0xc1,0xce,0xb6,
+	0x89,0x8b,0xad,0x8e,0x68,0x68,0x86,0x8f,
+	0x71,0x5b,0x6c,0x89,0x80,0x64,0x66,0x80,
+	0x6a,0x4d,0x40,0x43,0x6b,0x6b,0x5b,0x60,
+	0x88,0xa0,0x8c,0x73,0x85,0xa0,0x95,0x6b,
+	0x5a,0x71,0x7b,0x5b,0x3b,0x49,0x6f,0x73,
+	0x5b,0x5e,0x8b,0xad,0xa3,0x90,0xa4,0xc9,
+	0xc8,0xa0,0x8d,0xa1,0xac,0x8c,0x65,0x66,
+	0x83,0x86,0x67,0x5b,0x7e,0xa1,0x98,0x85,
+	0x96,0xc3,0xd6,0xc1,0xab,0x99,0xac,0xa3,
+	0x6b,0x66,0x86,0x8e,0x71,0x5b,0x6b,0x89,
+	0x80,0x65,0x65,0x82,0x73,0x3f,0x3a,0x42,
+	0x53,0x5a,0x49,0x4e,0x78,0x93,0x87,0x71,
+	0x82,0x9f,0x99,0x78,0x63,0x74,0x7f,0x66,
+	0x45,0x49,0x66,0x71,0x59,0x57,0x79,0x9f,
+	0x9d,0x8d,0x9a,0xbd,0xc6,0xaa,0x95,0xa2,
+	0xb0,0x9a,0x76,0x6d,0x84,0x8a,0x72,0x64,
+	0x79,0x98,0x9c,0x8c,0x93,0xba,0xd0,0xc9,
+	0xbb,0xc0,0xac,0x9f,0x90,0x6e,0x7a,0x84,
+	0x75,0x60,0x68,0x81,0x80,0x6a,0x6b,0x7c,
+	0x85,0x4f,0x31,0x48,0x4d,0x4b,0x40,0x45,
+	0x63,0x7d,0x7e,0x73,0x7b,0x94,0x98,0x82,
+	0x74,0x7a,0x84,0x72,0x59,0x57,0x67,0x6f,
+	0x5f,0x5a,0x70,0x8b,0x8f,0x85,0x8f,0xaa,
+	0xb6,0xa7,0x98,0xa1,0xa9,0x9d,0x83,0x7a,
+	0x86,0x89,0x7a,0x6d,0x7c,0x92,0x97,0x8e,
+	0x98,0xb2,0xc7,0xc4,0xc2,0xcc,0xd2,0xa1,
+	0x89,0x92,0x89,0x7c,0x6e,0x61,0x69,0x79,
+	0x7d,0x6f,0x6f,0x7d,0x83,0x5b,0x2a,0x40,
+	0x50,0x3d,0x2f,0x34,0x4b,0x65,0x68,0x66,
+	0x71,0x88,0x8f,0x85,0x7a,0x83,0x8b,0x80,
+	0x6b,0x68,0x70,0x74,0x64,0x60,0x6d,0x82,
+	0x82,0x7e,0x85,0x9c,0xa6,0x9d,0x94,0x9b,
+	0xa5,0x9b,0x87,0x81,0x88,0x8c,0x7e,0x74,
+	0x7d,0x93,0x93,0x8d,0x92,0xa8,0xba,0xb9,
+	0xb6,0xc5,0xd7,0xd0,0xa1,0x7d,0x99,0xa2,
+	0x80,0x5e,0x66,0x75,0x7c,0x6f,0x6e,0x7f,
+	0x86,0x70,0x35,0x39,0x58,0x51,0x2e,0x25,
+	0x3c,0x54,0x57,0x53,0x5e,0x79,0x84,0x7c,
+	0x77,0x82,0x93,0x90,0x78,0x76,0x84,0x89,
+	0x78,0x6b,0x75,0x86,0x87,0x78,0x77,0x8b,
+	0x9b,0x8f,0x7f,0x87,0x97,0x96,0x7f,0x78,
+	0x84,0x91,0x84,0x76,0x7b,0x94,0x9b,0x90,
+	0x8c,0xa2,0xb7,0xb7,0xaa,0xb2,0xc7,0xd4,
+	0xbb,0xa0,0x87,0x98,0x9d,0x83,0x6d,0x71,
+	0x7e,0x71,0x68,0x73,0x88,0x7f,0x4f,0x33,
+	0x59,0x65,0x4e,0x28,0x35,0x4c,0x5a,0x4d,
+	0x4c,0x63,0x7c,0x78,0x6c,0x74,0x8d,0x97,
+	0x89,0x7a,0x8a,0x9b,0x95,0x7d,0x79,0x8c,
+	0x97,0x85,0x73,0x7c,0x92,0x90,0x7a,0x71,
+	0x84,0x92,0x84,0x6e,0x74,0x89,0x8e,0x7a,
+	0x73,0x84,0x9b,0x98,0x88,0x8d,0xa9,0xb6,
+	0xa8,0x9b,0xad,0xc4,0xc2,0xad,0xa3,0xa6,
+	0x96,0x8c,0x7f,0x80,0x87,0x7f,0x6f,0x66,
+	0x7b,0x87,0x72,0x3f,0x4c,0x68,0x6c,0x4d,
+	0x34,0x45,0x5a,0x5b,0x4a,0x4f,0x69,0x7a,
+	0x70,0x66,0x75,0x8f,0x92,0x82,0x7b,0x93,
+	0xa1,0x95,0x81,0x85,0x98,0x9b,0x83,0x77,
+	0x80,0x92,0x89,0x6f,0x6c,0x81,0x88,0x77,
+	0x65,0x72,0x88,0x87,0x76,0x72,0x8b,0x9c,
+	0x94,0x86,0x90,0xab,0xb2,0x9f,0x97,0xab,
+	0xbc,0xb6,0xa1,0xa0,0xb1,0xa8,0x7f,0x76,
+	0x87,0x97,0x84,0x6a,0x69,0x7c,0x86,0x65,
+	0x43,0x58,0x6e,0x6c,0x47,0x3a,0x4a,0x5e,
+	0x58,0x49,0x4f,0x68,0x75,0x6a,0x63,0x73,
+	0x8d,0x8e,0x7e,0x80,0x95,0xa3,0x98,0x87,
+	0x8e,0x9e,0x9d,0x87,0x7c,0x85,0x8d,0x84,
+	0x6e,0x6b,0x79,0x81,0x70,0x64,0x6f,0x81,
+	0x83,0x76,0x76,0x88,0x97,0x94,0x89,0x8f,
+	0xa3,0xa9,0x9d,0x95,0xa0,0xad,0xaa,0x9b,
+	0x9a,0xa3,0xa8,0x8b,0x72,0x83,0x8f,0x8c,
+	0x74,0x6f,0x76,0x80,0x6a,0x57,0x62,0x6d,
+	0x6f,0x58,0x4d,0x53,0x63,0x64,0x5c,0x57,
+	0x67,0x74,0x75,0x6a,0x6f,0x84,0x8d,0x85,
+	0x81,0x8a,0x9b,0x9b,0x8c,0x88,0x92,0x9a,
+	0x8f,0x7e,0x7c,0x87,0x88,0x76,0x6b,0x72,
+	0x7e,0x78,0x6c,0x6a,0x7c,0x86,0x7f,0x74,
+	0x7f,0x93,0x97,0x8d,0x87,0x96,0xa4,0x9d,
+	0x8e,0x90,0xa0,0xa6,0x9a,0x8b,0x94,0xa2,
+	0x95,0x76,0x77,0x89,0x93,0x80,0x6e,0x6f,
+	0x7d,0x74,0x68,0x61,0x6e,0x76,0x6b,0x58,
+	0x56,0x6b,0x74,0x68,0x5b,0x66,0x7c,0x7e,
+	0x6d,0x6b,0x7f,0x92,0x89,0x7b,0x81,0x98,
+	0x9d,0x8c,0x7f,0x8c,0x9d,0x92,0x79,0x76,
+	0x88,0x8d,0x79,0x67,0x6e,0x82,0x80,0x6b,
+	0x67,0x7b,0x8c,0x82,0x72,0x79,0x95,0x9a,
+	0x87,0x7e,0x8f,0xa3,0x9b,0x85,0x86,0x9b,
+	0xa3,0x92,0x80,0x8c,0x9e,0x97,0x74,0x72,
+	0x8a,0x95,0x80,0x6b,0x71,0x80,0x7b,0x6c,
+	0x62,0x75,0x7e,0x70,0x5b,0x5e,0x77,0x7c,
+	0x6c,0x5e,0x6d,0x83,0x7f,0x6c,0x6d,0x85,
+	0x93,0x86,0x76,0x82,0x99,0x99,0x84,0x7c,
+	0x8d,0x9b,0x8b,0x76,0x77,0x8b,0x8a,0x76,
+	0x68,0x76,0x86,0x7f,0x6b,0x6c,0x82,0x8c,
+	0x7f,0x72,0x7f,0x95,0x93,0x81,0x7e,0x90,
+	0x9d,0x91,0x80,0x85,0x9a,0x99,0x89,0x7e,
+	0x8d,0x9a,0x8c,0x74,0x76,0x8c,0x90,0x7b,
+	0x6e,0x77,0x81,0x7a,0x6f,0x6b,0x7b,0x7c,
+	0x72,0x63,0x6a,0x7c,0x7c,0x6d,0x68,0x77,
+	0x82,0x7c,0x71,0x74,0x87,0x8d,0x81,0x7a,
+	0x85,0x93,0x90,0x81,0x80,0x8e,0x91,0x85,
+	0x78,0x7e,0x86,0x84,0x76,0x71,0x7b,0x82,
+	0x7b,0x71,0x76,0x83,0x86,0x7c,0x7a,0x83,
+	0x8e,0x8b,0x80,0x84,0x8e,0x90,0x8a,0x83,
+	0x88,0x8f,0x8f,0x86,0x83,0x8a,0x8e,0x85,
+	0x7a,0x7e,0x87,0x87,0x7c,0x77,0x79,0x7b,
+	0x7a,0x75,0x76,0x79,0x78,0x73,0x6f,0x74,
+	0x7a,0x79,0x74,0x72,0x7a,0x7e,0x7c,0x79,
+	0x7b,0x84,0x85,0x82,0x80,0x87,0x89,0x8a,
+	0x84,0x83,0x86,0x89,0x84,0x7f,0x7f,0x81,
+	0x80,0x7c,0x77,0x7c,0x7c,0x7e,0x77,0x7b,
+	0x7e,0x82,0x81,0x7e,0x82,0x87,0x88,0x85,
+	0x85,0x87,0x8a,0x89,0x85,0x84,0x8a,0x8b,
+	0x87,0x83,0x84,0x87,0x84,0x7f,0x7d,0x82,
+	0x84,0x80,0x79,0x79,0x7a,0x80,0x7a,0x76,
+	0x76,0x7c,0x79,0x74,0x74,0x79,0x7e,0x7b,
+	0x75,0x77,0x80,0x82,0x7c,0x7a,0x82,0x87,
+	0x85,0x7f,0x80,0x88,0x8b,0x83,0x7e,0x84,
+	0x88,0x86,0x7c,0x7a,0x80,0x86,0x7c,0x76,
+	0x7b,0x82,0x82,0x78,0x78,0x7f,0x87,0x82,
+	0x7c,0x7e,0x89,0x8a,0x83,0x7e,0x84,0x8d,
+	0x89,0x80,0x7f,0x89,0x8d,0x85,0x7c,0x81,
+	0x89,0x86,0x7b,0x7a,0x83,0x87,0x80,0x75,
+	0x76,0x82,0x83,0x78,0x73,0x79,0x83,0x7c,
+	0x73,0x74,0x7e,0x84,0x79,0x73,0x7c,0x86,
+	0x82,0x79,0x77,0x85,0x8b,0x80,0x7a,0x82,
+	0x8c,0x89,0x7b,0x7c,0x85,0x8a,0x82,0x77,
+	0x7c,0x87,0x83,0x78,0x75,0x80,0x87,0x7e,
+	0x76,0x7c,0x86,0x88,0x7c,0x78,0x84,0x8b,
+	0x85,0x7a,0x7f,0x8b,0x8b,0x81,0x7a,0x85,
+	0x8d,0x85,0x7d,0x7d,0x88,0x87,0x7f,0x78,
+	0x7f,0x88,0x83,0x77,0x78,0x80,0x85,0x7b,
+	0x75,0x7a,0x83,0x81,0x75,0x75,0x7f,0x84,
+	0x7c,0x74,0x7b,0x86,0x83,0x79,0x79,0x84,
+	0x89,0x82,0x7a,0x7f,0x88,0x89,0x7d,0x7b,
+	0x83,0x89,0x82,0x79,0x7b,0x85,0x85,0x7b,
+	0x79,0x7e,0x86,0x80,0x79,0x7b,0x84,0x87,
+	0x7f,0x7a,0x80,0x89,0x86,0x7d,0x7d,0x86,
+	0x88,0x83,0x7d,0x81,0x88,0x88,0x7f,0x7d,
+	0x83,0x85,0x82,0x7b,0x7e,0x84,0x84,0x7c,
+	0x79,0x7e,0x84,0x7f,0x78,0x7c,0x80,0x82,
+	0x7b,0x78,0x7b,0x82,0x7f,0x7b,0x79,0x81,
+	0x84,0x80,0x7a,0x7f,0x86,0x85,0x7d,0x7d,
+	0x81,0x88,0x82,0x7c,0x7d,0x86,0x84,0x7e,
+	0x7c,0x7f,0x84,0x82,0x7b,0x7c,0x81,0x84,
+	0x7f,0x7b,0x7e,0x84,0x81,0x7f,0x7c,0x82,
+	0x86,0x82,0x7e,0x7f,0x86,0x85,0x80,0x7f,
+	0x81,0x88,0x82,0x7e,0x7e,0x84,0x83,0x82,
+	0x7c,0x85,0x83,0x7b,0x76,0x87,0x89,0x7e,
+	0x78,0x7f,0x80,0x7d,0x7a,0x7d,0x80,0x7f,
+	0x7b,0x7e,0x80,0x82,0x7b,0x7d,0x80,0x81,
+	0x7f,0x7e,0x80,0x82,0x81,0x7f,0x7d,0x81,
+	0x82,0x80,0x7e,0x80,0x81,0x81,0x7e,0x7f,
+	0x81,0x81,0x7e,0x81,0x7e,0x81,0x80,0x80,
+	0x7e,0x81,0x7f,0x82,0x7d,0x81,0x7f,0x81,
+	0x7e,0x82,0x80,0x80,0x7f,0x81,0x7f,0x80,
+	0x7e,0x81,0x7f,0x81,0x7d,0x82,0x80,0x82,
+	0x7d,0x81,0x80,0x81,0x7f,0x80,0x7e,0x84,
+	0x7e,0x81,0x7c,0x82,0x81,0x81,0x7c,0x81,
+	0x81,0x83,0x7c,0x81,0x7e,0x84,0x7e,0x7e,
+	0x7f,0x84,0x7f,0x7f,0x7c,0x84,0x81,0x81,
+	0x7a,0x82,0x80,0x84,0x7b,0x81,0x7e,0x87,
+	0x7c,0x7f,0x7d,0x86,0x7e,0x82,0x79,0x86,
+	0x80,0x82,0x79,0x85,0x7d,0x87,0x78,0x82,
+	0x7c,0x82,0x4b,0x74,0x6b,0xb3,0x7f,0x86,
+	0x50,0x95,0x87,0xa7,0x43,0x62,0x60,0xbc,
+	0x96,0x83,0x48,0x7c,0x9d,0xad,0x76,0x57,
+	0x6c,0x99,0xa6,0x74,0x59,0x58,0x9a,0x94,
+	0x87,0x40,0x65,0x75,0xab,0x62,0x5c,0x39,
+	0x8f,0x79,0x88,0x29,0x5c,0x53,0x9e,0x50,
+	0x62,0x27,0x86,0x62,0x8a,0x28,0x60,0x47,
+	0x9e,0x4a,0x60,0x23,0x8b,0x68,0x8d,0x2b,
+	0x64,0x50,0xa6,0x5d,0x6c,0x32,0x8a,0x79,
+	0x9a,0x47,0x69,0x64,0xad,0x7d,0x7a,0x4e,
+	0x91,0x94,0xaa,0x68,0x75,0x7d,0xb7,0x9c,
+	0x88,0x6a,0x95,0xad,0xb5,0x84,0x77,0x8c,
+	0xb6,0xb3,0x8b,0x74,0x89,0xb4,0xad,0x8d,
+	0x6a,0x86,0xa6,0xb2,0x7c,0x67,0x6d,0xa5,
+	0x9e,0x82,0x4c,0x69,0x84,0x9a,0x6b,0x53,
+	0x4d,0x7d,0x81,0x67,0x3d,0x4e,0x6b,0x7c,
+	0x5b,0x3a,0x3f,0x6b,0x7e,0x5f,0x3d,0x3f,
+	0x6b,0x79,0x6f,0x44,0x4f,0x6a,0x8c,0x68,
+	0x55,0x4c,0x80,0x86,0x82,0x4c,0x5e,0x75,
+	0xa5,0x89,0x85,0x7b,0xbd,0xce,0xc8,0x7a,
+	0x62,0x65,0x97,0x9b,0x94,0x88,0xb0,0xc8,
+	0xcb,0xa4,0x93,0x8f,0x81,0x79,0x6b,0x83,
+	0x8d,0xa8,0x81,0x6e,0x49,0x6e,0x60,0x75,
+	0x3a,0x56,0x4a,0x82,0x57,0x68,0x3b,0x79,
+	0x62,0x89,0x46,0x74,0x54,0x9d,0x62,0x87,
+	0x4d,0x97,0x73,0xa8,0x61,0x9a,0x73,0xbf,
+	0x84,0xad,0x77,0xc1,0x9c,0xcc,0x8b,0xbe,
+	0x9b,0xda,0xa4,0xc5,0x92,0xcd,0xab,0xce,
+	0x94,0xb4,0x97,0xc4,0x94,0xa2,0x7a,0xa0,
+	0x89,0x99,0x68,0x7a,0x6b,0x8b,0x69,0x6a,
+	0x52,0x71,0x6d,0x73,0x56,0x5f,0x68,0x81,
+	0x75,0x6c,0x6a,0x84,0x96,0x93,0x86,0x88,
+	0xa2,0xb6,0xb4,0x9d,0xa4,0xb8,0xcd,0xc0,
+	0xae,0xa9,0xc0,0xcd,0xc1,0xa3,0x9e,0xb1,
+	0xbd,0xac,0x8f,0x86,0x95,0xa7,0x8e,0x78,
+	0x65,0x83,0x84,0x85,0x55,0x63,0x62,0x8c,
+	0x69,0x6a,0x4a,0x83,0x7e,0x9c,0x68,0x8c,
+	0x7e,0xa7,0x5c,0x78,0x43,0x8c,0x84,0xaf,
+	0x70,0x9b,0x8e,0xda,0xa7,0xb2,0x57,0x98,
+	0x89,0xa4,0x68,0x86,0x75,0xb0,0x88,0x8a,
+	0x59,0x89,0x7d,0x95,0x5b,0x62,0x57,0x83,
+	0x6b,0x60,0x3e,0x57,0x65,0x6d,0x4e,0x42,
+	0x4c,0x68,0x6f,0x57,0x4e,0x55,0x7e,0x7a,
+	0x7b,0x5a,0x7e,0x88,0xac,0x82,0x90,0x7f,
+	0xbd,0xa7,0xb8,0x83,0xb2,0xa3,0xd5,0x99,
+	0xad,0x85,0xc5,0xa1,0xb7,0x70,0x9b,0x80,
+	0xb4,0x6f,0x82,0x50,0x8d,0x6a,0x83,0x3a,
+	0x64,0x4d,0x83,0x4b,0x5d,0x34,0x73,0x5f,
+	0x7b,0x44,0x69,0x62,0x99,0x75,0x82,0x68,
+	0x9d,0x9d,0xb0,0x88,0x9b,0xa3,0xcc,0xb5,
+	0xae,0x9c,0xbd,0xc7,0xc7,0xa6,0xa3,0xad,
+	0xc4,0xb6,0x9a,0x8b,0x9a,0xab,0x9f,0x83,
+	0x70,0x81,0x8e,0x8a,0x6b,0x5e,0x69,0x81,
+	0x7c,0x65,0x56,0x6b,0x88,0x8b,0x7b,0x75,
+	0x8c,0xa0,0x91,0x4f,0x57,0x63,0x7b,0x83,
+	0x80,0x73,0x95,0xae,0xc4,0x92,0x73,0x52,
+	0x95,0x80,0x6e,0x47,0x6e,0x74,0x90,0x62,
+	0x67,0x55,0x85,0x6e,0x70,0x3d,0x5c,0x58,
+	0x76,0x44,0x46,0x33,0x61,0x53,0x51,0x2d,
+	0x42,0x4d,0x68,0x4e,0x46,0x47,0x68,0x76,
+	0x6f,0x5f,0x68,0x8a,0x96,0x99,0x7f,0x95,
+	0xa1,0xc7,0xac,0xae,0x99,0xcb,0xc2,0xd2,
+	0x9c,0xb8,0xa8,0xda,0xa8,0xaf,0x7d,0xb4,
+	0x96,0xaf,0x64,0x83,0x61,0x9d,0x5d,0x70,
+	0x31,0x70,0x50,0x78,0x2f,0x53,0x34,0x79,
+	0x4d,0x65,0x30,0x70,0x62,0x92,0x5a,0x76,
+	0x69,0xaa,0x92,0xa1,0x7b,0xa7,0xad,0xcb,
+	0xa7,0xa9,0xa5,0xce,0xca,0xbe,0xa3,0xae,
+	0xc3,0xcb,0xb8,0x99,0xa0,0xad,0xc1,0x9c,
+	0x91,0x7c,0xa7,0x97,0x9f,0x65,0x81,0x78,
+	0xa9,0x75,0x81,0x56,0x99,0x87,0xa8,0x68,
+	0x92,0x80,0xc1,0x7f,0x75,0x2e,0x8f,0x77,
+	0x97,0x4a,0x7f,0x68,0xbe,0x88,0x96,0x39,
+	0x6a,0x6f,0x97,0x45,0x52,0x45,0x83,0x68,
+	0x70,0x3f,0x66,0x68,0x83,0x53,0x4e,0x44,
+	0x6a,0x66,0x55,0x36,0x3e,0x56,0x5e,0x4d,
+	0x2f,0x3c,0x4b,0x69,0x4b,0x45,0x3a,0x69,
+	0x6b,0x77,0x50,0x6e,0x70,0xa4,0x84,0x94,
+	0x74,0xaf,0xa9,0xca,0x94,0xb3,0xa4,0xe2,
+	0xbb,0xc8,0x98,0xca,0xb7,0xd9,0x9a,0xab,
+	0x8b,0xbd,0x98,0x9d,0x65,0x82,0x75,0x8e,
+	0x5c,0x5a,0x43,0x66,0x5c,0x59,0x34,0x43,
+	0x4c,0x61,0x51,0x44,0x44,0x5c,0x73,0x6b,
+	0x65,0x61,0x80,0x8e,0x9c,0x82,0x92,0x93,
+	0xbf,0xac,0xb6,0x99,0xc0,0xb9,0xd6,0xab,
+	0xbe,0xa6,0xd5,0xb7,0xc5,0x96,0xb9,0xa4,
+	0xc8,0x95,0xa1,0x83,0xad,0x92,0xa2,0x72,
+	0x8d,0x7f,0xa1,0x7d,0x84,0x6e,0x91,0x8c,
+	0x99,0x7f,0x8d,0x92,0xab,0x9a,0x85,0x62,
+	0x64,0x8e,0x8b,0x7f,0x62,0x7e,0x79,0x7e,
+	0x46,0x47,0x58,0x77,0x5a,0x54,0x38,0x5c,
+	0x51,0x71,0x4b,0x64,0x49,0x72,0x53,0x6a,
+	0x3d,0x5b,0x3d,0x63,0x33,0x4d,0x2b,0x56,
+	0x36,0x51,0x2a,0x4b,0x38,0x5a,0x3c,0x55,
+	0x41,0x64,0x5a,0x6e,0x5f,0x76,0x78,0x8f,
+	0x8a,0x93,0x98,0xa8,0xb2,0xb5,0xb7,0xb9,
+	0xca,0xc8,0xd0,0xbe,0xcf,0xc2,0xd4,0xb8,
+	0xc3,0xa7,0xbf,0x9f,0xae,0x82,0x96,0x75,
+	0x90,0x61,0x73,0x46,0x69,0x45,0x5e,0x30,
+	0x4c,0x30,0x57,0x33,0x4d,0x30,0x55,0x48,
+	0x65,0x4c,0x66,0x61,0x83,0x7b,0x8a,0x82,
+	0x96,0xa2,0xaf,0xac,0xa9,0xb8,0xbe,0xce,
+	0xbd,0xc4,0xb7,0xd5,0xc1,0xd2,0xac,0xc3,
+	0xb0,0xcf,0xa5,0xb7,0x90,0xb8,0x9b,0xb2,
+	0x7f,0x9c,0x80,0xae,0x89,0x9d,0x7a,0xa3,
+	0x8f,0xac,0x85,0x9c,0x8f,0xb4,0xa2,0xa3,
+	0x83,0x8a,0x75,0x7d,0x8b,0x7c,0x81,0x69,
+	0x54,0x25,0x34,0x46,0x5e,0x5b,0x44,0x2a,
+	0x3d,0x40,0x61,0x45,0x53,0x39,0x64,0x55,
+	0x69,0x3c,0x54,0x44,0x6d,0x49,0x54,0x2f,
+	0x57,0x48,0x62,0x36,0x47,0x3a,0x66,0x50,
+	0x58,0x3d,0x5c,0x62,0x77,0x63,0x65,0x6a,
+	0x8b,0x93,0x8f,0x87,0x92,0xae,0xb8,0xb9,
+	0xa6,0xb5,0xc1,0xdd,0xc5,0xc3,0xb1,0xd2,
+	0xcd,0xd3,0xa9,0xb0,0xa7,0xc3,0xa2,0x9b,
+	0x73,0x8e,0x81,0x8b,0x5a,0x5c,0x4b,0x6b,
+	0x54,0x4d,0x2b,0x40,0x47,0x58,0x3c,0x36,
+	0x37,0x57,0x61,0x5c,0x4b,0x59,0x73,0x89,
+	0x83,0x78,0x7f,0x9a,0xb3,0xae,0xa1,0x9e,
+	0xba,0xcc,0xce,0xb7,0xb2,0xc0,0xd6,0xd2,
+	0xbd,0xaf,0xb7,0xcc,0xc8,0xb4,0x9d,0xa7,
+	0xb5,0xbb,0xa2,0x92,0x8f,0xa7,0xaa,0x9e,
+	0x84,0x8c,0x9c,0xac,0xa0,0x8e,0x90,0xa3,
+	0xb7,0xa8,0x92,0x7c,0x84,0x77,0x86,0x77,
+	0x61,0x5c,0x4d,0x42,0x52,0x2c,0x59,0x40,
+	0x54,0x2a,0x38,0x2d,0x5f,0x4f,0x58,0x35,
+	0x51,0x52,0x6e,0x4c,0x4c,0x3d,0x5f,0x5b,
+	0x5b,0x3b,0x42,0x4d,0x5e,0x55,0x40,0x41,
+	0x4d,0x67,0x59,0x58,0x43,0x68,0x6b,0x85,
+	0x63,0x7d,0x72,0xa7,0x93,0xa7,0x84,0xb2,
+	0xab,0xd5,0xab,0xc1,0xac,0xde,0xca,0xd9,
+	0xaf,0xc7,0xbf,0xdb,0xb7,0xb2,0x9c,0xb0,
+	0xab,0xa1,0x81,0x78,0x7b,0x7f,0x75,0x55,
+	0x50,0x4c,0x60,0x4a,0x47,0x2b,0x45,0x40,
+	0x56,0x35,0x43,0x39,0x63,0x56,0x68,0x4a,
+	0x6f,0x71,0x94,0x7c,0x8b,0x83,0xaa,0xa9,
+	0xb5,0xa2,0xb1,0xba,0xce,0xc3,0xbf,0xb9,
+	0xc7,0xd0,0xcb,0xbf,0xb7,0xbe,0xc5,0xc2,
+	0xb2,0xab,0xab,0xb3,0xb2,0xa4,0x9c,0x9c,
+	0xa7,0xa5,0xa1,0x95,0x9e,0x9f,0xae,0x9f,
+	0xa4,0x9c,0xae,0xa0,0xa1,0x80,0x74,0x5e,
+	0x77,0x72,0x4f,0x50,0x56,0x5d,0x40,0x55,
+	0x3d,0x37,0x2c,0x36,0x29,0x3a,0x2f,0x47,
+	0x36,0x4e,0x39,0x53,0x3b,0x56,0x3b,0x59,
+	0x3c,0x58,0x3b,0x57,0x40,0x5a,0x3e,0x58,
+	0x45,0x5e,0x4f,0x5f,0x53,0x64,0x66,0x72,
+	0x70,0x73,0x7e,0x85,0x97,0x90,0x9c,0x98,
+	0xb3,0xae,0xc3,0xab,0xc6,0xba,0xdb,0xbf,
+	0xd2,0xb6,0xd6,0xc0,0xd5,0xaf,0xbb,0xa4,
+	0xbd,0xa2,0x9e,0x81,0x8d,0x80,0x86,0x66,
+	0x5f,0x53,0x5f,0x58,0x49,0x3b,0x39,0x46,
+	0x49,0x43,0x32,0x3c,0x48,0x5c,0x51,0x50,
+	0x50,0x6c,0x78,0x80,0x74,0x7a,0x8f,0xa6,
+	0xa9,0x9e,0x9f,0xae,0xc8,0xc3,0xba,0xae,
+	0xbe,0xcf,0xd5,0xbf,0xb5,0xb9,0xce,0xce,
+	0xbe,0xab,0xaf,0xbf,0xc2,0xb7,0x9c,0xa5,
+	0xab,0xc0,0xa6,0xa1,0x91,0xb1,0xad,0xb7,
+	0x90,0x9e,0x97,0xb8,0x91,0x89,0x59,0x6d,
+	0x60,0x87,0x56,0x40,0x51,0x78,0x6f,0x4e,
+	0x44,0x57,0x4d,0x53,0x35,0x2e,0x34,0x49,
+	0x52,0x45,0x3b,0x3c,0x59,0x58,0x57,0x3c,
+	0x4b,0x4f,0x6a,0x4e,0x50,0x3a,0x64,0x5a,
+	0x69,0x42,0x59,0x52,0x7d,0x63,0x6b,0x51,
+	0x7b,0x7a,0x92,0x6f,0x82,0x80,0xaa,0x9f,
+	0xa0,0x91,0xa9,0xb9,0xc3,0xb5,0xaa,0xb5,
+	0xc7,0xd1,0xba,0xb3,0xad,0xc5,0xbf,0xb9,
+	0x95,0xa0,0x9b,0xad,0x8c,0x83,0x6a,0x84,
+	0x76,0x79,0x4e,0x54,0x4f,0x68,0x4c,0x49,
+	0x31,0x4b,0x4d,0x57,0x3c,0x42,0x45,0x64,
+	0x62,0x5b,0x53,0x66,0x7e,0x87,0x7e,0x7b,
+	0x89,0xa0,0xac,0xa5,0x9e,0xa5,0xbe,0xc7,
+	0xc2,0xb1,0xb8,0xc8,0xd3,0xcb,0xb8,0xb8,
+	0xc4,0xd0,0xc4,0xb6,0xac,0xbd,0xc0,0xc0,
+	0xaa,0xa8,0xac,0xbd,0xb4,0xaa,0x9e,0xab,
+	0xb1,0xb4,0x9d,0x94,0x8d,0x8b,0x7d,0x5f,
+	0x55,0x6b,0x7f,0x55,0x58,0x4b,0x59,0x6c,
+	0x57,0x4b,0x5f,0x3f,0x4b,0x3a,0x41,0x26,
+	0x38,0x2f,0x4b,0x37,0x43,0x31,0x4b,0x42,
+	0x53,0x3a,0x49,0x3f,0x57,0x49,0x51,0x44,
+	0x56,0x54,0x62,0x55,0x5d,0x5c,0x6e,0x70,
+	0x73,0x72,0x79,0x89,0x8f,0x96,0x90,0x9e,
+	0xa2,0xb7,0xac,0xbc,0xaf,0xca,0xbf,0xd4,
+	0xbb,0xd1,0xbb,0xd9,0xbc,0xd0,0xad,0xc4,
+	0xaa,0xbf,0x99,0xa5,0x85,0x9b,0x7b,0x88,
+	0x62,0x70,0x56,0x6a,0x4d,0x51,0x3d,0x49,
+	0x41,0x48,0x37,0x3c,0x3d,0x47,0x4a,0x47,
+	0x4a,0x4f,0x64,0x63,0x6f,0x64,0x7d,0x7b,
+	0x9a,0x87,0x9f,0x8f,0xb5,0xa5,0xc2,0xa2,
+	0xc4,0xb1,0xd8,0xb7,0xcf,0xb1,0xd7,0xbe,
+	0xd9,0xb1,0xcb,0xb4,0xd4,0xb8,0xc5,0xa8,
+	0xc4,0xb4,0xc6,0xa9,0xb2,0xa9,0xb9,0xad,
+	0xa7,0x96,0x92,0x90,0x81,0x6d,0x54,0x65,
+	0x79,0x97,0x5a,0x55,0x57,0x68,0x51,0x6c,
+	0x5d,0x52,0x3c,0x78,0x57,0x5d,0x35,0x50,
+	0x34,0x48,0x24,0x3b,0x2b,0x4e,0x32,0x43,
+	0x2d,0x4d,0x3f,0x54,0x38,0x4b,0x44,0x5f,
+	0x4e,0x58,0x48,0x61,0x63,0x6d,0x61,0x69,
+	0x70,0x82,0x84,0x82,0x86,0x8f,0xa3,0xa2,
+	0xa8,0x9e,0xb5,0xb6,0xca,0xb5,0xc3,0xb8,
+	0xd7,0xc5,0xd1,0xb3,0xcd,0xbb,0xd2,0xaa,
+	0xba,0x9c,0xb8,0x97,0xa4,0x78,0x90,0x73,
+	0x88,0x5e,0x69,0x4b,0x67,0x4a,0x55,0x33,
+	0x48,0x38,0x50,0x35,0x40,0x33,0x4d,0x46,
+	0x51,0x45,0x54,0x5a,0x6b,0x6a,0x6a,0x73,
+	0x80,0x91,0x8e,0x94,0x93,0xaa,0xa9,0xb8,
+	0xa8,0xba,0xb5,0xcf,0xba,0xcc,0xb4,0xd4,
+	0xc1,0xd7,0xb8,0xce,0xb8,0xda,0xb8,0xce,
+	0xae,0xcc,0xb4,0xcc,0xa8,0xbc,0xa2,0xba,
+	0x98,0xa0,0x76,0x83,0x63,0x71,0x62,0x8d,
+	0x8f,0x7d,0x5f,0x80,0x69,0x5f,0x44,0x49,
+	0x50,0x67,0x4f,0x3a,0x5c,0x66,0x61,0x4e,
+	0x4f,0x3e,0x3e,0x2b,0x39,0x2d,0x40,0x2d,
+	0x40,0x2c,0x49,0x36,0x4f,0x35,0x53,0x3e,
+	0x5f,0x46,0x64,0x4b,0x6f,0x58,0x7b,0x61,
+	0x81,0x6e,0x93,0x7c,0x9c,0x86,0xa9,0x98,
+	0xb9,0xa3,0xc0,0xb1,0xcb,0xbc,0xcf,0xbc,
+	0xd0,0xc4,0xd2,0xbf,0xc9,0xbb,0xc4,0xb7,
+	0xb5,0xa9,0xa5,0xa0,0x99,0x8f,0x83,0x7e,
+	0x73,0x75,0x60,0x62,0x4e,0x5d,0x50,0x65,
+	0x59,0x72,0x66,0x82,0x6c,0x81,0x68,0x8b,
+	0x7c,0xa3,0x8d,0xb3,0xa1,0xca,0xad,0xca,
+	0xab,0xcf,0xb5,0xd3,0xac,0xca,0xae,0xd0,
+	0xb0,0xc8,0xa6,0xc6,0xab,0xc5,0xa4,0xb8,
+	0xa0,0xbb,0xa4,0xb2,0x95,0xa9,0x9b,0xab,
+	0x92,0x98,0x8c,0x9b,0x8e,0x90,0x80,0x84,
+	0x85,0x85,0x7d,0x73,0x74,0x72,0x79,0x6b,
+	0x68,0x5e,0x6a,0x62,0x66,0x4f,0x5b,0x4f,
+	0x63,0x49,0x55,0x3c,0x54,0x43,0x56,0x35,
+	0x48,0x36,0x52,0x37,0x45,0x29,0x47,0x36,
+	0x4b,0x2a,0x3f,0x2c,0x4a,0x34,0x43,0x28,
+	0x43,0x37,0x4c,0x33,0x3f,0x35,0x4e,0x43,
+	0x4a,0x38,0x4a,0x49,0x59,0x48,0x4c,0x4b,
+	0x5f,0x5d,0x5e,0x53,0x5d,0x66,0x6f,0x6a,
+	0x65,0x68,0x75,0x80,0x7a,0x7a,0x7b,0x8d,
+	0x94,0x92,0x84,0x8a,0x90,0x9c,0x8e,0x85,
+	0x7f,0x8c,0x8f,0x8b,0x76,0x76,0x76,0x82,
+	0x73,0x64,0x59,0x5f,0x63,0x5c,0x4b,0x47,
+	0x50,0x57,0x56,0x48,0x48,0x51,0x61,0x61,
+	0x5b,0x57,0x69,0x74,0x7f,0x74,0x7a,0x80,
+	0x98,0x99,0x98,0x8f,0xa6,0xaf,0xbb,0xad,
+	0xb0,0xb4,0xcb,0xc9,0xc9,0xbd,0xc8,0xd1,
+	0xd9,0xc6,0xc3,0xc7,0xd1,0xcf,0xc9,0xc1,
+	0xc9,0xd6,0xd7,0xcb,0xbd,0xc2,0xc5,0xc8,
+	0xad,0x9f,0x8c,0x96,0x86,0x7d,0x60,0x6f,
+	0x70,0x8d,0x87,0x8c,0x7c,0x9a,0x83,0x89,
+	0x61,0x76,0x73,0xa4,0x92,0xab,0x9b,0xc8,
+	0xbb,0xd7,0xb3,0xcc,0xb7,0xda,0xb2,0xbb,
+	0x96,0xb6,0x9c,0xa9,0x76,0x87,0x6b,0x88,
+	0x60,0x63,0x3f,0x5d,0x4b,0x5b,0x34,0x45,
+	0x39,0x5d,0x4f,0x56,0x44,0x63,0x68,0x7e,
+	0x70,0x7d,0x84,0xa8,0xa6,0xab,0xa3,0xba,
+	0xc8,0xd1,0xc5,0xbb,0xbc,0xb3,0x8b,0x8c,
+	0x8c,0x7c,0x7e,0x82,0x80,0x74,0x77,0x69,
+	0x4b,0x36,0x48,0x36,0x3b,0x2f,0x36,0x27,
+	0x38,0x40,0x53,0x42,0x49,0x4b,0x6d,0x6e,
+	0x77,0x6b,0x7b,0x87,0x96,0x88,0x83,0x7e,
+	0x90,0x8e,0x88,0x76,0x79,0x84,0x8c,0x84,
+	0x77,0x78,0x83,0x8c,0x7f,0x76,0x72,0x83,
+	0x86,0x8a,0x78,0x85,0x8d,0xa3,0x97,0x97,
+	0x8f,0xa4,0xa0,0x9e,0x82,0x83,0x7c,0x88,
+	0x73,0x73,0x6e,0x97,0x8b,0x68,0x54,0x5f,
+	0x75,0x86,0x82,0x81,0x84,0xa4,0xaf,0x7f,
+	0x67,0x5e,0x72,0x75,0x70,0x5d,0x5a,0x5a,
+	0x69,0x61,0x63,0x5a,0x72,0x76,0x86,0x73,
+	0x83,0x7e,0x99,0x87,0x90,0x7a,0x92,0x84,
+	0x95,0x77,0x86,0x74,0x90,0x75,0x83,0x67,
+	0x83,0x72,0x89,0x6a,0x84,0x72,0x97,0x82,
+	0x9c,0x85,0xa8,0x9a,0xb7,0x96,0xac,0x95,
+	0xae,0x8d,0x9a,0x76,0x8e,0x77,0x91,0x7e,
+	0xa3,0x74,0x6e,0x5e,0x68,0x6c,0x80,0x81,
+	0x96,0x95,0xaa,0x76,0x70,0x5e,0x58,0x5b,
+	0x5e,0x5a,0x56,0x4f,0x51,0x55,0x5a,0x5f,
+	0x5f,0x6a,0x74,0x80,0x82,0x87,0x8a,0x95,
+	0x98,0x94,0x90,0x92,0x90,0x90,0x88,0x80,
+	0x7d,0x7e,0x7c,0x72,0x6f,0x6d,0x76,0x74,
+	0x79,0x73,0x82,0x89,0x98,0x95,0x9f,0xa0,
+	0xb3,0xaf,0xb3,0xa6,0xb2,0xa9,0xb2,0x9b,
+	0x9d,0x8e,0xa1,0x9c,0xaa,0x99,0x7d,0x62,
+	0x7a,0x57,0x75,0x6e,0x99,0x95,0xae,0x75,
+	0x66,0x63,0x5f,0x4d,0x52,0x43,0x57,0x4d,
+	0x4f,0x3a,0x48,0x49,0x60,0x5a,0x5f,0x62,
+	0x7c,0x89,0x92,0x8d,0x93,0xa2,0xab,0xa8,
+	0x97,0x93,0x95,0x9a,0x87,0x7b,0x65,0x72,
+	0x6d,0x72,0x56,0x60,0x5d,0x7f,0x75,0x82,
+	0x74,0x9b,0x9e,0xbe,0x9f,0xb5,0xa8,0xce,
+	0xb6,0xbb,0x93,0xaf,0x9a,0xb0,0x83,0x8e,
+	0x7e,0xaf,0x9f,0x9e,0x49,0x75,0x5f,0x88,
+	0x6f,0x8e,0x87,0xb8,0x7a,0x76,0x4e,0x54,
+	0x58,0x6f,0x4f,0x48,0x36,0x51,0x49,0x4b,
+	0x31,0x41,0x51,0x70,0x6c,0x6b,0x73,0x91,
+	0xa9,0xad,0xa1,0x9e,0xb1,0xb8,0xb2,0x90,
+	0x85,0x81,0x8e,0x76,0x61,0x47,0x59,0x5d,
+	0x6a,0x4e,0x59,0x62,0x8e,0x8d,0x9b,0x88,
+	0xb1,0xba,0xd6,0xb6,0xbc,0xaf,0xd2,0xb9,
+	0xba,0x8c,0x9e,0x97,0xb1,0x8d,0x96,0x8b,
+	0xb1,0x7a,0x77,0x61,0x63,0x7c,0xa3,0x9c,
+	0x7e,0x4d,0x76,0x62,0x5e,0x44,0x46,0x4b,
+	0x59,0x4a,0x37,0x2b,0x3b,0x4b,0x4c,0x42,
+	0x44,0x5f,0x79,0x8c,0x86,0x90,0xa1,0xc1,
+	0xc3,0xbb,0xa6,0xb1,0xae,0xae,0x85,0x74,
+	0x61,0x6f,0x5b,0x53,0x36,0x48,0x52,0x6b,
+	0x60,0x6c,0x73,0x9e,0xa9,0xb6,0xaa,0xbd,
+	0xc6,0xd9,0xc5,0xbc,0xae,0xbc,0xb6,0xab,
+	0x91,0x91,0x97,0xa8,0xa2,0x9c,0x8d,0x73,
+	0x85,0x8b,0x73,0x7d,0x84,0x6a,0x69,0x5f,
+	0x42,0x4e,0x5a,0x55,0x43,0x38,0x3e,0x43,
+	0x40,0x2d,0x2b,0x33,0x4c,0x52,0x57,0x5b,
+	0x78,0x94,0xac,0xaa,0xb3,0xbe,0xd5,0xd1,
+	0xc3,0xaa,0xa5,0x9b,0x90,0x6c,0x52,0x44,
+	0x49,0x45,0x3b,0x31,0x43,0x5d,0x76,0x7c,
+	0x87,0x98,0xbb,0xce,0xd0,0xc5,0xca,0xd5,
+	0xda,0xc6,0xb1,0xa5,0xab,0xa9,0x9c,0x88,
+	0x86,0x98,0xaa,0xad,0x91,0x6a,0x86,0x9f,
+	0x8b,0x6e,0x42,0x63,0x62,0x50,0x3e,0x3c,
+	0x41,0x51,0x49,0x3a,0x25,0x30,0x37,0x41,
+	0x2f,0x35,0x3e,0x64,0x70,0x7c,0x7f,0x9e,
+	0xb7,0xd0,0xcb,0xc6,0xc3,0xd1,0xc9,0xb3,
+	0x8e,0x7d,0x74,0x6c,0x50,0x39,0x2f,0x3a,
+	0x4a,0x4b,0x4d,0x58,0x7a,0x95,0xa7,0xa3,
+	0xb2,0xc1,0xda,0xd3,0xca,0xba,0xc7,0xc4,
+	0xc6,0xa8,0xa0,0x9c,0xb0,0xa7,0xa6,0x97,
+	0xa9,0xa2,0x90,0x85,0x8e,0x68,0x50,0x59,
+	0x60,0x3d,0x3e,0x48,0x57,0x48,0x40,0x39,
+	0x48,0x47,0x42,0x30,0x34,0x43,0x52,0x57,
+	0x56,0x62,0x7d,0x9c,0xa4,0xa9,0xad,0xc6,
+	0xd1,0xd3,0xba,0xb1,0xa3,0xa8,0x8a,0x76,
+	0x50,0x54,0x48,0x50,0x35,0x3a,0x3a,0x61,
+	0x64,0x78,0x70,0x92,0xa5,0xc3,0xb8,0xbf,
+	0xbb,0xd3,0xd0,0xcc,0xb2,0xb4,0xb2,0xbd,
+	0xac,0x9f,0x9a,0xab,0xb6,0xb5,0xa0,0x7f,
+	0x81,0x98,0x6e,0x3d,0x48,0x4b,0x4d,0x40,
+	0x3e,0x2e,0x46,0x45,0x52,0x33,0x37,0x2f,
+	0x4b,0x3f,0x47,0x36,0x55,0x5f,0x83,0x7a,
+	0x8f,0x94,0xbf,0xc3,0xd2,0xbb,0xca,0xc3,
+	0xcd,0xaa,0x97,0x79,0x79,0x68,0x59,0x3c,
+	0x35,0x3a,0x48,0x4e,0x4b,0x57,0x6f,0x91,
+	0x98,0xa6,0xa3,0xbe,0xc6,0xd8,0xbe,0xc5,
+	0xb6,0xcc,0xb7,0xba,0x98,0xab,0xa0,0xbb,
+	0xa3,0xb2,0x9f,0xb2,0x85,0x8c,0x69,0x5a,
+	0x52,0x60,0x4a,0x35,0x2c,0x42,0x44,0x47,
+	0x37,0x3a,0x3c,0x46,0x43,0x37,0x3a,0x43,
+	0x5a,0x5d,0x67,0x6a,0x89,0x9c,0xb5,0xae,
+	0xc1,0xc0,0xd9,0xcc,0xca,0xa8,0xae,0x96,
+	0x95,0x67,0x5f,0x41,0x4f,0x3c,0x45,0x2f,
+	0x46,0x4d,0x6f,0x6e,0x82,0x89,0xad,0xb7,
+	0xc6,0xbd,0xc7,0xca,0xd5,0xcb,0xc0,0xb5,
+	0xb9,0xb9,0xb6,0xaa,0xa7,0xae,0xb9,0xba,
+	0xa6,0x7f,0x75,0x75,0x5b,0x5c,0x3f,0x42,
+	0x2d,0x41,0x2e,0x3b,0x2f,0x45,0x3b,0x3e,
+	0x2b,0x36,0x35,0x46,0x40,0x49,0x4e,0x6b,
+	0x7c,0x93,0x9a,0xae,0xc0,0xd6,0xd6,0xd3,
+	0xcd,0xc9,0xc1,0xaf,0x94,0x7b,0x69,0x5d,
+	0x4c,0x3e,0x31,0x33,0x3c,0x47,0x4e,0x5c,
+	0x6d,0x89,0x98,0xab,0xae,0xc0,0xc4,0xd5,
+	0xca,0xd0,0xc2,0xcc,0xbe,0xc4,0xb0,0xb6,
+	0xae,0xbb,0xb1,0xb7,0xa6,0x99,0x74,0x77,
+	0x57,0x63,0x55,0x4d,0x3d,0x2b,0x37,0x2f,
+	0x3f,0x35,0x43,0x31,0x45,0x32,0x47,0x38,
+	0x51,0x44,0x62,0x5b,0x80,0x79,0x9e,0x98,
+	0xb9,0xb3,0xce,0xc2,0xce,0xbb,0xc1,0xa8,
+	0xa4,0x85,0x7b,0x65,0x5c,0x50,0x44,0x41,
+	0x40,0x4d,0x50,0x62,0x63,0x7f,0x84,0xa3,
+	0x9e,0xb4,0xa9,0xc7,0xb9,0xcb,0xaf,0xc1,
+	0xad,0xc1,0xa6,0xb5,0x9a,0xb3,0xa5,0xb8,
+	0x9b,0x9f,0x7d,0x81,0x72,0x62,0x61,0x59,
+	0x5b,0x4a,0x44,0x3d,0x47,0x4b,0x56,0x49,
+	0x48,0x45,0x54,0x52,0x56,0x4b,0x5c,0x64,
+	0x7c,0x7b,0x84,0x88,0xa2,0xad,0xb7,0xab,
+	0xb3,0xb0,0xbb,0xac,0x9a,0x86,0x82,0x7e,
+	0x73,0x5c,0x4e,0x4f,0x5a,0x5c,0x58,0x55,
+	0x65,0x7b,0x8c,0x8a,0x8c,0x95,0xab,0xb4,
+	0xb2,0xa1,0xa9,0xac,0xb9,0xa6,0xa1,0x91,
+	0xa8,0xa3,0xac,0x91,0x99,0x93,0xa0,0x7c,
+	0x81,0x5a,0x70,0x6a,0x74,0x53,0x4b,0x4b,
+	0x64,0x60,0x59,0x4a,0x54,0x63,0x65,0x5e,
+	0x4d,0x59,0x69,0x7c,0x6d,0x74,0x70,0x95,
+	0x99,0xa7,0x8c,0xa3,0x9f,0xbf,0x9f,0xa2,
+	0x7f,0x9b,0x88,0x92,0x61,0x68,0x59,0x77,
+	0x5f,0x63,0x4e,0x69,0x74,0x86,0x75,0x7b,
+	0x85,0x9e,0xa5,0x9d,0x93,0x97,0xad,0xab,
+	0xa4,0x8c,0x97,0x99,0xab,0x94,0x92,0x86,
+	0x9f,0x98,0x97,0x6d,0x7f,0x78,0x80,0x6b,
+	0x69,0x59,0x68,0x66,0x6d,0x57,0x5a,0x5d,
+	0x71,0x6c,0x63,0x56,0x63,0x70,0x76,0x6d,
+	0x69,0x73,0x87,0x8f,0x8c,0x87,0x8f,0x9f,
+	0xa8,0x9d,0x92,0x8f,0x96,0x96,0x8c,0x76,
+	0x73,0x72,0x7b,0x6c,0x67,0x5d,0x6e,0x72,
+	0x7b,0x6e,0x77,0x7d,0x92,0x91,0x90,0x8a,
+	0x97,0x9b,0xa2,0x95,0x92,0x92,0x98,0x9c,
+	0x90,0x8d,0x89,0x98,0x93,0x94,0x7b,0x7f,
+	0x80,0x8e,0x74,0x6d,0x63,0x7a,0x6e,0x72,
+	0x5d,0x6b,0x64,0x76,0x66,0x6f,0x60,0x72,
+	0x6c,0x75,0x6c,0x72,0x6e,0x7c,0x82,0x8a,
+	0x85,0x85,0x8c,0x93,0x96,0x94,0x93,0x90,
+	0x8b,0x8b,0x88,0x80,0x7b,0x77,0x75,0x74,
+	0x70,0x6f,0x70,0x72,0x78,0x79,0x7b,0x80,
+	0x84,0x8a,0x8c,0x8b,0x8d,0x92,0x93,0x94,
+	0x8f,0x90,0x8f,0x91,0x90,0x8b,0x8b,0x8d,
+	0x8d,0x8b,0x7d,0x80,0x83,0x86,0x7e,0x6f,
+	0x70,0x75,0x76,0x76,0x6d,0x6d,0x6e,0x72,
+	0x72,0x6f,0x6f,0x70,0x74,0x75,0x75,0x75,
+	0x77,0x7e,0x80,0x82,0x83,0x87,0x8b,0x8e,
+	0x8d,0x8c,0x8b,0x8e,0x8a,0x87,0x82,0x80,
+	0x7f,0x7e,0x76,0x77,0x73,0x77,0x78,0x78,
+	0x76,0x79,0x80,0x82,0x83,0x83,0x85,0x8b,
+	0x8c,0x8d,0x8a,0x8a,0x8f,0x8e,0x8c,0x8a,
+	0x88,0x8c,0x8b,0x8b,0x86,0x82,0x80,0x85,
+	0x83,0x82,0x79,0x7b,0x76,0x79,0x74,0x77,
+	0x74,0x77,0x74,0x73,0x70,0x75,0x76,0x76,
+	0x76,0x75,0x79,0x65,0x39,0x6e,0x5e,0xbe,
+	0x9f,0x87,0x6c,0x54,0xae,0x8f,0x84,0x46,
+	0x51,0x81,0xcc,0xb5,0x7d,0x3f,0x4f,0x98,
+	0xb6,0xad,0x58,0x42,0x5e,0x9f,0xc4,0x82,
+	0x5a,0x3d,0x8e,0xb9,0xc2,0x86,0x45,0x64,
+	0x89,0xd5,0xa5,0x6b,0x3f,0x60,0xbf,0xbf,
+	0xae,0x43,0x47,0x73,0xb8,0xce,0x71,0x56,
+	0x2e,0x91,0xb3,0xb2,0x70,0x29,0x61,0x7f,
+	0xd2,0x8d,0x5f,0x39,0x56,0xb9,0xa7,0xa6,
+	0x38,0x51,0x73,0xb4,0xc9,0x6a,0x67,0x37,
+	0xa6,0xb4,0xb5,0x79,0x36,0x78,0x80,0xdb,
+	0x87,0x68,0x43,0x5d,0xbb,0x99,0xaa,0x36,
+	0x5d,0x70,0xae,0xc0,0x64,0x6d,0x38,0xa9,
+	0xa8,0xb0,0x7c,0x3c,0x82,0x7e,0xd9,0x84,
+	0x77,0x50,0x68,0xbe,0x95,0xae,0x3a,0x6a,
+	0x70,0xaa,0xbb,0x62,0x74,0x2e,0xa3,0x96,
+	0xa9,0x75,0x35,0x7b,0x6a,0xcf,0x77,0x75,
+	0x47,0x5e,0xb4,0x8a,0xb4,0x37,0x70,0x68,
+	0xa7,0xbc,0x66,0x80,0x32,0xad,0x92,0xb4,
+	0x7e,0x40,0x81,0x6a,0xd5,0x78,0x81,0x47,
+	0x62,0xb0,0x89,0xb5,0x36,0x74,0x60,0xad,
+	0xb3,0x6c,0x7a,0x33,0xaf,0x8e,0xbc,0x71,
+	0x4c,0x7d,0x75,0xdb,0x76,0x8b,0x42,0x76,
+	0xab,0x95,0xb0,0x37,0x7a,0x5d,0xb9,0xa5,
+	0x70,0x6d,0x34,0xad,0x86,0xba,0x5d,0x4e,
+	0x6e,0x77,0xce,0x6d,0x83,0x34,0x7e,0x9d,
+	0x9e,0xa0,0x37,0x7c,0x5d,0xc5,0x9c,0x7b,
+	0x65,0x42,0xb3,0x8c,0xc3,0x54,0x5c,0x6b,
+	0x8a,0xce,0x6e,0x83,0x2d,0x8b,0x9a,0xa8,
+	0x95,0x38,0x79,0x5d,0xce,0x91,0x80,0x56,
+	0x4c,0xb3,0x91,0xc3,0x4c,0x66,0x66,0x9b,
+	0xc9,0x74,0x81,0x31,0x98,0x96,0xb3,0x89,
+	0x40,0x76,0x64,0xd2,0x86,0x82,0x47,0x55,
+	0xaa,0x93,0xb8,0x3e,0x64,0x5a,0xa4,0xb7,
+	0x72,0x74,0x2b,0x9c,0x93,0xba,0x77,0x46,
+	0x71,0x6e,0xd5,0x84,0x85,0x40,0x67,0xa8,
+	0x9f,0xb4,0x3f,0x6b,0x5e,0xb1,0xb1,0x78,
+	0x6c,0x35,0xa0,0x92,0xbd,0x6b,0x4b,0x69,
+	0x7b,0xcf,0x7f,0x83,0x3b,0x74,0xa2,0xaa,
+	0xa4,0x44,0x6d,0x65,0xbf,0xa5,0x80,0x5f,
+	0x49,0xa1,0x98,0xb8,0x5f,0x57,0x64,0x91,
+	0xbe,0x82,0x71,0x3d,0x7f,0x9c,0xac,0x87,
+	0x49,0x62,0x72,0xb9,0xa2,0x81,0x2f,0x51,
+	0x85,0xca,0xb4,0x51,0x35,0x56,0xca,0xd8,
+	0x99,0x35,0x2d,0x7d,0xd4,0xce,0x75,0x29,
+	0x40,0x9a,0xdc,0xb7,0x5b,0x25,0x57,0xb2,
+	0xda,0x9b,0x41,0x2c,0x72,0xc6,0xce,0x7d,
+	0x34,0x3a,0x8f,0xcf,0xbb,0x64,0x2f,0x50,
+	0xa7,0xd2,0xa2,0x4f,0x31,0x6a,0xba,0xc9,
+	0x88,0x40,0x3d,0x83,0xc7,0xb9,0x70,0x38,
+	0x4f,0x9c,0xc8,0xa4,0x5d,0x39,0x65,0xad,
+	0xc5,0x8e,0x4b,0x41,0x7c,0xba,0xb8,0x79,
+	0x42,0x4f,0x92,0xbf,0xa9,0x64,0x41,0x61,
+	0xa5,0xbd,0x96,0x56,0x48,0x75,0xaf,0xb5,
+	0x80,0x4d,0x53,0x88,0xb7,0xa6,0x70,0x4a,
+	0x62,0x98,0xb4,0x97,0x61,0x4d,0x72,0xa3,
+	0xb0,0x84,0x59,0x56,0x83,0xa9,0xa4,0x75,
+	0x57,0x61,0x91,0xaa,0x98,0x69,0x58,0x77,
+	0xa7,0x93,0x64,0x4d,0x7e,0xa7,0xb1,0x56,
+	0x2a,0x4d,0xaa,0xa9,0x71,0x59,0x8a,0xa5,
+	0x91,0x51,0x43,0x7f,0xa9,0x98,0x5e,0x68,
+	0x9b,0xa9,0x74,0x5a,0x80,0xac,0x8f,0x57,
+	0x5d,0x96,0x9e,0x6b,0x47,0x6f,0x9b,0x85,
+	0x4b,0x4b,0x7f,0x92,0x60,0x38,0x53,0x82,
+	0x75,0x42,0x3c,0x61,0x73,0x55,0x38,0x4f,
+	0x74,0x6c,0x3f,0x3c,0x61,0x79,0x52,0x2d,
+	0x4b,0x7e,0x75,0x41,0x36,0x6c,0x88,0x61,
+	0x38,0x54,0x88,0x85,0x50,0x46,0x7a,0x9b,
+	0x75,0x4c,0x65,0xa0,0x9c,0x69,0x5a,0x8c,
+	0xb1,0x91,0x65,0x79,0xb0,0xb1,0x7e,0x6e,
+	0x9d,0xc2,0xa0,0x72,0x83,0xb8,0xbb,0x87,
+	0x6f,0x9e,0xc0,0xa0,0x6e,0x7a,0xae,0xb3,
+	0x80,0x63,0x8a,0xad,0x91,0x62,0x6a,0x97,
+	0x98,0x66,0x4f,0x74,0x99,0x7a,0x45,0x4f,
+	0x7b,0x86,0x59,0x3f,0x5c,0x80,0x6b,0x43,
+	0x47,0x75,0x7d,0x58,0x40,0x61,0x7f,0x74,
+	0x52,0x56,0x7d,0x89,0x64,0x50,0x72,0x93,
+	0x84,0x5f,0x5c,0x80,0x90,0x73,0x5b,0x73,
+	0x8e,0x8a,0x71,0x79,0xa2,0xb7,0x9b,0x7a,
+	0x74,0x86,0x88,0x86,0x99,0xc3,0xcf,0xb1,
+	0x92,0x84,0x86,0x83,0x7c,0x83,0x95,0x92,
+	0x77,0x62,0x68,0x75,0x68,0x53,0x54,0x6a,
+	0x71,0x5f,0x56,0x64,0x74,0x6e,0x5b,0x5e,
+	0x72,0x78,0x66,0x5f,0x6e,0x7e,0x75,0x66,
+	0x6f,0x83,0x89,0x7c,0x79,0x8d,0x9c,0x98,
+	0x8e,0x9a,0xb0,0xb6,0xa9,0xac,0xbe,0xcb,
+	0xc2,0xb9,0xc0,0xd4,0xcf,0xbe,0xba,0xc5,
+	0xca,0xb7,0xa7,0xa8,0xb3,0xa4,0x8e,0x84,
+	0x8d,0x8c,0x77,0x64,0x68,0x71,0x6a,0x53,
+	0x4f,0x5f,0x67,0x58,0x4d,0x5b,0x71,0x6d,
+	0x64,0x67,0x80,0x8c,0x87,0x7f,0x92,0xaa,
+	0xaa,0x9e,0xa1,0xb7,0xc1,0xb6,0xaa,0xb7,
+	0xc5,0xc1,0xae,0xa9,0xb7,0xbc,0xa8,0x97,
+	0x9d,0xa8,0x9e,0x87,0x7e,0x8c,0x8f,0x7b,
+	0x69,0x6e,0x7b,0x75,0x5f,0x58,0x69,0x71,
+	0x62,0x54,0x5d,0x70,0x6f,0x63,0x61,0x7c,
+	0x8b,0x8c,0x83,0x8e,0x8b,0x79,0x7a,0x76,
+	0x94,0xb6,0xb2,0xa4,0x8a,0x99,0x9b,0x8b,
+	0x95,0xa4,0xb2,0xa4,0x94,0x96,0xa2,0x9e,
+	0x8a,0x7f,0x85,0x88,0x7a,0x65,0x63,0x69,
+	0x63,0x52,0x46,0x4a,0x4c,0x42,0x37,0x35,
+	0x3c,0x3f,0x37,0x38,0x44,0x4c,0x4f,0x51,
+	0x5c,0x6d,0x74,0x79,0x83,0x94,0x9e,0xa6,
+	0xab,0xba,0xc5,0xc6,0xc9,0xcf,0xd6,0xd6,
+	0xcd,0xcc,0xcd,0xc8,0xba,0xad,0xac,0xa8,
+	0x97,0x82,0x7e,0x7a,0x70,0x5b,0x4f,0x52,
+	0x51,0x45,0x36,0x38,0x45,0x44,0x3a,0x39,
+	0x49,0x5b,0x58,0x52,0x61,0x7a,0x84,0x7e,
+	0x81,0x98,0xad,0xa9,0xa3,0xab,0xc3,0xcb,
+	0xbc,0xb4,0xc2,0xd3,0xc9,0xb2,0xb2,0xc4,
+	0xc5,0xaa,0x99,0xa1,0xaf,0xa0,0x82,0x7c,
+	0x8e,0x91,0x76,0x5f,0x69,0x7b,0x75,0x55,
+	0x4e,0x66,0x74,0x5f,0x4a,0x55,0x75,0x77,
+	0x5e,0x60,0x8c,0xa7,0xa0,0x8b,0x91,0x99,
+	0x93,0x90,0x80,0x8c,0x8e,0x6c,0x64,0x66,
+	0x84,0x93,0x7b,0x6f,0x87,0x9f,0x93,0x73,
+	0x73,0x8e,0x93,0x77,0x5f,0x6f,0x82,0x78,
+	0x55,0x50,0x65,0x70,0x56,0x41,0x49,0x60,
+	0x5d,0x42,0x3a,0x52,0x63,0x55,0x43,0x4f,
+	0x6b,0x73,0x60,0x5f,0x78,0x91,0x8a,0x7c,
+	0x88,0xa6,0xb0,0xa1,0x99,0xb0,0xc5,0xbf,
+	0xac,0xab,0xc1,0xc7,0xb1,0x9f,0xa9,0xb5,
+	0xab,0x8d,0x84,0x91,0x92,0x7a,0x62,0x66,
+	0x72,0x67,0x4e,0x44,0x53,0x5f,0x4c,0x3c,
+	0x45,0x5b,0x5f,0x4e,0x4b,0x64,0x79,0x73,
+	0x67,0x76,0x92,0x9b,0x8f,0x8a,0xa0,0xb8,
+	0xb3,0xa4,0xaa,0xc1,0xc9,0xb7,0xab,0xba,
+	0xc8,0xc0,0xa8,0xa5,0xb4,0xb8,0xa3,0x8f,
+	0x96,0xa3,0x99,0x81,0x78,0x88,0x8e,0x7b,
+	0x67,0x6e,0x80,0x7c,0x66,0x60,0x73,0x83,
+	0x78,0x6a,0x74,0x91,0x99,0x8d,0x8d,0xa6,
+	0xb2,0x9a,0x70,0x82,0x99,0x76,0x47,0x53,
+	0x61,0x6c,0x69,0x60,0x67,0x7f,0x87,0x75,
+	0x6c,0x77,0x87,0x7d,0x68,0x65,0x74,0x77,
+	0x63,0x54,0x5b,0x64,0x5f,0x49,0x45,0x51,
+	0x56,0x49,0x3e,0x43,0x53,0x52,0x44,0x46,
+	0x56,0x62,0x5e,0x58,0x65,0x79,0x81,0x7c,
+	0x7f,0x91,0xa2,0xa1,0x9f,0xa7,0xba,0xc1,
+	0xb8,0xb6,0xbe,0xca,0xc3,0xb6,0xb1,0xbb,
+	0xb9,0xa7,0x98,0x9a,0x99,0x90,0x7a,0x6e,
+	0x73,0x6f,0x60,0x4f,0x4f,0x54,0x50,0x41,
+	0x3d,0x45,0x4f,0x48,0x43,0x4a,0x5b,0x63,
+	0x5f,0x61,0x72,0x84,0x87,0x85,0x8e,0xa1,
+	0xac,0xa9,0xa8,0xb4,0xc2,0xc3,0xba,0xb9,
+	0xc6,0xc8,0xbf,0xb5,0xb6,0xbf,0xb7,0xaa,
+	0xa1,0xa7,0xa9,0x9e,0x8d,0x8c,0x94,0x8f,
+	0x80,0x78,0x7d,0x84,0x7d,0x70,0x71,0x7d,
+	0x82,0x7b,0x75,0x83,0x92,0x98,0x92,0x9b,
+	0xac,0xb4,0xa1,0x81,0x72,0x8c,0x6a,0x47,
+	0x48,0x53,0x4e,0x49,0x49,0x54,0x67,0x6d,
+	0x62,0x57,0x61,0x6a,0x64,0x56,0x57,0x60,
+	0x61,0x53,0x49,0x4d,0x55,0x4c,0x40,0x3b,
+	0x44,0x48,0x3e,0x36,0x3b,0x47,0x48,0x41,
+	0x42,0x4f,0x5c,0x5e,0x59,0x66,0x79,0x82,
+	0x82,0x88,0x97,0xaa,0xad,0xac,0xb4,0xc4,
+	0xcd,0xc9,0xc5,0xce,0xd7,0xd3,0xc9,0xc2,
+	0xc6,0xc5,0xb9,0xa8,0xa0,0xa1,0x96,0x83,
+	0x74,0x70,0x6f,0x5e,0x4c,0x48,0x47,0x48,
+	0x39,0x30,0x36,0x3e,0x40,0x38,0x3a,0x49,
+	0x59,0x58,0x58,0x64,0x7c,0x85,0x83,0x88,
+	0x9c,0xad,0xb1,0xab,0xb5,0xc5,0xd0,0xc6,
+	0xc2,0xca,0xd6,0xd2,0xc2,0xbf,0xc9,0xcb,
+	0xbb,0xac,0xae,0xb7,0xb3,0xa2,0x98,0x9f,
+	0xa4,0x98,0x88,0x88,0x95,0x94,0x86,0x7f,
+	0x8a,0x97,0x93,0x88,0x8e,0x9f,0xab,0xa2,
+	0x9a,0xa1,0xa5,0x8e,0x66,0x64,0x72,0x56,
+	0x5c,0x41,0x48,0x45,0x3b,0x36,0x37,0x48,
+	0x5a,0x57,0x4e,0x54,0x63,0x66,0x59,0x53,
+	0x58,0x65,0x5d,0x4e,0x4b,0x57,0x5b,0x4d,
+	0x43,0x46,0x53,0x51,0x42,0x42,0x4e,0x57,
+	0x53,0x4a,0x54,0x65,0x6c,0x67,0x66,0x78,
+	0x8c,0x8c,0x88,0x92,0xa7,0xb2,0xb0,0xad,
+	0xba,0xcb,0xcb,0xc3,0xc2,0xcd,0xd4,0xc9,
+	0xba,0xbc,0xc1,0xba,0xa6,0x9a,0x99,0x9a,
+	0x88,0x74,0x6b,0x6f,0x68,0x55,0x47,0x49,
+	0x4d,0x47,0x36,0x36,0x40,0x47,0x41,0x3c,
+	0x44,0x57,0x5c,0x5a,0x5c,0x70,0x81,0x85,
+	0x83,0x8d,0xa2,0xad,0xaa,0xad,0xb6,0xc6,
+	0xc9,0xc3,0xc0,0xcc,0xd4,0xcc,0xc0,0xc2,
+	0xca,0xc9,0xbc,0xb2,0xb5,0xba,0xb2,0xa4,
+	0x9d,0xa4,0xa7,0x9b,0x90,0x92,0x99,0x9c,
+	0x91,0x8d,0x93,0xa1,0xa1,0x99,0x98,0xaa,
+	0xab,0xa2,0x8a,0x7d,0x6f,0x7d,0x77,0x54,
+	0x4e,0x4c,0x51,0x3a,0x3e,0x30,0x3e,0x33,
+	0x33,0x3d,0x53,0x54,0x4b,0x47,0x57,0x60,
+	0x59,0x49,0x4d,0x5c,0x5d,0x4b,0x43,0x4b,
+	0x5a,0x52,0x42,0x40,0x53,0x59,0x4d,0x43,
+	0x51,0x63,0x67,0x59,0x5d,0x72,0x83,0x7e,
+	0x75,0x84,0x9c,0xa4,0x9a,0x9a,0xad,0xc1,
+	0xbe,0xaf,0xb7,0xcb,0xd3,0xc1,0xb5,0xbf,
+	0xce,0xc4,0xab,0xa5,0xb1,0xb2,0x9d,0x82,
+	0x85,0x8d,0x84,0x66,0x59,0x63,0x68,0x56,
+	0x3e,0x40,0x50,0x51,0x3b,0x33,0x45,0x57,
+	0x50,0x44,0x49,0x66,0x71,0x67,0x62,0x77,
+	0x92,0x92,0x87,0x8b,0xa8,0xb7,0xae,0xa2,
+	0xb2,0xca,0xc9,0xb7,0xb4,0xc7,0xd3,0xc4,
+	0xb3,0xb7,0xca,0xc6,0xb2,0xa4,0xb2,0xbd,
+	0xae,0x9a,0x9b,0xaa,0xac,0x99,0x8d,0x9b,
+	0xa9,0xa1,0x92,0x93,0xa7,0xad,0x9f,0x92,
+	0x99,0x99,0x80,0x61,0x6a,0x90,0x7a,0x6d,
+	0x4c,0x2d,0x53,0x51,0x40,0x48,0x39,0x3c,
+	0x2f,0x2b,0x32,0x42,0x44,0x3f,0x3e,0x47,
+	0x50,0x4b,0x45,0x48,0x4f,0x51,0x49,0x47,
+	0x49,0x50,0x4e,0x4a,0x4a,0x52,0x56,0x55,
+	0x56,0x5a,0x63,0x69,0x6b,0x71,0x79,0x80,
+	0x89,0x8e,0x95,0x9d,0xa7,0xae,0xb4,0xb7,
+	0xbd,0xc5,0xc9,0xca,0xca,0xcb,0xce,0xcd,
+	0xc5,0xbf,0xbe,0xbc,0xb2,0xa6,0x9d,0x9a,
+	0x93,0x84,0x74,0x71,0x6d,0x62,0x54,0x49,
+	0x4e,0x4b,0x40,0x37,0x3b,0x44,0x42,0x3b,
+	0x3b,0x4a,0x56,0x55,0x54,0x5f,0x73,0x7c,
+	0x7a,0x7c,0x92,0xa2,0xa2,0x9c,0xa4,0xba,
+	0xc1,0xb9,0xb5,0xc4,0xd1,0xcd,0xc1,0xc1,
+	0xce,0xd3,0xc5,0xba,0xc0,0xca,0xc5,0xb3,
+	0xae,0xb9,0xbd,0xb2,0xa4,0xa9,0xb3,0xb2,
+	0xa3,0xa1,0xa8,0xb0,0xa5,0x93,0x92,0x93,
+	0x84,0x67,0x5d,0x7f,0x9d,0x7b,0x7f,0x74,
+	0x5a,0x44,0x2c,0x3d,0x52,0x4c,0x61,0x43,
+	0x38,0x3c,0x42,0x37,0x34,0x3b,0x49,0x4a,
+	0x41,0x40,0x4c,0x53,0x4c,0x44,0x49,0x54,
+	0x54,0x4d,0x49,0x52,0x5c,0x58,0x53,0x56,
+	0x63,0x6a,0x65,0x63,0x70,0x7d,0x80,0x7d,
+	0x82,0x91,0x9d,0x9d,0x9b,0xa4,0xb6,0xba,
+	0xb5,0xb3,0xc1,0xca,0xc5,0xbe,0xc0,0xc6,
+	0xc7,0xbb,0xb1,0xb1,0xb6,0xaa,0x9a,0x91,
+	0x93,0x8d,0x80,0x6f,0x6b,0x6c,0x65,0x55,
+	0x4b,0x4f,0x51,0x4a,0x3d,0x3e,0x49,0x4c,
+	0x45,0x41,0x4d,0x5b,0x5d,0x57,0x5f,0x71,
+	0x7c,0x7e,0x7a,0x88,0x9b,0xa1,0x9c,0xa0,
+	0xac,0xbd,0xbb,0xb3,0xb9,0xc7,0xcb,0xc1,
+	0xbc,0xc3,0xcd,0xc9,0xbc,0xb9,0xc4,0xc7,
+	0xbb,0xb0,0xb4,0xbf,0xbc,0xac,0xa6,0xb4,
+	0xb8,0xaf,0x9f,0xa1,0xa8,0xa3,0x8c,0x76,
+	0x71,0x72,0x72,0x86,0x88,0x7e,0x9e,0x81,
+	0x59,0x45,0x3d,0x2f,0x3a,0x4d,0x44,0x64,
+	0x56,0x36,0x37,0x3f,0x3e,0x2b,0x2c,0x3d,
+	0x47,0x3d,0x34,0x39,0x4d,0x4e,0x40,0x3b,
+	0x4d,0x58,0x52,0x43,0x4e,0x5d,0x63,0x58,
+	0x54,0x65,0x78,0x73,0x67,0x70,0x88,0x92,
+	0x88,0x84,0x97,0xab,0xab,0xa1,0xa5,0xbc,
+	0xc8,0xbb,0xb3,0xc2,0xd2,0xcf,0xbc,0xbb,
+	0xc8,0xcd,0xbd,0xa9,0xac,0xb9,0xae,0x96,
+	0x86,0x91,0x93,0x7e,0x65,0x64,0x6f,0x6a,
+	0x4e,0x41,0x4f,0x56,0x4a,0x36,0x39,0x4c,
+	0x51,0x3f,0x3a,0x4d,0x60,0x5d,0x50,0x59,
+	0x74,0x81,0x75,0x71,0x86,0xa0,0x9e,0x93,
+	0x96,0xb3,0xbe,0xb3,0xa9,0xb6,0xce,0xca,
+	0xb8,0xb5,0xca,0xd5,0xc5,0xb3,0xbc,0xcf,
+	0xcb,0xb4,0xae,0xbf,0xc9,0xb9,0xa7,0xab,
+	0xbd,0xbb,0xa3,0x96,0xa1,0xa4,0x90,0x6e,
+	0x65,0x70,0x7c,0x83,0x8e,0x7b,0x86,0x95,
+	0x74,0x5b,0x54,0x45,0x33,0x43,0x5b,0x4f,
+	0x59,0x5a,0x4b,0x54,0x4f,0x3b,0x28,0x34,
+	0x45,0x43,0x32,0x31,0x45,0x52,0x44,0x38,
+	0x44,0x59,0x58,0x45,0x46,0x5a,0x67,0x5e,
+	0x50,0x5d,0x73,0x79,0x68,0x69,0x7e,0x92,
+	0x8a,0x7f,0x8b,0xa5,0xab,0x9f,0x9a,0xb0,
+	0xc4,0xbd,0xae,0xb6,0xcb,0xd0,0xbe,0xb4,
+	0xc2,0xd1,0xc3,0xad,0xab,0xb8,0xb9,0xa0,
+	0x8d,0x92,0x9c,0x8d,0x71,0x68,0x74,0x74,
+	0x5b,0x48,0x4d,0x5b,0x50,0x3b,0x36,0x47,
+	0x4f,0x41,0x34,0x40,0x54,0x58,0x47,0x49,
+	0x62,0x72,0x6b,0x63,0x72,0x8b,0x92,0x88,
+	0x88,0x9f,0xb1,0xab,0xa1,0xab,0xc0,0xc6,
+	0xb8,0xb3,0xc4,0xd3,0xc7,0xb9,0xbe,0xcf,
+	0xd1,0xbf,0xb5,0xc3,0xcc,0xc3,0xb1,0xb3,
+	0xc0,0xc1,0xae,0xa2,0xa6,0xad,0x9c,0x80,
+	0x74,0x77,0x71,0x68,0x75,0x9a,0x98,0x6f,
+	0x73,0x7b,0x76,0x62,0x40,0x33,0x51,0x72,
+	0x4d,0x3d,0x5a,0x66,0x61,0x48,0x34,0x35,
+	0x3e,0x3b,0x30,0x2b,0x3a,0x45,0x3c,0x36,
+	0x3b,0x4c,0x4d,0x44,0x41,0x51,0x5b,0x58,
+	0x4f,0x58,0x69,0x6e,0x66,0x67,0x75,0x87,
+	0x88,0x83,0x8b,0x9e,0xa5,0xa0,0x9f,0xaf,
+	0xbc,0xbb,0xb4,0xba,0xc8,0xcc,0xc3,0xc0,
+	0xc5,0xce,0xc6,0xbb,0xb7,0xbe,0xb9,0xac,
+	0x9e,0xa1,0x9f,0x96,0x82,0x80,0x7d,0x6f,
+	0x60,0x60,0x62,0x55,0x48,0x48,0x46,0x40,
+	0x39,0x3e,0x3e,0x3d,0x38,0x46,0x59,0x6c,
+	0x73,0x7a,0x82,0x8e,0x91,0x8e,0x8f,0x9c,
+	0xa0,0xa1,0x9c,0xa7,0xac,0xb1,0xac,0xaf,
+	0xb5,0xbf,0xb7,0xb8,0xb7,0xc2,0xbf,0xbc,
+	0xb5,0xbc,0xbe,0xbc,0xb1,0xb2,0xb5,0xb7,
+	0xab,0xa8,0xa6,0xaf,0xa4,0x9f,0x97,0xa2,
+	0x9d,0x99,0x8b,0x90,0x90,0x8f,0x7d,0x78,
+	0x72,0x6c,0x4d,0x64,0x6f,0x70,0x64,0x5a,
+	0x4f,0x55,0x53,0x52,0x43,0x49,0x4b,0x4e,
+	0x41,0x40,0x3f,0x49,0x40,0x3c,0x37,0x45,
+	0x3f,0x3f,0x33,0x3e,0x3e,0x44,0x35,0x3d,
+	0x3f,0x4b,0x3f,0x42,0x40,0x50,0x49,0x4e,
+	0x43,0x54,0x53,0x5a,0x4c,0x5a,0x5a,0x68,
+	0x58,0x62,0x60,0x74,0x66,0x70,0x66,0x7c,
+	0x71,0x80,0x6c,0x83,0x7a,0x88,0x4b,0x78,
+	0x6f,0xba,0x8b,0x92,0x61,0xa1,0x98,0xb7,
+	0x60,0x73,0x78,0xc3,0xb3,0x97,0x67,0x86,
+	0xaf,0xbd,0x91,0x6c,0x7c,0xa2,0xb7,0x81,
+	0x64,0x5a,0x98,0x98,0x88,0x42,0x60,0x6f,
+	0xa6,0x60,0x52,0x32,0x85,0x79,0x7e,0x28,
+	0x53,0x56,0x99,0x5a,0x60,0x36,0x88,0x79,
+	0x92,0x47,0x71,0x6e,0xb1,0x76,0x7c,0x5b,
+	0xaa,0xa5,0xaf,0x6c,0x8c,0x97,0xd3,0xa4,
+	0x97,0x7d,0xb9,0xc4,0xc6,0x90,0x97,0xab,
+	0xd6,0xbd,0x9d,0x8c,0xad,0xc9,0xc3,0x9e,
+	0x93,0xb0,0xce,0xca,0xa0,0x90,0x9e,0xbe,
+	0xae,0x86,0x60,0x77,0x89,0x8d,0x67,0x61,
+	0x6e,0x9c,0x9f,0x84,0x63,0x6e,0x89,0x90,
+	0x77,0x67,0x7a,0xa2,0xb8,0xa0,0x96,0x98,
+	0xbf,0xbf,0xbb,0x93,0xa9,0xa8,0xc8,0x9b,
+	0x9c,0x7a,0xa8,0x8b,0x9b,0x5c,0x7a,0x5a,
+	0x8a,0x4b,0x66,0x2e,0x6d,0x3f,0x70,0x2d,
+	0x64,0x3b,0x86,0x4b,0x87,0x4b,0x97,0x67,
+	0xaf,0x6c,0xb4,0x7d,0xc6,0x86,0xca,0x87,
+	0xcc,0x8e,0xd2,0x94,0xd3,0x8f,0xb1,0x62,
+	0xaf,0x6b,0x99,0x64,0x91,0x50,0x6c,0x4f,
+	0x77,0x41,0x56,0x3d,0x5f,0x37,0x50,0x3c,
+	0x5b,0x45,0x4a,0x38,0x4f,0x58,0x68,0x5f,
+	0x63,0x75,0x8e,0x9d,0x93,0x94,0x97,0xb3,
+	0xac,0xa3,0x81,0x8d,0x88,0x98,0x6a,0x64,
+	0x48,0x74,0x65,0x6e,0x42,0x65,0x6c,0xa2,
+	0x82,0x8e,0x7f,0xba,0xbc,0xc8,0x92,0xa5,
+	0xa2,0xc7,0x9b,0x82,0x5f,0x7d,0x80,0x77,
+	0x46,0x42,0x5a,0x88,0x93,0x6c,0x3c,0x61,
+	0x89,0xa7,0x95,0x98,0x98,0x9f,0x9e,0x71,
+	0x69,0x6e,0x94,0x80,0x60,0x32,0x47,0x5a,
+	0x66,0x3d,0x30,0x3c,0x71,0x7e,0x75,0x63,
+	0x80,0xab,0xc4,0xb0,0x97,0xa1,0xba,0xc4,
+	0x9c,0x7b,0x65,0x86,0x79,0x6a,0x35,0x4a,
+	0x52,0x81,0x5b,0x68,0x57,0x9f,0x9c,0xbd,
+	0x85,0xb1,0xa7,0xe0,0xa8,0xb3,0x7b,0xb9,
+	0x92,0xab,0x56,0x7b,0x56,0x99,0x59,0x76,
+	0x44,0x9b,0x82,0x94,0x47,0x7b,0x6f,0xcd,
+	0x9d,0x9b,0x5d,0x97,0x82,0xaa,0x63,0x7b,
+	0x5b,0x89,0x5b,0x5d,0x2f,0x52,0x50,0x62,
+	0x43,0x4b,0x59,0x82,0x8d,0x88,0x89,0x9c,
+	0xc0,0xbc,0xb7,0x94,0xab,0x9d,0xad,0x70,
+	0x70,0x4b,0x78,0x51,0x62,0x28,0x62,0x51,
+	0x93,0x5f,0x8d,0x70,0xc3,0xa3,0xd0,0x8c,
+	0xc9,0xa5,0xe0,0x92,0xad,0x71,0xb0,0x7c,
+	0x9b,0x4d,0x7c,0x5d,0x9e,0x67,0x8e,0x68,
+	0x8d,0x73,0x97,0x6a,0xa3,0x85,0xa1,0x7d,
+	0x77,0x66,0x89,0x84,0x80,0x59,0x51,0x58,
+	0x64,0x58,0x3c,0x39,0x45,0x6a,0x5f,0x64,
+	0x56,0x8a,0x96,0xb7,0x91,0xad,0xa1,0xd7,
+	0xae,0xb4,0x75,0x9e,0x7b,0x95,0x48,0x59,
+	0x32,0x73,0x4a,0x66,0x33,0x77,0x6f,0xb1,
+	0x7d,0xa4,0x8c,0xd8,0xb8,0xcf,0x8f,0xb9,
+	0xa4,0xc9,0x87,0x89,0x64,0x99,0x85,0x8a,
+	0x58,0x77,0x83,0xae,0x90,0x6c,0x64,0x93,
+	0xa0,0xa0,0x61,0x6a,0x7c,0x89,0x85,0x5f,
+	0x5d,0x66,0x7f,0x61,0x4a,0x2a,0x4f,0x50,
+	0x5e,0x2f,0x43,0x4a,0x8b,0x7a,0x89,0x6e,
+	0xac,0xb7,0xdd,0xa5,0xb1,0x9d,0xd0,0xa5,
+	0x9c,0x53,0x72,0x5e,0x7a,0x39,0x3e,0x2b,
+	0x6d,0x62,0x75,0x51,0x7f,0x95,0xc7,0xa8,
+	0xab,0xa3,0xcd,0xd0,0xc6,0x9b,0x9b,0xa5,
+	0xb3,0x9a,0x78,0x70,0x83,0x9e,0x8e,0x84,
+	0x7b,0x94,0x84,0xa1,0x72,0x7f,0x69,0x8b,
+	0x7c,0x69,0x48,0x71,0x6f,0x85,0x4a,0x52,
+	0x3e,0x6e,0x4d,0x52,0x22,0x4f,0x4f,0x7b,
+	0x54,0x6a,0x68,0xab,0xa4,0xb7,0x92,0xb5,
+	0xb9,0xd7,0xa9,0x9a,0x7e,0x97,0x89,0x74,
+	0x44,0x45,0x50,0x61,0x53,0x45,0x4a,0x6d,
+	0x8f,0x90,0x8c,0x8a,0xb3,0xc4,0xce,0xa8,
+	0xaf,0xae,0xce,0xb0,0xa6,0x7c,0x9d,0x95,
+	0xa9,0x78,0x85,0x81,0xb6,0x9d,0x87,0x5d,
+	0x94,0x84,0x9a,0x4f,0x66,0x4f,0x78,0x67,
+	0x6b,0x3e,0x59,0x57,0x70,0x47,0x3e,0x2e,
+	0x56,0x54,0x57,0x3b,0x51,0x6b,0x91,0x8b,
+	0x87,0x92,0xb2,0xcd,0xc4,0xb0,0xa0,0xb5,
+	0xb0,0xa6,0x70,0x65,0x5a,0x74,0x52,0x4a,
+	0x28,0x55,0x59,0x7d,0x59,0x78,0x78,0xb9,
+	0xaa,0xbf,0x94,0xc3,0xbd,0xe0,0xaa,0xb1,
+	0x94,0xc2,0xa7,0xaa,0x79,0x95,0x93,0xb8,
+	0x9a,0x97,0x71,0x87,0x9e,0x91,0x69,0x4e,
+	0x5c,0x78,0x63,0x42,0x46,0x4c,0x69,0x51,
+	0x4b,0x2c,0x4d,0x42,0x5a,0x2c,0x47,0x39,
+	0x76,0x60,0x82,0x60,0xa0,0x9b,0xd1,0xa4,
+	0xc3,0xa5,0xdb,0xb2,0xbd,0x7c,0x91,0x71,
+	0x89,0x4f,0x51,0x31,0x55,0x4b,0x5b,0x46,
+	0x5f,0x71,0x95,0x99,0x9b,0xa4,0xb7,0xd0,
+	0xc7,0xc4,0xac,0xc4,0xb8,0xc5,0x99,0xa3,
+	0x89,0xb5,0x94,0xad,0x83,0xb0,0x80,0x94,
+	0x79,0x93,0x64,0x8c,0x4b,0x76,0x48,0x5a,
+	0x3e,0x6b,0x41,0x53,0x2f,0x50,0x3c,0x4f,
+	0x2c,0x41,0x3b,0x5f,0x57,0x65,0x62,0x82,
+	0x97,0xa6,0xaa,0xaa,0xbb,0xc1,0xcd,0xb0,
+	0xad,0x92,0xa2,0x80,0x7e,0x4c,0x5d,0x41,
+	0x5e,0x3c,0x51,0x3a,0x6e,0x64,0x90,0x75,
+	0xa0,0x99,0xcc,0xb4,0xce,0xb0,0xd3,0xc0,
+	0xd5,0xae,0xb7,0xa4,0xba,0xac,0xad,0x9b,
+	0xa8,0xab,0x98,0x77,0x83,0x85,0x7d,0x7f,
+	0x54,0x45,0x50,0x57,0x44,0x49,0x32,0x37,
+	0x37,0x4c,0x3d,0x3b,0x28,0x3d,0x47,0x59,
+	0x4c,0x56,0x64,0x88,0x97,0x9d,0x9b,0xab,
+	0xc1,0xcd,0xbf,0xae,0xa6,0xa7,0xa6,0x89,
+	0x6d,0x5c,0x5e,0x61,0x54,0x42,0x3f,0x54,
+	0x68,0x73,0x69,0x7a,0x8b,0xb0,0xb0,0xb5,
+	0xa8,0xc3,0xc6,0xd7,0xb5,0xbb,0xab,0xcc,
+	0xb7,0xbc,0x99,0xb7,0xac,0xb6,0x71,0x7e,
+	0x7e,0x95,0x7c,0x7c,0x4d,0x42,0x54,0x69,
+	0x4b,0x30,0x30,0x3b,0x49,0x3f,0x3b,0x2d,
+	0x4a,0x46,0x5c,0x41,0x5d,0x59,0x89,0x79,
+	0x9a,0x81,0xb3,0xa5,0xcc,0xa0,0xbf,0x9c,
+	0xc2,0x96,0xa5,0x6f,0x88,0x63,0x7c,0x4f,
+	0x5d,0x44,0x63,0x53,0x68,0x5c,0x74,0x7a,
+	0x92,0x97,0x9e,0xa9,0xb1,0xc0,0xba,0xc6,
+	0xb6,0xc9,0xb7,0xca,0xb0,0xc7,0xac,0xc4,
+	0xa2,0xa0,0x69,0x98,0x7d,0x95,0x65,0x82,
+	0x56,0x4b,0x3d,0x63,0x49,0x4b,0x24,0x3c,
+	0x2d,0x45,0x35,0x3f,0x3c,0x53,0x56,0x5e,
+	0x5e,0x68,0x7d,0x8b,0x94,0x8f,0x9a,0xa5,
+	0xb6,0xb0,0xa7,0x9b,0xa6,0xa4,0x9e,0x81,
+	0x75,0x73,0x7b,0x73,0x5e,0x52,0x59,0x6f,
+	0x73,0x6a,0x5f,0x77,0x8c,0xa0,0x93,0x90,
+	0x9a,0xb8,0xc3,0xb8,0xa7,0xab,0xc3,0xcc,
+	0xc3,0xa4,0xac,0xae,0xba,0x7d,0x80,0x71,
+	0x9a,0x89,0x8c,0x5a,0x64,0x4c,0x6a,0x5b,
+	0x5e,0x36,0x4d,0x48,0x5f,0x31,0x3e,0x3d,
+	0x6f,0x63,0x61,0x49,0x67,0x82,0x91,0x81,
+	0x74,0x83,0x9e,0xb5,0x94,0x8e,0x7f,0xaf,
+	0x9f,0xa5,0x6a,0x85,0x77,0xa5,0x6f,0x75,
+	0x4a,0x84,0x73,0x8b,0x50,0x6e,0x67,0xa0,
+	0x81,0x8b,0x6b,0x9c,0xa3,0xb7,0x94,0x98,
+	0xa0,0xbf,0xbf,0xad,0x9d,0xa4,0xbe,0xb3,
+	0x92,0x67,0x85,0x90,0xa2,0x72,0x6e,0x62,
+	0x83,0x79,0x66,0x40,0x59,0x5e,0x6f,0x4e,
+	0x46,0x39,0x53,0x60,0x68,0x59,0x57,0x67,
+	0x7d,0x84,0x7b,0x76,0x80,0x94,0x98,0x92,
+	0x84,0x86,0x98,0x98,0x92,0x7d,0x82,0x82,
+	0x93,0x81,0x7d,0x6a,0x80,0x79,0x89,0x68,
+	0x79,0x6a,0x8f,0x7a,0x8a,0x6e,0x8e,0x86,
+	0xa6,0x89,0x9b,0x89,0xad,0xa0,0xb0,0x94,
+	0xa4,0xa1,0xb1,0x9b,0x83,0x78,0x8c,0x92,
+	0x89,0x75,0x6d,0x79,0x7d,0x87,0x64,0x5d,
+	0x53,0x7d,0x65,0x6d,0x3d,0x66,0x50,0x7d,
+	0x53,0x74,0x51,0x87,0x6e,0x91,0x64,0x8b,
+	0x72,0xa4,0x7c,0x94,0x6d,0x98,0x86,0x9c,
+	0x78,0x83,0x7b,0x92,0x87,0x81,0x74,0x7b,
+	0x86,0x86,0x80,0x6c,0x7b,0x7a,0x93,0x74,
+	0x81,0x6c,0x97,0x83,0x9e,0x71,0x97,0x83,
+	0xb3,0x8a,0xa3,0x7e,0xae,0x96,0xb1,0x7c,
+	0x8b,0x72,0xa1,0x82,0x8c,0x60,0x83,0x79,
+	0x8f,0x71,0x74,0x63,0x73,0x75,0x70,0x61,
+	0x5d,0x6c,0x6d,0x6d,0x5c,0x6c,0x72,0x87,
+	0x74,0x7b,0x6c,0x8c,0x86,0x90,0x74,0x85,
+	0x7d,0x97,0x82,0x86,0x70,0x8a,0x85,0x8f,
+	0x78,0x7e,0x79,0x8e,0x83,0x80,0x72,0x80,
+	0x83,0x89,0x7b,0x78,0x7a,0x86,0x8a,0x83,
+	0x7f,0x81,0x8d,0x93,0x8f,0x8a,0x8b,0x96,
+	0x9b,0x98,0x8d,0x8a,0x88,0x88,0x89,0x83,
+	0x7b,0x7d,0x80,0x82,0x78,0x7a,0x78,0x81,
+	0x73,0x6e,0x6a,0x74,0x72,0x72,0x69,0x6a,
+	0x68,0x79,0x78,0x7a,0x72,0x7a,0x7e,0x88,
+	0x82,0x7f,0x7b,0x85,0x89,0x85,0x80,0x7c,
+	0x84,0x84,0x89,0x7a,0x80,0x7c,0x8b,0x7f,
+	0x86,0x75,0x86,0x7d,0x8d,0x76,0x83,0x74,
+	0x8b,0x7c,0x8c,0x72,0x8a,0x7b,0x96,0x7f,
+	0x8f,0x7b,0x97,0x89,0x9b,0x83,0x92,0x85,
+	0x96,0x7e,0x87,0x7a,0x88,0x7f,0x84,0x79,
+	0x79,0x7b,0x82,0x83,0x76,0x71,0x6c,0x7e,
+	0x75,0x7c,0x64,0x76,0x6a,0x86,0x6d,0x81,
+	0x68,0x8a,0x75,0x92,0x6d,0x8b,0x70,0x99,
+	0x77,0x8f,0x6b,0x90,0x79,0x95,0x71,0x88,
+	0x70,0x93,0x7b,0x8c,0x70,0x87,0x7c,0x8f,
+	0x7a,0x80,0x75,0x86,0x84,0x83,0x7b,0x79,
+	0x86,0x86,0x8b,0x7a,0x85,0x7f,0x99,0x83,
+	0x93,0x75,0x98,0x84,0x9e,0x71,0x88,0x70,
+	0x9c,0x78,0x8e,0x61,0x8c,0x73,0x98,0x6c,
+	0x87,0x62,0x8c,0x70,0x8b,0x60,0x7f,0x6b,
+	0x8b,0x6c,0x7c,0x67,0x89,0x7b,0x88,0x70,
+	0x80,0x7d,0x8f,0x81,0x7d,0x79,0x85,0x8a,
+	0x83,0x7f,0x76,0x86,0x82,0x8e,0x74,0x80,
+	0x77,0x93,0x7b,0x88,0x6c,0x8c,0x78,0x95,
+	0x6c,0x87,0x6d,0x98,0x76,0x90,0x68,0x92,
+	0x79,0x9d,0x73,0x8f,0x72,0x9f,0x7e,0x9a,
+	0x6e,0x93,0x78,0x98,0x74,0x89,0x6e,0x90,
+	0x7c,0x89,0x6e,0x80,0x7c,0x8c,0x76,0x75,
+	0x71,0x80,0x81,0x7a,0x72,0x6f,0x7e,0x7f,
+	0x84,0x70,0x7c,0x78,0x91,0x7a,0x86,0x6c,
+	0x8d,0x7e,0x97,0x6c,0x89,0x70,0x9a,0x78,
+	0x8d,0x66,0x91,0x77,0x9a,0x6b,0x88,0x6c,
+	0x98,0x77,0x8e,0x65,0x8c,0x77,0x96,0x71,
+	0x84,0x6f,0x95,0x7e,0x8c,0x70,0x87,0x82,
+	0x96,0x7f,0x82,0x7c,0x8c,0x8e,0x87,0x7a,
+	0x78,0x88,0x88,0x89,0x71,0x7d,0x79,0x92,
+	0x7a,0x81,0x6a,0x88,0x79,0x8e,0x67,0x80,
+	0x6a,0x93,0x70,0x85,0x62,0x8c,0x77,0x95,
+	0x69,0x86,0x6e,0x98,0x78,0x8d,0x67,0x8e,
+	0x7b,0x99,0x6d,0x86,0x70,0x97,0x7b,0x8a,
+	0x6a,0x88,0x7e,0x93,0x74,0x7d,0x73,0x8e,
+	0x82,0x83,0x71,0x7f,0x84,0x8c,0x7f,0x77,
+	0x7b,0x89,0x8f,0x80,0x7c,0x79,0x8e,0x8a,
+	0x8c,0x73,0x83,0x81,0x96,0x7a,0x7f,0x6f,
+	0x90,0x81,0x8c,0x6b,0x81,0x76,0x97,0x75,
+	0x80,0x67,0x8b,0x7d,0x8c,0x68,0x7d,0x70,
+	0x93,0x77,0x83,0x67,0x88,0x80,0x91,0x70,
+	0x7f,0x74,0x95,0x81,0x85,0x6d,0x87,0x84,
+	0x91,0x78,0x7c,0x76,0x8f,0x85,0x82,0x70,
+	0x7e,0x83,0x8f,0x7c,0x75,0x77,0x86,0x8b,
+	0x81,0x75,0x78,0x86,0x8b,0x84,0x77,0x7b,
+	0x85,0x90,0x83,0x7e,0x78,0x89,0x8a,0x8b,
+	0x78,0x7d,0x7e,0x8d,0x84,0x7d,0x73,0x83,
+	0x86,0x89,0x76,0x78,0x7a,0x89,0x83,0x7a,
+	0x75,0x7b,0x83,0x85,0x79,0x73,0x7b,0x84,
+	0x86,0x7d,0x77,0x7a,0x86,0x87,0x80,0x78,
+	0x7d,0x85,0x8a,0x7f,0x7c,0x7b,0x86,0x86,
+	0x84,0x78,0x7e,0x80,0x87,0x80,0x7c,0x78,
+	0x82,0x84,0x81,0x7a,0x7c,0x80,0x84,0x83,
+	0x7d,0x7e,0x80,0x86,0x81,0x83,0x7e,0x85,
+	0x80,0x89,0x7c,0x88,0x7c,0x89,0x7c,0x89,
+	0x78,0x88,0x75,0x86,0x73,0x88,0x83,0x89,
+	0x72,0x73,0x7d,0x85,0x7f,0x7d,0x7b,0x80,
+	0x7e,0x7e,0x7b,0x80,0x82,0x81,0x7d,0x7d,
+	0x7e,0x82,0x82,0x7e,0x7d,0x81,0x82,0x85,
+	0x7e,0x7e,0x7d,0x84,0x83,0x81,0x7c,0x7d,
+	0x82,0x85,0x81,0x7d,0x7d,0x83,0x83,0x82,
+	0x7d,0x7c,0x80,0x85,0x84,0x7c,0x7c,0x7f,
+	0x84,0x85,0x7d,0x7c,0x7e,0x84,0x84,0x7f,
+	0x7b,0x7e,0x84,0x86,0x7f,0x7b,0x7d,0x83,
+	0x87,0x80,0x7b,0x7c,0x82,0x87,0x81,0x7c,
+	0x7a,0x82,0x85,0x84,0x7b,0x7a,0x81,0x88,
+	0x83,0x7d,0x79,0x7f,0x86,0x84,0x7d,0x7a,
+	0x7e,0x85,0x86,0x7f,0x79,0x7d,0x85,0x86,
+	0x80,0x79,0x7b,0x84,0x85,0x82,0x7a,0x7a,
+	0x83,0x87,0x83,0x7a,0x7b,0x82,0x86,0x84,
+	0x7c,0x78,0x81,0x87,0x85,0x7c,0x7b,0x7d,
+	0x88,0x84,0x7f,0x7a,0x6d,0x42,0x76,0x61,
+	0xac,0x9c,0x81,0x77,0x4a,0x9d,0x83,0x83,
+	0x50,0x4f,0x7b,0xb2,0xb3,0x81,0x51,0x5e,
+	0x87,0xbe,0x98,0x76,0x45,0x66,0x96,0xa4,
+	0x91,0x47,0x58,0x60,0xa4,0x8d,0x6b,0x4c,
+	0x3f,0x84,0x74,0x91,0x40,0x49,0x4b,0x6d,
+	0x85,0x48,0x58,0x28,0x76,0x65,0x74,0x53,
+	0x31,0x62,0x4b,0x8f,0x3e,0x57,0x34,0x60,
+	0x83,0x5e,0x74,0x23,0x71,0x55,0x92,0x6e,
+	0x4d,0x62,0x47,0xa7,0x67,0x95,0x44,0x6b,
+	0x80,0x86,0xb0,0x57,0x8d,0x50,0xb1,0x96,
+	0x9c,0x8f,0x5d,0xad,0x80,0xd6,0x7c,0x99,
+	0x7d,0x92,0xc6,0x8f,0xbb,0x5e,0xab,0x8a,
+	0xb9,0xa5,0x77,0x9a,0x68,0xc7,0x80,0xa7,
+	0x69,0x73,0x8f,0x80,0xac,0x53,0x83,0x4c,
+	0x89,0x7e,0x6e,0x6e,0x38,0x76,0x4e,0x86,
+	0x52,0x55,0x4d,0x49,0x73,0x4c,0x6d,0x3c,
+	0x60,0x57,0x63,0x66,0x4c,0x6d,0x57,0x7b,
+	0x63,0x6d,0x5f,0x6a,0x7f,0x73,0x79,0x67,
+	0x6f,0x6f,0x7d,0x74,0x6f,0x71,0x74,0x82,
+	0x85,0x8b,0x9a,0xa9,0xaa,0x94,0x6c,0x6c,
+	0x80,0xb2,0xcc,0xd9,0xce,0xaf,0x99,0x73,
+	0x88,0x86,0x91,0x88,0x81,0x8c,0x71,0x74,
+	0x49,0x5d,0x59,0x68,0x66,0x4d,0x61,0x4d,
+	0x7b,0x63,0x70,0x58,0x55,0x71,0x67,0x86,
+	0x59,0x6f,0x5a,0x77,0x85,0x74,0x82,0x5c,
+	0x8c,0x7c,0xa4,0x8b,0x86,0x93,0x8a,0xbf,
+	0x9f,0xbd,0x90,0xad,0xb7,0xbe,0xd3,0xa1,
+	0xbe,0xa1,0xd2,0xc1,0xbf,0xb0,0x90,0xbb,
+	0x9f,0xc6,0x8c,0x8f,0x7c,0x81,0xa2,0x75,
+	0x86,0x44,0x71,0x62,0x7a,0x72,0x47,0x5f,
+	0x40,0x86,0x65,0x7a,0x54,0x59,0x82,0x7b,
+	0xaa,0x6d,0x8e,0x74,0xa5,0xb9,0xa7,0xb0,
+	0x7d,0xbc,0xa8,0xda,0xb3,0xa0,0xa4,0x9a,
+	0xd8,0xa8,0xbe,0x7b,0x96,0x9e,0xa5,0xb2,
+	0x6f,0x84,0x5f,0x9c,0x8a,0x82,0x6a,0x44,
+	0x79,0x64,0x98,0x57,0x57,0x47,0x5f,0x8c,
+	0x68,0x78,0x39,0x6d,0x75,0x9f,0x9b,0x73,
+	0x85,0x5e,0x9f,0x90,0x98,0x7a,0x86,0xb4,
+	0xb9,0xc8,0x77,0x8a,0x67,0xa9,0xbd,0xab,
+	0x9f,0x68,0x96,0x93,0xbc,0x96,0x6f,0x6f,
+	0x66,0xa4,0x7f,0x84,0x46,0x4e,0x66,0x6d,
+	0x7f,0x3d,0x45,0x2d,0x65,0x6c,0x61,0x4f,
+	0x27,0x5e,0x5e,0x91,0x66,0x59,0x5a,0x6d,
+	0xa8,0x94,0x9d,0x6d,0x8c,0xa4,0xc3,0xca,
+	0x99,0xa5,0x94,0xd0,0xcc,0xc3,0xa2,0x88,
+	0xac,0xac,0xc9,0x91,0x7e,0x6c,0x7f,0x9c,
+	0x80,0x72,0x3b,0x56,0x5c,0x76,0x67,0x3c,
+	0x3b,0x36,0x6f,0x6b,0x66,0x45,0x3f,0x6c,
+	0x7d,0x9c,0x71,0x72,0x6c,0x99,0xbb,0xb0,
+	0xa5,0x81,0xa8,0xb9,0xd9,0xc5,0xa1,0x9f,
+	0xa3,0xd5,0xc7,0xba,0x8e,0x8b,0xa4,0xb2,
+	0xba,0x84,0x74,0x6a,0x8e,0x9c,0x87,0x68,
+	0x45,0x62,0x71,0x8b,0x69,0x47,0x41,0x53,
+	0x84,0x83,0x78,0x53,0x66,0x8c,0xaf,0xb6,
+	0x86,0x68,0x50,0x97,0xa6,0x98,0x84,0x7a,
+	0x9d,0xa5,0x9d,0x86,0x68,0x58,0x7f,0xa8,
+	0xa3,0x87,0x61,0x6d,0x8d,0xa4,0x93,0x66,
+	0x52,0x59,0x82,0x86,0x6d,0x44,0x34,0x50,
+	0x66,0x6f,0x4a,0x2e,0x2b,0x4a,0x69,0x5f,
+	0x4a,0x2a,0x44,0x62,0x81,0x79,0x5a,0x59,
+	0x68,0x9e,0xa7,0x9f,0x84,0x81,0xaa,0xc0,
+	0xd5,0xaf,0xa5,0xa1,0xc1,0xdd,0xc9,0xb5,
+	0x8f,0xa3,0xb3,0xbe,0xa9,0x7d,0x75,0x70,
+	0x96,0x85,0x72,0x4a,0x41,0x5d,0x61,0x6e,
+	0x40,0x38,0x35,0x54,0x6e,0x5d,0x56,0x3a,
+	0x5e,0x73,0x91,0x82,0x6a,0x76,0x7f,0xb4,
+	0xad,0xac,0x91,0x96,0xbb,0xc5,0xd8,0xa8,
+	0xae,0xa4,0xc3,0xd4,0xbb,0xb1,0x8b,0xab,
+	0xac,0xbe,0xa4,0x81,0x86,0x7e,0xa8,0x8d,
+	0x89,0x62,0x63,0x80,0x7e,0x8f,0x5d,0x65,
+	0x5d,0x81,0x91,0x81,0x83,0x64,0x99,0x97,
+	0xae,0x79,0x4e,0x73,0x6e,0x9c,0x89,0x9c,
+	0x7d,0x85,0x8a,0x6d,0x97,0x5f,0x63,0x53,
+	0x80,0x89,0x76,0x77,0x4f,0x7e,0x6f,0x8b,
+	0x6a,0x53,0x59,0x4e,0x7d,0x53,0x60,0x33,
+	0x40,0x50,0x4c,0x63,0x2c,0x46,0x2e,0x56,
+	0x5c,0x4e,0x56,0x36,0x6a,0x5c,0x87,0x70,
+	0x6c,0x7d,0x79,0xb1,0x93,0xb3,0x94,0xa7,
+	0xba,0xb9,0xd8,0xa8,0xc6,0xa6,0xc7,0xc8,
+	0xb6,0xc0,0x8c,0xb3,0x90,0xaf,0x91,0x7d,
+	0x7d,0x5d,0x88,0x5c,0x74,0x48,0x49,0x53,
+	0x43,0x68,0x37,0x56,0x32,0x50,0x5c,0x55,
+	0x71,0x43,0x73,0x5f,0x8b,0x8a,0x83,0x96,
+	0x7a,0xb5,0x9d,0xc7,0xa9,0xa8,0xbc,0xad,
+	0xe0,0xb3,0xcc,0xa5,0xb8,0xc6,0xb7,0xcf,
+	0x94,0xb1,0x92,0xb4,0xae,0x94,0x9a,0x6e,
+	0x9d,0x84,0x9e,0x7e,0x6e,0x7c,0x6d,0xa1,
+	0x7b,0x8d,0x70,0x80,0x9f,0x99,0xb1,0x72,
+	0x6b,0x48,0x83,0x8f,0x6c,0x6f,0x5b,0x90,
+	0x93,0xaa,0x8c,0x57,0x50,0x60,0x8e,0x60,
+	0x4d,0x35,0x3f,0x60,0x5b,0x6d,0x3f,0x4b,
+	0x45,0x60,0x67,0x4b,0x46,0x2b,0x4c,0x4d,
+	0x57,0x43,0x2a,0x37,0x3c,0x5c,0x4f,0x45,
+	0x39,0x44,0x61,0x6a,0x72,0x5c,0x65,0x72,
+	0x90,0x9f,0x95,0x94,0x93,0xab,0xc1,0xc8,
+	0xbf,0xb3,0xba,0xcb,0xd7,0xd3,0xbf,0xb6,
+	0xb7,0xbf,0xc3,0xae,0x9f,0x8b,0x90,0x93,
+	0x89,0x80,0x5e,0x64,0x57,0x65,0x5b,0x4a,
+	0x48,0x38,0x52,0x43,0x53,0x44,0x44,0x55,
+	0x4f,0x71,0x59,0x74,0x6b,0x7c,0x8e,0x85,
+	0xa7,0x8b,0xb3,0xa2,0xb7,0xbe,0xb3,0xd1,
+	0xb2,0xd8,0xb9,0xcf,0xc9,0xbf,0xd5,0xa9,
+	0xce,0xa9,0xc5,0xb9,0xac,0xb7,0x91,0xbc,
+	0x96,0xb2,0x96,0x90,0x9f,0x88,0xb8,0x8a,
+	0xa9,0x89,0x9c,0xad,0x99,0xa6,0x61,0x61,
+	0x56,0x8a,0x88,0x69,0x63,0x4d,0x7f,0x79,
+	0x8d,0x7f,0x61,0x6b,0x3e,0x6f,0x60,0x66,
+	0x47,0x37,0x5a,0x47,0x61,0x31,0x4a,0x46,
+	0x5c,0x69,0x46,0x51,0x33,0x5b,0x5a,0x5f,
+	0x4e,0x34,0x4d,0x49,0x6f,0x56,0x51,0x43,
+	0x4d,0x72,0x6f,0x79,0x57,0x63,0x73,0x8f,
+	0xa0,0x89,0x85,0x80,0xa3,0xba,0xbb,0xad,
+	0x99,0xa8,0xbc,0xd3,0xc8,0xaf,0xa1,0xa9,
+	0xc2,0xca,0xb4,0x94,0x86,0x92,0xa6,0xa2,
+	0x8a,0x63,0x63,0x6f,0x7f,0x7b,0x57,0x4b,
+	0x3e,0x63,0x68,0x61,0x4c,0x37,0x53,0x5b,
+	0x7d,0x63,0x5d,0x55,0x64,0x91,0x85,0x94,
+	0x6e,0x83,0x94,0xa9,0xbf,0x98,0xa8,0x90,
+	0xc0,0xc4,0xc4,0xbc,0x99,0xbf,0xb1,0xd8,
+	0xbd,0xae,0xab,0x9d,0xcc,0xaf,0xc2,0x95,
+	0x9a,0xa6,0xa6,0xc3,0x94,0xa4,0x89,0xa6,
+	0xb5,0xa7,0xb2,0x7c,0x9b,0x77,0x83,0x64,
+	0x71,0x77,0x66,0x83,0x5f,0x78,0x5e,0x5f,
+	0x79,0x73,0x96,0x64,0x60,0x32,0x45,0x74,
+	0x5d,0x72,0x28,0x40,0x31,0x4c,0x50,0x3e,
+	0x48,0x33,0x56,0x4e,0x59,0x4c,0x3d,0x4f,
+	0x46,0x62,0x50,0x51,0x49,0x4b,0x61,0x5e,
+	0x6c,0x59,0x61,0x66,0x75,0x84,0x7e,0x82,
+	0x7a,0x8d,0x99,0xa4,0xa4,0x9d,0xa1,0xa9,
+	0xb6,0xbd,0xb8,0xb0,0xb1,0xb3,0xbf,0xbb,
+	0xb7,0xa7,0xa1,0xa9,0xa4,0xaa,0x90,0x8c,
+	0x7e,0x82,0x88,0x77,0x79,0x56,0x66,0x5c,
+	0x68,0x63,0x4e,0x57,0x41,0x64,0x56,0x63,
+	0x59,0x4c,0x67,0x5b,0x85,0x68,0x7b,0x6f,
+	0x79,0x99,0x89,0xad,0x83,0xa2,0x9d,0xaf,
+	0xc4,0xa6,0xc1,0x9b,0xc7,0xbe,0xca,0xc6,
+	0xa8,0xc6,0xaa,0xd8,0xb7,0xbd,0xaf,0xa3,
+	0xc6,0xa9,0xcb,0x9c,0xac,0xa4,0xad,0xc3,
+	0xa2,0xb6,0x8f,0xaa,0x9b,0x8e,0x7b,0x44,
+	0x7d,0x73,0x95,0x8e,0x6f,0x66,0x51,0x78,
+	0x61,0x83,0x5a,0x61,0x4c,0x40,0x48,0x45,
+	0x6b,0x3c,0x69,0x4a,0x45,0x46,0x27,0x40,
+	0x2a,0x51,0x45,0x48,0x43,0x36,0x55,0x47,
+	0x64,0x46,0x4d,0x4d,0x50,0x6c,0x56,0x6a,
+	0x4d,0x66,0x6b,0x74,0x81,0x69,0x7f,0x71,
+	0x95,0x92,0x98,0x95,0x88,0xa8,0xa2,0xbd,
+	0xaa,0xa9,0xaa,0xac,0xc7,0xb6,0xc0,0xa2,
+	0xad,0xb3,0xb4,0xba,0x9c,0x9d,0x8c,0x9e,
+	0x9c,0x91,0x84,0x6b,0x77,0x73,0x7d,0x6b,
+	0x5c,0x54,0x54,0x67,0x5e,0x5c,0x4a,0x4b,
+	0x55,0x62,0x6a,0x5e,0x59,0x5c,0x70,0x7f,
+	0x84,0x7c,0x77,0x81,0x95,0xa1,0xa3,0x9b,
+	0x99,0xa7,0xb5,0xc5,0xba,0xb5,0xb1,0xbb,
+	0xcd,0xcc,0xcb,0xb4,0xbb,0xbf,0xcc,0xcf,
+	0xbb,0xb8,0xac,0xc4,0xc2,0xc6,0xb6,0xa6,
+	0xb5,0xb1,0xc2,0xab,0x9b,0x83,0x74,0x75,
+	0x65,0x8f,0x7e,0x76,0x94,0x87,0x7e,0x62,
+	0x63,0x52,0x6c,0x65,0x64,0x47,0x2a,0x2f,
+	0x42,0x74,0x4d,0x61,0x49,0x3a,0x48,0x3c,
+	0x44,0x28,0x38,0x35,0x4c,0x50,0x40,0x45,
+	0x36,0x56,0x52,0x5e,0x4f,0x44,0x56,0x55,
+	0x76,0x5f,0x67,0x58,0x67,0x7e,0x7d,0x8c,
+	0x6d,0x83,0x82,0x9e,0xa6,0x97,0x9d,0x8e,
+	0xb4,0xb1,0xc3,0xae,0xa3,0xb4,0xb3,0xd3,
+	0xb6,0xba,0x9f,0xaa,0xbb,0xb1,0xb6,0x89,
+	0x98,0x86,0x9e,0x97,0x7e,0x77,0x59,0x7c,
+	0x6d,0x7b,0x5a,0x4a,0x53,0x4f,0x72,0x51,
+	0x57,0x3c,0x4f,0x64,0x63,0x70,0x48,0x63,
+	0x5d,0x82,0x85,0x7a,0x7e,0x6b,0x9c,0x96,
+	0xb2,0x96,0x94,0xa1,0xa7,0xcc,0xb0,0xbb,
+	0x9f,0xb4,0xc3,0xc5,0xcc,0xa4,0xba,0xaa,
+	0xcb,0xc5,0xb7,0xb2,0x9b,0xc0,0xb3,0xc9,
+	0xa8,0xa3,0xa7,0xa4,0xc3,0x9d,0xa1,0x73,
+	0x79,0x74,0x72,0x90,0x7f,0x7a,0x81,0xa3,
+	0x88,0x74,0x65,0x4f,0x6a,0x55,0x62,0x33,
+	0x2f,0x41,0x63,0x6a,0x5e,0x6e,0x3b,0x4c,
+	0x49,0x4f,0x4d,0x31,0x40,0x36,0x59,0x50,
+	0x4e,0x44,0x3c,0x5a,0x53,0x6e,0x4b,0x53,
+	0x51,0x61,0x77,0x66,0x6f,0x55,0x75,0x78,
+	0x8c,0x89,0x75,0x87,0x7f,0xab,0x9e,0xa6,
+	0x95,0x98,0xb3,0xb4,0xcb,0xa7,0xb2,0xa8,
+	0xc0,0xcc,0xbd,0xba,0x9a,0xb8,0xad,0xc1,
+	0xaa,0x92,0x92,0x87,0xa5,0x8a,0x8b,0x67,
+	0x67,0x70,0x6c,0x77,0x4d,0x54,0x42,0x5a,
+	0x5b,0x52,0x4d,0x35,0x53,0x4e,0x69,0x55,
+	0x53,0x55,0x5b,0x7f,0x73,0x81,0x6a,0x7f,
+	0x8d,0x9b,0xab,0x91,0xa2,0x96,0xbd,0xba,
+	0xbf,0xb7,0xa9,0xc3,0xbc,0xd7,0xbd,0xbe,
+	0xb6,0xbd,0xce,0xc2,0xc7,0xab,0xba,0xba,
+	0xc3,0xc1,0xae,0xb2,0xa4,0xbb,0xab,0xaa,
+	0x96,0x83,0x84,0x72,0x77,0x68,0x86,0x95,
+	0x7f,0x8f,0x9c,0x8e,0x69,0x62,0x4b,0x42,
+	0x33,0x2a,0x46,0x59,0x53,0x50,0x6e,0x59,
+	0x4e,0x49,0x43,0x45,0x38,0x39,0x36,0x3f,
+	0x45,0x41,0x45,0x3c,0x4a,0x48,0x53,0x4d,
+	0x4e,0x4f,0x56,0x61,0x5c,0x63,0x60,0x69,
+	0x72,0x76,0x7d,0x7a,0x83,0x8a,0x96,0x99,
+	0x9c,0xa1,0xa7,0xb0,0xb9,0xbb,0xb9,0xbb,
+	0xc4,0xca,0xc9,0xc7,0xc1,0xc4,0xc2,0xc6,
+	0xbd,0xb1,0xac,0xa4,0xaa,0x9d,0x95,0x82,
+	0x7e,0x7c,0x74,0x73,0x5a,0x5a,0x4b,0x56,
+	0x50,0x47,0x42,0x35,0x46,0x3e,0x4d,0x3f,
+	0x40,0x44,0x4b,0x61,0x56,0x67,0x56,0x6e,
+	0x76,0x83,0x8c,0x81,0x94,0x8c,0xaf,0xa6,
+	0xb3,0xaa,0xab,0xc3,0xb9,0xd5,0xb8,0xc5,
+	0xbd,0xca,0xd6,0xc4,0xd0,0xb2,0xce,0xc0,
+	0xd1,0xc4,0xb7,0xc0,0xb0,0xcd,0xb2,0xbe,
+	0xa4,0xa6,0xaa,0x9a,0xa1,0x73,0x7c,0x57,
+	0x70,0x7c,0x99,0x93,0x59,0x8a,0x7b,0x7e,
+	0x4b,0x38,0x32,0x40,0x74,0x42,0x4b,0x4f,
+	0x68,0x58,0x4d,0x4e,0x2e,0x40,0x26,0x46,
+	0x32,0x3f,0x39,0x31,0x4b,0x36,0x56,0x38,
+	0x4e,0x44,0x4d,0x59,0x49,0x64,0x49,0x6d,
+	0x5f,0x72,0x6f,0x6e,0x84,0x75,0x96,0x81,
+	0x9c,0x91,0xa1,0xac,0xa3,0xbc,0xa4,0xc7,
+	0xb5,0xcd,0xc0,0xc1,0xca,0xbe,0xd6,0xbc,
+	0xcc,0xb2,0xbd,0xb9,0xb1,0xb4,0x94,0xa1,
+	0x8e,0x98,0x83,0x84,0x6e,0x66,0x5f,0x57,
+	0x61,0x51,0x4c,0x44,0x3f,0x39,0x3d,0x3e,
+	0x42,0x40,0x3e,0x3f,0x46,0x51,0x56,0x5a,
+	0x5c,0x62,0x6e,0x7a,0x82,0x85,0x88,0x91,
+	0x9c,0xa5,0xac,0xac,0xb0,0xb5,0xbe,0xc5,
+	0xc4,0xc2,0xc5,0xc6,0xca,0xce,0xca,0xc7,
+	0xc6,0xc6,0xcb,0xc8,0xc4,0xbe,0xbe,0xbe,
+	0xbf,0xbb,0xb5,0xab,0xa9,0xa1,0x9b,0x89,
+	0x79,0x57,0x60,0x8b,0x8d,0x84,0x76,0x6f,
+	0x69,0x66,0x65,0x5d,0x59,0x56,0x55,0x57,
+	0x52,0x4f,0x4b,0x4b,0x4a,0x4a,0x48,0x42,
+	0x42,0x43,0x42,0x41,0x3f,0x3e,0x3e,0x3e,
+	0x3e,0x40,0x3f,0x3d,0x3d,0x40,0x43,0x44,
+	0x41,0x44,0x46,0x48,0x4a,0x4c,0x4c,0x4f,
+	0x4f,0x56,0x55,0x5b,0x5a,0x5f,0x60,0x64,
+	0x66,0x69,0x6a,0x6f,0x70,0x73,0x76,0x78,
+	0x7b,0x7c,0x81,0x64,0x4b,0x7d,0x6d,0xad,
+	0xc4,0x8a,0x9e,0x66,0x81,0xae,0x6b,0xb8,
+	0x84,0x76,0xd5,0x81,0xcc,0xa1,0x6b,0xbf,
+	0x70,0xb5,0xb7,0x6b,0xb3,0x54,0x7d,0x9d,
+	0x56,0xa8,0x59,0x5b,0x84,0x38,0x8f,0x5d,
+	0x49,0x7b,0x23,0x6d,0x5c,0x45,0x7f,0x28,
+	0x57,0x5e,0x48,0x99,0x55,0x6c,0x76,0x49,
+	0x9c,0x76,0x83,0x95,0x5c,0xa2,0x94,0xa4,
+	0xc5,0x87,0xad,0x9f,0xa7,0xda,0xb0,0xc7,
+	0xb4,0x9e,0xd0,0xb8,0xcf,0xca,0xaa,0xc7,
+	0xb7,0xca,0xd5,0xbe,0xc9,0xb4,0xb9,0xc8,
+	0xbd,0xc4,0xaf,0x9f,0x9f,0x95,0x95,0x88,
+	0x79,0x6c,0x6c,0x74,0x8a,0x95,0x89,0x86,
+	0x7c,0x79,0x88,0x73,0x7c,0x76,0x71,0x92,
+	0x94,0xb0,0xb7,0x9f,0xbe,0xa8,0xbf,0xce,
+	0xa6,0xbd,0x9d,0x9f,0xba,0x8e,0xac,0x85,
+	0x6f,0x8f,0x62,0x86,0x73,0x49,0x6d,0x35,
+	0x5d,0x6b,0x43,0x70,0x34,0x49,0x69,0x4b,
+	0x92,0x63,0x64,0x86,0x5b,0xac,0x9c,0x92,
+	0xb7,0x71,0xaf,0xb1,0xa8,0xe1,0x99,0xa7,
+	0x99,0x5e,0xaf,0x8b,0x91,0x85,0x43,0x8e,
+	0x7c,0x85,0xa1,0x42,0x59,0x52,0x49,0x7c,
+	0x3b,0x5e,0x47,0x22,0x6c,0x48,0x73,0x7b,
+	0x3d,0x75,0x4e,0x74,0xa6,0x6f,0xa0,0x6e,
+	0x63,0xa4,0x74,0xaf,0x92,0x60,0x8f,0x55,
+	0x93,0xa4,0x72,0xa3,0x53,0x6a,0x95,0x6e,
+	0xb8,0x77,0x64,0x85,0x4e,0xab,0x9f,0x85,
+	0xac,0x53,0x8f,0xa2,0x90,0xd3,0x77,0x7a,
+	0x82,0x51,0xb5,0x81,0x84,0x90,0x4a,0x8e,
+	0x6c,0x77,0xab,0x51,0x75,0x68,0x64,0xd1,
+	0x9d,0xae,0x6a,0x26,0x73,0x61,0x88,0x97,
+	0x35,0x63,0x37,0x5b,0xa5,0x68,0x8f,0x58,
+	0x42,0x94,0x78,0xb6,0xa1,0x5a,0x84,0x51,
+	0x90,0xb6,0x7e,0xa0,0x51,0x5c,0x94,0x7f,
+	0xc2,0x8a,0x60,0x79,0x4f,0xa3,0xa8,0x85,
+	0x97,0x48,0x6f,0x97,0x98,0xd5,0x90,0x80,
+	0x8a,0x77,0xcf,0xbc,0xab,0x9d,0x56,0x88,
+	0x9f,0xb4,0xe0,0x73,0x53,0x4e,0x4a,0xa6,
+	0x8c,0x90,0x72,0x51,0x8f,0xa2,0x96,0x8e,
+	0x40,0x3b,0x37,0x4d,0x8d,0x6f,0x6f,0x46,
+	0x2e,0x68,0x72,0x9f,0x9d,0x62,0x6c,0x59,
+	0x85,0xb4,0x96,0x97,0x5e,0x50,0x80,0x87,
+	0xb2,0x9a,0x67,0x6c,0x5a,0x91,0xb3,0x9b,
+	0x95,0x5a,0x59,0x80,0x8d,0xb6,0x94,0x6c,
+	0x6f,0x65,0xa8,0xc2,0xb5,0xab,0x75,0x81,
+	0xa3,0xb4,0xd8,0xaa,0x91,0x8e,0x8b,0x9d,
+	0x9a,0x8b,0x6a,0x40,0x54,0x7a,0x94,0xb6,
+	0x8b,0x7b,0x57,0x3c,0x7d,0x6e,0x67,0x4d,
+	0x21,0x41,0x5e,0x83,0x96,0x68,0x56,0x50,
+	0x6a,0xa4,0xa4,0x9b,0x72,0x4e,0x69,0x81,
+	0xa1,0xa0,0x6e,0x5a,0x53,0x74,0xa8,0xa9,
+	0x9d,0x75,0x5e,0x7e,0x98,0xb7,0xa8,0x77,
+	0x63,0x5a,0x7f,0xa6,0xa4,0x94,0x6b,0x63,
+	0x88,0xa6,0xc8,0xb5,0x8e,0x82,0x84,0xb5,
+	0xd8,0xd4,0xaf,0x5b,0x5b,0x6d,0x84,0xa0,
+	0x85,0x60,0x54,0x5e,0x93,0xb3,0xa1,0x5d,
+	0x2c,0x31,0x42,0x6c,0x7f,0x63,0x41,0x3b,
+	0x50,0x87,0xa2,0x99,0x75,0x55,0x62,0x86,
+	0xa6,0xab,0x7d,0x57,0x48,0x60,0x8f,0xa0,
+	0x90,0x6d,0x4e,0x6b,0x94,0xbc,0xc0,0x93,
+	0x71,0x68,0x7f,0xb3,0xb0,0x98,0x68,0x47,
+	0x69,0x8d,0xae,0xb3,0x7e,0x71,0x70,0x96,
+	0xd2,0xcc,0xbd,0x99,0x82,0xb3,0xb0,0xac,
+	0xad,0x5b,0x51,0x4d,0x72,0xa6,0x92,0x82,
+	0x5c,0x4d,0x83,0x84,0x7b,0x72,0x2c,0x2a,
+	0x2f,0x60,0x92,0x7d,0x79,0x54,0x50,0x89,
+	0x95,0xb3,0x95,0x5e,0x66,0x59,0x82,0x9d,
+	0x76,0x6f,0x43,0x49,0x80,0x87,0xab,0x90,
+	0x6e,0x84,0x80,0xb2,0xc4,0x9f,0x9a,0x67,
+	0x71,0x94,0x89,0xa4,0x79,0x5a,0x71,0x69,
+	0xa0,0xac,0x92,0x9e,0x78,0x98,0xbe,0xbd,
+	0xd9,0xa1,0x6f,0x86,0x71,0x93,0x8f,0x72,
+	0x7a,0x4d,0x6e,0x87,0x7d,0x9d,0x6e,0x63,
+	0x53,0x3e,0x7e,0x5c,0x4e,0x5d,0x3c,0x6f,
+	0x82,0x84,0xa4,0x72,0x7a,0x83,0x72,0xa6,
+	0x82,0x70,0x6e,0x3d,0x67,0x66,0x65,0x86,
+	0x50,0x6b,0x79,0x7a,0xbd,0xa1,0xab,0xae,
+	0x84,0xb6,0xa5,0xa2,0xb2,0x6a,0x7d,0x6d,
+	0x64,0x9b,0x72,0x84,0x82,0x60,0xa6,0x98,
+	0xb4,0xd6,0xa5,0xcc,0xb3,0x87,0xb9,0x92,
+	0x8d,0x78,0x50,0x85,0x69,0x7d,0x8f,0x56,
+	0x79,0x66,0x67,0x98,0x52,0x4f,0x53,0x2a,
+	0x52,0x3c,0x64,0x82,0x5c,0x89,0x76,0x7b,
+	0xab,0x80,0x9b,0x7f,0x59,0x78,0x53,0x65,
+	0x6d,0x3f,0x60,0x47,0x57,0x87,0x75,0xa1,
+	0x99,0x8b,0xb9,0xa5,0xc3,0xc9,0xa1,0xb0,
+	0x88,0x86,0x97,0x78,0x8b,0x73,0x5f,0x7b,
+	0x6f,0x93,0xa5,0x97,0xb3,0xa9,0xbf,0xd9,
+	0xb9,0xa4,0x9e,0x8d,0x84,0x6c,0x82,0x82,
+	0x72,0x74,0x60,0x68,0x77,0x77,0x83,0x75,
+	0x5a,0x37,0x3e,0x5f,0x57,0x42,0x48,0x50,
+	0x65,0x7b,0x8c,0x8e,0x8a,0x82,0x7b,0x7f,
+	0x7a,0x73,0x66,0x4e,0x4c,0x4a,0x4e,0x62,
+	0x5e,0x6c,0x74,0x7c,0xa0,0xa7,0xb9,0xc3,
+	0xb3,0xc1,0xb1,0xad,0xb5,0x93,0x93,0x80,
+	0x6c,0x82,0x6c,0x7a,0x83,0x75,0x98,0x96,
+	0xa7,0xcc,0xb8,0xd2,0xa8,0x82,0xb6,0x92,
+	0x8d,0x81,0x66,0x87,0x6d,0x69,0x82,0x5a,
+	0x83,0x74,0x68,0x87,0x59,0x4b,0x48,0x42,
+	0x73,0x41,0x3b,0x68,0x4f,0x8b,0x8c,0x7a,
+	0x9f,0x70,0x84,0x92,0x69,0x8a,0x57,0x42,
+	0x58,0x31,0x61,0x5e,0x4a,0x74,0x51,0x7c,
+	0xa7,0x9c,0xd2,0xb3,0xaa,0xc6,0xa6,0xce,
+	0xc0,0x99,0x9d,0x6a,0x75,0x8a,0x78,0x95,
+	0x71,0x67,0x84,0x85,0xbb,0xcd,0xba,0xbf,
+	0x82,0x7d,0xb1,0xb2,0xb2,0x75,0x5e,0x66,
+	0x6a,0x8b,0x8e,0x78,0x6a,0x54,0x65,0x82,
+	0x8a,0x76,0x37,0x32,0x44,0x5b,0x65,0x70,
+	0x6d,0x5a,0x62,0x70,0x90,0xaa,0x99,0x81,
+	0x64,0x4f,0x6b,0x72,0x71,0x65,0x36,0x3b,
+	0x48,0x65,0x97,0x88,0x8a,0x83,0x7e,0xb6,
+	0xc7,0xd1,0xcf,0x93,0x96,0x93,0x98,0xbe,
+	0x8f,0x7c,0x65,0x48,0x86,0x8d,0x9c,0xa7,
+	0x73,0x8f,0xa1,0xb0,0xde,0x92,0x92,0x90,
+	0x69,0x95,0x8a,0x91,0x94,0x4f,0x5f,0x67,
+	0x73,0xaa,0x7e,0x74,0x62,0x3b,0x5a,0x58,
+	0x77,0x81,0x3f,0x3d,0x53,0x66,0xa8,0x84,
+	0x7f,0x72,0x5a,0x93,0x91,0x8b,0x85,0x3a,
+	0x46,0x49,0x56,0x83,0x5f,0x58,0x53,0x4c,
+	0x92,0xa4,0xb6,0xba,0x8d,0x9f,0xab,0xbb,
+	0xdb,0xaf,0x99,0x7d,0x6a,0x90,0x93,0x92,
+	0x86,0x5d,0x6b,0x7d,0x9b,0xbe,0xaf,0xa3,
+	0x8f,0x76,0x8f,0xb0,0xb4,0x9f,0x64,0x64,
+	0x6d,0x85,0x95,0x83,0x6d,0x5c,0x65,0x7c,
+	0x91,0x89,0x67,0x39,0x3c,0x5f,0x7a,0x7b,
+	0x6b,0x5b,0x54,0x6b,0x7d,0x9f,0x98,0x83,
+	0x74,0x61,0x71,0x84,0x76,0x78,0x4e,0x46,
+	0x57,0x5b,0x84,0x80,0x73,0x80,0x71,0x99,
+	0xb3,0xaf,0xbf,0x9b,0x92,0xa4,0x92,0xb3,
+	0x9b,0x7e,0x81,0x5e,0x80,0x8d,0x7e,0x9b,
+	0x74,0x80,0x9b,0x93,0xc0,0xa6,0x7e,0x8d,
+	0x78,0x9d,0x9f,0x78,0x95,0x62,0x6d,0x7d,
+	0x69,0x97,0x7b,0x6e,0x86,0x59,0x7f,0x70,
+	0x4e,0x80,0x55,0x67,0x6d,0x55,0x89,0x71,
+	0x71,0x8b,0x66,0x91,0x8d,0x76,0x95,0x61,
+	0x70,0x76,0x5a,0x81,0x62,0x60,0x78,0x56,
+	0x86,0x82,0x7c,0xa0,0x7e,0x9b,0xa5,0x8e,
+	0xb5,0x92,0x92,0x9f,0x79,0x99,0x85,0x78,
+	0x90,0x68,0x83,0x86,0x75,0x9d,0x82,0x91,
+	0xa3,0x87,0xa7,0x85,0x7f,0x9f,0x7f,0x96,
+	0x7d,0x71,0x8a,0x6e,0x7c,0x83,0x6d,0x8a,
+	0x72,0x79,0x84,0x68,0x71,0x61,0x66,0x7b,
+	0x65,0x6e,0x73,0x67,0x82,0x72,0x7c,0x8a,
+	0x7b,0x8d,0x80,0x76,0x80,0x6d,0x7e,0x76,
+	0x6b,0x76,0x67,0x6f,0x7b,0x77,0x8a,0x80,
+	0x82,0x8f,0x89,0x9b,0x9a,0x92,0x95,0x85,
+	0x89,0x8c,0x8a,0x8c,0x7c,0x79,0x79,0x7d,
+	0x88,0x8b,0x89,0x89,0x86,0x90,0x99,0x9b,
+	0x92,0x81,0x83,0x82,0x8b,0x87,0x86,0x7d,
+	0x75,0x73,0x76,0x81,0x88,0x81,0x7e,0x6f,
+	0x6a,0x6c,0x71,0x80,0x77,0x65,0x66,0x68,
+	0x7b,0x8a,0x7c,0x81,0x72,0x76,0x89,0x86,
+	0x8f,0x80,0x6b,0x76,0x6b,0x81,0x87,0x74,
+	0x7c,0x66,0x70,0x8a,0x86,0x9b,0x87,0x7a,
+	0x88,0x7e,0x9b,0xa0,0x86,0x8d,0x6e,0x77,
+	0x8e,0x82,0x99,0x7b,0x6c,0x80,0x72,0x9a,
+	0x9b,0x8a,0x93,0x74,0x8a,0x99,0x87,0x9f,
+	0x80,0x75,0x7d,0x6d,0x96,0x8b,0x7a,0x7e,
+	0x5e,0x7c,0x89,0x85,0x96,0x64,0x5d,0x6a,
+	0x69,0x95,0x7c,0x71,0x70,0x54,0x7d,0x85,
+	0x8c,0x9b,0x6a,0x73,0x74,0x78,0xa4,0x87,
+	0x7f,0x73,0x58,0x82,0x82,0x8e,0x95,0x63,
+	0x72,0x72,0x80,0xab,0x8a,0x8d,0x77,0x63,
+	0x92,0x8b,0x9d,0x97,0x65,0x77,0x6b,0x82,
+	0xa7,0x85,0x8a,0x6e,0x65,0x95,0x8d,0xa9,
+	0x9b,0x72,0x83,0x71,0x8c,0xa8,0x89,0x8f,
+	0x63,0x60,0x8b,0x80,0xa1,0x86,0x62,0x74,
+	0x64,0x8a,0x96,0x76,0x81,0x55,0x5f,0x7f,
+	0x78,0x9b,0x7b,0x60,0x6f,0x61,0x95,0x9e,
+	0x85,0x8c,0x59,0x6f,0x8a,0x87,0xaa,0x7b,
+	0x67,0x70,0x63,0x9a,0x97,0x88,0x87,0x58,
+	0x75,0x8a,0x8e,0xad,0x78,0x71,0x72,0x68,
+	0xa0,0x94,0x8b,0x84,0x53,0x7b,0x85,0x90,
+	0xab,0x77,0x77,0x74,0x72,0xad,0x9a,0x97,
+	0x88,0x5b,0x7f,0x83,0x97,0xa8,0x6d,0x73,
+	0x65,0x6d,0xa1,0x87,0x90,0x75,0x54,0x79,
+	0x72,0x93,0x97,0x63,0x6f,0x5a,0x71,0x99,
+	0x80,0x8d,0x6d,0x60,0x82,0x7c,0x9e,0x92,
+	0x70,0x7d,0x64,0x83,0x9c,0x85,0x91,0x6a,
+	0x69,0x85,0x7c,0xa0,0x89,0x72,0x7c,0x65,
+	0x8c,0x93,0x87,0x8e,0x66,0x73,0x80,0x81,
+	0xa0,0x7f,0x77,0x79,0x6c,0x94,0x91,0x8c,
+	0x8f,0x6c,0x81,0x86,0x8f,0xa2,0x80,0x7d,
+	0x75,0x73,0x94,0x88,0x89,0x80,0x66,0x7d,
+	0x7c,0x89,0x93,0x72,0x74,0x6c,0x72,0x8d,
+	0x7c,0x82,0x75,0x65,0x7b,0x78,0x8b,0x89,
+	0x74,0x7c,0x72,0x7f,0x91,0x84,0x89,0x78,
+	0x73,0x84,0x81,0x90,0x87,0x77,0x7e,0x74,
+	0x86,0x8c,0x83,0x85,0x73,0x78,0x82,0x83,
+	0x8c,0x7f,0x78,0x7b,0x77,0x89,0x89,0x84,
+	0x82,0x75,0x7f,0x87,0x8a,0x8e,0x81,0x7d,
+	0x81,0x82,0x90,0x8d,0x86,0x7b,0x77,0x7f,
+	0x86,0x88,0x85,0x7a,0x77,0x79,0x80,0x87,
+	0x83,0x79,0x76,0x74,0x79,0x81,0x83,0x7c,
+	0x76,0x72,0x76,0x83,0x85,0x86,0x7a,0x77,
+	0x7c,0x7e,0x8c,0x88,0x80,0x7e,0x74,0x84,
+	0x87,0x88,0x8a,0x76,0x7c,0x7d,0x80,0x8f,
+	0x7f,0x7f,0x7b,0x70,0x89,0x81,0x87,0x86,
+	0x70,0x80,0x7a,0x84,0x91,0x79,0x86,0x79,
+	0x79,0x93,0x7f,0x8f,0x85,0x74,0x8c,0x7b,
+	0x8d,0x8f,0x74,0x8a,0x71,0x80,0x8e,0x77,
+	0x8e,0x77,0x75,0x88,0x6f,0x8f,0x7d,0x74,
+	0x87,0x68,0x85,0x81,0x74,0x8e,0x69,0x7f,
+	0x83,0x72,0x93,0x75,0x7d,0x87,0x6d,0x93,
+	0x7d,0x80,0x8d,0x6d,0x8d,0x7f,0x7b,0x95,
+	0x70,0x87,0x81,0x73,0x95,0x72,0x85,0x84,
+	0x6c,0x92,0x75,0x82,0x8a,0x6c,0x8d,0x78,
+	0x7f,0x90,0x70,0x8d,0x7c,0x7a,0x95,0x75,
+	0x8c,0x82,0x75,0x94,0x78,0x8c,0x89,0x70,
+	0x8c,0x75,0x85,0x8c,0x74,0x8a,0x74,0x79,
+	0x8d,0x74,0x8a,0x7a,0x71,0x87,0x70,0x8a,
+	0x83,0x75,0x83,0x6c,0x80,0x87,0x7b,0x8c,
+	0x74,0x78,0x81,0x7b,0x91,0x82,0x7d,0x7f,
+	0x73,0x88,0x87,0x88,0x87,0x73,0x7a,0x7f,
+	0x82,0x90,0x80,0x7a,0x76,0x75,0x87,0x8a,
+	0x88,0x7d,0x73,0x76,0x81,0x8b,0x8d,0x84,
+	0x76,0x75,0x7d,0x89,0x94,0x87,0x7b,0x76,
+	0x75,0x8b,0x8e,0x8e,0x85,0x69,0x79,0x81,
+	0x85,0x94,0x80,0x78,0x7d,0x73,0x86,0x86,
+	0x7f,0x7c,0x7c,0x82,0x84,0x7f,0x77,0x76,
+	0x7c,0x84,0x86,0x84,0x7b,0x77,0x79,0x7f,
+	0x86,0x88,0x80,0x78,0x79,0x7e,0x85,0x87,
+	0x86,0x7b,0x77,0x7b,0x84,0x87,0x86,0x80,
+	0x78,0x79,0x7f,0x86,0x88,0x83,0x7a,0x79,
+	0x7b,0x83,0x89,0x85,0x7f,0x78,0x79,0x80,
+	0x86,0x89,0x80,0x7b,0x78,0x7c,0x85,0x87,
+	0x84,0x7f,0x76,0x7b,0x80,0x88,0x87,0x81,
+	0x79,0x79,0x7e,0x86,0x88,0x84,0x7b,0x79,
+	0x7a,0x83,0x87,0x87,0x7e,0x7b,0x78,0x7f,
+	0x85,0x8a,0x81,0x7c,0x77,0x7e,0x81,0x8a,
+	0x83,0x80,0x78,0x7b,0x7e,0x89,0x85,0x83,
+	0x7a,0x7b,0x7b,0x86,0x86,0x87,0x7b,0x7b,
+	0x78,0x83,0x84,0x8a,0x7d,0x7e,0x75,0x82,
+	0x7f,0x8d,0x7e,0x83,0x74,0x82,0x7a,0x8d,
+	0x7d,0x87,0x44,0x68,0x63,0xaf,0x94,0x89,
+	0x55,0x7c,0x88,0xaa,0x61,0x49,0x5f,0x9a,
+	0xbb,0x79,0x60,0x57,0xaf,0xa0,0x96,0x3c,
+	0x74,0x83,0xcb,0x68,0x65,0x34,0xa6,0x8d,
+	0xa6,0x2c,0x66,0x59,0xbe,0x5e,0x6a,0x1c,
+	0x91,0x6d,0x99,0x1d,0x5c,0x3d,0xa4,0x4c,
+	0x63,0x16,0x7d,0x5e,0x8f,0x24,0x53,0x39,
+	0x97,0x50,0x59,0x1b,0x77,0x6c,0x8a,0x2f,
+	0x4f,0x4e,0x9b,0x6b,0x5f,0x34,0x75,0x82,
+	0x94,0x51,0x56,0x67,0xa0,0x90,0x72,0x53,
+	0x7d,0xa3,0xa5,0x7b,0x64,0x85,0xae,0xb5,
+	0x83,0x70,0x84,0xbe,0xb5,0x98,0x6d,0x90,
+	0xb2,0xc8,0x8e,0x7a,0x80,0xbc,0xb5,0x9a,
+	0x64,0x84,0xa5,0xbe,0x84,0x65,0x68,0xa0,
+	0xa7,0x87,0x51,0x5b,0x85,0x99,0x76,0x4c,
+	0x4c,0x70,0x89,0x64,0x42,0x3f,0x6e,0x75,
+	0x67,0x30,0x42,0x5c,0x86,0x5d,0x46,0x33,
+	0x6d,0x74,0x77,0x40,0x52,0x64,0x8e,0x6a,
+	0x57,0x4c,0x7b,0x87,0x84,0x52,0x55,0x77,
+	0x98,0x92,0x74,0x7d,0xa0,0xd4,0xc3,0x9d,
+	0x60,0x71,0x7d,0xa6,0x83,0x94,0x94,0xd7,
+	0xbd,0xbe,0x81,0xa2,0x71,0x92,0x5b,0x8f,
+	0x74,0xb6,0x7b,0x89,0x3b,0x74,0x54,0x88,
+	0x3b,0x5d,0x39,0x85,0x5a,0x78,0x36,0x71,
+	0x5b,0x92,0x53,0x6e,0x4e,0x8f,0x73,0x89,
+	0x56,0x7e,0x79,0xa0,0x7d,0x88,0x78,0xa4,
+	0xa0,0xa4,0x8e,0x9d,0xac,0xbb,0xb3,0xa3,
+	0xac,0xb7,0xc9,0xb5,0xb5,0xa3,0xc3,0xb4,
+	0xc1,0x98,0xac,0x99,0xbd,0x8e,0xa0,0x72,
+	0xa2,0x7c,0x9d,0x5b,0x84,0x5a,0x93,0x58,
+	0x7d,0x43,0x83,0x57,0x8a,0x4a,0x7d,0x56,
+	0x97,0x66,0x91,0x60,0xa0,0x7e,0xb1,0x7c,
+	0xab,0x8a,0xc5,0x9d,0xbe,0x94,0xc2,0xab,
+	0xc8,0xa4,0xb6,0xa7,0xbf,0xac,0xaa,0x99,
+	0xa0,0xa2,0x9b,0x93,0x7f,0x8a,0x80,0x8d,
+	0x6b,0x7a,0x5e,0x82,0x5f,0x78,0x4b,0x76,
+	0x53,0x83,0x50,0x7f,0x56,0x9b,0x6e,0xa9,
+	0x6c,0x8c,0x4c,0x93,0x4e,0x9a,0x65,0xb1,
+	0x77,0xba,0x80,0xc7,0x98,0xd8,0x8a,0xa0,
+	0x70,0xa1,0x78,0xae,0x7b,0xa5,0x7b,0xa1,
+	0x78,0x91,0x6e,0x83,0x6c,0x78,0x5f,0x63,
+	0x57,0x5b,0x5c,0x50,0x5a,0x47,0x5d,0x49,
+	0x66,0x46,0x67,0x48,0x78,0x52,0x83,0x55,
+	0x8d,0x61,0xa6,0x6d,0xaa,0x71,0xbd,0x85,
+	0xca,0x83,0xc7,0x8c,0xd9,0x94,0xcb,0x87,
+	0xca,0x94,0xca,0x82,0xab,0x7c,0xb0,0x7b,
+	0x95,0x62,0x84,0x6c,0x82,0x5d,0x62,0x54,
+	0x6c,0x65,0x5c,0x53,0x52,0x6e,0x64,0x70,
+	0x52,0x73,0x69,0x97,0x6b,0x8c,0x6a,0xae,
+	0x8a,0xb7,0x77,0xb5,0x90,0xd8,0x93,0xc3,
+	0x84,0xd7,0xa0,0xd8,0x81,0xbf,0x8e,0xd8,
+	0x8c,0xb1,0x6e,0xb5,0x87,0xaf,0x64,0x8a,
+	0x68,0x9f,0x6e,0x79,0x4c,0x7a,0x71,0x83,
+	0x63,0x72,0x7d,0xa0,0xa0,0x8f,0x81,0x6d,
+	0x70,0x75,0x69,0x40,0x78,0x76,0xa1,0x6c,
+	0x8b,0x77,0xc2,0x9e,0xc3,0x7b,0xb0,0x69,
+	0x9f,0x5d,0x71,0x40,0x9a,0x68,0x8f,0x3d,
+	0x7d,0x5b,0x99,0x4b,0x68,0x36,0x7f,0x58,
+	0x71,0x2d,0x56,0x48,0x7a,0x49,0x51,0x36,
+	0x6a,0x6a,0x6c,0x4e,0x55,0x6f,0x86,0x85,
+	0x65,0x73,0x7c,0xae,0x8f,0x98,0x70,0xaf,
+	0xa0,0xc8,0x83,0xa8,0x89,0xd4,0xa0,0xb8,
+	0x71,0xb4,0x95,0xca,0x7a,0x95,0x69,0xb2,
+	0x85,0x95,0x50,0x7c,0x6f,0x98,0x5e,0x62,
+	0x48,0x7b,0x71,0x71,0x47,0x57,0x69,0x81,
+	0x74,0x5b,0x5d,0x74,0x95,0x82,0x7c,0x68,
+	0x97,0x9e,0xb2,0x84,0x99,0x94,0xcb,0xb0,
+	0xb6,0x8d,0xbc,0xb7,0xd6,0xa1,0xac,0x9b,
+	0xcc,0xb6,0xb4,0x89,0xa2,0xa1,0xb8,0x92,
+	0x89,0x7c,0x9b,0x9a,0x92,0x74,0x79,0x8d,
+	0xa0,0x98,0x88,0x8a,0x9e,0xab,0x88,0x49,
+	0x49,0x6c,0x67,0x67,0x58,0x59,0x6b,0x89,
+	0x8e,0x85,0x7e,0x92,0xab,0xb5,0xa1,0x7a,
+	0x55,0x63,0x80,0x58,0x46,0x45,0x62,0x65,
+	0x65,0x48,0x51,0x55,0x6c,0x58,0x4d,0x3f,
+	0x53,0x5a,0x5c,0x46,0x43,0x4c,0x60,0x62,
+	0x53,0x4e,0x56,0x70,0x71,0x6f,0x5d,0x75,
+	0x7a,0x98,0x7d,0x89,0x76,0xa7,0x9a,0xb3,
+	0x84,0xa2,0x94,0xc7,0x9d,0xae,0x82,0xb4,
+	0x9e,0xbf,0x86,0x9a,0x81,0xb1,0x90,0x94,
+	0x6a,0x85,0x83,0x92,0x74,0x67,0x63,0x75,
+	0x81,0x68,0x5f,0x4f,0x76,0x6e,0x7d,0x4b,
+	0x6a,0x5a,0x96,0x66,0x82,0x4e,0x93,0x7a,
+	0xae,0x69,0x96,0x74,0xc1,0x93,0xb3,0x78,
+	0xb5,0xa0,0xd4,0x99,0xad,0x94,0xca,0xb7,
+	0xbc,0x93,0xa4,0xad,0xc1,0xad,0x92,0x92,
+	0x9e,0xb6,0x9d,0x93,0x75,0xa3,0x9b,0xb1,
+	0x7c,0x95,0x8a,0xc5,0x9f,0xa5,0x5f,0x6a,
+	0x56,0x95,0x50,0x54,0x3a,0x80,0x69,0x7f,
+	0x51,0x7d,0x84,0xad,0x8c,0x8d,0x81,0x98,
+	0x76,0x50,0x48,0x4e,0x55,0x53,0x48,0x2c,
+	0x2d,0x41,0x62,0x52,0x44,0x2e,0x4c,0x5b,
+	0x63,0x40,0x3a,0x42,0x66,0x63,0x53,0x3c,
+	0x50,0x69,0x79,0x64,0x52,0x5f,0x7f,0x90,
+	0x80,0x6e,0x73,0x97,0xa6,0x9f,0x85,0x8a,
+	0xa1,0xbc,0xae,0x97,0x92,0xa7,0xbe,0xb4,
+	0x9d,0x8a,0xa3,0xaf,0xb4,0x8a,0x85,0x82,
+	0xa9,0x93,0x8d,0x5f,0x80,0x7b,0x9a,0x63,
+	0x6c,0x4e,0x85,0x6f,0x7b,0x45,0x63,0x5f,
+	0x8b,0x66,0x65,0x52,0x7b,0x80,0x87,0x6d,
+	0x6b,0x84,0x98,0xa0,0x84,0x8c,0x8b,0xbc,
+	0xa7,0xb3,0x88,0xb8,0xaa,0xdb,0x9f,0xba,
+	0x94,0xd7,0xb4,0xd4,0x92,0xbf,0xa6,0xd8,
+	0xa7,0xb6,0x8d,0xbe,0xac,0xc1,0x96,0xa4,
+	0x9e,0xc0,0xb5,0xac,0x99,0xa1,0xa2,0x87,
+	0x58,0x4d,0x77,0x72,0x7d,0x44,0x55,0x42,
+	0x74,0x6e,0x86,0x67,0x82,0x80,0xa2,0x80,
+	0x72,0x3a,0x3d,0x5c,0x68,0x4b,0x2f,0x26,
+	0x3d,0x3c,0x38,0x30,0x3a,0x46,0x50,0x47,
+	0x3d,0x3d,0x4d,0x53,0x53,0x43,0x47,0x4f,
+	0x61,0x5a,0x5b,0x4d,0x68,0x69,0x7d,0x65,
+	0x75,0x6c,0x92,0x86,0x98,0x7b,0x9a,0x91,
+	0xb5,0x99,0xa8,0x93,0xb5,0xac,0xbb,0x9f,
+	0xa8,0xa6,0xb7,0xaf,0xa1,0x9a,0x98,0xa9,
+	0x9a,0x9a,0x77,0x8f,0x7e,0x98,0x6d,0x7c,
+	0x58,0x84,0x60,0x81,0x47,0x6d,0x4d,0x80,
+	0x51,0x6e,0x42,0x74,0x5e,0x82,0x57,0x73,
+	0x63,0x8e,0x7c,0x89,0x74,0x8e,0x94,0xa8,
+	0x9a,0x97,0xa0,0xaf,0xbe,0xb1,0xb1,0xa5,
+	0xc7,0xbe,0xcc,0xa5,0xbf,0xaf,0xd7,0xb1,
+	0xc0,0x99,0xc4,0xb0,0xca,0x98,0xb1,0x9c,
+	0xc7,0xaa,0xb6,0x91,0xb5,0xac,0xbf,0x94,
+	0x8c,0x6a,0x6a,0x6b,0x83,0x64,0x75,0x5d,
+	0x6d,0x5b,0x5b,0x5f,0x79,0x89,0x81,0x74,
+	0x67,0x6a,0x58,0x45,0x4c,0x50,0x59,0x5a,
+	0x3a,0x33,0x22,0x3e,0x47,0x51,0x38,0x39,
+	0x3e,0x58,0x54,0x48,0x3a,0x47,0x57,0x5c,
+	0x4e,0x42,0x4c,0x61,0x6d,0x62,0x56,0x5d,
+	0x76,0x84,0x7e,0x71,0x76,0x8f,0xa0,0x9e,
+	0x8b,0x93,0xa2,0xbe,0xb2,0xaa,0x9b,0xb8,
+	0xbf,0xca,0xa5,0xaa,0xa5,0xca,0xb2,0xaf,
+	0x89,0xa3,0x9e,0xb1,0x84,0x80,0x70,0x92,
+	0x81,0x7c,0x53,0x62,0x66,0x77,0x5e,0x4d,
+	0x48,0x60,0x6a,0x5e,0x4f,0x49,0x66,0x6e,
+	0x77,0x57,0x67,0x6a,0x96,0x7f,0x89,0x6d,
+	0x9c,0x97,0xba,0x8a,0xa6,0x93,0xcc,0xaf,
+	0xc1,0x94,0xc0,0xb5,0xdb,0xa9,0xb9,0x9f,
+	0xd0,0xbb,0xc4,0x99,0xb0,0xaf,0xc8,0xab,
+	0xa2,0x97,0xb1,0xb7,0xb2,0x9a,0x98,0xa8,
+	0xb5,0xaa,0x85,0x74,0x67,0x77,0x82,0x89,
+	0x64,0x98,0x76,0x86,0x55,0x65,0x55,0x85,
+	0x64,0x69,0x2b,0x45,0x39,0x83,0x47,0x62,
+	0x42,0x5b,0x43,0x4e,0x24,0x40,0x40,0x61,
+	0x42,0x47,0x35,0x58,0x56,0x5f,0x41,0x47,
+	0x4f,0x68,0x60,0x52,0x4a,0x5b,0x73,0x6d,
+	0x66,0x56,0x71,0x7b,0x91,0x74,0x7c,0x78,
+	0xa7,0x98,0xa7,0x81,0xa8,0xa3,0xcd,0xa5,
+	0xb4,0x99,0xce,0xbb,0xcf,0x9a,0xb9,0xab,
+	0xd4,0xa9,0xad,0x88,0xae,0xa1,0xab,0x78,
+	0x80,0x75,0x92,0x77,0x6b,0x50,0x5f,0x68,
+	0x69,0x4e,0x3f,0x47,0x5a,0x60,0x4a,0x46,
+	0x44,0x68,0x64,0x6b,0x4b,0x68,0x6e,0x93,
+	0x77,0x84,0x74,0xa4,0x9c,0xb5,0x8d,0xac,
+	0xa4,0xd2,0xb4,0xc0,0xa4,0xcb,0xc4,0xda,
+	0xb0,0xbf,0xb4,0xd7,0xc1,0xc3,0xa8,0xba,
+	0xbd,0xc6,0xb0,0xa9,0xa8,0xbb,0xb9,0xaf,
+	0xa2,0xa4,0xb0,0xb0,0xa3,0x89,0x82,0x75,
+	0x76,0x65,0x8e,0x75,0x90,0x98,0x81,0x5e,
+	0x61,0x52,0x5f,0x37,0x34,0x24,0x63,0x52,
+	0x66,0x53,0x49,0x38,0x4c,0x38,0x40,0x2c,
+	0x48,0x40,0x53,0x39,0x48,0x3f,0x59,0x4a,
+	0x51,0x3d,0x54,0x4f,0x5f,0x4c,0x54,0x52,
+	0x67,0x62,0x65,0x5e,0x6c,0x76,0x80,0x7c,
+	0x7c,0x85,0x94,0x9f,0x99,0xa1,0xa2,0xb8,
+	0xb6,0xc1,0xad,0xc4,0xbd,0xd3,0xba,0xc6,
+	0xb2,0xcf,0xb7,0xc4,0xa0,0xb5,0x9c,0xb5,
+	0x8d,0x99,0x76,0x91,0x72,0x82,0x55,0x6c,
+	0x50,0x6d,0x46,0x54,0x38,0x55,0x42,0x54,
+	0x36,0x4c,0x43,0x60,0x4e,0x59,0x51,0x6b,
+	0x6f,0x7a,0x70,0x7c,0x88,0x98,0x9c,0x98,
+	0x9e,0xa6,0xba,0xb6,0xb7,0xac,0xc1,0xc0,
+	0xcf,0xb3,0xc2,0xb4,0xd2,0xba,0xc4,0xa8,
+	0xc2,0xb3,0xc9,0xa5,0xb5,0xa1,0xc0,0xa9,
+	0xb6,0x96,0xb0,0xa2,0xb9,0x96,0xa0,0x87,
+	0x9d,0x7e,0x7a,0x5a,0x7a,0x90,0x91,0x81,
+	0x90,0x69,0x71,0x56,0x4d,0x2d,0x3d,0x59,
+	0x66,0x50,0x66,0x53,0x59,0x53,0x4d,0x3e,
+	0x3c,0x49,0x50,0x50,0x41,0x46,0x4b,0x5d,
+	0x51,0x50,0x43,0x5a,0x58,0x68,0x4c,0x5a,
+	0x53,0x75,0x61,0x6e,0x54,0x76,0x72,0x8e,
+	0x6e,0x81,0x76,0xa2,0x92,0xa2,0x85,0xaa,
+	0xa3,0xc7,0xa3,0xb5,0xa4,0xd0,0xbe,0xcb,
+	0xa5,0xc0,0xb8,0xd0,0xaf,0xb0,0x9a,0xb8,
+	0xa9,0xa8,0x82,0x89,0x85,0x95,0x79,0x67,
+	0x59,0x69,0x6d,0x5e,0x47,0x42,0x4f,0x59,
+	0x53,0x3b,0x3f,0x46,0x62,0x56,0x52,0x42,
+	0x66,0x6b,0x80,0x61,0x71,0x72,0xa0,0x90,
+	0x99,0x7c,0xa7,0xa7,0xc5,0x9e,0xae,0xa4,
+	0xd1,0xbe,0xc4,0x9f,0xc0,0xbe,0xd9,0xb1,
+	0xb8,0xa7,0xcf,0xc1,0xc4,0x9f,0xb4,0xb5,
+	0xcd,0xad,0xaa,0x9b,0xb9,0xb5,0xb2,0x8c,
+	0x91,0x8e,0x97,0x75,0x5e,0x5a,0x8a,0xa7,
+	0x80,0x6e,0x7b,0x72,0x68,0x49,0x27,0x2c,
+	0x59,0x65,0x49,0x58,0x4e,0x53,0x56,0x51,
+	0x30,0x29,0x32,0x4c,0x45,0x39,0x2b,0x3d,
+	0x4e,0x56,0x41,0x38,0x42,0x5b,0x5e,0x50,
+	0x41,0x4f,0x67,0x70,0x61,0x55,0x63,0x7a,
+	0x88,0x79,0x72,0x7b,0x98,0xa4,0x9d,0x8c,
+	0x9e,0xb1,0xc6,0xb4,0xae,0xab,0xcc,0xd0,
+	0xcd,0xb1,0xb9,0xc4,0xd7,0xbf,0xae,0xa2,
+	0xb8,0xb6,0xad,0x89,0x86,0x8b,0x97,0x81,
+	0x69,0x58,0x68,0x6d,0x62,0x46,0x3d,0x4a,
+	0x57,0x51,0x38,0x35,0x42,0x5a,0x51,0x4a,
+	0x3c,0x5a,0x65,0x75,0x5b,0x65,0x6c,0x93,
+	0x88,0x90,0x77,0x9e,0xa2,0xbc,0x99,0xa9,
+	0xa1,0xcf,0xb9,0xc7,0xa1,0xc7,0xbc,0xde,
+	0xb1,0xc1,0xac,0xd9,0xbf,0xca,0xa0,0xc1,
+	0xb4,0xd3,0xa8,0xb6,0x9d,0xc3,0xae,0xb6,
+	0x87,0x9b,0x87,0x98,0x68,0x64,0x58,0x94,
+	0x9e,0x86,0x5c,0x83,0x75,0x72,0x42,0x33,
+	0x2e,0x63,0x63,0x44,0x47,0x5f,0x5e,0x5d,
+	0x4a,0x35,0x2e,0x36,0x40,0x3a,0x32,0x2c,
+	0x3d,0x44,0x47,0x39,0x3d,0x41,0x56,0x4f,
+	0x50,0x47,0x5b,0x60,0x6b,0x5d,0x66,0x68,
+	0x7f,0x7c,0x83,0x7a,0x8f,0x96,0xa4,0x99,
+	0xa2,0xa6,0xbb,0xb9,0xbd,0xb7,0xc2,0xca,
+	0xce,0xc7,0xc4,0xc4,0xca,0xca,0xc1,0xb8,
+	0xb2,0xb7,0xac,0xa5,0x94,0x91,0x89,0x84,
+	0x76,0x6b,0x6f,0x67,0x5e,0x42,0x49,0x46,
+	0x4b,0x40,0x3f,0x3a,0x3e,0x3c,0x45,0x3f,
+	0x45,0x49,0x52,0x57,0x5c,0x60,0x6a,0x70,
+	0x7d,0x80,0x87,0x8e,0x97,0x9f,0xa6,0xa7,
+	0xae,0xb6,0xbc,0xbc,0xbe,0xc1,0xc7,0xc8,
+	0xca,0xc6,0xc7,0xc9,0xcd,0xc9,0xc5,0xc3,
+	0xc6,0xc5,0xc3,0xbd,0xb9,0xb8,0xb6,0xb0,
+	0x95,0x52,0x73,0x97,0x9e,0x93,0x89,0x83,
+	0x81,0x77,0x71,0x68,0x6a,0x69,0x65,0x5f,
+	0x5b,0x59,0x5c,0x5a,0x52,0x4d,0x4e,0x4f,
+	0x4f,0x49,0x45,0x43,0x48,0x48,0x43,0x3c,
+	0x40,0x42,0x46,0x3e,0x3c,0x3d,0x42,0x43,
+	0x41,0x3c,0x3f,0x45,0x48,0x46,0x42,0x44,
+	0x4c,0x50,0x51,0x4c,0x50,0x55,0x5d,0x5b,
+	0x58,0x59,0x63,0x67,0x68,0x64,0x68,0x6d,
+	0x76,0x74,0x75,0x73,0x7d,0x80,0x86,0x80,
+	0x79,0x4a,0x7e,0x76,0xb1,0xb5,0x8f,0x97,
+	0x65,0xb4,0xa3,0x9f,0x77,0x72,0x95,0xca,
+	0xcd,0xa5,0x71,0x73,0x9c,0xce,0xbd,0x8d,
+	0x5e,0x6b,0x9b,0xae,0x9b,0x56,0x4a,0x5e,
+	0x94,0x9a,0x68,0x46,0x2f,0x69,0x7b,0x84,
+	0x4e,0x31,0x44,0x60,0x8a,0x59,0x53,0x37,
+	0x68,0x84,0x82,0x7e,0x4a,0x70,0x71,0xa9,
+	0x8e,0x77,0x74,0x7a,0xbd,0xa4,0xb3,0x79,
+	0x91,0xa5,0xb9,0xca,0x90,0xa7,0x87,0xc9,
+	0xc0,0xbf,0xa7,0x8a,0xbe,0xae,0xe2,0xa4,
+	0xaa,0x98,0xad,0xd3,0xad,0xc0,0x77,0xa8,
+	0x94,0xad,0x9a,0x67,0x79,0x56,0x9f,0x77,
+	0x90,0x72,0x7b,0xa0,0x89,0xb5,0x62,0x86,
+	0x5b,0x86,0x8f,0x79,0x90,0x5e,0xb3,0x92,
+	0xcd,0xa9,0xa0,0xae,0x94,0xd4,0x94,0xba,
+	0x78,0x98,0x94,0x8b,0xa5,0x56,0x8b,0x4e,
+	0x8f,0x6b,0x6a,0x65,0x3f,0x7e,0x4d,0x8d,
+	0x47,0x67,0x60,0x63,0x92,0x5a,0x90,0x4c,
+	0x92,0x78,0x93,0x98,0x72,0xad,0x7e,0xcb,
+	0x96,0xbb,0x9c,0x8e,0x99,0x78,0xb6,0x69,
+	0x8a,0x65,0x85,0x8f,0x72,0x99,0x5f,0x9c,
+	0x61,0x65,0x51,0x4c,0x5d,0x2b,0x70,0x36,
+	0x6a,0x4a,0x64,0x78,0x62,0x95,0x59,0x97,
+	0x6a,0x92,0x83,0x71,0x8b,0x52,0x8f,0x52,
+	0x86,0x5e,0x6b,0x7d,0x65,0xa7,0x6d,0xb0,
+	0x7d,0xa7,0xa1,0x91,0xb2,0x6e,0xa7,0x60,
+	0x96,0x6b,0x73,0x7d,0x56,0x96,0x5a,0xa2,
+	0x6c,0x93,0x8b,0x7e,0xad,0x6e,0xb8,0x77,
+	0xc8,0x98,0x81,0x8e,0x56,0x9e,0x52,0x9b,
+	0x61,0x81,0x73,0x59,0x91,0x5c,0xb4,0x44,
+	0x68,0x41,0x50,0x7a,0x51,0x99,0x50,0x9d,
+	0x6e,0x9d,0x9a,0x82,0xa6,0x64,0xa8,0x5f,
+	0x89,0x59,0x51,0x64,0x3a,0x7e,0x3e,0x83,
+	0x57,0x8a,0x9c,0x96,0xc8,0x8c,0xce,0x95,
+	0xc5,0x9f,0x8e,0x94,0x5b,0x96,0x54,0x8a,
+	0x53,0x6a,0x75,0x6c,0xa6,0x6c,0xaa,0x72,
+	0xac,0xa2,0xaf,0xc5,0xa1,0xbb,0x67,0xa1,
+	0x70,0x84,0x78,0x64,0x92,0x5b,0x89,0x4a,
+	0x6c,0x6b,0x7e,0x94,0x38,0x5f,0x28,0x77,
+	0x67,0x81,0x81,0x6d,0xa1,0x82,0xbe,0x8b,
+	0x99,0x7f,0x78,0x94,0x5e,0x7c,0x32,0x57,
+	0x44,0x5c,0x6d,0x4a,0x7c,0x5c,0xad,0x9d,
+	0xb9,0xae,0x9b,0xc5,0x9e,0xd1,0x88,0x91,
+	0x70,0x6f,0x8d,0x60,0x83,0x43,0x76,0x6c,
+	0x8e,0x9a,0x77,0x9e,0x7a,0xc6,0xb1,0xcd,
+	0xba,0x80,0x9a,0x78,0xa7,0x6f,0x7e,0x65,
+	0x6e,0x90,0x62,0x83,0x3d,0x79,0x6a,0x97,
+	0x6f,0x38,0x59,0x2b,0x8d,0x6a,0x8e,0x72,
+	0x70,0x9e,0x8a,0xc3,0x7b,0x91,0x6c,0x7d,
+	0x8e,0x5f,0x73,0x25,0x5c,0x48,0x70,0x6d,
+	0x53,0x7d,0x65,0xbf,0xa0,0xc2,0x9e,0x9a,
+	0xbe,0xa0,0xcc,0x79,0x8b,0x61,0x7a,0x87,
+	0x65,0x7a,0x3d,0x7e,0x70,0xa0,0x95,0x7d,
+	0x9f,0x86,0xda,0xb6,0xd3,0x83,0x7c,0x98,
+	0x79,0xaf,0x60,0x80,0x59,0x7f,0x88,0x6a,
+	0x7a,0x40,0x84,0x71,0x90,0x53,0x46,0x50,
+	0x3f,0x92,0x6d,0x91,0x6a,0x7b,0x9d,0x93,
+	0xba,0x6e,0x8c,0x60,0x83,0x80,0x5e,0x64,
+	0x29,0x64,0x4e,0x7f,0x6a,0x60,0x7f,0x75,
+	0xc5,0xa0,0xbd,0x95,0x99,0xb6,0xa1,0xc1,
+	0x73,0x85,0x61,0x81,0x8a,0x6d,0x7c,0x48,
+	0x84,0x7a,0xa6,0x98,0x85,0xa1,0x94,0xdb,
+	0xbb,0xb0,0x7a,0x7b,0x8a,0x7f,0xa5,0x66,
+	0x75,0x5c,0x77,0x8b,0x6f,0x7b,0x4b,0x7f,
+	0x75,0x72,0x60,0x43,0x48,0x43,0x85,0x77,
+	0x88,0x6f,0x6b,0x97,0x90,0xb4,0x76,0x79,
+	0x5f,0x72,0x85,0x65,0x62,0x2e,0x54,0x5c,
+	0x7d,0x80,0x65,0x7b,0x7c,0xbc,0xba,0xbf,
+	0xa2,0x93,0xad,0xac,0xbb,0x89,0x75,0x62,
+	0x74,0x8c,0x7d,0x78,0x57,0x73,0x8a,0xab,
+	0xaf,0x9a,0xa0,0xae,0xd6,0xcc,0x9e,0x8a,
+	0x72,0x76,0x8a,0x93,0x7c,0x62,0x5c,0x6d,
+	0x86,0x85,0x73,0x61,0x64,0x66,0x5e,0x69,
+	0x46,0x30,0x4b,0x6a,0x8d,0x87,0x76,0x76,
+	0x7f,0xa5,0x9f,0x94,0x69,0x5d,0x69,0x6f,
+	0x79,0x4b,0x44,0x37,0x5e,0x7e,0x7e,0x83,
+	0x68,0x97,0xa7,0xd1,0xc3,0xa7,0xa3,0x93,
+	0xbf,0xa4,0x9f,0x6e,0x5e,0x76,0x76,0x9b,
+	0x6a,0x76,0x66,0x8e,0xb8,0xaf,0xc5,0x97,
+	0xc8,0xbf,0xbe,0xa7,0x8b,0x84,0x51,0x94,
+	0x7c,0x89,0x6a,0x50,0x78,0x68,0xa2,0x6e,
+	0x77,0x54,0x38,0x6c,0x54,0x60,0x21,0x50,
+	0x5a,0x7b,0x98,0x6a,0x8b,0x63,0xa1,0x93,
+	0x95,0x80,0x51,0x75,0x55,0x87,0x5a,0x53,
+	0x4d,0x4b,0x89,0x74,0x9c,0x72,0x8d,0x9f,
+	0xaf,0xd0,0x9d,0xad,0x85,0xa5,0xa4,0x94,
+	0x8b,0x5b,0x78,0x6a,0x93,0x84,0x79,0x80,
+	0x7f,0xb3,0xb0,0xc9,0xb6,0xba,0xca,0xb2,
+	0xa6,0x9a,0x88,0x63,0x6f,0x82,0x7c,0x78,
+	0x5f,0x67,0x70,0x89,0x86,0x71,0x41,0x2c,
+	0x51,0x56,0x3f,0x37,0x3b,0x4b,0x6f,0x79,
+	0x87,0x76,0x7e,0x86,0x8e,0x96,0x7b,0x79,
+	0x5e,0x6c,0x6c,0x66,0x67,0x4d,0x6b,0x64,
+	0x88,0x89,0x88,0x99,0x8d,0xb8,0xa2,0xb9,
+	0x9d,0x98,0x9c,0x86,0xa2,0x74,0x88,0x6d,
+	0x7b,0x88,0x7a,0x9e,0x7c,0xa8,0x98,0xb9,
+	0xc1,0xb9,0xd8,0xb0,0xbc,0x7e,0xa5,0x90,
+	0x6e,0x7c,0x5d,0x86,0x61,0x7e,0x72,0x73,
+	0x8b,0x67,0x84,0x31,0x51,0x4b,0x42,0x42,
+	0x2e,0x5f,0x43,0x74,0x63,0x77,0x86,0x76,
+	0x9a,0x73,0x97,0x74,0x83,0x7b,0x69,0x7c,
+	0x56,0x7a,0x5c,0x78,0x74,0x75,0x8c,0x7a,
+	0xa3,0x8d,0xa5,0x97,0x96,0xa1,0x8d,0xa1,
+	0x7f,0x8d,0x7a,0x80,0x89,0x7c,0x91,0x7b,
+	0x98,0x96,0xaa,0xb3,0xaf,0xc1,0xbc,0xd5,
+	0xcb,0xbe,0x8a,0x88,0x9a,0x89,0x79,0x68,
+	0x6a,0x69,0x73,0x7d,0x84,0x7a,0x70,0x4e,
+	0x3c,0x55,0x51,0x3b,0x27,0x3a,0x40,0x58,
+	0x5a,0x5c,0x69,0x6c,0x87,0x85,0x8b,0x7f,
+	0x7e,0x88,0x82,0x93,0x75,0x7d,0x6d,0x7b,
+	0x88,0x7b,0x8a,0x6d,0x8c,0x84,0x99,0x95,
+	0x81,0x90,0x77,0x9d,0x85,0x8d,0x7d,0x6f,
+	0x8c,0x7b,0xa1,0x7e,0x94,0x8a,0x9b,0xb9,
+	0xa6,0xc4,0xa0,0xc1,0xc0,0xc8,0xca,0x84,
+	0x8f,0x80,0xa6,0x8c,0x76,0x70,0x58,0x81,
+	0x6a,0x94,0x67,0x59,0x37,0x47,0x6a,0x4d,
+	0x50,0x24,0x3d,0x45,0x53,0x6c,0x4e,0x6e,
+	0x5b,0x87,0x84,0x88,0x8b,0x71,0x98,0x82,
+	0xa5,0x85,0x83,0x82,0x7a,0x9e,0x7f,0x93,
+	0x70,0x80,0x86,0x86,0x97,0x6f,0x84,0x69,
+	0x8b,0x86,0x7e,0x80,0x67,0x8b,0x7f,0xa1,
+	0x8d,0x8d,0x97,0x96,0xc2,0xaa,0xbf,0xa3,
+	0xb6,0xc2,0xc4,0xca,0x99,0x85,0x77,0x9e,
+	0x9d,0x85,0x6f,0x5a,0x78,0x79,0x88,0x6e,
+	0x45,0x3f,0x4f,0x6e,0x55,0x44,0x2e,0x38,
+	0x4f,0x5a,0x67,0x52,0x5c,0x60,0x7d,0x89,
+	0x84,0x81,0x77,0x8d,0x98,0xa1,0x94,0x84,
+	0x85,0x8e,0x9e,0x95,0x88,0x75,0x77,0x84,
+	0x8d,0x85,0x72,0x66,0x6e,0x7c,0x87,0x7f,
+	0x6d,0x6d,0x79,0x93,0x9a,0x93,0x89,0x86,
+	0xa4,0xae,0xbe,0xa6,0x9f,0xa2,0xb2,0xca,
+	0xb6,0xaa,0x82,0x7a,0x8d,0x9d,0x9b,0x6d,
+	0x6a,0x66,0x89,0x86,0x6f,0x4a,0x3b,0x6a,
+	0x67,0x71,0x42,0x3c,0x3c,0x4f,0x72,0x5e,
+	0x67,0x47,0x62,0x7a,0x83,0x95,0x6a,0x82,
+	0x73,0xa7,0xa3,0x99,0x91,0x72,0x9e,0x92,
+	0xb0,0x86,0x76,0x75,0x73,0xa0,0x78,0x81,
+	0x50,0x68,0x78,0x82,0x8e,0x5d,0x75,0x65,
+	0x9c,0x9a,0x95,0x8d,0x72,0xa7,0x9e,0xc5,
+	0x9b,0x94,0x94,0x9b,0xc9,0xa5,0xaf,0x79,
+	0x85,0x80,0x99,0xa2,0x6d,0x77,0x5b,0x92,
+	0x84,0x74,0x55,0x43,0x74,0x66,0x83,0x4e,
+	0x4b,0x48,0x53,0x82,0x64,0x76,0x42,0x6a,
+	0x74,0x8b,0x97,0x67,0x82,0x69,0xa8,0x9d,
+	0x9e,0x89,0x70,0x9b,0x8c,0xb5,0x7f,0x7b,
+	0x6d,0x76,0x9c,0x7a,0x85,0x4d,0x6e,0x71,
+	0x89,0x8d,0x60,0x79,0x5e,0xa0,0x93,0x99,
+	0x86,0x71,0x9f,0x94,0xc3,0x8e,0x92,0x84,
+	0x94,0xbb,0x9c,0xac,0x6c,0x8b,0x7b,0x9a,
+	0x9d,0x70,0x7c,0x59,0x96,0x80,0x7c,0x5b,
+	0x4f,0x76,0x69,0x8d,0x55,0x5e,0x4b,0x61,
+	0x85,0x6c,0x7f,0x48,0x70,0x6e,0x92,0x91,
+	0x6e,0x7e,0x68,0xa6,0x95,0xa1,0x82,0x73,
+	0x95,0x88,0xb5,0x7a,0x84,0x65,0x7b,0x96,
+	0x7c,0x88,0x4e,0x74,0x6a,0x90,0x88,0x6a,
+	0x77,0x5f,0xa0,0x8a,0x9f,0x7d,0x76,0x94,
+	0x90,0xbc,0x85,0x95,0x75,0x95,0xab,0x9a,
+	0xa1,0x68,0x8f,0x74,0xa0,0x92,0x78,0x78,
+	0x5e,0x9a,0x78,0x86,0x57,0x62,0x72,0x73,
+	0x8f,0x5b,0x6b,0x48,0x77,0x80,0x7b,0x7a,
+	0x4c,0x7b,0x6b,0xa2,0x80,0x78,0x73,0x71,
+	0xa7,0x8d,0xa5,0x6c,0x81,0x86,0x97,0xa8,
+	0x74,0x85,0x5a,0x90,0x87,0x8c,0x77,0x55,
+	0x7a,0x6e,0xa0,0x75,0x77,0x68,0x71,0xa0,
+	0x89,0x9f,0x66,0x86,0x84,0xa2,0xa7,0x80,
+	0x8b,0x6c,0xa6,0x96,0xa3,0x85,0x6e,0x89,
+	0x7b,0xaa,0x7a,0x83,0x64,0x78,0x93,0x7d,
+	0x83,0x50,0x76,0x6a,0x8d,0x81,0x63,0x67,
+	0x53,0x8f,0x77,0x8c,0x63,0x60,0x78,0x7c,
+	0xa2,0x73,0x81,0x63,0x89,0x9c,0x93,0x94,
+	0x66,0x89,0x80,0xa6,0x8f,0x7b,0x73,0x68,
+	0x9a,0x81,0x91,0x62,0x69,0x76,0x80,0x9b,
+	0x6d,0x7c,0x5f,0x8c,0x92,0x92,0x8a,0x68,
+	0x8a,0x81,0xad,0x8d,0x84,0x79,0x7a,0xa3,
+	0x92,0x9f,0x6c,0x7e,0x7e,0x8e,0x9b,0x76,
+	0x7e,0x62,0x8c,0x88,0x89,0x6f,0x5f,0x77,
+	0x77,0x95,0x70,0x6e,0x5e,0x70,0x8a,0x82,
+	0x81,0x5c,0x72,0x77,0x94,0x8c,0x76,0x72,
+	0x6f,0x95,0x93,0x95,0x76,0x73,0x83,0x92,
+	0x9f,0x80,0x76,0x69,0x83,0x91,0x8b,0x7a,
+	0x63,0x71,0x7f,0x93,0x84,0x73,0x6a,0x77,
+	0x90,0x97,0x88,0x73,0x73,0x87,0x9a,0x99,
+	0x85,0x73,0x79,0x8f,0x9d,0x94,0x7d,0x73,
+	0x7a,0x90,0x92,0x8a,0x70,0x6f,0x7b,0x8e,
+	0x93,0x72,0x6a,0x66,0x83,0x8b,0x85,0x71,
+	0x5e,0x73,0x7c,0x96,0x78,0x71,0x65,0x77,
+	0x93,0x88,0x89,0x65,0x79,0x80,0x9b,0x94,
+	0x79,0x78,0x6f,0x9a,0x8f,0x92,0x74,0x6c,
+	0x81,0x84,0x9e,0x71,0x77,0x62,0x83,0x8f,
+	0x86,0x83,0x5d,0x83,0x7a,0xa0,0x85,0x79,
+	0x75,0x74,0xa0,0x89,0x98,0x6a,0x7d,0x84,
+	0x92,0xa0,0x74,0x83,0x67,0x94,0x8a,0x8f,
+	0x7d,0x64,0x86,0x79,0xa0,0x73,0x76,0x67,
+	0x78,0x95,0x7a,0x8b,0x56,0x7c,0x74,0x90,
+	0x88,0x6b,0x79,0x62,0x99,0x7e,0x92,0x6d,
+	0x71,0x85,0x83,0xa1,0x70,0x86,0x6a,0x8e,
+	0x8f,0x89,0x86,0x65,0x88,0x78,0x9c,0x79,
+	0x79,0x71,0x72,0x97,0x7c,0x8e,0x63,0x7e,
+	0x7d,0x8e,0x90,0x73,0x82,0x6d,0x97,0x88,
+	0x90,0x7b,0x73,0x89,0x84,0x9c,0x7b,0x80,
+	0x74,0x86,0x8c,0x84,0x86,0x6c,0x81,0x7e,
+	0x90,0x80,0x75,0x74,0x76,0x8b,0x81,0x81,
+	0x6f,0x74,0x7d,0x84,0x85,0x79,0x74,0x77,
+	0x83,0x87,0x84,0x7a,0x78,0x7d,0x89,0x88,
+	0x85,0x7a,0x7c,0x82,0x87,0x8b,0x7c,0x7d,
+	0x78,0x87,0x84,0x82,0x7d,0x73,0x84,0x7b,
+	0x8c,0x79,0x7f,0x7a,0x7e,0x8b,0x7d,0x89,
+	0x72,0x88,0x7f,0x8a,0x85,0x7b,0x89,0x77,
+	0x93,0x7a,0x8d,0x7a,0x81,0x86,0x79,0x8f,
+	0x72,0x8d,0x71,0x89,0x80,0x7c,0x85,0x6f,
+	0x8d,0x6f,0x8c,0x73,0x80,0x7e,0x77,0x89,
+	0x6e,0x8d,0x6e,0x8d,0x77,0x7f,0x83,0x74,
+	0x91,0x71,0x90,0x72,0x88,0x7f,0x80,0x8c,
+	0x72,0x8e,0x6f,0x92,0x78,0x85,0x7f,0x75,
+	0x8c,0x73,0x93,0x6f,0x86,0x77,0x82,0x8a,
+	0x76,0x8c,0x6b,0x8e,0x7a,0x8e,0x80,0x79,
+	0x86,0x77,0x94,0x7b,0x8c,0x75,0x81,0x86,
+	0x83,0x8e,0x71,0x85,0x79,0x8e,0x7e,0x8d,
+	0x7c,0x7a,0x79,0x78,0x8b,0x85,0x85,0x7a,
+	0x78,0x76,0x7e,0x82,0x85,0x7d,0x79,0x78,
+	0x81,0x86,0x84,0x7b,0x77,0x7a,0x84,0x88,
+	0x83,0x7b,0x78,0x7f,0x86,0x86,0x81,0x78,
+	0x7b,0x80,0x88,0x86,0x7d,0x77,0x7d,0x84,
+	0x89,0x83,0x7b,0x77,0x80,0x87,0x86,0x80,
+	0x79,0x7a,0x81,0x87,0x85,0x7e,0x78,0x7d,
+	0x84,0x87,0x83,0x7c,0x78,0x7f,0x85,0x86,
+	0x81,0x79,0x7a,0x82,0x86,0x86,0x7e,0x79,
+	0x7c,0x84,0x87,0x83,0x7b,0x7a,0x7d,0x86,
+	0x85,0x81,0x79,0x7a,0x82,0x86,0x85,0x7e,
+	0x79,0x7d,0x83,0x86,0x82,0x7c,0x7a,0x7e,
+	0x85,0x85,0x81,0x79,0x7c,0x81,0x85,0x84,
+	0x7e,0x7c,0x7b,0x82,0x86,0x83,0x7c,0x7b,
+	0x7e,0x84,0x85,0x80,0x7b,0x7c,0x82,0x84,
+	0x83,0x7e,0x7c,0x7d,0x83,0x84,0x83,0x61,
+	0x39,0x70,0x65,0x9a,0xc1,0x77,0x89,0x53,
+	0x5e,0x9f,0x4f,0x8f,0x72,0x48,0xbf,0x6e,
+	0xa3,0x9b,0x43,0xa2,0x60,0x8a,0xb4,0x55,
+	0x9d,0x59,0x5d,0xa4,0x57,0xa0,0x72,0x49,
+	0x8e,0x42,0x87,0x84,0x4a,0x85,0x39,0x5c,
+	0x80,0x47,0x8a,0x3f,0x3e,0x6d,0x3a,0x8a,
+	0x65,0x47,0x6e,0x24,0x6b,0x6c,0x4e,0x7c,
+	0x2b,0x50,0x6c,0x4d,0x95,0x52,0x51,0x67,
+	0x38,0x8e,0x6f,0x68,0x84,0x38,0x79,0x75,
+	0x70,0xa7,0x5b,0x7c,0x79,0x61,0xb3,0x7d,
+	0x91,0x95,0x5b,0xa7,0x8a,0x9c,0xb8,0x70,
+	0xa3,0x88,0x8c,0xc9,0x89,0xae,0x94,0x75,
+	0xbb,0x8e,0xb2,0xab,0x6f,0xa7,0x7c,0x9b,
+	0xb7,0x75,0x9d,0x6e,0x73,0xa1,0x74,0x99,
+	0x70,0x52,0x83,0x55,0x87,0x7c,0x47,0x6f,
+	0x3c,0x5c,0x75,0x4c,0x6b,0x3e,0x3f,0x61,
+	0x41,0x71,0x54,0x42,0x5b,0x3a,0x65,0x64,
+	0x58,0x70,0x44,0x5a,0x69,0x5b,0x84,0x60,
+	0x5f,0x69,0x5a,0x83,0x7d,0x77,0x84,0x71,
+	0xa3,0xb8,0xc2,0xd7,0x99,0x7a,0x63,0x61,
+	0xa0,0xa3,0xa7,0xa9,0x95,0xc5,0xca,0xc2,
+	0xb8,0x66,0x5b,0x68,0x88,0xb4,0x91,0x84,
+	0x70,0x56,0x71,0x5a,0x5c,0x59,0x39,0x50,
+	0x4a,0x59,0x6f,0x54,0x5c,0x52,0x4f,0x73,
+	0x66,0x76,0x6f,0x59,0x72,0x6d,0x80,0x90,
+	0x79,0x8a,0x7e,0x87,0xa7,0x9e,0xb1,0xa8,
+	0x9c,0xb8,0xb0,0xcd,0xd1,0xbc,0xcc,0xbb,
+	0xc7,0xdc,0xcc,0xd9,0xc1,0xb5,0xc5,0xb5,
+	0xc7,0xba,0x9e,0xa4,0x87,0x94,0x99,0x83,
+	0x8b,0x68,0x64,0x6d,0x60,0x75,0x65,0x56,
+	0x5e,0x4c,0x67,0x6f,0x6a,0x78,0x5f,0x71,
+	0x80,0x82,0xa4,0x93,0x93,0xa1,0x96,0xbb,
+	0xbc,0xbc,0xc5,0xac,0xbd,0xc3,0xc3,0xd7,
+	0xba,0xb7,0xb5,0xa5,0xc2,0xaf,0xaa,0xa4,
+	0x83,0x92,0x8c,0x8c,0x93,0x6f,0x70,0x66,
+	0x5e,0x79,0x65,0x65,0x5d,0x47,0x61,0x5c,
+	0x69,0x79,0x5f,0x74,0x79,0x88,0xaa,0x7a,
+	0x64,0x6a,0x53,0x86,0x87,0xa3,0xa9,0x99,
+	0xb1,0xb4,0xc5,0xd8,0x91,0x99,0x89,0x78,
+	0xad,0x96,0xae,0xa2,0x81,0x91,0x72,0x7b,
+	0x88,0x61,0x78,0x57,0x4e,0x6b,0x46,0x61,
+	0x51,0x35,0x59,0x33,0x4b,0x58,0x34,0x5d,
+	0x3f,0x47,0x6e,0x46,0x76,0x68,0x5d,0x91,
+	0x6b,0x95,0x9d,0x82,0xba,0x96,0xab,0xc9,
+	0x9d,0xd3,0xb6,0xaf,0xd9,0xa4,0xc8,0xbd,
+	0x99,0xca,0x91,0xa5,0xab,0x72,0xa1,0x71,
+	0x6f,0x8d,0x4d,0x77,0x59,0x41,0x75,0x39,
+	0x5e,0x5e,0x31,0x6c,0x41,0x59,0x7b,0x47,
+	0x82,0x64,0x65,0x9d,0x70,0xa3,0x9e,0x7f,
+	0xbb,0x90,0xb5,0xcc,0x9a,0xd1,0xa6,0xad,
+	0xd6,0xa3,0xd3,0xb5,0x97,0xc5,0x8e,0xb3,
+	0xb6,0x81,0xae,0x73,0x7f,0xa0,0x66,0x9f,
+	0x73,0x5e,0x8c,0x53,0x8a,0x7f,0x57,0x89,
+	0x4d,0x71,0x93,0x6b,0xad,0x80,0x7b,0x9e,
+	0x47,0x7e,0x80,0x53,0x86,0x53,0x8c,0xa7,
+	0x8d,0xcf,0x94,0x97,0x9b,0x51,0xa9,0x7f,
+	0x62,0x8c,0x4f,0x87,0x8c,0x71,0x9f,0x59,
+	0x65,0x75,0x50,0x8e,0x63,0x53,0x66,0x2a,
+	0x62,0x5e,0x4c,0x71,0x2f,0x40,0x50,0x39,
+	0x7a,0x56,0x4d,0x61,0x34,0x72,0x76,0x74,
+	0x96,0x60,0x78,0x8b,0x86,0xc2,0xa4,0xa1,
+	0xaa,0x88,0xc2,0xc3,0xc1,0xd1,0x99,0xa9,
+	0xae,0xab,0xd4,0xab,0x9a,0x90,0x70,0x96,
+	0x93,0x8a,0x86,0x50,0x54,0x57,0x5c,0x79,
+	0x58,0x48,0x3c,0x2e,0x56,0x61,0x66,0x62,
+	0x41,0x4a,0x5c,0x78,0x94,0x8a,0x7d,0x75,
+	0x7b,0xa2,0xba,0xbf,0xb2,0x9e,0x9e,0xb3,
+	0xce,0xda,0xd2,0xb4,0xa2,0xad,0xbc,0xd2,
+	0xcb,0xac,0x99,0x86,0x9a,0xb0,0xaa,0xa3,
+	0x7b,0x67,0x78,0x7a,0x9b,0x8f,0x6d,0x68,
+	0x4f,0x72,0x92,0x89,0x9a,0x71,0x6d,0x8d,
+	0x8b,0xae,0x7d,0x53,0x6f,0x47,0x70,0x94,
+	0x90,0xac,0x80,0x80,0x96,0x71,0x90,0x8a,
+	0x66,0x62,0x41,0x74,0x8b,0x7a,0x8e,0x54,
+	0x55,0x6f,0x60,0x93,0x70,0x52,0x5b,0x31,
+	0x62,0x6c,0x58,0x6b,0x30,0x38,0x4f,0x43,
+	0x7a,0x57,0x45,0x50,0x30,0x6b,0x78,0x6e,
+	0x8b,0x54,0x67,0x85,0x7f,0xbd,0x9e,0x90,
+	0xa1,0x82,0xbb,0xc7,0xb9,0xd1,0x98,0xa5,
+	0xbc,0xac,0xdc,0xb5,0x9d,0xa2,0x7c,0xa5,
+	0xa7,0x8e,0x99,0x5d,0x61,0x6e,0x60,0x81,
+	0x60,0x47,0x4b,0x30,0x56,0x5f,0x52,0x5b,
+	0x37,0x3f,0x5a,0x5d,0x7f,0x71,0x66,0x6e,
+	0x6b,0x8f,0xa4,0xa4,0xa7,0x93,0x99,0xb0,
+	0xbd,0xcf,0xc6,0xb7,0xb0,0xb6,0xc5,0xd0,
+	0xce,0xb9,0xac,0xa3,0xaa,0xbb,0xb2,0xaa,
+	0x96,0x7f,0x90,0x8e,0x97,0x98,0x74,0x79,
+	0x6d,0x70,0x91,0x7e,0x85,0x7c,0x67,0x90,
+	0x8d,0x9f,0xb0,0x81,0x8a,0x5e,0x5d,0xa8,
+	0x84,0x85,0x79,0x5f,0x87,0x68,0x4c,0x70,
+	0x4e,0x6a,0x4d,0x3f,0x73,0x4c,0x5e,0x60,
+	0x40,0x72,0x5d,0x5f,0x75,0x3c,0x5c,0x53,
+	0x46,0x6e,0x40,0x49,0x4e,0x2a,0x5b,0x43,
+	0x42,0x59,0x29,0x4e,0x4d,0x45,0x70,0x4a,
+	0x5c,0x6a,0x58,0x89,0x7f,0x82,0x9a,0x7e,
+	0xa3,0xab,0xa9,0xcb,0xaf,0xba,0xc6,0xbb,
+	0xdb,0xce,0xc6,0xcc,0xb3,0xc3,0xc4,0xb5,
+	0xbb,0x9b,0x95,0x92,0x83,0x8e,0x7b,0x67,
+	0x61,0x4b,0x54,0x55,0x4a,0x49,0x34,0x33,
+	0x3a,0x3f,0x4d,0x48,0x45,0x46,0x4c,0x60,
+	0x70,0x7b,0x7a,0x7b,0x7c,0x9c,0xa8,0xab,
+	0xb6,0xa1,0xbb,0xcd,0xd3,0xd6,0xcf,0xce,
+	0xce,0xd0,0xcf,0xce,0xcb,0xc8,0xc3,0xc0,
+	0xb9,0xb5,0xaf,0xaa,0xa4,0xa1,0x9d,0x98,
+	0x93,0x90,0x8c,0x8c,0x8d,0x8f,0x8e,0x8e,
+	0x8f,0x97,0x9d,0xa5,0xa6,0xa5,0x97,0x86,
+	0x67,0x76,0x97,0x8f,0x81,0x51,0x45,0x21,
+	0x3f,0x53,0x53,0x43,0x2e,0x3c,0x41,0x4c,
+	0x4d,0x4c,0x4c,0x50,0x57,0x59,0x57,0x52,
+	0x48,0x46,0x48,0x4d,0x4c,0x46,0x3c,0x38,
+	0x38,0x40,0x45,0x44,0x3e,0x3d,0x3e,0x49,
+	0x55,0x5c,0x5f,0x60,0x61,0x6f,0x7e,0x8e,
+	0x95,0x96,0x98,0xa2,0xad,0xbd,0xc7,0xc5,
+	0xc3,0xc1,0xc6,0xcf,0xd4,0xcf,0xc5,0xba,
+	0xb3,0xb4,0xb4,0xad,0xa0,0x8f,0x82,0x7d,
+	0x7b,0x79,0x6f,0x60,0x53,0x4e,0x4e,0x54,
+	0x52,0x4c,0x43,0x41,0x45,0x52,0x54,0x30,
+	0x40,0x51,0x4e,0x9a,0x97,0x80,0x8d,0x5c,
+	0x75,0x8d,0x7f,0xc5,0xa2,0x95,0xcc,0x96,
+	0xb9,0xd5,0x96,0xc3,0xb9,0x91,0xda,0xac,
+	0xa4,0xc9,0x7b,0x9a,0xb4,0x86,0xc5,0xa6,
+	0x75,0xaa,0x73,0x86,0xbd,0x79,0x96,0x8f,
+	0x54,0xa2,0x9b,0x8f,0xca,0x7e,0x7d,0xa3,
+	0x71,0xad,0xaa,0x60,0x95,0x6a,0x50,0x8d,
+	0x40,0x6a,0x85,0x33,0x59,0x47,0x36,0x89,
+	0x68,0x53,0x72,0x2e,0x54,0x80,0x57,0x8d,
+	0x6b,0x34,0x65,0x44,0x5d,0x97,0x58,0x66,
+	0x5b,0x24,0x69,0x6c,0x63,0x91,0x4e,0x40,
+	0x66,0x44,0x86,0x98,0x65,0x87,0x5b,0x51,
+	0x9e,0x8a,0xa6,0xba,0x6f,0x8c,0x93,0x8a,
+	0xd9,0xc2,0xa9,0xba,0x7b,0x9d,0xc9,0xaf,
+	0xda,0xb6,0x7a,0x9c,0x82,0x98,0xca,0x92,
+	0x8d,0x79,0x42,0x78,0x81,0x77,0x97,0x53,
+	0x39,0x53,0x3b,0x71,0x86,0x56,0x62,0x3b,
+	0x30,0x71,0x6f,0x86,0x91,0x51,0x5e,0x69,
+	0x6e,0xb3,0xaa,0x90,0x97,0x69,0x85,0xb5,
+	0xaf,0xcf,0xb5,0x82,0x9a,0x8e,0xac,0xdc,
+	0xb4,0xac,0x97,0x70,0xa2,0xaf,0xb0,0xc7,
+	0x8b,0x79,0x89,0x7c,0xb3,0xbc,0x94,0x9a,
+	0x6f,0x6a,0xa4,0x9e,0xb6,0xb1,0x75,0x81,
+	0x80,0x85,0xbd,0x95,0x78,0x69,0x4a,0x5e,
+	0x78,0x6b,0x8a,0x63,0x32,0x56,0x33,0x5d,
+	0x7c,0x56,0x58,0x3e,0x25,0x61,0x69,0x75,
+	0x85,0x46,0x43,0x4e,0x46,0x86,0x80,0x5f,
+	0x61,0x32,0x3f,0x6f,0x69,0x87,0x71,0x3c,
+	0x50,0x4c,0x62,0x9e,0x7d,0x76,0x6b,0x46,
+	0x77,0x95,0x99,0xba,0x87,0x75,0x8e,0x84,
+	0xbc,0xd5,0xae,0xb6,0x91,0x86,0xbf,0xbd,
+	0xcf,0xcf,0x8c,0x93,0x90,0x90,0xc6,0xb0,
+	0x92,0x8b,0x55,0x68,0x8b,0x7c,0x95,0x70,
+	0x3d,0x50,0x40,0x5f,0x86,0x60,0x5b,0x43,
+	0x27,0x5c,0x6a,0x75,0x8c,0x54,0x4e,0x62,
+	0x5e,0x9b,0xa5,0x89,0x92,0x6b,0x74,0xac,
+	0xa8,0xc5,0xbd,0x87,0x99,0x95,0xa5,0xdb,
+	0xc0,0xb1,0xa6,0x7d,0x9f,0xbb,0xb4,0xce,
+	0xa1,0x82,0x91,0x84,0xad,0xc4,0x9e,0xa0,
+	0x7f,0x6f,0xa2,0xa0,0xb0,0xba,0x7b,0x86,
+	0x86,0x82,0xb7,0x9e,0x7a,0x74,0x40,0x69,
+	0x7d,0x67,0x89,0x67,0x4a,0x4d,0x4f,0x5d,
+	0x7d,0x52,0x56,0x43,0x29,0x5c,0x60,0x66,
+	0x7e,0x49,0x48,0x54,0x47,0x7c,0x78,0x5b,
+	0x6a,0x3b,0x48,0x70,0x5f,0x7f,0x71,0x41,
+	0x5e,0x4f,0x61,0x93,0x72,0x79,0x73,0x4d,
+	0x82,0x8e,0x8c,0xb3,0x84,0x7d,0x98,0x83,
+	0xb8,0xc5,0xa4,0xbd,0x94,0x92,0xc6,0xb0,
+	0xcb,0xcc,0x8f,0xa7,0x9b,0x95,0xca,0xa5,
+	0x97,0x98,0x5e,0x80,0x8c,0x74,0x98,0x68,
+	0x47,0x63,0x40,0x63,0x79,0x4a,0x60,0x42,
+	0x2a,0x65,0x52,0x67,0x7c,0x42,0x59,0x61,
+	0x54,0x98,0x86,0x7a,0x95,0x65,0x83,0xa9,
+	0x94,0xc2,0xad,0x89,0xb1,0x97,0xb0,0xd9,
+	0xab,0xc1,0xb1,0x8c,0xc2,0xb6,0xb5,0xd3,
+	0x9a,0xa1,0xac,0x8c,0xc2,0xb8,0x9b,0xb8,
+	0x86,0x8f,0xb5,0x96,0xb9,0xb1,0x82,0xa6,
+	0x8c,0x8e,0xb4,0x82,0x7c,0x72,0x44,0x84,
+	0x74,0x50,0x83,0x4c,0x55,0x6f,0x37,0x67,
+	0x75,0x47,0x5d,0x34,0x31,0x50,0x36,0x50,
+	0x53,0x33,0x51,0x42,0x40,0x62,0x46,0x53,
+	0x59,0x3e,0x57,0x55,0x4b,0x65,0x51,0x54,
+	0x65,0x4f,0x65,0x69,0x60,0x77,0x71,0x6f,
+	0x85,0x78,0x8a,0x95,0x91,0xa6,0xa3,0xa2,
+	0xb2,0xab,0xbc,0xc8,0xc2,0xca,0xc3,0xbd,
+	0xc8,0xc9,0xce,0xcd,0xc0,0xb2,0xa9,0xa8,
+	0xab,0xa8,0x9f,0x88,0x79,0x6d,0x6a,0x75,
+	0x6d,0x63,0x53,0x39,0x40,0x45,0x4b,0x5b,
+	0x47,0x37,0x3c,0x31,0x54,0x64,0x5e,0x6c,
+	0x51,0x51,0x6f,0x75,0x94,0x9f,0x81,0x8b,
+	0x83,0x8a,0xba,0xb2,0xb7,0xb4,0x8c,0xa6,
+	0xb3,0xb8,0xdb,0xbb,0xa9,0xad,0x94,0xbd,
+	0xce,0xba,0xc8,0x9c,0x8c,0xaf,0xa4,0xc6,
+	0xc9,0x98,0xa1,0x8c,0x8b,0xbf,0xac,0xa9,
+	0x9f,0x5f,0x71,0x73,0x6b,0x9c,0x8a,0x76,
+	0x62,0x4c,0x77,0x7b,0x59,0x6e,0x59,0x33,
+	0x54,0x61,0x7f,0x81,0x44,0x46,0x31,0x2f,
+	0x6a,0x5c,0x5e,0x59,0x24,0x40,0x50,0x57,
+	0x84,0x5e,0x47,0x4d,0x33,0x63,0x7f,0x6d,
+	0x7c,0x4f,0x40,0x69,0x6a,0x91,0x9b,0x6d,
+	0x71,0x64,0x70,0xac,0xa8,0xab,0x9d,0x75,
+	0x8d,0xa1,0xb6,0xd8,0xb9,0xa0,0x9a,0x8e,
+	0xb9,0xd0,0xc8,0xbf,0x94,0x82,0x97,0xa3,
+	0xbd,0xb5,0x8b,0x72,0x61,0x6d,0x8f,0x92,
+	0x85,0x62,0x40,0x42,0x57,0x70,0x7b,0x63,
+	0x45,0x30,0x3b,0x57,0x76,0x7c,0x62,0x4c,
+	0x44,0x52,0x7e,0x93,0x93,0x83,0x60,0x69,
+	0x85,0x9d,0xc1,0xaf,0x92,0x8b,0x81,0xa7,
+	0xcd,0xc3,0xc6,0x9f,0x87,0xa4,0xae,0xcd,
+	0xd9,0xa8,0xa1,0x90,0x92,0xc8,0xc3,0xbf,
+	0xb7,0x7e,0x8f,0xa1,0xa5,0xcc,0xa3,0x81,
+	0x7a,0x54,0x75,0x8d,0x82,0xa6,0x7f,0x4d,
+	0x79,0x7f,0x92,0x87,0x40,0x3d,0x31,0x48,
+	0x81,0x5b,0x6e,0x78,0x3d,0x4d,0x51,0x4e,
+	0x74,0x4b,0x38,0x3d,0x22,0x4f,0x66,0x53,
+	0x65,0x3e,0x30,0x56,0x4f,0x71,0x77,0x52,
+	0x5d,0x4d,0x56,0x85,0x7d,0x84,0x7f,0x5e,
+	0x77,0x87,0x8f,0xb2,0x9b,0x91,0x97,0x8c,
+	0xad,0xc1,0xb7,0xc2,0xa8,0x9f,0xb8,0xb5,
+	0xca,0xcd,0xaf,0xad,0xa0,0x9f,0xb9,0xb0,
+	0xa8,0x9f,0x7c,0x81,0x83,0x84,0x8d,0x77,
+	0x64,0x5a,0x4f,0x5a,0x62,0x5a,0x56,0x43,
+	0x38,0x42,0x48,0x54,0x58,0x4d,0x47,0x47,
+	0x52,0x64,0x6c,0x72,0x70,0x6b,0x73,0x7f,
+	0x91,0x99,0x9c,0x9c,0x95,0xa4,0xac,0xb7,
+	0xc3,0xba,0xb8,0xbd,0xb6,0xc9,0xcd,0xc6,
+	0xce,0xbe,0xbe,0xcb,0xbe,0xce,0xc8,0xb7,
+	0x7d,0x49,0x7e,0xae,0xaa,0xaf,0xac,0x8f,
+	0xa0,0x8f,0x83,0x94,0x7a,0x7a,0x85,0x6a,
+	0x7d,0x74,0x5e,0x77,0x61,0x5e,0x73,0x50,
+	0x5f,0x5e,0x45,0x64,0x54,0x48,0x5f,0x3b,
+	0x45,0x57,0x39,0x59,0x4d,0x31,0x51,0x35,
+	0x3f,0x5c,0x36,0x4d,0x44,0x27,0x53,0x41,
+	0x43,0x62,0x37,0x43,0x4f,0x33,0x64,0x59,
+	0x47,0x65,0x3a,0x48,0x69,0x4f,0x76,0x69,
+	0x46,0x6b,0x54,0x62,0x8e,0x68,0x7a,0x75,
+	0x51,0x84,0x82,0x83,0xae,0x7a,0x7f,0x91,
+	0x74,0xa8,0xa9,0x85,0xa0,0x70,0x74,0x9d,
+	0x81,0x9e,0x96,0x5e,0x7b,0x67,0x64,0x90,
+	0x68,0x65,0x62,0x34,0x58,0x5e,0x53,0x77,
+	0x4e,0x41,0x58,0x41,0x6b,0x7b,0x60,0x77,
+	0x5e,0x57,0x88,0x7c,0x93,0xa0,0x78,0x8d,
+	0x8e,0x8d,0xbf,0xb0,0xac,0xb4,0x92,0xad,
+	0xc2,0xb8,0xd8,0xc1,0xaa,0xbf,0xad,0xc2,
+	0xdd,0xbf,0xc5,0xb3,0xa1,0xc8,0xc4,0xcf,
+	0xd9,0xae,0xb1,0xb3,0xa2,0xc5,0xb6,0x9c,
+	0x99,0x6a,0x6f,0x83,0x72,0x90,0x81,0x6d,
+	0x88,0x7a,0x8c,0xa7,0x85,0x81,0x73,0x58,
+	0x80,0x95,0xa4,0xc0,0xa2,0xa1,0xae,0xa9,
+	0xcd,0xd3,0xba,0xbe,0x9a,0x96,0xad,0xa2,
+	0xaf,0xa2,0x72,0x77,0x67,0x68,0x86,0x6c,
+	0x61,0x56,0x35,0x4b,0x58,0x58,0x6e,0x54,
+	0x47,0x52,0x4f,0x71,0x85,0x7b,0x84,0x72,
+	0x75,0x99,0xa1,0xb8,0xc0,0xa1,0xa9,0xa9,
+	0xb0,0xcc,0xc1,0x9a,0x80,0x77,0x81,0x82,
+	0x7f,0x98,0x85,0x73,0x6b,0x57,0x50,0x66,
+	0x66,0x56,0x35,0x26,0x45,0x50,0x5e,0x67,
+	0x4c,0x4a,0x51,0x55,0x7d,0x86,0x7f,0x80,
+	0x6c,0x6e,0x8a,0x8d,0x9c,0x95,0x74,0x75,
+	0x6f,0x7a,0x99,0x8d,0x88,0x80,0x65,0x79,
+	0x88,0x8e,0x9d,0x81,0x6c,0x73,0x6b,0x8b,
+	0x9e,0x8f,0x94,0x81,0x72,0x9a,0x9d,0xac,
+	0xb0,0x85,0x7d,0x77,0x6c,0x94,0x8b,0x83,
+	0x89,0x78,0x61,0x68,0x66,0x8a,0x88,0x67,
+	0x77,0x74,0x90,0xc8,0x9e,0x73,0x63,0x36,
+	0x63,0x68,0x6d,0x80,0x5a,0x47,0x57,0x48,
+	0x75,0x89,0x77,0x83,0x6c,0x63,0x8b,0x89,
+	0x9e,0xa4,0x75,0x7c,0x75,0x72,0xa1,0x94,
+	0x89,0x88,0x61,0x70,0x89,0x82,0x9f,0x85,
+	0x68,0x76,0x68,0x81,0xa6,0x8f,0x9c,0x8e,
+	0x79,0xa2,0xaa,0xb1,0xca,0x9c,0x94,0x95,
+	0x81,0xa7,0xaa,0x94,0xa7,0x8c,0x81,0x73,
+	0x6c,0x77,0x80,0x60,0x75,0x71,0x82,0xba,
+	0xac,0x77,0x6b,0x37,0x4b,0x63,0x57,0x78,
+	0x55,0x40,0x50,0x3e,0x5f,0x7f,0x68,0x7c,
+	0x6c,0x5d,0x88,0x87,0x96,0xad,0x81,0x82,
+	0x88,0x75,0x9f,0x9b,0x83,0x93,0x68,0x67,
+	0x87,0x6f,0x89,0x88,0x5d,0x75,0x69,0x6b,
+	0x9f,0x8a,0x90,0xa3,0x7d,0x9f,0xb2,0xa5,
+	0xce,0xb3,0x99,0xb3,0x8f,0xa1,0xb9,0x93,
+	0xa7,0xa3,0x89,0xac,0x69,0x6c,0x84,0x54,
+	0x6b,0x7f,0x71,0xa5,0xb3,0x7c,0x71,0x56,
+	0x3a,0x62,0x43,0x5b,0x62,0x35,0x50,0x48,
+	0x39,0x6a,0x58,0x5b,0x7a,0x59,0x78,0x8f,
+	0x7c,0xa6,0x9b,0x86,0xa8,0x8d,0x94,0xab,
+	0x83,0x91,0x8b,0x64,0x86,0x71,0x63,0x80,
+	0x5e,0x63,0x7a,0x5e,0x7f,0x8b,0x79,0xa0,
+	0x96,0x94,0xbc,0xa5,0xb5,0xc3,0xa3,0xb6,
+	0xb0,0x96,0xb1,0x9c,0x99,0xb0,0x9b,0xac,
+	0xb4,0x6c,0x74,0x79,0x53,0x7e,0x77,0x88,
+	0xa5,0x8d,0x6a,0x68,0x51,0x51,0x4d,0x3d,
+	0x51,0x3f,0x3f,0x50,0x3a,0x47,0x50,0x41,
+	0x60,0x64,0x68,0x85,0x80,0x89,0x9f,0x96,
+	0xaa,0xb0,0xa2,0xaa,0x9c,0x90,0x96,0x85,
+	0x80,0x7a,0x61,0x62,0x5d,0x59,0x69,0x66,
+	0x68,0x71,0x74,0x83,0x96,0xa4,0xb0,0xb1,
+	0xb4,0xb3,0xbb,0xbf,0xc1,0xbd,0xae,0x9e,
+	0x9a,0x97,0x9d,0xaa,0xa4,0xa4,0x93,0x59,
+	0x74,0x75,0x6e,0x8c,0x85,0x8c,0x8f,0x5b,
+	0x73,0x70,0x47,0x55,0x42,0x38,0x53,0x49,
+	0x47,0x51,0x2b,0x36,0x46,0x41,0x70,0x73,
+	0x6b,0x87,0x79,0x8d,0xba,0xb0,0xc2,0xc4,
+	0x97,0xac,0x9f,0x8f,0xac,0x80,0x6a,0x68,
+	0x3b,0x4f,0x62,0x4b,0x6b,0x5c,0x48,0x77,
+	0x75,0x91,0xbf,0xa4,0xb4,0xba,0xa2,0xce,
+	0xd1,0xbf,0xd5,0xa6,0x94,0xab,0x91,0xaa,
+	0xb6,0x93,0xa5,0x97,0x72,0x7d,0x86,0x82,
+	0x8c,0x6f,0x7e,0x70,0x51,0x85,0x67,0x46,
+	0x52,0x3b,0x3f,0x5e,0x49,0x53,0x4a,0x27,
+	0x3b,0x40,0x49,0x71,0x67,0x66,0x78,0x73,
+	0x96,0xb6,0xb6,0xc8,0xb7,0xa5,0xae,0xa9,
+	0xa9,0xaa,0x85,0x6d,0x58,0x45,0x51,0x59,
+	0x54,0x56,0x49,0x4d,0x62,0x7b,0x9a,0xac,
+	0xa9,0xaa,0xac,0xb8,0xca,0xd7,0xd3,0xc0,
+	0xae,0xa2,0xa1,0xaf,0xae,0xaa,0xa2,0x92,
+	0x95,0xa0,0x85,0x8b,0x99,0x80,0x75,0x61,
+	0x4c,0x6d,0x6b,0x59,0x4a,0x32,0x42,0x46,
+	0x49,0x5e,0x41,0x35,0x37,0x26,0x44,0x5a,
+	0x55,0x6e,0x63,0x62,0x8c,0x92,0xb1,0xcd,
+	0xb3,0xbc,0xba,0xa3,0xbe,0xb2,0x9a,0x97,
+	0x65,0x54,0x60,0x45,0x5a,0x5a,0x3e,0x51,
+	0x4e,0x52,0x89,0x87,0x98,0xae,0x97,0xad,
+	0xbe,0xb7,0xd6,0xc7,0xaf,0xbb,0xa2,0xa2,
+	0xba,0xa1,0xab,0xa6,0x8b,0xa5,0xa2,0x8c,
+	0x90,0x8e,0x87,0x7e,0x48,0x4d,0x6c,0x58,
+	0x57,0x43,0x31,0x44,0x3d,0x44,0x51,0x39,
+	0x39,0x3a,0x30,0x4a,0x53,0x56,0x6b,0x68,
+	0x74,0x91,0x9d,0xb6,0xc6,0xc1,0xc8,0xc2,
+	0xbd,0xc2,0xb4,0xa0,0x8e,0x71,0x5e,0x51,
+	0x49,0x44,0x3e,0x3c,0x3e,0x49,0x5a,0x6e,
+	0x86,0x95,0xa0,0xb2,0xba,0xc6,0xd6,0xcf,
+	0xd5,0xcd,0xc0,0xc4,0xba,0xb0,0xbb,0xa7,
+	0xab,0xb4,0xa7,0xb1,0xa5,0x75,0x95,0x93,
+	0x70,0x4a,0x3d,0x51,0x55,0x2f,0x3d,0x43,
+	0x30,0x4a,0x3b,0x31,0x45,0x32,0x37,0x47,
+	0x31,0x4b,0x54,0x51,0x7b,0x7e,0x87,0xae,
+	0xa3,0xb8,0xd3,0xc0,0xd4,0xce,0xab,0xb9,
+	0x9a,0x82,0x88,0x62,0x55,0x49,0x36,0x45,
+	0x47,0x3e,0x4a,0x52,0x66,0x7d,0x8f,0xa1,
+	0xaf,0xbb,0xc5,0xcd,0xce,0xce,0xcd,0xc9,
+	0xc4,0xc0,0xbc,0xb8,0xb3,0xb3,0xb3,0xb7,
+	0xb3,0x9e,0x7f,0x8a,0x8d,0x64,0x38,0x4a,
+	0x4b,0x3f,0x2b,0x2e,0x2e,0x33,0x34,0x34,
+	0x32,0x30,0x2e,0x33,0x37,0x3e,0x45,0x52,
+	0x5f,0x71,0x85,0x9a,0xab,0xbb,0xc9,0xd0,
+	0xd6,0xd7,0xd1,0xc6,0xb4,0x9f,0x88,0x74,
+	0x61,0x4f,0x40,0x36,0x31,0x33,0x3b,0x4a,
+	0x59,0x6d,0x7e,0x91,0xa3,0xb4,0xc3,0xce,
+	0xd3,0xd5,0xd2,0xd1,0xcd,0xca,0xc2,0xc0,
+	0xb6,0xb5,0xb2,0xb7,0xb8,0xb5,0x9d,0x7f,
+	0x89,0x7f,0x58,0x47,0x4e,0x4c,0x40,0x2d,
+	0x34,0x34,0x3c,0x3c,0x3d,0x3a,0x3b,0x3f,
+	0x44,0x49,0x4f,0x55,0x60,0x6b,0x7b,0x89,
+	0x97,0xa4,0xaf,0xb3,0xbc,0xbc,0xbe,0xb7,
+	0xaf,0x7f,0x74,0x78,0x73,0x97,0x5f,0x5f,
+	0x30,0x4c,0x64,0x5a,0x51,0x42,0x5f,0x8d,
+	0xb5,0xa3,0x90,0x7d,0xa2,0xc6,0xd3,0xbc,
+	0x91,0x91,0xa1,0xc8,0xbf,0x9e,0x82,0x78,
+	0xac,0xac,0xb4,0x6e,0x5c,0x70,0x89,0x9d,
+	0x72,0x69,0x3e,0x57,0x68,0x6a,0x5d,0x23,
+	0x41,0x45,0x86,0x7d,0x6a,0x5b,0x4c,0x8c,
+	0x7e,0x9a,0x58,0x58,0x64,0x88,0xba,0x96,
+	0xa4,0x7a,0xb5,0xc3,0xce,0xb3,0x6b,0x7a,
+	0x5f,0x9a,0x70,0x60,0x3f,0x3e,0x7f,0x7e,
+	0xa2,0x60,0x6c,0x69,0x91,0xaf,0x81,0x87,
+	0x51,0x99,0xa4,0xc6,0xb3,0x86,0x9f,0x94,
+	0xd8,0xa9,0x9b,0x6b,0x69,0x9b,0x95,0xaf,
+	0x5d,0x72,0x73,0x99,0xa4,0x7b,0x72,0x36,
+	0x63,0x64,0x79,0x5a,0x31,0x4a,0x51,0x9d,
+	0x80,0x7b,0x51,0x56,0x89,0x84,0x95,0x51,
+	0x58,0x5e,0x93,0xbc,0x9d,0x9e,0x77,0xb3,
+	0xbf,0xca,0xa2,0x60,0x65,0x5f,0x97,0x76,
+	0x5f,0x43,0x44,0x8e,0x8f,0xa8,0x61,0x60,
+	0x69,0x8c,0xb0,0x7c,0x78,0x52,0x97,0xb8,
+	0xc8,0xb7,0x7a,0x9e,0x95,0xd4,0xa6,0x85,
+	0x61,0x5b,0xa6,0x97,0xad,0x5d,0x72,0x80,
+	0x99,0xad,0x6c,0x6a,0x28,0x66,0x6b,0x77,
+	0x5f,0x28,0x60,0x5a,0xb6,0x7e,0x79,0x4e,
+	0x56,0x94,0x7b,0x98,0x3a,0x64,0x65,0xab,
+	0xc4,0x93,0xa1,0x69,0xc3,0xaa,0xc3,0x7c,
+	0x50,0x66,0x5f,0xab,0x65,0x72,0x3b,0x6a,
+	0x9a,0x98,0xa3,0x45,0x6f,0x5b,0xa9,0x99,
+	0x7b,0x71,0x58,0xb9,0xac,0xda,0x8e,0x81,
+	0x88,0x9a,0xcb,0x84,0x82,0x46,0x81,0x9d,
+	0xa4,0x9d,0x5d,0x83,0x77,0xac,0x8d,0x6c,
+	0x4c,0x32,0x77,0x6c,0x8c,0x47,0x4a,0x60,
+	0x82,0xb6,0x76,0x73,0x39,0x6f,0x87,0x8d,
+	0x82,0x3b,0x73,0x73,0xcc,0xb1,0x9b,0x81,
+	0x72,0xc0,0x9f,0xb5,0x54,0x56,0x5c,0x7e,
+	0xae,0x65,0x77,0x38,0x8d,0x96,0xa2,0x85,
+	0x3f,0x71,0x5d,0xc1,0x83,0x88,0x61,0x74,
+	0xc3,0xae,0xd4,0x66,0x89,0x74,0xab,0xb5,
+	0x77,0x7d,0x3f,0xa6,0x8b,0xbb,0x7f,0x68,
+	0x7d,0x75,0xb4,0x6b,0x75,0x2b,0x5e,0x77,
+	0x87,0x86,0x3c,0x68,0x5d,0xb0,0x8e,0x7b,
+	0x51,0x47,0x86,0x85,0x9f,0x5a,0x65,0x6c,
+	0xa4,0xc0,0xa1,0x8a,0x64,0x93,0x9f,0xb1,
+	0x7f,0x57,0x57,0x75,0xa2,0x91,0x76,0x50,
+	0x65,0x8b,0xa1,0x8e,0x62,0x50,0x6b,0x99,
+	0xab,0x91,0x6e,0x6e,0x93,0xbe,0xb5,0x94,
+	0x6a,0x73,0x96,0xb1,0xa4,0x75,0x66,0x72,
+	0x9b,0xa9,0x94,0x70,0x5c,0x78,0x91,0x90,
+	0x71,0x4f,0x56,0x70,0x92,0x85,0x65,0x4e,
+	0x5a,0x87,0x90,0x87,0x59,0x56,0x6f,0x8e,
+	0xa3,0x7a,0x75,0x5d,0x94,0xa2,0xa4,0x8a,
+	0x61,0x85,0x82,0xbc,0x84,0x81,0x5e,0x6f,
+	0x9a,0x83,0x97,0x43,0x74,0x5f,0x9d,0x92,
+	0x71,0x7b,0x53,0xae,0x82,0xb5,0x69,0x75,
+	0x7f,0x85,0xbc,0x73,0x9f,0x56,0xa5,0x97,
+	0xa9,0x9b,0x5f,0x8f,0x5c,0xb5,0x72,0x87,
+	0x60,0x66,0x99,0x74,0xa5,0x52,0x87,0x62,
+	0x8b,0x88,0x5e,0x74,0x3c,0x8d,0x66,0x99,
+	0x6d,0x6e,0x85,0x77,0xb2,0x6f,0x92,0x5c,
+	0x80,0x86,0x7e,0x97,0x60,0x98,0x74,0xac,
+	0x90,0x88,0x89,0x65,0x96,0x65,0x8e,0x58,
+	0x71,0x73,0x75,0x9e,0x71,0xa0,0x6f,0x9a,
+	0x87,0x85,0x8b,0x61,0x91,0x61,0x9c,0x75,
+	0x95,0x8f,0x8b,0xae,0x7d,0xad,0x6e,0x8f,
+	0x69,0x77,0x79,0x63,0x8f,0x64,0x9e,0x72,
+	0x93,0x85,0x85,0x8e,0x62,0x80,0x4d,0x7c,
+	0x5c,0x76,0x71,0x6e,0x93,0x7f,0xa7,0x7c,
+	0x8f,0x73,0x81,0x7f,0x71,0x79,0x5f,0x81,
+	0x81,0x9b,0x94,0x8e,0x8b,0x8b,0x95,0x86,
+	0x78,0x60,0x60,0x6d,0x7e,0x81,0x81,0x76,
+	0x8f,0x93,0xa8,0x8f,0x7b,0x6f,0x69,0x8a,
+	0x73,0x85,0x61,0x7f,0x8e,0xa5,0xb5,0x85,
+	0x97,0x6b,0x9f,0x79,0x82,0x60,0x52,0x7b,
+	0x70,0xb4,0x76,0x96,0x6e,0x93,0xa1,0x82,
+	0x88,0x35,0x72,0x4f,0x94,0x72,0x6c,0x77,
+	0x70,0xc0,0x8c,0xb5,0x59,0x76,0x6d,0x7e,
+	0x93,0x4e,0x78,0x4a,0xaa,0x99,0xb2,0x8f,
+	0x6c,0x97,0x79,0xb3,0x5b,0x68,0x3f,0x6a,
+	0x96,0x86,0x9f,0x5b,0x99,0x89,0xbe,0x99,
+	0x6b,0x66,0x47,0x97,0x73,0x93,0x58,0x70,
+	0x91,0xa9,0xcd,0x84,0x8e,0x5a,0x92,0x88,
+	0x7e,0x67,0x3c,0x75,0x7a,0xbd,0x8f,0x88,
+	0x75,0x82,0xad,0x8a,0x85,0x3a,0x54,0x60,
+	0x8c,0x90,0x6a,0x75,0x70,0xb4,0xac,0xa5,
+	0x6d,0x56,0x6d,0x7d,0x93,0x65,0x5e,0x5a,
+	0x8f,0xb2,0xaf,0x95,0x6d,0x7d,0x8c,0x9e,
+	0x7b,0x54,0x47,0x5f,0x91,0x9f,0x93,0x76,
+	0x7b,0x98,0xaf,0xa3,0x77,0x50,0x56,0x75,
+	0x8e,0x85,0x6a,0x69,0x84,0xb4,0xb9,0xa4,
+	0x74,0x69,0x7b,0x89,0x89,0x5e,0x53,0x57,
+	0x8f,0xa8,0xa5,0x8c,0x70,0x8d,0x92,0xa2,
+	0x73,0x55,0x47,0x5f,0x8e,0x86,0x89,0x64,
+	0x85,0x9b,0xb3,0xa5,0x6e,0x67,0x55,0x88,
+	0x7b,0x7c,0x5c,0x60,0x8e,0x9f,0xc0,0x88,
+	0x88,0x6b,0x8a,0x93,0x76,0x6b,0x3d,0x71,
+	0x78,0xa9,0x92,0x80,0x85,0x84,0xb5,0x8c,
+	0x8b,0x4f,0x5b,0x6f,0x7b,0x92,0x65,0x83,
+	0x75,0xaf,0xae,0x9e,0x89,0x5f,0x83,0x6d,
+	0x90,0x61,0x61,0x65,0x77,0xae,0x93,0xa5,
+	0x6f,0x8f,0x89,0x8f,0x85,0x50,0x63,0x4c,
+	0x8b,0x80,0x8d,0x7d,0x79,0xa3,0x94,0xb3,
+	0x70,0x72,0x5b,0x6d,0x84,0x69,0x7d,0x57,
+	0x90,0x8f,0xb1,0xa0,0x80,0x87,0x6b,0x99,
+	0x6c,0x77,0x53,0x5f,0x81,0x85,0xab,0x7c,
+	0x97,0x7f,0x9f,0x98,0x7d,0x75,0x4b,0x76,
+	0x66,0x8d,0x77,0x79,0x89,0x89,0xb6,0x8e,
+	0x9b,0x69,0x74,0x74,0x73,0x7c,0x58,0x76,
+	0x6a,0x9f,0x98,0x9a,0x92,0x7a,0x96,0x7b,
+	0x8e,0x62,0x63,0x61,0x6d,0x8e,0x7e,0x97,
+	0x79,0x9b,0x96,0x9a,0x8f,0x6b,0x73,0x5c,
+	0x7e,0x6f,0x78,0x74,0x79,0x99,0x94,0xa9,
+	0x86,0x8a,0x77,0x7c,0x7d,0x67,0x6f,0x5b,
+	0x7d,0x80,0x95,0x95,0x8b,0x96,0x86,0x98,
+	0x7d,0x79,0x63,0x63,0x73,0x70,0x85,0x7a,
+	0x8e,0x8c,0x9b,0x9c,0x8b,0x87,0x6d,0x76,
+	0x6b,0x72,0x6c,0x6e,0x7d,0x82,0x9a,0x93,
+	0x97,0x8c,0x87,0x85,0x79,0x74,0x65,0x6c,
+	0x6c,0x7c,0x83,0x86,0x88,0x87,0x8b,0x84,
+	0x7d,0x6d,0x60,0x5b,0x59,0x5b,0x5c,0x5d,
+	0x63,0x63,0x6a,0x64,0x62,0x5a,0x4f,0x4e,
+	0x41,0x43,0x32,0x40,0x42,0x53,0x61,0x5a,
+	0x62,0x49,0x53,0x3a,0x42,0x38,0x3a,0x4c,
+	0x50,0x71,0x6a,0x75,0x60,0x57,0x4f,0x44,
+	0x57,0x4f,0x6f,0x70,0x86,0x89,0x80,0x7d,
+	0x60,0x6c,0x5c,0x79,0x81,0x93,0xa5,0xa0,
+	0xad,0x8d,0x96,0x7b,0x82,0x88,0x93,0xb1,
+	0xac,0xc5,0xab,0xb1,0x98,0x8d,0x89,0x7d,
+	0x9e,0x97,0xbc,0xb2,0xb0,0xa0,0x85,0x87,
+	0x69,0x80,0x6a,0x84,0x8a,0x92,0x9a,0x7e,
+	0x7b,0x48,0x55,0x42,0x54,0x61,0x65,0x78,
+	0x64,0x74,0x4f,0x50,0x3e,0x36,0x49,0x44,
+	0x6b,0x5f,0x78,0x6c,0x69,0x5c,0x45,0x52,
+	0x3f,0x6c,0x6a,0x82,0x7f,0x76,0x75,0x5f,
+	0x6c,0x4c,0x5c,0x55,0x66,0x7a,0x7a,0x8f,
+	0x80,0x9c,0x90,0x9f,0x8b,0x6c,0x76,0x84,
+	0xc7,0xcd,0xda,0xc6,0xbd,0xa9,0x79,0x6d,
+	0x5c,0x90,0x9c,0xae,0xab,0x8f,0x7f,0x56,
+	0x5e,0x4b,0x5f,0x61,0x64,0x70,0x62,0x6c,
+	0x53,0x59,0x4b,0x50,0x5b,0x5f,0x77,0x6c,
+	0x7b,0x6c,0x6d,0x68,0x62,0x6c,0x65,0x80,
+	0x84,0x98,0x9b,0x98,0x9d,0x8f,0xa0,0x95,
+	0xa9,0xae,0xba,0xc9,0xcc,0xd9,0xc8,0xc9,
+	0xbd,0xc0,0xc3,0xc4,0xcb,0xc3,0xcb,0xc2,
+	0xbc,0xac,0x98,0x8e,0x81,0x89,0x81,0x83,
+	0x78,0x72,0x6c,0x61,0x5b,0x4a,0x48,0x48,
+	0x54,0x60,0x65,0x69,0x65,0x6c,0x6d,0x76,
+	0x76,0x7b,0x88,0x98,0xae,0xb7,0xb9,0xb5,
+	0xb4,0xb8,0xbc,0xc1,0xbf,0xc2,0xc7,0xcc,
+	0xcf,0xc6,0xb6,0xa7,0xa0,0xa2,0xa0,0x9b,
+	0x95,0x8d,0x8c,0x8a,0x80,0x70,0x62,0x59,
+	0x5d,0x66,0x65,0x63,0x59,0x5c,0x5a,0x5e,
+	0x59,0x4f,0x52,0x5a,0x74,0x81,0x8b,0x93,
+	0x91,0x96,0x73,0x7f,0x7f,0x86,0xa6,0xbd,
+	0xd6,0xb6,0x99,0x92,0x8e,0x9c,0xac,0xad,
+	0xa3,0xa4,0x9d,0xae,0xa4,0x9d,0x87,0x78,
+	0x7f,0x78,0x84,0x6b,0x65,0x56,0x56,0x60,
+	0x4d,0x4c,0x2d,0x3d,0x3f,0x4c,0x4d,0x3c,
+	0x46,0x3b,0x5b,0x54,0x60,0x58,0x56,0x75,
+	0x78,0x99,0x88,0x91,0x92,0x9f,0xbb,0xb1,
+	0xc2,0xa7,0xc0,0xc2,0xce,0xd1,0xb6,0xbc,
+	0xa7,0xc3,0xb2,0xae,0x9d,0x81,0x92,0x7e,
+	0x91,0x6a,0x63,0x54,0x51,0x66,0x4b,0x54,
+	0x2c,0x3f,0x42,0x4e,0x5b,0x3e,0x53,0x42,
+	0x71,0x6d,0x77,0x74,0x68,0x92,0x90,0xba,
+	0xa4,0xa8,0xa8,0xad,0xd1,0xbc,0xce,0xaa,
+	0xbf,0xc5,0xce,0xd6,0xab,0xb5,0x97,0xb5,
+	0xab,0xa3,0x96,0x78,0x94,0x85,0x9d,0x75,
+	0x66,0x5a,0x55,0x77,0x61,0x6e,0x49,0x5e,
+	0x69,0x70,0x7c,0x52,0x63,0x53,0x81,0x90,
+	0x97,0x9a,0x8a,0xa8,0x94,0x94,0x89,0x8a,
+	0x80,0x87,0x92,0x7f,0x9b,0x68,0x71,0x82,
+	0x8b,0x9b,0x7a,0x83,0x79,0x99,0x9e,0x91,
+	0x7f,0x5d,0x6d,0x68,0x7b,0x69,0x5b,0x58,
+	0x58,0x6f,0x60,0x57,0x37,0x33,0x43,0x4f,
+	0x5d,0x4a,0x4c,0x49,0x5d,0x66,0x60,0x58,
+	0x4d,0x64,0x7b,0x95,0x99,0x90,0x90,0x9a,
+	0xab,0xb3,0xac,0xa5,0xa9,0xbd,0xd5,0xd5,
+	0xc8,0xb1,0xa9,0xab,0xb1,0xad,0x96,0x8f,
+	0x89,0x97,0x94,0x83,0x67,0x49,0x50,0x4f,
+	0x5f,0x50,0x46,0x45,0x46,0x5e,0x51,0x4e,
+	0x35,0x3e,0x55,0x67,0x84,0x71,0x7e,0x79,
+	0x90,0x9e,0x94,0x9c,0x87,0xac,0xb5,0xd4,
+	0xcf,0xba,0xbd,0xab,0xc9,0xb5,0xbc,0xa8,
+	0xa6,0xbe,0xb6,0xcb,0x9c,0x98,0x7e,0x83,
+	0x93,0x7f,0x8d,0x6b,0x86,0x7d,0x88,0x7b,
+	0x58,0x5e,0x47,0x74,0x70,0x7d,0x7a,0x6e,
+	0x8d,0x82,0xa0,0x84,0x8f,0x90,0x9d,0xaa,
+	0x90,0xb4,0x81,0x5e,0x51,0x6b,0x6a,0x4c,
+	0x65,0x67,0x8e,0x96,0x91,0x87,0x69,0x76,
+	0x68,0x78,0x6b,0x6c,0x6d,0x70,0x7e,0x69,
+	0x5f,0x40,0x38,0x3b,0x3e,0x4c,0x43,0x49,
+	0x45,0x4a,0x47,0x3d,0x33,0x2e,0x3b,0x4f,
+	0x61,0x6f,0x74,0x78,0x80,0x82,0x8b,0x88,
+	0x92,0xa0,0xb2,0xca,0xcd,0xd7,0xc8,0xc9,
+	0xc1,0xbc,0xc0,0xb9,0xc6,0xbe,0xc9,0xbb,
+	0xae,0x9f,0x82,0x7f,0x66,0x6f,0x63,0x66,
+	0x67,0x56,0x5e,0x3d,0x41,0x2c,0x32,0x34,
+	0x35,0x50,0x49,0x67,0x59,0x62,0x5e,0x5b,
+	0x71,0x6a,0x8f,0x8a,0xa9,0xad,0xb5,0xc2,
+	0xaa,0xba,0xa1,0xbb,0xba,0xc7,0xd4,0xc2,
+	0xd7,0xb9,0xc9,0xaa,0xa4,0x9d,0x91,0xaf,
+	0x9c,0xb4,0x96,0x94,0x87,0x77,0x84,0x63,
+	0x76,0x61,0x7e,0x85,0x85,0x8a,0x67,0x77,
+	0x62,0x7f,0x80,0x88,0x9d,0x9e,0xc8,0xb8,
+	0xb8,0x7b,0x6a,0x78,0x4c,0x52,0x54,0x67,
+	0x4a,0x51,0x60,0x58,0x5d,0x3e,0x51,0x54,
+	0x75,0x7f,0x76,0x72,0x5c,0x68,0x5a,0x5a,
+	0x46,0x3a,0x48,0x53,0x6c,0x5d,0x51,0x38,
+	0x34,0x3f,0x40,0x43,0x3a,0x45,0x56,0x6a,
+	0x72,0x68,0x58,0x55,0x64,0x7d,0x8c,0x94,
+	0x95,0xa1,0xb5,0xbe,0xbf,0xaa,0xa4,0xac,
+	0xc0,0xd6,0xd2,0xcf,0xbd,0xc0,0xc2,0xb6,
+	0xac,0x8a,0x8f,0x8c,0xa0,0x9d,0x86,0x73,
+	0x55,0x62,0x52,0x56,0x40,0x36,0x46,0x49,
+	0x69,0x50,0x4a,0x32,0x39,0x50,0x56,0x6b,
+	0x5a,0x74,0x7b,0x97,0x9f,0x8c,0x8d,0x7c,
+	0xa6,0xac,0xc9,0xbf,0xb9,0xc3,0xbf,0xd7,
+	0xb6,0xb5,0xa0,0xaa,0xc6,0xc4,0xce,0xa7,
+	0xab,0x9a,0xa5,0xa3,0x8b,0x8c,0x77,0x9e,
+	0x9b,0xa6,0x8f,0x75,0x7a,0x71,0x94,0x7e,
+	0x8a,0x81,0x8f,0xad,0xa7,0xb3,0x8a,0x91,
+	0x81,0x87,0x81,0x7c,0x7d,0x4e,0x5c,0x5e,
+	0x63,0x4c,0x29,0x3e,0x42,0x70,0x64,0x6b,
+	0x5b,0x5d,0x6f,0x60,0x6b,0x49,0x57,0x58,
+	0x6e,0x7a,0x60,0x5e,0x3c,0x54,0x4b,0x55,
+	0x49,0x3d,0x52,0x51,0x71,0x5b,0x56,0x41,
+	0x44,0x60,0x63,0x7c,0x66,0x7a,0x81,0x97,
+	0xa3,0x8f,0x94,0x83,0xab,0xb7,0xcd,0xcb,
+	0xba,0xc9,0xc1,0xda,0xc1,0xb8,0xa9,0xac,
+	0xc5,0xc1,0xc3,0x9b,0x91,0x82,0x84,0x83,
+	0x67,0x62,0x4d,0x66,0x63,0x65,0x4f,0x32,
+	0x33,0x31,0x4b,0x43,0x45,0x44,0x4c,0x67,
+	0x69,0x6f,0x59,0x5e,0x69,0x84,0x9c,0x9a,
+	0xa0,0x9c,0xaf,0xb8,0xbd,0xb0,0xa4,0xb0,
+	0xbb,0xd5,0xd0,0xc8,0xb9,0xb4,0xbc,0xb8,
+	0xb4,0x9f,0x9f,0xa5,0xb2,0xb9,0xa2,0x96,
+	0x84,0x8c,0x90,0x95,0x8c,0x84,0x8c,0x95,
+	0xa4,0x9e,0x8f,0x86,0x89,0x9f,0xa6,0xa7,
+	0x8f,0x83,0x6f,0x8a,0x8b,0x6a,0x47,0x27,
+	0x54,0x59,0x6a,0x4e,0x3f,0x41,0x4b,0x56,
+	0x55,0x4f,0x49,0x54,0x66,0x6e,0x6b,0x57,
+	0x4f,0x51,0x58,0x5c,0x4f,0x48,0x46,0x52,
+	0x5d,0x5b,0x4e,0x3f,0x42,0x4e,0x5d,0x60,
+	0x5b,0x5b,0x67,0x76,0x81,0x7c,0x75,0x77,
+	0x88,0x9f,0xaf,0xad,0xab,0xad,0xbb,0xc8,
+	0xc9,0xbe,0xb8,0xbd,0xce,0xd6,0xd2,0xbe,
+	0xb1,0xae,0xb0,0xae,0x9d,0x8d,0x7e,0x84,
+	0x85,0x7f,0x6a,0x52,0x4a,0x48,0x52,0x4d,
+	0x42,0x36,0x39,0x48,0x4d,0x4b,0x3e,0x3c,
+	0x47,0x5b,0x70,0x6d,0x70,0x6f,0x85,0x94,
+	0x9f,0x9d,0x93,0xa2,0xb0,0xca,0xc8,0xc5,
+	0xba,0xbe,0xce,0xcd,0xd0,0xbd,0xba,0xbe,
+	0xc8,0xcd,0xbc,0xb2,0x9f,0xae,0xae,0xb0,
+	0xa3,0x94,0x98,0x9a,0xaa,0x9f,0x99,0x91,
+	0x98,0xa8,0xac,0xad,0x9b,0x97,0x94,0x94,
+	0x85,0x6b,0x71,0x80,0x77,0x84,0x5c,0x36,
+	0x28,0x4e,0x4a,0x62,0x57,0x3b,0x32,0x35,
+	0x45,0x4a,0x49,0x3e,0x41,0x48,0x57,0x5a,
+	0x4f,0x46,0x42,0x50,0x56,0x56,0x4b,0x43,
+	0x48,0x55,0x5d,0x56,0x4a,0x46,0x53,0x62,
+	0x6c,0x69,0x64,0x67,0x78,0x88,0x8e,0x88,
+	0x84,0x8f,0xa5,0xb8,0xbc,0xb6,0xb0,0xbb,
+	0xca,0xd1,0xcd,0xbd,0xbe,0xc8,0xd5,0xd5,
+	0xc3,0xaf,0xa1,0xa9,0xa8,0xa1,0x8b,0x7b,
+	0x79,0x7c,0x7f,0x67,0x54,0x3e,0x41,0x4d,
+	0x4e,0x48,0x39,0x39,0x42,0x52,0x4f,0x45,
+	0x3b,0x41,0x5e,0x70,0x7c,0x72,0x73,0x7f,
+	0x91,0xa1,0x98,0x98,0x95,0xb1,0xc6,0xd0,
+	0xcb,0xb7,0xba,0xbe,0xd2,0xca,0xc3,0xba,
+	0xbe,0xd6,0xd3,0xd2,0xb0,0xaa,0xa7,0xb6,
+	0xbf,0xb1,0xad,0xa4,0xb6,0xb9,0xba,0xa6,
+	0x91,0x99,0x9e,0xb5,0xa5,0x98,0x75,0x6a,
+	0x70,0x8c,0x91,0x65,0x82,0x64,0x68,0x50,
+	0x34,0x24,0x3b,0x52,0x48,0x65,0x38,0x2e,
+	0x32,0x3f,0x57,0x41,0x3f,0x27,0x37,0x43,
+	0x48,0x4d,0x38,0x4b,0x49,0x68,0x56,0x48,
+	0x3a,0x34,0x55,0x53,0x6b,0x52,0x5d,0x60,
+	0x6f,0x7c,0x62,0x6a,0x59,0x82,0x8d,0xa5,
+	0x9e,0x92,0xa2,0x9e,0xc0,0xa9,0xb0,0xa4,
+	0xb6,0xd3,0xd1,0xdc,0xb2,0xbb,0xac,0xc0,
+	0xb8,0xa9,0xa5,0x94,0xb6,0xa3,0xab,0x80,
+	0x6e,0x69,0x65,0x7b,0x5f,0x66,0x4a,0x60,
+	0x61,0x59,0x51,0x2c,0x3e,0x3a,0x60,0x5b,
+	0x5e,0x56,0x56,0x73,0x68,0x7a,0x5a,0x6d,
+	0x76,0x96,0xac,0x9f,0xa6,0x8e,0xab,0xa9,
+	0xb4,0xab,0xa0,0xb7,0xbc,0xdb,0xc7,0xc1,
+	0xa9,0xab,0xb9,0xb5,0xbf,0xa5,0xb6,0xb4,
+	0xc7,0xc0,0xaa,0x9f,0x8d,0xa9,0xa8,0xb7,
+	0xa4,0xa2,0xa3,0xa1,0xa0,0x7d,0x67,0x51,
+	0x6a,0x9b,0x93,0x94,0x90,0x79,0x66,0x5e,
+	0x45,0x2c,0x25,0x41,0x6b,0x5b,0x74,0x64,
+	0x4e,0x41,0x44,0x44,0x39,0x39,0x39,0x4d,
+	0x57,0x58,0x4b,0x3c,0x3c,0x43,0x51,0x54,
+	0x51,0x52,0x5d,0x67,0x6a,0x5e,0x54,0x4e,
+	0x61,0x70,0x7e,0x80,0x7d,0x88,0x8e,0x9b,
+	0x90,0x8e,0x8a,0x9b,0xb4,0xbf,0xc9,0xb8,
+	0xc2,0xb7,0xc8,0xbd,0xb7,0xb7,0xb2,0xcf,
+	0xc5,0xd0,0xaf,0xa8,0x99,0x92,0x98,0x80,
+	0x89,0x72,0x88,0x7d,0x7b,0x65,0x49,0x4e,
+	0x39,0x54,0x3f,0x51,0x48,0x4e,0x59,0x4c,
+	0x56,0x35,0x4d,0x43,0x63,0x6b,0x73,0x83,
+	0x76,0x93,0x7d,0x95,0x7f,0x90,0x9d,0xa6,
+	0xc4,0xb6,0xcd,0xb4,0xc4,0xb5,0xb9,0xbc,
+	0xb2,0xcb,0xc0,0xdc,0xc7,0xce,0xc1,0xb5,
+	0xb9,0xaa,0xbd,0xb1,0xc7,0xbd,0xc3,0xbc,
+	0xac,0xaa,0x92,0x93,0x7d,0x7e,0x71,0x72,
+	0x81,0x9a,0x9a,0x6e,0x8f,0x86,0x76,0x5e,
+	0x4c,0x40,0x34,0x37,0x45,0x5a,0x37,0x3f,
+	0x62,0x58,0x51,0x46,0x48,0x44,0x42,0x36,
+	0x2e,0x2a,0x31,0x3c,0x48,0x48,0x4f,0x4b,
+	0x52,0x52,0x4c,0x49,0x41,0x53,0x5e,0x70,
+	0x73,0x71,0x72,0x70,0x7f,0x77,0x81,0x78,
+	0x8d,0x9b,0xac,0xb8,0xa9,0xae,0xa0,0xb6,
+	0xb2,0xb8,0xb8,0xb6,0xcd,0xc9,0xda,0xbd,
+	0xb6,0xa4,0xa7,0xb2,0xa4,0xae,0x92,0xa3,
+	0x94,0x9b,0x84,0x68,0x65,0x51,0x70,0x60,
+	0x6b,0x54,0x51,0x58,0x4e,0x56,0x34,0x40,
+	0x35,0x54,0x5f,0x61,0x66,0x4f,0x68,0x5d,
+	0x77,0x65,0x6c,0x74,0x82,0xa7,0x9b,0xac,
+	0x8d,0x9b,0x9d,0xa9,0xb4,0xa1,0xb7,0xad,
+	0xd2,0xc8,0xc9,0xb4,0xa4,0xb7,0xb4,0xcd,
+	0xb4,0xc0,0xb6,0xc2,0xcb,0xb8,0xb2,0x92,
+	0xa5,0xa2,0xb7,0xa9,0x96,0x8f,0x76,0x82,
+	0x67,0x73,0x77,0x8b,0x7a,0x8d,0xb1,0x8a,
+	0x76,0x4b,0x4a,0x33,0x2b,0x38,0x4a,0x57,
+	0x49,0x7c,0x70,0x5b,0x42,0x3c,0x45,0x3a,
+	0x3c,0x2b,0x3c,0x47,0x55,0x50,0x38,0x34,
+	0x31,0x4b,0x52,0x57,0x50,0x55,0x64,0x6e,
+	0x73,0x61,0x5a,0x5a,0x74,0x8a,0x90,0x90,
+	0x87,0x94,0xa1,0xa9,0xa0,0x96,0x99,0xab,
+	0xc7,0xd1,0xca,0xbd,0xb7,0xbe,0xc7,0xc3,
+	0xb4,0xab,0xb4,0xc4,0xcd,0xbf,0xa4,0x8f,
+	0x89,0x92,0x8e,0x82,0x71,0x6d,0x76,0x7b,
+	0x75,0x53,0x41,0x35,0x43,0x4f,0x4e,0x45,
+	0x3b,0x49,0x51,0x5b,0x49,0x3b,0x39,0x4a,
+	0x6a,0x72,0x79,0x6a,0x74,0x82,0x8d,0x91,
+	0x7e,0x84,0x8b,0xb0,0xbc,0xc1,0xb5,0xa7,
+	0xb4,0xb7,0xc6,0xb3,0xb2,0xb4,0xc6,0xdb,
+	0xd2,0xca,0xac,0xb4,0xb5,0xbf,0xc1,0xae,
+	0xb6,0xaf,0xcc,0xb9,0xb2,0x8c,0x7a,0x61,
+	0x5d,0x9a,0x8d,0x94,0x81,0x8a,0x8b,0x75,
+	0x69,0x4a,0x5e,0x60,0x77,0x6e,0x5d,0x5a,
+	0x51,0x67,0x4e,0x51,0x35,0x3e,0x4f,0x58,
+	0x67,0x45,0x48,0x32,0x48,0x44,0x3f,0x39,
+	0x2b,0x4a,0x49,0x62,0x45,0x3c,0x31,0x30,
+	0x4c,0x3d,0x4e,0x33,0x4d,0x53,0x5f,0x5f,
+	0x3d,0x46,0x33,0x5d,0x5a,0x65,0x5d,0x57,
+	0x6f,0x67,0x7c,0x58,0x5d,0x55,0x6c,0x86,
+	0x80,0x8c,0x6f,0x88,0x80,0x90,0x86,0x77,
+	0x84,0x81,0xad,0xa2,0xaf,0x96,0x95,0xa1,
+	0x9b,0xad,0x8f,0x9e,0x91,0xae,0xb7,0xa9,
+	0xa7,0x7f,0x93,0x83,0x96,0x83,0x78,0x7b,
+	0x72,0x8b,0x74,0x73,0x4f,0x4f,0x55,0x57,
+	0x64,0x4b,0x54,0x45,0x5b,0x5c,0x4d,0x4c,
+	0x32,0x4d,0x4a,0x69,0x66,0x6b,0x74,0x79,
+	0x90,0x84,0x7f,0x6c,0x6e,0x79,0x85,0xa0,
+	0x9a,0xb5,0xb1,0xcc,0xc3,0xbd,0xa8,0x94,
+	0xa0,0x9c,0xb4,0xb1,0xbe,0xc5,0xcc,0xdb,
+	0xc3,0xc2,0xa0,0xa4,0xa3,0xab,0xb6,0xb0,
+	0xc0,0xbc,0xcf,0xc0,0xb0,0x96,0x79,0x77,
+	0x68,0x7a,0x6a,0x79,0x7a,0x87,0x92,0x80,
+	0x7f,0x5c,0x5e,0x58,0x67,0x74,0x81,0xa2,
+	0xaa,0xcd,0xc3,0xc2,0xaf,0xa1,0xa7,0xa0,
+	0xb2,0xa6,0xb0,0xb0,0xbc,0xc4,0xaf,0xa3,
+	0x79,0x79,0x69,0x6e,0x68,0x5e,0x65,0x5c,
+	0x71,0x64,0x5a,0x43,0x2d,0x37,0x30,0x49,
+	0x4a,0x5b,0x6c,0x86,0xa3,0x9c,0xa1,0x8a,
+	0x94,0x95,0xa5,0xad,0xaa,0xbb,0xbb,0xd6,
+	0xce,0xc3,0xa5,0x71,0x72,0x7a,0x87,0x6f,
+	0x6d,0x7c,0x88,0x93,0x6b,0x67,0x52,0x46,
+	0x31,0x3d,0x44,0x3b,0x49,0x48,0x64,0x5c,
+	0x5d,0x4a,0x3e,0x4b,0x4b,0x68,0x60,0x77,
+	0x85,0x9f,0xba,0xb3,0xb6,0x93,0x9a,0x8b,
+	0x8f,0x86,0x71,0x78,0x6c,0x86,0x78,0x72,
+	0x58,0x4a,0x55,0x55,0x75,0x6b,0x84,0x93,
+	0xb1,0xd1,0xc9,0xc9,0xa5,0xa8,0x98,0x9b,
+	0x8f,0x76,0x78,0x6d,0x86,0x78,0x7d,0x68,
+	0x5f,0x77,0x7e,0x69,0x4f,0x5d,0x6f,0xa2,
+	0xc7,0xd0,0xa5,0x75,0x74,0x6f,0x7e,0x74,
+	0x5e,0x5c,0x55,0x6b,0x62,0x57,0x42,0x2f,
+	0x3b,0x41,0x59,0x55,0x68,0x79,0x9c,0xc0,
+	0xc3,0xc3,0xab,0xae,0xa8,0xa7,0x96,0x7b,
+	0x72,0x66,0x75,0x6b,0x61,0x49,0x3f,0x4c,
+	0x58,0x6f,0x70,0x7e,0x92,0xb1,0xd0,0xd2,
+	0xcd,0xb8,0xb5,0xb2,0xb0,0xa1,0x86,0x7b,
+	0x77,0x82,0x7f,0x73,0x5f,0x59,0x6b,0x84,
+	0x89,0x59,0x5c,0x65,0x98,0xc0,0xcb,0x94,
+	0x80,0x77,0x84,0x8d,0x80,0x68,0x59,0x57,
+	0x5f,0x5b,0x4c,0x36,0x2c,0x33,0x44,0x51,
+	0x58,0x61,0x76,0x99,0xb7,0xcb,0xc3,0xbe,
+	0xb9,0xbf,0xbc,0xa5,0x8b,0x6a,0x68,0x5f,
+	0x60,0x4c,0x3a,0x36,0x3b,0x5b,0x64,0x78,
+	0x7a,0x8f,0xb3,0xc6,0xe0,0xcc,0xcd,0xbb,
+	0xc6,0xc3,0xae,0xa0,0x7d,0x84,0x7c,0x85,
+	0x77,0x65,0x6a,0x6a,0x98,0x90,0x6f,0x65,
+	0x6c,0x95,0xb4,0xaf,0x7a,0x80,0x69,0x7d,
+	0x86,0x72,0x6e,0x4a,0x51,0x48,0x4c,0x46,
+	0x28,0x31,0x24,0x4c,0x4c,0x62,0x68,0x73,
+	0x9d,0xab,0xd1,0xc2,0xcb,0xc1,0xbe,0xc6,
+	0xa4,0x9c,0x6a,0x67,0x55,0x50,0x4b,0x2e,
+	0x3a,0x32,0x5c,0x64,0x79,0x89,0x8e,0xb7,
+	0xbe,0xdd,0xd1,0xcf,0xc9,0xc5,0xce,0xb4,
+	0xb0,0x8c,0x8b,0x84,0x81,0x82,0x6f,0x7a,
+	0x7a,0x9c,0x99,0x71,0x7d,0x79,0x92,0x9d,
+	0x7f,0x7a,0x6e,0x67,0x6d,0x76,0x6a,0x63,
+	0x4e,0x47,0x42,0x3b,0x3c,0x2e,0x30,0x32,
+	0x45,0x55,0x64,0x72,0x81,0x9a,0xac,0xc2,
+	0xc8,0xc7,0xc7,0xc2,0xbc,0xab,0x95,0x7b,
+	0x65,0x55,0x49,0x40,0x39,0x37,0x40,0x51,
+	0x61,0x76,0x83,0x9a,0xa4,0xb9,0xc2,0xc8,
+	0xcd,0xc7,0xca,0xbe,0xbb,0xaa,0xa1,0x96,
+	0x86,0x8a,0x7d,0x88,0x84,0x95,0x9e,0x8c,
+	0x79,0x84,0x8f,0x88,0x7d,0x63,0x70,0x68,
+	0x5f,0x6e,0x5f,0x62,0x57,0x4a,0x4b,0x37,
+	0x3f,0x2e,0x3d,0x3d,0x48,0x58,0x55,0x74,
+	0x79,0x9b,0xa3,0xb0,0xbc,0xba,0xcf,0xbf,
+	0xc6,0xaa,0x9c,0x8d,0x74,0x73,0x4f,0x4c,
+	0x35,0x3d,0x44,0x49,0x5d,0x58,0x78,0x81,
+	0xa0,0xaf,0xb4,0xc2,0xbd,0xd1,0xcd,0xd1,
+	0xc1,0xb0,0xae,0xa3,0xa8,0x96,0x91,0x86,
+	0x8b,0x9e,0xa5,0xa5,0x73,0x7a,0x8c,0x89,
+	0x8a,0x5c,0x5d,0x60,0x52,0x5e,0x5f,0x58,
+	0x4a,0x46,0x47,0x49,0x44,0x37,0x2f,0x34,
+	0x42,0x53,0x59,0x62,0x6a,0x81,0x9f,0xaf,
+	0xbd,0xb7,0xbf,0xc0,0xc9,0xc5,0xa9,0x97,
+	0x78,0x78,0x66,0x5c,0x47,0x33,0x3c,0x3d,
+	0x59,0x5a,0x67,0x6c,0x80,0xa3,0xae,0xc6,
+	0xb7,0xc3,0xc5,0xcf,0xd8,0xc1,0xbc,0xa2,
+	0xad,0xaa,0xa8,0xa3,0x8b,0x9f,0x9d,0xb6,
+	0x92,0x76,0x89,0x7e,0x87,0x65,0x5d,0x59,
+	0x50,0x43,0x49,0x5b,0x47,0x48,0x30,0x3e,
+	0x41,0x3f,0x41,0x2b,0x3c,0x3d,0x5d,0x65,
+	0x6d,0x79,0x80,0xaa,0xb4,0xcb,0xbf,0xbd,
+	0xc1,0xbb,0xc2,0xa0,0x91,0x6f,0x69,0x64,
+	0x59,0x50,0x34,0x3e,0x40,0x5a,0x66,0x6a,
+	0x7a,0x80,0xa9,0xb7,0xcb,0xc7,0xc1,0xc9,
+	0xc9,0xd4,0xc0,0xb6,0xa3,0xa5,0xac,0xab,
+	0xac,0x9b,0xa1,0xa4,0x9b,0x79,0x86,0x83,
+	0x72,0x78,0x55,0x5a,0x61,0x41,0x34,0x38,
+	0x41,0x3c,0x34,0x2c,0x30,0x3a,0x42,0x40,
+	0x3c,0x3b,0x4c,0x5e,0x70,0x7c,0x84,0x96,
+	0xae,0xc8,0xd1,0xce,0xc6,0xba,0xba,0xac,
+	0x9e,0x81,0x6b,0x61,0x5a,0x5d,0x49,0x47,
+	0x3b,0x47,0x58,0x63,0x77,0x77,0x94,0xa5,
+	0xc0,0xcd,0xcb,0xcd,0xc1,0xce,0xc0,0xc6,
+	0xb4,0xad,0xb3,0xad,0xc0,0xb3,0xb8,0xa7,
+	0x8d,0x73,0x81,0x91,0x6f,0x79,0x66,0x50,
+	0x67,0x5d,0x4c,0x2d,0x40,0x33,0x3b,0x35,
+	0x31,0x3e,0x38,0x50,0x44,0x4f,0x4a,0x54,
+	0x67,0x6c,0x89,0x88,0xa7,0xae,0xc4,0xcd,
+	0xc1,0xc2,0xa5,0xab,0x90,0x8b,0x77,0x67,
+	0x68,0x57,0x65,0x4f,0x55,0x4a,0x4e,0x5f,
+	0x61,0x7e,0x7f,0x9f,0xa9,0xc1,0xcd,0xc5,
+	0xcd,0xb9,0xc6,0xb7,0xbd,0xba,0xb6,0xc4,
+	0xbb,0xd1,0xba,0xb3,0x7f,0x6e,0x89,0x78,
+	0x7a,0x66,0x78,0x51,0x54,0x67,0x54,0x40,
+	0x1f,0x2e,0x21,0x2f,0x2f,0x33,0x46,0x45,
+	0x5c,0x51,0x5e,0x5c,0x62,0x75,0x78,0x97,
+	0x99,0xb5,0xbb,0xc7,0xc6,0xb6,0xb2,0x94,
+	0x93,0x7a,0x7a,0x71,0x6b,0x72,0x62,0x6a,
+	0x59,0x5d,0x54,0x57,0x63,0x67,0x82,0x8b,
+	0xa8,0xb0,0xbe,0xc3,0xbc,0xc0,0xb0,0xb9,
+	0xad,0xb8,0xbc,0xc2,0xcc,0xc4,0xc1,0x97,
+	0x7c,0x87,0x83,0x83,0x66,0x70,0x68,0x62,
+	0x48,0x60,0x5e,0x53,0x3a,0x26,0x2b,0x28,
+	0x33,0x40,0x4d,0x5a,0x5e,0x67,0x64,0x6c,
+	0x6d,0x72,0x7c,0x85,0x9a,0xa4,0xb7,0xb8,
+	0xb7,0xb0,0xa2,0x9a,0x88,0x80,0x74,0x75,
+	0x77,0x78,0x7a,0x70,0x70,0x63,0x61,0x5d,
+	0x5f,0x68,0x71,0x88,0x97,0xad,0xb3,0xba,
+	0xb8,0xb2,0xb5,0xa9,0xb0,0xae,0xbc,0xc3,
+	0xcf,0xcb,0xb8,0x95,0x7f,0x8d,0x7f,0x74,
+	0x61,0x6a,0x72,0x75,0x62,0x55,0x64,0x59,
+	0x4c,0x2f,0x27,0x2b,0x30,0x44,0x52,0x62,
+	0x6e,0x6d,0x73,0x6a,0x72,0x6d,0x78,0x7d,
+	0x8a,0x9c,0xa4,0xb2,0xa7,0xa6,0x96,0x8c,
+	0x83,0x77,0x76,0x73,0x7e,0x80,0x8a,0x85,
+	0x7e,0x79,0x69,0x6a,0x62,0x6b,0x6f,0x7f,
+	0x92,0x9d,0xaf,0xa9,0xae,0xa4,0xa2,0x9f,
+	0x9d,0xa6,0xa8,0xbb,0xbf,0xc1,0xac,0x8b,
+	0x8e,0x83,0x81,0x64,0x67,0x68,0x75,0x7f,
+	0x7e,0x6a,0x5f,0x6a,0x56,0x4c,0x35,0x36,
+	0x3e,0x47,0x5e,0x69,0x78,0x7b,0x79,0x77,
+	0x6f,0x75,0x70,0x7c,0x7e,0x8f,0x99,0xa1,
+	0xa3,0x96,0x91,0x81,0x7b,0x75,0x73,0x7a,
+	0x7a,0x8a,0x8b,0x93,0x8a,0x84,0x77,0x6f,
+	0x6f,0x69,0x75,0x79,0x8a,0x95,0x9e,0xa6,
+	0x9a,0x9f,0x8f,0x97,0x91,0x99,0x9f,0xa6,
+	0xb2,0xad,0xa2,0x8c,0x93,0x84,0x7b,0x6b,
+	0x64,0x71,0x71,0x86,0x82,0x81,0x69,0x6a,
+	0x6b,0x59,0x54,0x41,0x51,0x51,0x64,0x72,
+	0x76,0x84,0x7a,0x83,0x72,0x77,0x74,0x73,
+	0x83,0x7f,0x95,0x8d,0x9a,0x8f,0x8b,0x86,
+	0x75,0x7a,0x6c,0x7e,0x79,0x8b,0x8c,0x8d,
+	0x92,0x85,0x8a,0x73,0x76,0x6d,0x71,0x7c,
+	0x7f,0x94,0x8b,0x9d,0x92,0x99,0x90,0x8a,
+	0x8d,0x85,0x9b,0x97,0xa9,0x9e,0x98,0x90,
+	0x8d,0x92,0x79,0x74,0x63,0x71,0x77,0x7e,
+	0x8a,0x7d,0x81,0x66,0x79,0x67,0x65,0x56,
+	0x50,0x65,0x63,0x7b,0x73,0x81,0x80,0x80,
+	0x85,0x72,0x7d,0x6b,0x81,0x7d,0x8a,0x8d,
+	0x86,0x90,0x81,0x8c,0x79,0x7a,0x71,0x74,
+	0x82,0x80,0x94,0x85,0x91,0x88,0x8a,0x85,
+	0x76,0x79,0x6a,0x81,0x7a,0x8e,0x88,0x8b,
+	0x92,0x88,0x98,0x84,0x8a,0x7f,0x8b,0x95,
+	0x97,0x9f,0x88,0x8e,0x89,0x92,0x84,0x74,
+	0x70,0x67,0x7e,0x7a,0x8c,0x7f,0x81,0x74,
+	0x72,0x7c,0x69,0x6b,0x55,0x68,0x6d,0x79,
+	0x7c,0x78,0x82,0x7d,0x8b,0x7c,0x7b,0x72,
+	0x74,0x83,0x84,0x8d,0x80,0x86,0x82,0x89,
+	0x86,0x78,0x75,0x6e,0x7f,0x84,0x8c,0x87,
+	0x86,0x88,0x89,0x8e,0x81,0x78,0x6f,0x76,
+	0x80,0x88,0x88,0x83,0x87,0x8a,0x91,0x8e,
+	0x85,0x7c,0x7f,0x8c,0x96,0x96,0x8e,0x82,
+	0x88,0x90,0x8e,0x80,0x6e,0x6e,0x73,0x81,
+	0x85,0x84,0x7d,0x7b,0x7b,0x7c,0x7d,0x6c,
+	0x65,0x63,0x70,0x7c,0x7a,0x7b,0x76,0x84,
+	0x87,0x87,0x81,0x6e,0x76,0x77,0x8b,0x84,
+	0x85,0x7d,0x80,0x8c,0x85,0x88,0x71,0x72,
+	0x74,0x84,0x8b,0x84,0x87,0x7d,0x8f,0x89,
+	0x8f,0x79,0x71,0x75,0x79,0x8c,0x81,0x87,
+	0x7b,0x88,0x8f,0x8e,0x8c,0x75,0x80,0x7c,
+	0x96,0x90,0x8d,0x84,0x7d,0x91,0x8b,0x90,
+	0x71,0x70,0x71,0x7a,0x8a,0x7e,0x84,0x74,
+	0x85,0x7e,0x83,0x77,0x67,0x6d,0x69,0x82,
+	0x77,0x7e,0x74,0x7d,0x8b,0x86,0x8b,0x6e,
+	0x78,0x72,0x86,0x87,0x81,0x80,0x76,0x8f,
+	0x86,0x8d,0x76,0x74,0x74,0x7c,0x8a,0x81,
+	0x86,0x79,0x8a,0x8e,0x8d,0x84,0x71,0x78,
+	0x75,0x87,0x82,0x82,0x7c,0x81,0x8e,0x8e,
+	0x8d,0x7b,0x7a,0x7d,0x87,0x8f,0x87,0x87,
+	0x7f,0x8b,0x8e,0x8f,0x7f,0x72,0x73,0x79,
+	0x83,0x7e,0x7e,0x7b,0x82,0x88,0x85,0x7c,
+	0x72,0x6f,0x71,0x77,0x7b,0x78,0x77,0x7e,
+	0x85,0x8d,0x83,0x7f,0x73,0x79,0x7d,0x82,
+	0x80,0x7c,0x82,0x84,0x8f,0x88,0x80,0x78,
+	0x74,0x7f,0x7c,0x85,0x79,0x83,0x84,0x8c,
+	0x8f,0x82,0x81,0x72,0x7e,0x7a,0x81,0x7d,
+	0x7c,0x86,0x85,0x93,0x85,0x89,0x78,0x7f,
+	0x81,0x7f,0x89,0x7c,0x8c,0x82,0x90,0x88,
+	0x86,0x80,0x73,0x7f,0x72,0x82,0x76,0x82,
+	0x81,0x87,0x89,0x7a,0x82,0x70,0x7d,0x6e,
+	0x77,0x76,0x76,0x84,0x7f,0x8d,0x7f,0x88,
+	0x7c,0x7b,0x7c,0x77,0x80,0x78,0x87,0x81,
+	0x8a,0x87,0x85,0x84,0x78,0x7f,0x73,0x7e,
+	0x79,0x82,0x85,0x85,0x8c,0x83,0x89,0x7c,
+	0x7f,0x76,0x78,0x7b,0x7c,0x86,0x82,0x8b,
+	0x86,0x89,0x86,0x80,0x7f,0x79,0x7f,0x7d,
+	0x88,0x86,0x89,0x88,0x88,0x88,0x81,0x7d,
+	0x74,0x75,0x78,0x7e,0x83,0x82,0x86,0x82,
+	0x84,0x81,0x7d,0x75,0x6f,0x71,0x77,0x7f,
+	0x80,0x83,0x85,0x87,0x87,0x82,0x7b,0x77,
+	0x75,0x79,0x80,0x83,0x84,0x86,0x8a,0x89,
+	0x88,0x7e,0x78,0x74,0x76,0x7e,0x80,0x85,
+	0x82,0x87,0x8a,0x8a,0x84,0x79,0x76,0x71,
+	0x7c,0x7d,0x83,0x83,0x84,0x8d,0x8b,0x8f,
+	0x7e,0x7a,0x74,0x7a,0x81,0x83,0x87,0x81,
+	0x8c,0x89,0x90,0x83,0x7a,0x73,0x70,0x7d,
+	0x7a,0x85,0x7d,0x84,0x89,0x89,0x8a,0x77,
+	0x76,0x6b,0x77,0x78,0x7c,0x7f,0x7c,0x8b,
+	0x88,0x93,0x7f,0x7a,0x72,0x73,0x80,0x7a,
+	0x85,0x79,0x8a,0x8a,0x92,0x8c,0x7a,0x78,
+	0x6d,0x80,0x78,0x81,0x7b,0x80,0x8e,0x8b,
+	0x92,0x7d,0x7e,0x6d,0x78,0x7c,0x7a,0x82,
+	0x77,0x8d,0x8a,0x97,0x8a,0x7e,0x7a,0x71,
+	0x81,0x7a,0x85,0x79,0x84,0x8c,0x8f,0x95,
+	0x7e,0x7e,0x6d,0x7b,0x7a,0x7a,0x7d,0x76,
+	0x8b,0x86,0x96,0x85,0x7d,0x73,0x6f,0x7d,
+	0x73,0x7d,0x72,0x81,0x89,0x90,0x93,0x7e,
+	0x7e,0x6e,0x7c,0x78,0x7a,0x7a,0x76,0x8c,
+	0x8a,0x9b,0x85,0x82,0x74,0x77,0x7e,0x76,
+	0x7f,0x71,0x85,0x88,0x95,0x92,0x7f,0x7f,
+	0x70,0x7f,0x77,0x7c,0x75,0x77,0x8a,0x8b,
+	0x9a,0x84,0x82,0x76,0x78,0x7e,0x76,0x7b,
+	0x70,0x86,0x87,0x96,0x8e,0x81,0x7e,0x73,
+	0x81,0x75,0x7c,0x72,0x79,0x87,0x8e,0x98,
+	0x84,0x83,0x76,0x7d,0x7c,0x78,0x78,0x6f,
+	0x84,0x85,0x98,0x8b,0x85,0x7d,0x76,0x82,
+	0x76,0x7b,0x6e,0x7a,0x86,0x8e,0x96,0x84,
+	0x84,0x75,0x81,0x7d,0x77,0x75,0x6f,0x82,
+	0x88,0x97,0x89,0x86,0x7c,0x7b,0x83,0x77,
+	0x7b,0x6c,0x7a,0x83,0x91,0x93,0x83,0x84,
+	0x77,0x86,0x7b,0x7a,0x71,0x70,0x82,0x86,
+	0x96,0x88,0x85,0x7c,0x7e,0x84,0x79,0x79,
+	0x6b,0x7c,0x81,0x90,0x90,0x83,0x84,0x79,
+	0x83,0x78,0x73,0x68,0x65,0x73,0x77,0x83,
+	0x74,0x72,0x64,0x68,0x67,0x5a,0x5a,0x45,
+	0x53,0x4f,0x5e,0x56,0x4f,0x44,0x41,0x45,
+	0x3b,0x3d,0x31,0x3e,0x47,0x57,0x5c,0x5a,
+	0x4d,0x44,0x3d,0x3e,0x2c,0x31,0x24,0x46,
+	0x4d,0x70,0x72,0x74,0x77,0x69,0x72,0x58,
+	0x57,0x3a,0x4a,0x4e,0x6d,0x7b,0x8b,0x93,
+	0x9c,0xa5,0xa4,0x97,0x81,0x75,0x68,0x7d,
+	0x7a,0x9b,0x8d,0xb4,0xac,0xd1,0xc0,0xbc,
+	0xa6,0x8a,0x95,0x74,0x96,0x6c,0x9c,0x87,
+	0xbc,0xb2,0xbe,0xae,0x98,0x9b,0x7a,0x83,
+	0x52,0x66,0x4a,0x74,0x77,0x92,0x82,0x88,
+	0x7c,0x79,0x73,0x5a,0x47,0x29,0x3c,0x33,
+	0x60,0x50,0x75,0x5e,0x81,0x6f,0x76,0x64,
+	0x4d,0x54,0x35,0x5b,0x40,0x69,0x59,0x88,
+	0x81,0x93,0x8b,0x75,0x76,0x61,0x69,0x50,
+	0x5c,0x48,0x5f,0x67,0x82,0x87,0x99,0x9d,
+	0xaa,0xa9,0x9c,0x76,0x5a,0x6f,0x8a,0xb6,
+	0xba,0xdb,0xc7,0xc2,0x90,0x7f,0x7d,0x80,
+	0x88,0x76,0x83,0x6c,0x77,0x6a,0x77,0x72,
+	0x78,0x79,0x6c,0x67,0x50,0x4f,0x49,0x50,
+	0x56,0x5d,0x65,0x70,0x7b,0x83,0x7b,0x7a,
+	0x67,0x6a,0x61,0x65,0x66,0x69,0x7d,0x83,
+	0xa3,0xa3,0xaf,0xa8,0xac,0xa8,0xa6,0xa6,
+	0x9f,0xa8,0xab,0xc1,0xcb,0xd7,0xda,0xd9,
+	0xd5,0xcf,0xc4,0xb4,0xa5,0x9c,0x95,0x9c,
+	0x99,0x9d,0x99,0x96,0x94,0x87,0x7e,0x65,
+	0x59,0x49,0x47,0x48,0x4a,0x53,0x5a,0x6a,
+	0x71,0x7b,0x79,0x75,0x70,0x6e,0x75,0x76,
+	0x82,0x8c,0x9f,0xb1,0xc5,0xcf,0xd2,0xd0,
+	0xc9,0xc4,0xba,0xb3,0xad,0xaa,0xb3,0xb8,
+	0xc3,0xc4,0xc3,0xb8,0xaf,0x9f,0x8f,0x79,
+	0x6a,0x5f,0x60,0x60,0x6c,0x6e,0x74,0x74,
+	0x75,0x6c,0x5e,0x51,0x3f,0x3f,0x3c,0x48,
+	0x53,0x6a,0x7d,0x96,0xab,0xb3,0xa9,0x72,
+	0x75,0x69,0x7a,0x8a,0xab,0xb4,0xcb,0xaa,
+	0xb1,0xbc,0xaf,0xc2,0xab,0xac,0x92,0x91,
+	0x7f,0x8a,0x87,0x91,0x8d,0x94,0x8b,0x89,
+	0x72,0x66,0x50,0x3f,0x36,0x2c,0x35,0x33,
+	0x49,0x44,0x5c,0x52,0x5d,0x50,0x49,0x45,
+	0x39,0x45,0x42,0x5b,0x63,0x84,0x91,0xa5,
+	0xaf,0xb5,0xb5,0xb3,0xad,0xab,0xa6,0xb0,
+	0xb3,0xc3,0xcb,0xd2,0xd6,0xce,0xce,0xb2,
+	0xae,0x8b,0x83,0x71,0x6c,0x6d,0x65,0x70,
+	0x66,0x71,0x65,0x62,0x52,0x3f,0x3a,0x2f,
+	0x35,0x37,0x42,0x52,0x5f,0x7a,0x80,0x90,
+	0x8c,0x8b,0x8b,0x89,0x92,0x8d,0x9c,0xa3,
+	0xb8,0xc6,0xd2,0xd9,0xd1,0xd0,0xc0,0xbe,
+	0xad,0xa1,0x9a,0x94,0x9f,0xa1,0xa9,0xa5,
+	0xa1,0x9a,0x8f,0x86,0x6e,0x62,0x56,0x59,
+	0x5c,0x64,0x6d,0x6f,0x77,0x7d,0x81,0x7f,
+	0x74,0x68,0x69,0x70,0x7e,0x87,0x8e,0x73,
+	0x77,0x99,0x9d,0x9f,0xa5,0x9f,0x9c,0x85,
+	0x5f,0x6d,0x6e,0x6d,0x80,0x98,0x9e,0xa4,
+	0x93,0x8e,0x7e,0x79,0x6a,0x5d,0x57,0x54,
+	0x65,0x69,0x75,0x68,0x68,0x5a,0x5a,0x4b,
+	0x3e,0x2d,0x28,0x2c,0x3a,0x46,0x54,0x59,
+	0x62,0x6c,0x6e,0x76,0x61,0x69,0x59,0x74,
+	0x77,0x92,0x98,0xa8,0xbf,0xc5,0xdc,0xc9,
+	0xcd,0xb2,0xb7,0xad,0xb2,0xac,0xac,0xad,
+	0xb6,0xb8,0xbd,0xa7,0x98,0x7e,0x72,0x68,
+	0x4f,0x53,0x39,0x51,0x44,0x67,0x55,0x62,
+	0x51,0x52,0x51,0x48,0x4b,0x3c,0x4e,0x4d,
+	0x73,0x78,0x96,0x93,0xa4,0xa2,0xb2,0xa3,
+	0xa9,0x95,0xa1,0xa1,0xb2,0xbe,0xbd,0xce,
+	0xc0,0xda,0xc0,0xca,0xa2,0xa6,0x8b,0x96,
+	0x8c,0x92,0x8e,0x90,0x99,0x98,0x9d,0x87,
+	0x83,0x66,0x6e,0x59,0x69,0x56,0x6c,0x69,
+	0x89,0x8f,0xa0,0x9f,0x9b,0x99,0x84,0x6d,
+	0x48,0x6d,0x5c,0x74,0x80,0xaa,0xab,0xb4,
+	0x94,0x76,0x73,0x76,0x5c,0x49,0x58,0x57,
+	0x77,0x75,0x89,0x7f,0x87,0x7e,0x7a,0x67,
+	0x55,0x43,0x3e,0x3b,0x46,0x46,0x4e,0x52,
+	0x56,0x5d,0x52,0x50,0x35,0x3a,0x2b,0x38,
+	0x3b,0x45,0x59,0x65,0x81,0x88,0x96,0x93,
+	0x8f,0x92,0x8c,0x98,0x93,0xa4,0xa8,0xbc,
+	0xcb,0xd1,0xdd,0xcf,0xd1,0xbd,0xb8,0xa7,
+	0x9d,0x92,0x90,0x90,0x94,0x91,0x96,0x83,
+	0x85,0x6a,0x66,0x4d,0x42,0x39,0x2f,0x41,
+	0x37,0x56,0x48,0x66,0x57,0x6d,0x5a,0x65,
+	0x59,0x5e,0x61,0x6e,0x7d,0x8b,0x9f,0xac,
+	0xbd,0xbc,0xc9,0xb6,0xc3,0xa7,0xbd,0xa1,
+	0xc0,0xae,0xca,0xc2,0xcf,0xcd,0xc4,0xc3,
+	0xa8,0xaa,0x8c,0x93,0x7d,0x8d,0x7f,0x94,
+	0x89,0x9b,0x8e,0x96,0x84,0x85,0x75,0x77,
+	0x75,0x7b,0x89,0x8d,0xa0,0x92,0x89,0x63,
+	0x87,0x7a,0x6f,0x5e,0x6b,0x6f,0x79,0x7e,
+	0x7a,0x6b,0x57,0x77,0x7a,0x69,0x4e,0x47,
+	0x44,0x40,0x42,0x44,0x4e,0x55,0x5e,0x60,
+	0x61,0x5d,0x56,0x4f,0x42,0x3f,0x30,0x37,
+	0x30,0x45,0x3f,0x53,0x4b,0x5d,0x55,0x60,
+	0x58,0x57,0x55,0x59,0x6b,0x6d,0x87,0x84,
+	0xa4,0x9c,0xc0,0xab,0xc4,0xa8,0xbd,0xaf,
+	0xbe,0xba,0xbe,0xc5,0xc3,0xd2,0xc7,0xcf,
+	0xb2,0xb6,0x98,0xa1,0x85,0x8c,0x6f,0x7b,
+	0x68,0x7a,0x69,0x6c,0x5b,0x55,0x54,0x44,
+	0x4f,0x34,0x49,0x35,0x57,0x50,0x66,0x5f,
+	0x6c,0x6e,0x7a,0x7f,0x81,0x80,0x89,0x92,
+	0xa1,0xa9,0xb3,0xb7,0xbc,0xca,0xc6,0xcf,
+	0xbe,0xc4,0xba,0xc4,0xc3,0xc2,0xc2,0xba,
+	0xc3,0xbc,0xc2,0xb5,0xad,0xa6,0x9e,0xa7,
+	0x9b,0xa0,0x92,0x9c,0x9f,0xa4,0xac,0x9f,
+	0xaa,0x99,0xa9,0x8c,0x82,0x4b,0x5d,0x72,
+	0x7e,0x70,0x5f,0x5f,0x6b,0x6d,0x86,0x7f,
+	0x82,0x6a,0x50,0x3d,0x4e,0x70,0x4c,0x50,
+	0x22,0x49,0x31,0x4a,0x38,0x41,0x42,0x46,
+	0x4e,0x44,0x48,0x3d,0x49,0x44,0x4d,0x40,
+	0x47,0x3b,0x53,0x45,0x5b,0x47,0x59,0x4e,
+	0x65,0x66,0x69,0x73,0x68,0x87,0x7e,0xa0,
+	0x8a,0xa3,0x93,0xac,0xa9,0xb3,0xb1,0xaf,
+	0xb3,0xbb,0xc0,0xc3,0xba,0xb9,0xb3,0xb3,
+	0xb5,0xa3,0xa2,0x8b,0x97,0x87,0x91,0x7f,
+	0x7b,0x71,0x6e,0x72,0x62,0x62,0x4b,0x50,
+	0x4f,0x53,0x58,0x4e,0x59,0x55,0x68,0x66,
+	0x6c,0x68,0x64,0x72,0x71,0x86,0x7f,0x8e,
+	0x8d,0xa3,0xab,0xb5,0xb2,0xb2,0xae,0xb9,
+	0xb7,0xc1,0xb2,0xbc,0xb8,0xc9,0xcd,0xc7,
+	0xca,0xb5,0xc7,0xae,0xc2,0xa0,0xae,0x9c,
+	0xae,0xad,0xb2,0xb5,0xa9,0xb7,0xad,0xbb,
+	0xa4,0xa2,0x85,0x7c,0x5b,0x5b,0x79,0x7e,
+	0x7a,0x73,0x5d,0x6e,0x63,0x66,0x69,0x6c,
+	0x7e,0x6a,0x72,0x42,0x43,0x49,0x75,0x5d,
+	0x59,0x2d,0x2c,0x30,0x2a,0x36,0x29,0x3d,
+	0x3c,0x52,0x4d,0x51,0x42,0x48,0x40,0x4c,
+	0x3e,0x43,0x3c,0x49,0x54,0x5e,0x6c,0x5f,
+	0x75,0x67,0x86,0x6d,0x84,0x6b,0x7f,0x81,
+	0x93,0x9e,0x9d,0xaf,0xa6,0xc1,0xb4,0xc0,
+	0xaa,0xae,0xa6,0xb0,0xad,0xb1,0xa9,0xb2,
+	0xad,0xba,0xad,0xa7,0x96,0x86,0x88,0x78,
+	0x80,0x64,0x76,0x62,0x7a,0x70,0x75,0x67,
+	0x5e,0x61,0x54,0x5c,0x47,0x54,0x49,0x5f,
+	0x66,0x74,0x77,0x77,0x7c,0x83,0x84,0x85,
+	0x7d,0x82,0x85,0x98,0xa3,0xaa,0xb4,0xb1,
+	0xc5,0xbc,0xcb,0xb4,0xb8,0xab,0xb2,0xb7,
+	0xb5,0xbd,0xb7,0xc6,0xc3,0xcb,0xc2,0xb6,
+	0xb1,0xa5,0xad,0xa6,0xa9,0xa5,0xaf,0xb4,
+	0xb5,0xb3,0x9a,0x81,0x63,0x64,0x89,0x74,
+	0x7d,0x72,0x62,0x64,0x6d,0x71,0x73,0x77,
+	0x72,0x75,0x62,0x4f,0x34,0x26,0x41,0x5d,
+	0x55,0x68,0x50,0x41,0x42,0x3d,0x39,0x35,
+	0x2c,0x35,0x34,0x41,0x3d,0x4a,0x4c,0x58,
+	0x5e,0x5d,0x5e,0x53,0x58,0x54,0x59,0x5b,
+	0x5f,0x68,0x71,0x82,0x89,0x90,0x8f,0x8f,
+	0x93,0x91,0x95,0x91,0x95,0x9b,0xa5,0xb4,
+	0xb5,0xc1,0xb8,0xbf,0xb6,0xb7,0xaa,0xa0,
+	0x9e,0x98,0xa0,0x9d,0xa2,0x9a,0x9f,0x96,
+	0x97,0x89,0x7b,0x6e,0x65,0x62,0x5f,0x60,
+	0x5f,0x63,0x65,0x6c,0x6a,0x6b,0x5d,0x5e,
+	0x53,0x5b,0x56,0x5d,0x62,0x6d,0x7b,0x86,
+	0x8f,0x8f,0x96,0x91,0x97,0x93,0x99,0x95,
+	0x9f,0xa6,0xb5,0xbe,0xc5,0xc9,0xca,0xcb,
+	0xc4,0xc5,0xb7,0xb9,0xb2,0xbe,0xba,0xc5,
+	0xc5,0xcd,0xcc,0xcd,0xc9,0xbe,0xba,0xac,
+	0xab,0x9d,0x98,0x89,0x76,0x68,0x6f,0x9d,
+	0x93,0x8a,0x98,0x6d,0x63,0x56,0x56,0x5a,
+	0x5e,0x6a,0x64,0x69,0x51,0x45,0x2c,0x38,
+	0x5b,0x3d,0x52,0x48,0x38,0x2a,0x32,0x31,
+	0x3b,0x3c,0x3d,0x3d,0x38,0x3b,0x33,0x3c,
+	0x37,0x42,0x47,0x52,0x5d,0x60,0x69,0x65,
+	0x69,0x6a,0x67,0x6a,0x68,0x72,0x75,0x87,
+	0x8f,0x98,0xa3,0xa5,0xb0,0xaa,0xaf,0xa5,
+	0xa9,0xa5,0xab,0xb1,0xb2,0xba,0xb8,0xc1,
+	0xbf,0xba,0xb3,0xa4,0xa0,0x93,0x95,0x89,
+	0x8a,0x84,0x86,0x89,0x82,0x84,0x70,0x71,
+	0x5f,0x63,0x55,0x51,0x4e,0x4d,0x58,0x59,
+	0x68,0x5d,0x67,0x62,0x6a,0x67,0x66,0x63,
+	0x65,0x70,0x79,0x86,0x8c,0x96,0x9b,0xaa,
+	0xa9,0xb1,0xa4,0xaa,0xa4,0xb3,0xaf,0xbc,
+	0xb7,0xc0,0xca,0xcc,0xd3,0xc5,0xc8,0xb9,
+	0xc1,0xb9,0xbc,0xb3,0xb7,0xb9,0xc1,0xc7,
+	0xc0,0xbd,0xad,0xae,0x97,0x8f,0x67,0x60,
+	0x55,0x90,0x90,0x86,0xa1,0x8e,0x82,0x70,
+	0x74,0x5d,0x62,0x49,0x4f,0x37,0x30,0x26,
+	0x3a,0x62,0x54,0x59,0x6d,0x5d,0x3f,0x3a,
+	0x2e,0x34,0x2e,0x30,0x31,0x3b,0x44,0x4b,
+	0x4a,0x45,0x48,0x46,0x53,0x4a,0x55,0x48,
+	0x5e,0x5b,0x76,0x6e,0x77,0x77,0x7b,0x88,
+	0x83,0x8f,0x7d,0x93,0x89,0xaa,0xa2,0xae,
+	0xad,0xb1,0xbf,0xb9,0xc4,0xaf,0xb8,0xad,
+	0xb9,0xb4,0xb6,0xae,0xad,0xb1,0xaf,0xaf,
+	0x9f,0x94,0x8a,0x8a,0x83,0x7d,0x6f,0x6d,
+	0x65,0x6e,0x68,0x68,0x59,0x57,0x55,0x53,
+	0x54,0x49,0x4e,0x44,0x5a,0x57,0x63,0x60,
+	0x64,0x6c,0x71,0x7d,0x78,0x7f,0x7c,0x89,
+	0x93,0x9c,0xa1,0xa1,0xac,0xb1,0xbc,0xb9,
+	0xb7,0xb6,0xb7,0xbe,0xbf,0xc5,0xbc,0xc0,
+	0xc1,0xc9,0xca,0xc4,0xc2,0xba,0xc1,0xbc,
+	0xbf,0xb3,0xb4,0xab,0xaf,0xa7,0x9f,0x8b,
+	0x7a,0x6d,0x68,0x7e,0x97,0x95,0x72,0x9d,
+	0x9b,0x92,0x76,0x68,0x59,0x4a,0x43,0x2b,
+	0x2b,0x2a,0x59,0x57,0x47,0x5b,0x67,0x56,
+	0x4e,0x44,0x3e,0x3c,0x32,0x39,0x36,0x42,
+	0x3a,0x44,0x3a,0x48,0x44,0x51,0x4d,0x50,
+	0x52,0x56,0x62,0x5e,0x6b,0x5f,0x75,0x6c,
+	0x81,0x79,0x86,0x85,0x8a,0x99,0x97,0xa8,
+	0x9e,0xaf,0xaa,0xbb,0xb8,0xbc,0xbc,0xb9,
+	0xc2,0xbf,0xc6,0xbb,0xc0,0xb9,0xbb,0xb9,
+	0xb1,0xa8,0xa2,0x99,0x96,0x8c,0x87,0x79,
+	0x77,0x70,0x6e,0x68,0x5f,0x5b,0x4e,0x53,
+	0x49,0x4b,0x40,0x41,0x45,0x44,0x50,0x4c,
+	0x56,0x53,0x5d,0x61,0x64,0x6b,0x68,0x76,
+	0x78,0x85,0x8d,0x92,0x9e,0xa0,0xb0,0xaa,
+	0xb9,0xaf,0xb9,0xb6,0xba,0xc1,0xbc,0xca,
+	0xbd,0xd2,0xc4,0xd2,0xc5,0xc7,0xc3,0xbd,
+	0xc1,0xb5,0xbf,0xaf,0xbb,0xb2,0xba,0xad,
+	0xab,0x9b,0x91,0x7e,0x6d,0x63,0x69,0x87,
+	0x9c,0x83,0x7b,0xa1,0x92,0x88,0x61,0x54,
+	0x30,0x29,0x28,0x43,0x5d,0x3a,0x48,0x60,
+	0x6f,0x57,0x58,0x43,0x41,0x37,0x32,0x34,
+	0x2c,0x37,0x2f,0x40,0x3e,0x4c,0x4b,0x51,
+	0x53,0x53,0x55,0x52,0x57,0x57,0x5c,0x64,
+	0x6a,0x74,0x7c,0x85,0x8d,0x91,0x95,0x96,
+	0x9a,0x9a,0xa1,0xa3,0xad,0xb3,0xbb,0xc5,
+	0xc8,0xcf,0xcc,0xcc,0xc7,0xc3,0xbe,0xb8,
+	0xb3,0xb3,0xaf,0xb1,0xab,0xa9,0xa1,0x9c,
+	0x8c,0x85,0x75,0x69,0x61,0x55,0x59,0x4e,
+	0x54,0x4a,0x52,0x49,0x4d,0x43,0x41,0x3a,
+	0x37,0x3c,0x3a,0x4c,0x47,0x5a,0x5b,0x6e,
+	0x6f,0x7c,0x7c,0x81,0x82,0x86,0x8a,0x8f,
+	0x9f,0xa0,0xb3,0xb4,0xc6,0xc1,0xcb,0xc3,
+	0xc6,0xc1,0xbe,0xc0,0xbc,0xc4,0xc0,0xd1,
+	0xc6,0xd7,0xc9,0xd3,0xc0,0xc7,0x8e,0x44,
+	0x6c,0x90,0xa9,0xa2,0xa9,0x9b,0xa2,0x90,
+	0x94,0x81,0x81,0x72,0x6f,0x67,0x63,0x66,
+	0x62,0x6d,0x63,0x70,0x61,0x69,0x58,0x59,
+	0x4c,0x48,0x43,0x42,0x46,0x44,0x4e,0x48,
+	0x56,0x49,0x52,0x42,0x45,0x39,0x3a,0x35,
+	0x36,0x3d,0x3b,0x47,0x45,0x51,0x4b,0x53,
+	0x46,0x4d,0x41,0x46,0x41,0x48,0x4c,0x51,
+	0x5c,0x5c,0x68,0x63,0x6e,0x61,0x68,0x5f,
+	0x63,0x62,0x67,0x6b,0x72,0x7c,0x7e,0x86,
+	0x85,0x8b,0x84,0x88,0x80,0x86,0x82,0x88,
+	0x8b,0x92,0x98,0x9b,0xa1,0xa0,0xa4,0x9d,
+	0xa1,0x7f,0x69,0x8e,0x88,0xa7,0xdc,0xac,
+	0xb2,0xa3,0x7f,0xb3,0x90,0xa2,0xc3,0x76,
+	0xa9,0xaa,0x78,0xc2,0x92,0x83,0xc1,0x7c,
+	0x9b,0xaf,0x5e,0x89,0x72,0x3e,0x8b,0x5e,
+	0x5c,0x91,0x44,0x63,0x72,0x39,0x79,0x60,
+	0x38,0x72,0x36,0x41,0x78,0x38,0x6d,0x63,
+	0x34,0x69,0x5e,0x52,0xa0,0x6c,0x78,0x9f,
+	0x4f,0x92,0x8c,0x63,0xa6,0x6e,0x70,0xa2,
+	0x86,0xaa,0xd6,0x9a,0xc6,0xb5,0x7f,0xca,
+	0x91,0x99,0xb7,0x75,0x9b,0xae,0x96,0xd1,
+	0xcf,0xa3,0xda,0x99,0x9d,0xc7,0x84,0xb2,
+	0x9b,0x6b,0x97,0x85,0x7f,0xba,0x86,0x7e,
+	0x9a,0x52,0x93,0x8c,0x69,0x9c,0x5f,0x59,
+	0x80,0x63,0x88,0xb2,0x79,0xa4,0x9a,0x72,
+	0xc0,0x8e,0x9c,0xb6,0x76,0x94,0xa4,0x8e,
+	0xcb,0xc3,0x95,0xbb,0x76,0x79,0xa1,0x60,
+	0x88,0x6a,0x39,0x64,0x55,0x5b,0x9a,0x6b,
+	0x67,0x77,0x2f,0x6a,0x69,0x4d,0x82,0x4c,
+	0x4e,0x79,0x6d,0x9d,0xc9,0x94,0xb7,0x9d,
+	0x7a,0xc2,0x9d,0xa9,0xbc,0x74,0x80,0x81,
+	0x6d,0xbc,0xbc,0x7f,0x97,0x60,0x67,0x98,
+	0x6d,0x7e,0x4f,0x2d,0x48,0x45,0x45,0x8b,
+	0x71,0x5c,0x67,0x27,0x54,0x64,0x5e,0x78,
+	0x56,0x43,0x5e,0x75,0x92,0xca,0x9e,0x9c,
+	0x7e,0x5a,0x89,0x7f,0x90,0x81,0x65,0x4f,
+	0x68,0x7d,0xa6,0xc3,0x97,0x8f,0x5c,0x63,
+	0x78,0x87,0x94,0x77,0x69,0x50,0x7c,0x98,
+	0xca,0xcc,0xb1,0x8e,0x69,0x80,0x7c,0xaa,
+	0x89,0x75,0x63,0x50,0x91,0x9b,0xac,0xa0,
+	0x87,0x52,0x5c,0x62,0x7b,0xb8,0x82,0x92,
+	0x44,0x38,0x6c,0x94,0xa4,0xa4,0x6b,0x34,
+	0x5a,0x3a,0x85,0x8f,0x5d,0x6e,0x3b,0x57,
+	0x99,0xb6,0xb8,0xc3,0x60,0x5f,0x6f,0x53,
+	0xb8,0x86,0x71,0x70,0x43,0x6b,0xae,0xac,
+	0xbf,0xaf,0x43,0x76,0x57,0x6e,0xb7,0x77,
+	0x7d,0x6b,0x4d,0x8c,0xc4,0xb0,0xdd,0x9b,
+	0x5e,0x93,0x5e,0xa0,0xb8,0x7f,0x8b,0x71,
+	0x67,0xa9,0x9f,0x98,0xb7,0x51,0x53,0x6c,
+	0x4e,0xb0,0xa4,0x82,0x71,0x36,0x39,0x89,
+	0x7c,0x93,0x98,0x28,0x4f,0x41,0x4a,0x9b,
+	0x80,0x65,0x75,0x46,0x70,0xbb,0x9d,0xca,
+	0x98,0x4c,0x6a,0x53,0x72,0xac,0x85,0x73,
+	0x76,0x49,0x8e,0xb7,0xae,0xc9,0x83,0x55,
+	0x67,0x57,0x89,0xa7,0x81,0x7e,0x67,0x63,
+	0xa1,0xbf,0xc9,0xc7,0x8d,0x6f,0x79,0x7f,
+	0xb6,0xb9,0xaf,0x9b,0x8e,0x7c,0x87,0xae,
+	0x95,0x8e,0x59,0x49,0x4b,0x75,0x96,0xa0,
+	0x9f,0x3f,0x4c,0x45,0x5e,0x8c,0x77,0x61,
+	0x47,0x30,0x3d,0x7e,0x6a,0xa0,0x7d,0x5e,
+	0x88,0x75,0x9e,0xb4,0x91,0x6e,0x70,0x30,
+	0x69,0x82,0x69,0xb0,0x68,0x77,0x91,0x83,
+	0xab,0xc6,0x88,0x8d,0x81,0x40,0x9d,0x71,
+	0x83,0xa8,0x63,0x82,0x92,0x83,0xb0,0xc1,
+	0x7d,0xb7,0x81,0x7a,0xc8,0x90,0xc9,0xcc,
+	0x9a,0x90,0x90,0x6b,0x97,0x7a,0x56,0x93,
+	0x41,0x72,0x8a,0x6b,0x9e,0x7d,0x3a,0x6e,
+	0x4f,0x36,0x79,0x3d,0x57,0x6f,0x3b,0x79,
+	0x74,0x6a,0x94,0x88,0x79,0xa6,0x78,0x7e,
+	0x90,0x57,0x78,0x6d,0x53,0x77,0x67,0x66,
+	0x90,0x83,0x96,0xaf,0x90,0xa2,0x9d,0x88,
+	0xa1,0x91,0x81,0x8f,0x69,0x78,0x7d,0x81,
+	0x8e,0x91,0x87,0x87,0x8f,0x8f,0xb3,0xac,
+	0xbc,0xb3,0xb3,0xc2,0xa8,0xa0,0x97,0x93,
+	0x62,0x63,0x62,0x71,0x7e,0x87,0x85,0x63,
+	0x84,0x58,0x5b,0x59,0x53,0x4c,0x2b,0x2e,
+	0x4a,0x68,0x6e,0xa3,0x6c,0x79,0x80,0x60,
+	0xa6,0x90,0x8b,0x85,0x5b,0x47,0x72,0x5d,
+	0x7c,0x8e,0x4c,0x76,0x5d,0x6f,0xae,0xa6,
+	0xa7,0xb4,0x7e,0x8f,0xb0,0x8e,0xc2,0x9a,
+	0x69,0x7c,0x53,0x69,0x9a,0x7e,0x8e,0x8d,
+	0x5e,0x95,0xa3,0xaa,0xde,0xb6,0xa3,0xac,
+	0x63,0x92,0xaa,0x77,0x90,0x6a,0x51,0x7e,
+	0x7a,0x85,0xa9,0x65,0x6a,0x68,0x42,0x67,
+	0x65,0x61,0x5d,0x3f,0x3d,0x7b,0x78,0x9f,
+	0xaf,0x6b,0x84,0x61,0x6a,0x9a,0x8d,0x82,
+	0x77,0x48,0x48,0x71,0x5f,0x97,0x75,0x59,
+	0x64,0x55,0x84,0xac,0xbd,0xb2,0xb6,0x84,
+	0xa2,0xa9,0xab,0xbe,0x83,0x6c,0x50,0x53,
+	0x6a,0x90,0x8e,0x8f,0x84,0x74,0xa3,0xac,
+	0xd6,0xd2,0xb5,0x80,0x67,0x80,0x88,0x99,
+	0x8b,0x86,0x66,0x68,0x79,0x85,0x95,0x85,
+	0x6c,0x51,0x4c,0x3e,0x5a,0x7b,0x6b,0x53,
+	0x48,0x59,0x76,0x99,0x9c,0x91,0x74,0x5c,
+	0x64,0x79,0x8a,0x94,0x77,0x5d,0x50,0x4d,
+	0x6c,0x79,0x76,0x6a,0x57,0x4f,0x7b,0x99,
+	0xc0,0xd5,0xb2,0xb4,0x9f,0xa6,0xbb,0xb4,
+	0x97,0x7c,0x4e,0x46,0x6c,0x6c,0xa1,0x96,
+	0x88,0x93,0x8f,0xb2,0xd6,0xd1,0xab,0x83,
+	0x5a,0x85,0x85,0x7f,0xac,0x80,0x7d,0x70,
+	0x6b,0x7f,0x97,0x7a,0x78,0x5d,0x34,0x5d,
+	0x33,0x74,0x8b,0x5d,0x59,0x58,0x5f,0x8c,
+	0x9d,0x7e,0x93,0x54,0x5d,0x7e,0x6e,0x9d,
+	0x82,0x63,0x5b,0x4f,0x4b,0x7a,0x65,0x62,
+	0x70,0x3d,0x7d,0x8f,0xa9,0xdc,0xc4,0xb4,
+	0xba,0xa1,0xa7,0xc4,0x86,0x92,0x63,0x41,
+	0x71,0x68,0x8b,0xa8,0x8b,0x8d,0xa0,0x8d,
+	0xc7,0xc3,0x97,0x92,0x69,0x77,0x8a,0x76,
+	0xa0,0xa1,0x78,0x86,0x70,0x65,0x95,0x6f,
+	0x71,0x6d,0x3d,0x5f,0x57,0x4c,0x93,0x7b,
+	0x5d,0x69,0x52,0x79,0x96,0x75,0x8c,0x68,
+	0x51,0x7d,0x73,0x86,0x9b,0x5e,0x5b,0x4e,
+	0x3f,0x58,0x58,0x56,0x69,0x5d,0x6c,0x8a,
+	0xa6,0xc0,0xcc,0xd5,0xd1,0xc7,0xbc,0xa4,
+	0x95,0x7e,0x76,0x6b,0x6c,0x71,0x79,0x89,
+	0x90,0xa0,0xa4,0xb0,0xaf,0xa9,0x97,0x6f,
+	0x89,0x8c,0x97,0x7e,0x87,0x8a,0x8e,0x8e,
+	0x83,0x81,0x6c,0x6c,0x60,0x5f,0x65,0x63,
+	0x68,0x43,0x66,0x73,0x85,0x6c,0x6c,0x6f,
+	0x6c,0x77,0x6b,0x7c,0x71,0x7f,0x79,0x7c,
+	0x7b,0x6e,0x6f,0x58,0x5b,0x45,0x49,0x44,
+	0x4c,0x61,0x6a,0x91,0x99,0xbf,0xc0,0xd5,
+	0xd1,0xc8,0xc2,0xa6,0xa1,0x81,0x84,0x6f,
+	0x75,0x75,0x7a,0x8b,0x87,0x9f,0x96,0xa7,
+	0x9f,0x9b,0x91,0x69,0x82,0x87,0x9c,0x86,
+	0x87,0x89,0x88,0x8e,0x80,0x86,0x6d,0x76,
+	0x65,0x6c,0x6b,0x70,0x74,0x61,0x64,0x73,
+	0x84,0x80,0x73,0x72,0x6d,0x78,0x6d,0x80,
+	0x6b,0x5b,0x61,0x7b,0x6b,0x87,0xa4,0x71,
+	0x6f,0x63,0x42,0x35,0x58,0x6f,0x75,0x9f,
+	0xa1,0x93,0x98,0x9f,0x91,0xad,0xbf,0x9d,
+	0xa3,0x8a,0x68,0x69,0x83,0x7a,0x91,0xa7,
+	0x7a,0x81,0x80,0x74,0x8a,0xae,0x96,0x86,
+	0x8a,0x61,0x72,0x93,0x85,0x95,0xb1,0x8b,
+	0x6d,0x84,0x58,0x6b,0x91,0x84,0x79,0x8c,
+	0x64,0x4d,0x7a,0x6c,0x87,0xaf,0x8b,0x5d,
+	0x6c,0x5c,0x50,0x99,0x91,0x80,0x9a,0x74,
+	0x55,0x78,0x88,0x6d,0xa1,0x83,0x4c,0x5f,
+	0x52,0x45,0x7f,0xa2,0x82,0xaa,0x9c,0x6b,
+	0x96,0xa6,0x97,0xb5,0xbb,0x6e,0x78,0x78,
+	0x50,0x85,0xa7,0x8b,0x91,0x9b,0x58,0x6c,
+	0x98,0x7a,0xa2,0xb4,0x70,0x60,0x87,0x5e,
+	0x7f,0xbb,0x91,0x95,0x9f,0x60,0x51,0x85,
+	0x71,0x78,0xb2,0x71,0x61,0x7a,0x5c,0x57,
+	0xa7,0x9a,0x82,0xa0,0x58,0x40,0x75,0x76,
+	0x74,0xb1,0x95,0x5e,0x86,0x66,0x5e,0x9e,
+	0x9c,0x74,0x87,0x68,0x28,0x67,0x72,0x6e,
+	0xaf,0xaa,0x73,0x8b,0x8e,0x64,0xb1,0xbf,
+	0x8f,0xa4,0x86,0x44,0x64,0x8f,0x70,0xb1,
+	0xb7,0x6b,0x79,0x79,0x54,0x89,0xbf,0x87,
+	0x99,0x8c,0x39,0x67,0x94,0x88,0xaa,0xcc,
+	0x76,0x6b,0x79,0x3f,0x71,0xab,0x87,0x84,
+	0x91,0x45,0x48,0x8c,0x6c,0xa0,0xc6,0x81,
+	0x55,0x64,0x3c,0x53,0xb1,0x90,0x91,0x9d,
+	0x58,0x4a,0x86,0x86,0x93,0xc5,0x7f,0x4b,
+	0x56,0x35,0x4a,0x9b,0xa4,0x90,0xa9,0x72,
+	0x56,0x8c,0x99,0xab,0xcd,0xa7,0x67,0x65,
+	0x4f,0x56,0xa1,0xb2,0xa3,0xa2,0x74,0x4a,
+	0x6c,0x86,0x96,0xbd,0xa7,0x6f,0x5b,0x4b,
+	0x5e,0xa0,0xc8,0xb7,0xa6,0x78,0x49,0x52,
+	0x70,0x8b,0xa9,0x9f,0x71,0x51,0x47,0x59,
+	0x85,0xac,0xb9,0xa1,0x6d,0x40,0x35,0x55,
+	0x89,0xa8,0xa5,0x8c,0x62,0x46,0x67,0x8b,
+	0xab,0xc7,0x9f,0x60,0x3d,0x30,0x39,0x88,
+	0xa9,0x9f,0xa4,0x73,0x4f,0x72,0x9b,0xa9,
+	0xd7,0xbe,0x6b,0x60,0x47,0x47,0x8e,0xc2,
+	0xa6,0xaa,0x8a,0x3a,0x66,0x86,0x8a,0xbf,
+	0xbf,0x69,0x5b,0x66,0x34,0x99,0xd0,0xab,
+	0xb7,0x93,0x3c,0x51,0x8e,0x65,0xad,0xb7,
+	0x53,0x5c,0x63,0x3e,0x81,0xcc,0x88,0xa2,
+	0x9d,0x29,0x4a,0x77,0x63,0x93,0xc1,0x60,
+	0x5d,0x82,0x40,0x8d,0xcb,0x98,0x96,0x9b,
+	0x36,0x39,0x86,0x55,0x91,0xbc,0x6b,0x66,
+	0x87,0x5b,0x7d,0xd5,0x99,0x9a,0xa5,0x4a,
+	0x4f,0x85,0x73,0x8d,0xc4,0x7e,0x6b,0x8c,
+	0x5c,0x79,0xb3,0x96,0x89,0x98,0x5e,0x55,
+	0x8b,0x7e,0x8f,0xb9,0x95,0x7c,0x86,0x69,
+	0x71,0x99,0x8b,0x7e,0x81,0x62,0x57,0x79,
+	0x7e,0x8e,0x96,0x8b,0x77,0x71,0x6b,0x67,
+	0x7d,0x7c,0x83,0x71,0x70,0x74,0x70,0x8d,
+	0x94,0x95,0x8d,0x8a,0x6c,0x6d,0x80,0x64,
+	0x81,0x82,0x6f,0x77,0x8a,0x77,0x83,0xaa,
+	0x79,0x8f,0x98,0x6d,0x7c,0x8e,0x6e,0x71,
+	0x9f,0x67,0x80,0xa4,0x6f,0x87,0x9b,0x72,
+	0x72,0xa6,0x6d,0x78,0xad,0x64,0x7b,0x9e,
+	0x6f,0x7d,0xbb,0x7e,0x73,0xa5,0x56,0x67,
+	0x9c,0x6f,0x72,0xa6,0x6d,0x59,0x9c,0x62,
+	0x6f,0xb0,0x7d,0x68,0x8d,0x60,0x49,0x9d,
+	0x78,0x70,0xad,0x77,0x5c,0x91,0x7b,0x6a,
+	0xb6,0x8f,0x65,0x94,0x65,0x4b,0x93,0x8b,
+	0x74,0xae,0x88,0x54,0x8c,0x7c,0x69,0xb0,
+	0xa1,0x6c,0x8d,0x71,0x49,0x8b,0x97,0x7c,
+	0xac,0x93,0x54,0x7b,0x7b,0x6a,0xa3,0xad,
+	0x77,0x8a,0x7e,0x4e,0x8a,0x9c,0x8b,0xa6,
+	0x9d,0x5f,0x66,0x77,0x62,0x9a,0xa9,0x81,
+	0x7f,0x71,0x52,0x68,0x96,0x85,0xa1,0x92,
+	0x5d,0x5a,0x62,0x6e,0x89,0xac,0x8d,0x7e,
+	0x71,0x52,0x6f,0x87,0xa2,0x9e,0x9a,0x70,
+	0x5a,0x66,0x6b,0x98,0x9f,0xa3,0x82,0x66,
+	0x5f,0x61,0x88,0x99,0xb1,0x8e,0x7d,0x64,
+	0x53,0x7a,0x8c,0xa5,0xa0,0x93,0x5e,0x5b,
+	0x6b,0x6f,0xa7,0xae,0x98,0x81,0x71,0x53,
+	0x70,0xa1,0x95,0xad,0x97,0x62,0x59,0x6b,
+	0x6c,0x92,0xc1,0x8c,0x84,0x72,0x44,0x62,
+	0x92,0x8d,0x9a,0xa7,0x59,0x4d,0x6e,0x5d,
+	0x8d,0xbf,0x95,0x79,0x7e,0x46,0x53,0x98,
+	0x8f,0x9b,0xb1,0x6f,0x4e,0x77,0x66,0x7f,
+	0xc4,0xa0,0x7b,0x82,0x52,0x45,0x8f,0x97,
+	0x91,0xb8,0x82,0x4c,0x73,0x6e,0x70,0xb8,
+	0xac,0x77,0x83,0x60,0x39,0x84,0xa0,0x8e,
+	0xbb,0x9a,0x53,0x6c,0x79,0x66,0xac,0xbc,
+	0x79,0x81,0x6f,0x3d,0x73,0xa3,0x8c,0xac,
+	0xaa,0x53,0x5e,0x74,0x5d,0x8f,0xb9,0x80,
+	0x76,0x7c,0x3a,0x62,0xa0,0x8d,0xa1,0xb0,
+	0x63,0x4b,0x7a,0x59,0x82,0xbf,0x90,0x79,
+	0x85,0x54,0x52,0xa5,0x94,0x97,0xb9,0x70,
+	0x4a,0x6d,0x66,0x6c,0xbf,0xa0,0x78,0x91,
+	0x5c,0x4e,0x90,0x9f,0x88,0xb3,0x84,0x43,
+	0x6f,0x64,0x6e,0xae,0xb8,0x7c,0x8e,0x77,
+	0x42,0x8b,0x9b,0x8d,0xa7,0x96,0x4c,0x60,
+	0x78,0x60,0xa9,0xb8,0x89,0x85,0x7b,0x46,
+	0x68,0x9f,0x7b,0xa0,0x9b,0x56,0x58,0x74,
+	0x68,0x8c,0xc8,0x87,0x83,0x7d,0x46,0x5d,
+	0x91,0x8c,0x8d,0xb0,0x67,0x5a,0x7c,0x6a,
+	0x8b,0xb9,0x9f,0x73,0x87,0x4f,0x4c,0x90,
+	0x8a,0x94,0xaa,0x85,0x54,0x7b,0x73,0x73,
+	0xb6,0x9d,0x7c,0x79,0x64,0x41,0x83,0x99,
+	0x89,0xb5,0x94,0x63,0x6c,0x7c,0x6a,0xa0,
+	0xb0,0x77,0x82,0x6a,0x4d,0x6f,0xa2,0x8e,
+	0xa6,0xa5,0x66,0x73,0x6e,0x6f,0x85,0x94,
+	0x82,0x75,0x7a,0x6f,0x84,0x7d,0x8a,0x83,
+	0x83,0x83,0x78,0x80,0x73,0x7e,0x75,0x7d,
+	0x7e,0x80,0x87,0x81,0x8e,0x80,0x88,0x7d,
+	0x7e,0x7c,0x77,0x7d,0x77,0x83,0x7b,0x87,
+	0x84,0x87,0x88,0x81,0x87,0x7a,0x81,0x76,
+	0x7c,0x78,0x7b,0x81,0x7f,0x89,0x80,0x8d,
+	0x80,0x86,0x81,0x7b,0x81,0x73,0x7f,0x75,
+	0x82,0x7c,0x85,0x86,0x84,0x8b,0x7f,0x88,
+	0x7b,0x7f,0x79,0x7a,0x7d,0x76,0x84,0x7a,
+	0x8a,0x81,0x8a,0x85,0x82,0x85,0x79,0x81,
+	0x75,0x7f,0x77,0x7d,0x80,0x7f,0x89,0x7f,
+	0x8d,0x80,0x87,0x7e,0x80,0x7c,0x78,0x7d,
+	0x78,0x83,0x7b,0x84,0x84,0x84,0x89,0x7e,
+	0x87,0x7a,0x83,0x76,0x7e,0x7a,0x7e,0x7f,
+	0x7f,0x86,0x82,0x86,0x84,0x81,0x85,0x74,
+	0x54,0x4a,0x73,0x6d,0x6b,0xa3,0xb4,0x8d,
+	0x7d,0x91,0x47,0x31,0x6a,0x98,0x6b,0xa0,
+	0xd2,0x8b,0x56,0x7d,0x72,0x43,0x82,0xc5,
+	0x95,0x83,0xa1,0x78,0x2b,0x5e,0x85,0x6c,
+	0x80,0xb9,0x92,0x4f,0x68,0x6a,0x3a,0x5a,
+	0x9c,0x88,0x66,0x83,0x70,0x33,0x39,0x73,
+	0x5e,0x5d,0x9a,0x8e,0x4b,0x5f,0x6d,0x3f,
+	0x55,0x8c,0x85,0x6b,0x72,0x72,0x40,0x30,
+	0x6a,0x75,0x5c,0x99,0xa8,0x5f,0x63,0x80,
+	0x52,0x56,0x8d,0x95,0x7b,0x7c,0x85,0x5e,
+	0x40,0x74,0x8f,0x70,0x9e,0xc3,0x82,0x76,
+	0x97,0x76,0x69,0x9a,0xab,0x9a,0x8e,0x9c,
+	0x82,0x56,0x79,0xa3,0x84,0x9e,0xce,0x9d,
+	0x7a,0x98,0x85,0x6b,0x8f,0xab,0x9a,0x87,
+	0x90,0x84,0x51,0x61,0x93,0x77,0x7d,0xb3,
+	0x92,0x66,0x7c,0x73,0x52,0x6a,0x88,0x84,
+	0x6d,0x73,0x72,0x43,0x41,0x76,0x6a,0x64,
+	0x9b,0x90,0x60,0x6e,0x72,0x5b,0x68,0x8b,
+	0x92,0x7f,0x7c,0x89,0x68,0x5e,0x8e,0x91,
+	0x82,0xb0,0xba,0x94,0x96,0xa0,0x89,0x89,
+	0xa4,0xbe,0xab,0xa0,0xad,0x93,0x75,0xa0,
+	0xac,0x9b,0xb4,0xc4,0x9e,0x9b,0x9d,0x91,
+	0x81,0x8a,0x96,0x8f,0x7a,0x8a,0x8e,0x7b,
+	0x7d,0x96,0x94,0x96,0x9d,0x7e,0x66,0x60,
+	0x58,0x4f,0x53,0x7c,0x8b,0x70,0x86,0x76,
+	0x50,0x52,0x66,0x67,0x74,0x8d,0x83,0x77,
+	0x6f,0x6c,0x6c,0x6c,0x7c,0x82,0x78,0x72,
+	0x70,0x5c,0x58,0x63,0x69,0x6f,0x7e,0x7b,
+	0x6f,0x63,0x59,0x57,0x5b,0x63,0x6d,0x70,
+	0x6c,0x63,0x5e,0x5e,0x62,0x71,0x88,0x92,
+	0x99,0x99,0x97,0x8f,0x8d,0xa0,0xac,0xaa,
+	0xc0,0xc9,0xac,0xb3,0xbe,0xb0,0xb9,0xd1,
+	0xd6,0xd0,0xca,0xcc,0xb8,0x9d,0xad,0xb6,
+	0x91,0xa1,0xb0,0x80,0x77,0x88,0x6e,0x63,
+	0x75,0x7b,0x6c,0x5e,0x6c,0x67,0x3d,0x55,
+	0x70,0x43,0x51,0x7d,0x59,0x4c,0x73,0x6d,
+	0x61,0x73,0x8c,0x8c,0x78,0x96,0xaa,0x7f,
+	0x90,0xc1,0x96,0x8e,0xc6,0xaf,0x96,0xb7,
+	0xbd,0xaa,0xa6,0xbe,0xc2,0x99,0xa9,0xcf,
+	0x9b,0x8e,0xc7,0xa1,0x78,0xa9,0xa2,0x78,
+	0x89,0x9c,0x8c,0x6f,0x7d,0x93,0x60,0x5b,
+	0x98,0x6e,0x4d,0x8c,0x7d,0x45,0x68,0x7e,
+	0x60,0x60,0x86,0x92,0x6f,0x76,0xa9,0x7e,
+	0x5b,0x8a,0x76,0x52,0x7d,0x96,0x63,0x6f,
+	0x97,0x8d,0x7f,0xa1,0xcb,0xa4,0x8f,0xc1,
+	0x92,0x3f,0x8f,0xa1,0x64,0x8a,0xad,0x80,
+	0x67,0x86,0x8b,0x6c,0x76,0xa6,0x88,0x56,
+	0x7d,0x7a,0x34,0x59,0x87,0x5d,0x5c,0x85,
+	0x6a,0x40,0x47,0x66,0x4e,0x46,0x80,0x7c,
+	0x43,0x5e,0x6d,0x35,0x41,0x81,0x78,0x6c,
+	0x92,0x9a,0x6b,0x66,0x8f,0x89,0x77,0xaf,
+	0xc8,0x94,0x93,0xad,0x85,0x76,0xaa,0xbd,
+	0xaa,0xbc,0xcf,0xa4,0x81,0x9b,0x9f,0x86,
+	0xa3,0xc2,0x9c,0x7f,0x87,0x6f,0x4b,0x67,
+	0x8b,0x7d,0x7e,0x93,0x76,0x49,0x54,0x5d,
+	0x51,0x64,0x84,0x7c,0x5d,0x59,0x56,0x3b,
+	0x47,0x79,0x80,0x87,0x9f,0x92,0x73,0x70,
+	0x78,0x80,0x92,0xaa,0xb9,0xa9,0x91,0x91,
+	0x7e,0x7a,0xa5,0xb8,0xbd,0xd3,0xc3,0xa6,
+	0x9a,0x8d,0x97,0xa8,0xaf,0xc0,0xb3,0x90,
+	0x86,0x71,0x63,0x82,0x94,0x9c,0xb1,0x9c,
+	0x80,0x77,0x5c,0x61,0x7c,0x80,0x8e,0x9c,
+	0x81,0x74,0x6b,0x5f,0x82,0x96,0xa6,0xbe,
+	0x90,0x5d,0x71,0x52,0x41,0x66,0x73,0x81,
+	0x99,0x83,0x73,0x66,0x60,0x7c,0x95,0xa9,
+	0xd6,0xbd,0x8d,0x73,0x52,0x4c,0x67,0x6b,
+	0x6e,0x84,0x78,0x5f,0x49,0x38,0x52,0x5b,
+	0x68,0x9a,0x90,0x66,0x71,0x58,0x31,0x50,
+	0x67,0x65,0x74,0x70,0x5d,0x3f,0x2a,0x47,
+	0x52,0x56,0x93,0x9e,0x6f,0x7c,0x74,0x46,
+	0x5f,0x82,0x87,0x93,0x98,0x93,0x75,0x59,
+	0x77,0x8a,0x81,0xbd,0xd8,0xa7,0xa9,0xaf,
+	0x7d,0x7e,0xa3,0xab,0xac,0xaf,0xaf,0x8f,
+	0x61,0x77,0x8b,0x76,0xa2,0xd0,0x9d,0x8b,
+	0x98,0x65,0x4e,0x6f,0x84,0x80,0x7b,0x85,
+	0x6c,0x33,0x3f,0x64,0x4a,0x6c,0xb0,0x8d,
+	0x6f,0x82,0x64,0x41,0x5d,0x81,0x87,0x80,
+	0x94,0x8f,0x53,0x55,0x85,0x76,0x87,0xd2,
+	0xc9,0xa1,0xb0,0xa2,0x79,0x85,0xab,0xb9,
+	0xa9,0xb9,0xbd,0x84,0x71,0x9d,0x93,0x90,
+	0xd3,0xd9,0xa8,0xad,0xa5,0x7a,0x72,0x95,
+	0xa5,0x95,0x9a,0xaa,0x73,0x52,0x7b,0x81,
+	0x70,0xaf,0xcb,0xa3,0x9d,0xa5,0x80,0x6b,
+	0x7f,0x8b,0x60,0x6b,0x8f,0x64,0x27,0x49,
+	0x60,0x4c,0x83,0xb3,0x92,0x87,0x97,0x7e,
+	0x65,0x80,0xa3,0x9d,0x88,0x93,0x62,0x2c,
+	0x50,0x66,0x41,0x5a,0x8e,0x75,0x5d,0x66,
+	0x56,0x33,0x42,0x68,0x6a,0x59,0x72,0x6c,
+	0x31,0x34,0x5a,0x46,0x56,0x93,0x8d,0x69,
+	0x6f,0x6a,0x46,0x45,0x6f,0x7c,0x6b,0x7f,
+	0x8b,0x56,0x49,0x75,0x70,0x72,0xb1,0xc0,
+	0x9d,0x9c,0x9f,0x7e,0x71,0x97,0xb1,0x9d,
+	0xa5,0xbc,0x8c,0x6a,0x93,0x94,0x89,0xbe,
+	0xdc,0xb4,0xa4,0xa8,0x87,0x66,0x85,0xa2,
+	0x8e,0x8a,0xa1,0x78,0x46,0x64,0x70,0x5d,
+	0x84,0xad,0x92,0x75,0x7d,0x63,0x41,0x52,
+	0x79,0x70,0x67,0x83,0x70,0x3a,0x4e,0x6b,
+	0x5c,0x7b,0xb2,0xa4,0x89,0x90,0x87,0x66,
+	0x6f,0x9a,0x9f,0x91,0xae,0xa6,0x75,0x78,
+	0x9e,0x90,0xa2,0xd8,0xd6,0xb5,0xb9,0xb0,
+	0x8f,0x8b,0xb0,0xba,0xa6,0xb6,0xbb,0x83,
+	0x78,0x9d,0x92,0x93,0xcb,0xd1,0xac,0xa9,
+	0xa6,0x83,0x79,0x9c,0xaf,0x9b,0xa9,0xb4,
+	0x85,0x66,0x83,0x6d,0x51,0x78,0xac,0x84,
+	0x81,0x6f,0x46,0x3a,0x59,0x78,0x6e,0x76,
+	0x8f,0x71,0x51,0x75,0x7f,0x6e,0x95,0xa1,
+	0x71,0x52,0x72,0x5b,0x44,0x4b,0x56,0x50,
+	0x4b,0x64,0x4c,0x26,0x3e,0x53,0x41,0x65,
+	0x8c,0x73,0x62,0x6a,0x54,0x3d,0x4a,0x6a,
+	0x66,0x5f,0x73,0x67,0x38,0x46,0x64,0x53,
+	0x6d,0xa1,0x92,0x7b,0x88,0x79,0x5c,0x6a,
+	0x8e,0x96,0x8c,0xa1,0x9f,0x70,0x72,0x99,
+	0x8a,0x98,0xd6,0xce,0xae,0xb7,0xac,0x89,
+	0x8b,0xad,0xb6,0xa6,0xb0,0xb5,0x7d,0x69,
+	0x92,0x85,0x7e,0xbe,0xc1,0x90,0x93,0x8b,
+	0x5e,0x56,0x75,0x83,0x71,0x76,0x81,0x51,
+	0x2c,0x55,0x57,0x49,0x86,0x9c,0x70,0x70,
+	0x74,0x4e,0x47,0x6a,0x7e,0x79,0x7c,0x91,
+	0x6e,0x4b,0x6f,0x81,0x71,0xa6,0xd0,0xa6,
+	0xa0,0xb2,0x8c,0x81,0xa1,0xb5,0xb1,0xb3,
+	0xc0,0xa7,0x7f,0x93,0xab,0x94,0xb7,0xe7,
+	0xbe,0xac,0xbe,0x9b,0x81,0xa3,0xb1,0xaa,
+	0xac,0xb4,0x9f,0x76,0x7f,0x9b,0x89,0x9f,
+	0xd8,0xba,0x9d,0xb3,0x97,0x6b,0x80,0x82,
+	0x69,0x69,0x96,0x7f,0x5b,0x60,0x5e,0x55,
+	0x58,0x98,0x8b,0x68,0x81,0x7a,0x49,0x69,
+	0x7f,0x69,0x5b,0x5a,0x44,0x49,0x36,0x59,
+	0x51,0x37,0x6c,0x66,0x3c,0x4a,0x51,0x1d,
+	0x35,0x5f,0x55,0x56,0x6a,0x58,0x38,0x30,
+	0x46,0x4a,0x4a,0x78,0x89,0x5d,0x61,0x70,
+	0x42,0x48,0x7b,0x73,0x6f,0x8b,0x7d,0x5c,
+	0x59,0x6a,0x75,0x78,0xa0,0xba,0x99,0x91,
+	0xa9,0x80,0x7a,0xb1,0xb3,0xa6,0xc2,0xbb,
+	0x94,0x8d,0x99,0x9e,0xa0,0xbf,0xd8,0xb9,
+	0xa5,0xb4,0x92,0x78,0xa7,0xb0,0x95,0xaa,
+	0xa5,0x74,0x64,0x6d,0x6b,0x6b,0x81,0x9b,
+	0x80,0x65,0x71,0x57,0x38,0x5f,0x76,0x5c,
+	0x6f,0x76,0x4a,0x37,0x4b,0x4d,0x51,0x72,
+	0x8e,0x81,0x6d,0x78,0x6b,0x55,0x7a,0x9c,
+	0x8f,0x9f,0xb0,0x8d,0x76,0x8a,0x93,0x94,
+	0xb9,0xd4,0xc7,0xb7,0xbb,0xac,0x97,0xb1,
+	0xd0,0xc7,0xcb,0xd6,0xb7,0x97,0xa0,0xa8,
+	0xa4,0xbd,0xd7,0xc6,0xb3,0xb2,0xa1,0x8c,
+	0xa1,0xb8,0xb6,0xbb,0xbe,0xa6,0x8d,0x8a,
+	0x92,0x91,0x9b,0xa7,0x94,0x6b,0x5f,0x5c,
+	0x70,0x73,0x8e,0x99,0x85,0x80,0x65,0x54,
+	0x50,0x51,0x5b,0x61,0x67,0x5c,0x3c,0x39,
+	0x56,0x44,0x4c,0x73,0x57,0x5a,0x52,0x3d,
+	0x2f,0x2e,0x29,0x3f,0x48,0x55,0x5e,0x55,
+	0x44,0x47,0x3a,0x42,0x59,0x5d,0x64,0x6a,
+	0x54,0x50,0x4b,0x44,0x58,0x6c,0x6b,0x7a,
+	0x79,0x64,0x64,0x67,0x66,0x7d,0x8d,0x94,
+	0x9b,0x8f,0x86,0x8d,0x81,0x94,0xb3,0xaf,
+	0xb9,0xc6,0xa9,0xa2,0xaf,0xa8,0xb1,0xcc,
+	0xcb,0xc9,0xbd,0xaf,0xad,0x9e,0xa4,0xbe,
+	0xb2,0xac,0xbc,0x99,0x7a,0x8d,0x81,0x74,
+	0x8e,0x8f,0x7d,0x74,0x65,0x59,0x4b,0x4f,
+	0x66,0x61,0x54,0x69,0x53,0x2f,0x46,0x4c,
+	0x39,0x5a,0x70,0x5c,0x59,0x63,0x58,0x52,
+	0x61,0x80,0x82,0x7f,0x9a,0x92,0x6e,0x8b,
+	0x9c,0x86,0xa2,0xc4,0xae,0xa9,0xb9,0xae,
+	0xa0,0xb2,0xcb,0xc8,0xbe,0xd3,0xcb,0xa3,
+	0xb1,0xc8,0xa8,0xb5,0xdc,0xc0,0xad,0xc3,
+	0xb4,0x9e,0xac,0xc0,0xb6,0xae,0xbf,0xb9,
+	0x94,0x9d,0xb0,0x97,0x99,0xbd,0xa3,0x87,
+	0x95,0x81,0x5a,0x5c,0x77,0x80,0x94,0x91,
+	0x8f,0x85,0x77,0x7c,0x57,0x4a,0x5e,0x45,
+	0x1d,0x31,0x43,0x47,0x4d,0x5d,0x69,0x58,
+	0x61,0x51,0x2d,0x33,0x44,0x32,0x2e,0x50,
+	0x4d,0x34,0x4a,0x54,0x3a,0x40,0x5f,0x53,
+	0x46,0x5e,0x5e,0x42,0x4a,0x60,0x4d,0x48,
+	0x68,0x68,0x50,0x63,0x74,0x5e,0x63,0x84,
+	0x7c,0x70,0x8a,0x92,0x7d,0x85,0xa1,0x90,
+	0x8e,0xaf,0xb0,0x9d,0xb1,0xc4,0xb2,0xb3,
+	0xce,0xcb,0xba,0xcb,0xd6,0xb7,0xb9,0xcf,
+	0xba,0xa9,0xc2,0xbd,0x9f,0xac,0xb5,0x9d,
+	0x94,0xa3,0x9a,0x7f,0x84,0x8a,0x6c,0x5e,
+	0x72,0x5d,0x44,0x58,0x56,0x3a,0x45,0x53,
+	0x42,0x3d,0x4c,0x4f,0x3c,0x45,0x58,0x48,
+	0x44,0x5d,0x5a,0x48,0x62,0x6e,0x5d,0x6e,
+	0x88,0x83,0x85,0x99,0xa0,0x96,0x9f,0xb4,
+	0xad,0xa6,0xbe,0xbf,0xaa,0xba,0xc7,0xb4,
+	0xbe,0xd3,0xc9,0xc7,0xd2,0xd2,0xc2,0xc5,
+	0xcc,0xc9,0xbc,0xc6,0xc7,0xae,0xb2,0xbd,
+	0xaa,0xac,0xc0,0xb7,0xb4,0xbb,0xb4,0xab,
+	0xa6,0xa5,0xa0,0x90,0x8a,0x81,0x63,0x55,
+	0x61,0x6b,0x8e,0x98,0x74,0x87,0x9b,0x81,
+	0x66,0x4b,0x34,0x2b,0x2a,0x3d,0x62,0x4e,
+	0x2b,0x4f,0x5a,0x50,0x54,0x4a,0x40,0x42,
+	0x39,0x30,0x35,0x31,0x37,0x42,0x3c,0x41,
+	0x3f,0x36,0x37,0x3b,0x39,0x4b,0x50,0x52,
+	0x5b,0x54,0x50,0x59,0x55,0x5a,0x6c,0x69,
+	0x6a,0x72,0x67,0x67,0x6f,0x73,0x85,0x91,
+	0x96,0xa2,0x9d,0x99,0xa7,0xa5,0xa8,0xc1,
+	0xc1,0xbc,0xc6,0xb9,0xb0,0xb9,0xbd,0xc3,
+	0xcd,0xcf,0xd3,0xc6,0xba,0xc0,0xb4,0xab,
+	0xbd,0xb6,0xa3,0xa7,0x94,0x7f,0x7d,0x7a,
+	0x79,0x7b,0x79,0x78,0x6a,0x5a,0x5a,0x53,
+	0x47,0x59,0x59,0x49,0x4e,0x47,0x35,0x36,
+	0x40,0x44,0x4e,0x57,0x5f,0x5d,0x52,0x5e,
+	0x61,0x5e,0x73,0x84,0x7b,0x83,0x88,0x7a,
+	0x7c,0x8d,0x94,0x9f,0xab,0xb7,0xb5,0xaa,
+	0xb2,0xb5,0xad,0xbd,0xcf,0xc1,0xc2,0xc5,
+	0xb5,0xab,0xb5,0xbb,0xbc,0xc4,0xce,0xc5,
+	0xb6,0xb7,0xb9,0xab,0xb4,0xc6,0xb9,0xaf,
+	0xb6,0xa4,0x92,0x99,0x99,0x95,0x95,0x92,
+	0x84,0x69,0x61,0x68,0x6e,0x8e,0xa7,0x7c,
+	0x72,0x91,0x82,0x5d,0x51,0x44,0x35,0x3c,
+	0x55,0x6e,0x5f,0x40,0x4e,0x5e,0x64,0x73,
+	0x64,0x4f,0x50,0x48,0x34,0x37,0x42,0x41,
+	0x46,0x52,0x56,0x47,0x45,0x4e,0x47,0x45,
+	0x5d,0x63,0x54,0x5e,0x5f,0x4a,0x4d,0x60,
+	0x63,0x67,0x78,0x7f,0x74,0x6f,0x7d,0x79,
+	0x78,0x92,0x9e,0x91,0x9a,0x9f,0x90,0x8c,
+	0xa3,0xa8,0xac,0xbc,0xc8,0xba,0xb3,0xbc,
+	0xba,0xb0,0xc5,0xd2,0xc1,0xbe,0xc3,0xae,
+	0x9e,0xa9,0xae,0xa5,0xac,0xb4,0xa1,0x8c,
+	0x8e,0x85,0x73,0x7d,0x86,0x7e,0x6c,0x69,
+	0x67,0x4e,0x3f,0x43,0x42,0x4b,0x49,0x4c,
+	0x49,0x4b,0x47,0x4a,0x48,0x4b,0x4c,0x4e,
+	0x4f,0x55,0x59,0x5d,0x63,0x68,0x6f,0x78,
+	0x7b,0x83,0x89,0x8e,0x94,0x8e,0x60,0x58,
+	0x75,0x9b,0xba,0xcc,0xd2,0xd9,0xd8,0xd5,
+	0xd7,0xd3,0xcf,0xcf,0xc9,0xc5,0xc6,0xbe,
+	0xba,0xbc,0xb1,0xb2,0xaf,0xa7,0xab,0xa6,
+	0xa0,0xa4,0x9e,0x9c,0x9c,0x96,0x94,0x94,
+	0x8c,0x89,0x8a,0x81,0x80,0x81,0x76,0x7a,
+	0x77,0x6f,0x74,0x70,0x6a,0x70,0x67,0x65,
+	0x69,0x60,0x5e,0x61,0x58,0x58,0x59,0x52,
+	0x55,0x56,0x4f,0x54,0x54,0x4c,0x55,0x50,
+	0x4c,0x54,0x4d,0x4b,0x52,0x4c,0x4c,0x52,
+	0x49,0x4f,0x51,0x4c,0x53,0x54,0x4e,0x58,
+	0x55,0x53,0x5a,0x57,0x56,0x5e,0x5a,0x58,
+	0x62,0x5c,0x5e,0x67,0x5f,0x68,0x59,0x31,
+	0x4f,0x67,0x4f,0x8f,0xa3,0x71,0x77,0x72,
+	0x3b,0x43,0x69,0x7b,0x8c,0xa2,0xa0,0x83,
+	0x7c,0x7a,0x78,0x8e,0xa5,0x9b,0x94,0x8d,
+	0x75,0x72,0x88,0x8c,0x95,0x9b,0x82,0x71,
+	0x69,0x63,0x6e,0x76,0x79,0x77,0x5f,0x54,
+	0x54,0x4b,0x54,0x71,0x5e,0x59,0x68,0x47,
+	0x4e,0x73,0x66,0x77,0x9d,0x75,0x71,0x96,
+	0x69,0x71,0xa3,0x77,0x7f,0xa2,0x79,0x83,
+	0xad,0x94,0xa1,0xc4,0xac,0xa8,0xb9,0xa8,
+	0x9e,0xaf,0xac,0x99,0xa0,0xa8,0x88,0x9b,
+	0xb8,0x94,0xa3,0xc3,0x97,0xa0,0xc4,0x8d,
+	0x94,0xb9,0x7b,0x88,0xbe,0x86,0x91,0xbf,
+	0x81,0x88,0xb8,0x7d,0x7f,0xa6,0x72,0x6f,
+	0xa1,0x80,0x7e,0xbd,0xb1,0x9a,0xbc,0x9c,
+	0x65,0x75,0x6f,0x4d,0x83,0xa4,0x7a,0x9f,
+	0xbb,0x7d,0xa2,0xca,0x8e,0xa1,0xbc,0x6b,
+	0x7e,0xae,0x73,0x94,0xcc,0x88,0x8f,0xb5,
+	0x73,0x78,0xb4,0x86,0x82,0xad,0x6f,0x4e,
+	0x7c,0x5d,0x51,0x95,0x7d,0x52,0x7e,0x68,
+	0x3c,0x80,0x8e,0x68,0x97,0x91,0x46,0x66,
+	0x7c,0x53,0x8b,0xb0,0x76,0x81,0x92,0x5d,
+	0x79,0xba,0xa0,0xad,0xca,0x8d,0x71,0x97,
+	0x84,0x92,0xd4,0xbd,0x7a,0x74,0x56,0x36,
+	0x7f,0x93,0x8c,0xad,0x8c,0x5a,0x6f,0x75,
+	0x7c,0xb4,0xa8,0x6a,0x5f,0x37,0x2d,0x4e,
+	0x6f,0x88,0x91,0x7f,0x67,0x4d,0x4e,0x6f,
+	0x89,0x9f,0xa8,0x83,0x63,0x5a,0x52,0x6c,
+	0x95,0x99,0x8e,0x74,0x52,0x45,0x53,0x7a,
+	0x97,0x9b,0x9d,0x7b,0x53,0x69,0x7b,0x86,
+	0xc3,0xbb,0x84,0x8d,0x68,0x43,0x8b,0x9f,
+	0x88,0xb5,0x8c,0x41,0x66,0x66,0x5f,0xb2,
+	0xbe,0x8a,0x96,0x78,0x4b,0x78,0xa6,0xa0,
+	0xb5,0xb6,0x7d,0x65,0x87,0x69,0x6f,0xb1,
+	0x97,0x66,0x79,0x52,0x2b,0x89,0x93,0x76,
+	0xb0,0x87,0x35,0x79,0x6d,0x3c,0x9f,0x9f,
+	0x60,0x81,0x64,0x29,0x74,0x9a,0x87,0xb4,
+	0xa9,0x60,0x63,0x76,0x6c,0x94,0xc0,0x9c,
+	0x74,0x74,0x45,0x37,0x7e,0x89,0x78,0x9f,
+	0x74,0x30,0x63,0x6e,0x68,0xc0,0xc4,0x8c,
+	0xa3,0x84,0x5a,0x98,0xb1,0x9d,0xbe,0x9f,
+	0x5b,0x61,0x61,0x5d,0x8f,0xa0,0x8d,0x7f,
+	0x6c,0x5c,0x6e,0x8f,0xab,0xb2,0xaf,0x99,
+	0x79,0x79,0x93,0xa2,0xc1,0xb7,0x80,0x6f,
+	0x58,0x52,0x6a,0x8a,0x8f,0x94,0x7c,0x62,
+	0x57,0x56,0x6f,0x8f,0x92,0x9a,0x6b,0x3c,
+	0x45,0x56,0x5c,0x8b,0x9d,0x76,0x84,0x7d,
+	0x5c,0x84,0xa6,0x8e,0xa9,0xa8,0x68,0x6c,
+	0x79,0x5d,0x77,0x96,0x6c,0x62,0x6e,0x44,
+	0x4b,0x7e,0x79,0x7a,0x9f,0x87,0x65,0x93,
+	0x92,0x81,0xbb,0xbd,0x87,0xa6,0x9d,0x64,
+	0x91,0xa7,0x71,0x93,0x9b,0x54,0x6a,0x86,
+	0x57,0x7b,0xa6,0x73,0x80,0xa6,0x79,0x85,
+	0xbc,0xa1,0xa3,0xd3,0xaf,0x97,0x9f,0x7e,
+	0x6a,0x87,0x7b,0x58,0x80,0x75,0x51,0x78,
+	0x7b,0x58,0x7a,0x84,0x65,0x82,0x96,0x59,
+	0x54,0x6b,0x3c,0x51,0x6e,0x5b,0x65,0x84,
+	0x72,0x78,0x98,0x8f,0x8e,0xaa,0x98,0x84,
+	0x8d,0x7b,0x69,0x79,0x6f,0x5a,0x62,0x53,
+	0x43,0x57,0x61,0x6a,0x84,0x89,0x86,0x91,
+	0x91,0x98,0xab,0xb1,0xb5,0xac,0x9a,0x92,
+	0x88,0x83,0x90,0x91,0x87,0x87,0x76,0x65,
+	0x73,0x7a,0x81,0x99,0x95,0x88,0x89,0x8a,
+	0x8c,0xa6,0xbf,0xc1,0xc7,0xc4,0x9f,0x78,
+	0x92,0x91,0x83,0x90,0x77,0x5e,0x68,0x57,
+	0x55,0x7e,0x7a,0x68,0x7f,0x6c,0x56,0x80,
+	0x70,0x4a,0x83,0x69,0x39,0x54,0x51,0x43,
+	0x7c,0x8e,0x77,0x92,0x87,0x60,0x7e,0x95,
+	0x86,0xa6,0xae,0x79,0x6d,0x70,0x4b,0x5c,
+	0x83,0x68,0x60,0x6f,0x43,0x3e,0x77,0x7a,
+	0x89,0xc3,0xaa,0x86,0xac,0x98,0x88,0xca,
+	0xc3,0x96,0xb0,0x85,0x49,0x78,0x7d,0x67,
+	0x9f,0x98,0x5f,0x78,0x79,0x5e,0x9c,0xbe,
+	0x9e,0xb5,0xb0,0x7e,0x92,0xbb,0xb0,0xc9,
+	0xc5,0x7e,0x78,0x7d,0x55,0x5f,0x9d,0x8e,
+	0x79,0x8e,0x5c,0x3a,0x6e,0x73,0x6a,0xa8,
+	0x8d,0x4c,0x47,0x3c,0x30,0x6a,0x78,0x5a,
+	0x81,0x6e,0x3d,0x6d,0x83,0x7a,0xaa,0xac,
+	0x75,0x78,0x75,0x58,0x82,0xa0,0x88,0x85,
+	0x7b,0x47,0x47,0x67,0x66,0x78,0x94,0x74,
+	0x5a,0x70,0x66,0x76,0xb5,0xb9,0xa8,0xbb,
+	0x96,0x77,0xa1,0xa3,0x99,0xbe,0x9e,0x67,
+	0x73,0x60,0x50,0x8a,0x96,0x81,0x97,0x85,
+	0x63,0x8b,0xa1,0xa4,0xcf,0xd2,0xa7,0xae,
+	0xa6,0x8c,0x8e,0xa0,0x96,0x8c,0x73,0x4c,
+	0x52,0x71,0x73,0x88,0x9b,0x76,0x67,0x6e,
+	0x5e,0x71,0x97,0x7d,0x56,0x63,0x42,0x27,
+	0x48,0x56,0x67,0x8e,0x7f,0x68,0x73,0x6d,
+	0x70,0x9c,0xa3,0x92,0x95,0x78,0x58,0x6b,
+	0x77,0x75,0x90,0x88,0x62,0x5f,0x5d,0x57,
+	0x7b,0x96,0x8d,0x90,0x8b,0x6a,0x77,0x93,
+	0x97,0xb0,0xbb,0x95,0x87,0x85,0x75,0x88,
+	0xa7,0x99,0x92,0x8c,0x65,0x60,0x77,0x81,
+	0x97,0xad,0x99,0x8a,0x8d,0x8a,0x9e,0xc5,
+	0xd1,0xce,0xc6,0xa5,0x71,0x72,0x92,0x8e,
+	0x8e,0x7f,0x5f,0x55,0x59,0x55,0x78,0x90,
+	0x8a,0x88,0x81,0x5f,0x62,0x57,0x50,0x75,
+	0x6f,0x40,0x39,0x3c,0x39,0x5f,0x7f,0x81,
+	0x89,0x82,0x66,0x70,0x83,0x8a,0xa2,0xa5,
+	0x89,0x76,0x65,0x5d,0x6d,0x81,0x87,0x83,
+	0x75,0x63,0x58,0x6c,0x83,0x94,0xa5,0xa0,
+	0x83,0x7e,0x7f,0x7f,0x9e,0xaf,0x99,0x95,
+	0x85,0x5f,0x73,0x89,0x84,0xa1,0xa0,0x74,
+	0x7d,0x7b,0x70,0xa1,0xb8,0xa3,0xb7,0xa8,
+	0x85,0xa5,0xb5,0xb5,0xda,0xca,0x97,0x79,
+	0x75,0x71,0x8d,0x89,0x77,0x7e,0x68,0x54,
+	0x5d,0x6d,0x7b,0x90,0x92,0x78,0x48,0x37,
+	0x48,0x4f,0x63,0x5b,0x4c,0x52,0x45,0x32,
+	0x5a,0x6d,0x70,0x94,0x89,0x64,0x78,0x72,
+	0x6a,0xa2,0xa4,0x87,0x9d,0x7b,0x56,0x81,
+	0x83,0x7a,0xaa,0x92,0x68,0x7f,0x6b,0x62,
+	0x9d,0x9c,0x8c,0xa2,0x7d,0x64,0x7d,0x80,
+	0x84,0xa3,0x96,0x78,0x77,0x6c,0x69,0x87,
+	0x9b,0x9a,0x99,0x93,0x7c,0x81,0xa0,0xaa,
+	0xb9,0xd2,0xb6,0xa2,0xb4,0xa6,0xae,0xd5,
+	0xb9,0x8f,0x8b,0x7c,0x62,0x97,0x74,0x6c,
+	0x95,0x70,0x58,0x77,0x5e,0x63,0x92,0x72,
+	0x47,0x6a,0x45,0x33,0x4a,0x36,0x41,0x67,
+	0x54,0x3c,0x56,0x45,0x4f,0x7f,0x87,0x7e,
+	0x92,0x78,0x66,0x80,0x8c,0x8c,0xac,0xa1,
+	0x7f,0x80,0x7e,0x6f,0x94,0xa9,0x90,0x98,
+	0x90,0x63,0x76,0x91,0x7e,0x99,0xa3,0x6b,
+	0x6c,0x73,0x52,0x76,0x9c,0x79,0x86,0x8d,
+	0x5a,0x6e,0x96,0x86,0xa6,0xc1,0x92,0x90,
+	0xa5,0x83,0xa2,0xcd,0xb7,0xb8,0xc8,0x99,
+	0x9b,0xbf,0xb0,0xb0,0xbd,0x7a,0x76,0x8d,
+	0x72,0x6c,0x88,0x78,0x6a,0x84,0x5e,0x52,
+	0x73,0x5b,0x4b,0x86,0x6a,0x4f,0x53,0x3a,
+	0x37,0x68,0x5e,0x54,0x6b,0x4e,0x41,0x64,
+	0x67,0x6e,0x94,0x86,0x75,0x87,0x7f,0x7e,
+	0xa0,0xa4,0x9a,0x9f,0x8c,0x78,0x82,0x8b,
+	0x8b,0x99,0x98,0x80,0x7a,0x7f,0x74,0x83,
+	0x97,0x86,0x7d,0x7e,0x60,0x5b,0x78,0x6d,
+	0x76,0x8b,0x6e,0x6d,0x84,0x74,0x8a,0xb5,
+	0xa0,0xa9,0xb5,0x91,0x99,0xb1,0x9e,0xb0,
+	0xba,0x98,0x9b,0x9f,0x89,0xa2,0xab,0x92,
+	0x8d,0x8b,0x7f,0x89,0x89,0x73,0x8a,0x7a,
+	0x72,0x75,0x56,0x46,0x58,0x57,0x68,0x6f,
+	0x47,0x56,0x5e,0x4a,0x69,0x73,0x5b,0x72,
+	0x6b,0x50,0x6a,0x6b,0x5b,0x7d,0x7c,0x6a,
+	0x8b,0x89,0x81,0xa0,0xa0,0x93,0xa7,0xa0,
+	0x8d,0x9b,0x92,0x83,0x86,0x84,0x75,0x78,
+	0x81,0x72,0x72,0x82,0x74,0x72,0x8a,0x79,
+	0x73,0x8c,0x73,0x64,0x88,0x70,0x6b,0x98,
+	0x80,0x73,0xa5,0x84,0x83,0xbe,0xa1,0x9a,
+	0xcd,0x98,0x8c,0xb8,0x8d,0x8a,0xbd,0x88,
+	0x80,0x9d,0x62,0x5c,0x9f,0x7c,0x8b,0xa7,
+	0x72,0x6e,0x8f,0x6c,0x6f,0x86,0x64,0x62,
+	0x6f,0x45,0x40,0x65,0x5d,0x66,0x7a,0x67,
+	0x5a,0x6f,0x6d,0x74,0x8e,0x8b,0x74,0x77,
+	0x6a,0x5c,0x79,0x8c,0x84,0x97,0x92,0x74,
+	0x85,0x95,0x8d,0xb1,0xb6,0x91,0x90,0x81,
+	0x62,0x7e,0x88,0x77,0x86,0x76,0x52,0x60,
+	0x68,0x6b,0x94,0x99,0x86,0x86,0x74,0x6a,
+	0x83,0x8e,0x96,0x9d,0x84,0x76,0x74,0x71,
+	0x91,0xa6,0xab,0xae,0x9d,0x82,0x8f,0x93,
+	0x9c,0xb8,0xa8,0x88,0x7e,0x54,0x55,0x80,
+	0x87,0x8d,0x97,0x76,0x60,0x72,0x69,0x72,
+	0xa4,0x91,0x7a,0x70,0x48,0x42,0x68,0x6d,
+	0x72,0x86,0x66,0x4c,0x60,0x66,0x74,0xa3,
+	0xa3,0x87,0x86,0x71,0x5b,0x82,0x96,0x8b,
+	0x9e,0x8d,0x5d,0x6f,0x7e,0x78,0xab,0xba,
+	0x8f,0x91,0x84,0x59,0x83,0x9b,0x7e,0x96,
+	0x87,0x42,0x57,0x65,0x53,0x8f,0xa6,0x79,
+	0x87,0x83,0x59,0x89,0xa9,0x93,0xb0,0xa7,
+	0x64,0x70,0x7d,0x6a,0x99,0xb2,0x8a,0x8d,
+	0x89,0x64,0x86,0xad,0xa0,0xae,0xa8,0x6a,
+	0x63,0x76,0x68,0x81,0x9d,0x7d,0x6d,0x70,
+	0x4b,0x57,0x8f,0x8e,0x92,0x9c,0x6b,0x59,
+	0x6e,0x64,0x71,0x97,0x7a,0x67,0x6a,0x4a,
+	0x54,0x84,0x89,0x92,0xa3,0x82,0x6e,0x82,
+	0x7c,0x8f,0xae,0x98,0x85,0x7d,0x60,0x63,
+	0x83,0x8b,0x96,0x9a,0x81,0x72,0x74,0x79,
+	0x8d,0x9b,0x95,0x87,0x6e,0x5f,0x5e,0x6b,
+	0x7c,0x8b,0x85,0x7c,0x71,0x6c,0x80,0x96,
+	0xa1,0xa8,0xa1,0x86,0x7c,0x7c,0x7b,0x8e,
+	0x98,0x8b,0x83,0x78,0x6a,0x75,0x8f,0x97,
+	0x9c,0x9a,0x86,0x77,0x7b,0x7b,0x80,0x92,
+	0x88,0x71,0x68,0x5b,0x57,0x77,0x83,0x7f,
+	0x90,0x80,0x65,0x79,0x78,0x76,0x97,0x8f,
+	0x70,0x78,0x65,0x51,0x79,0x80,0x7c,0x97,
+	0x87,0x6d,0x84,0x85,0x83,0xa7,0xa4,0x88,
+	0x8d,0x78,0x64,0x7a,0x84,0x7d,0x8a,0x86,
+	0x67,0x6f,0x7d,0x76,0x8e,0xa0,0x88,0x81,
+	0x84,0x65,0x6d,0x8e,0x7a,0x7e,0x92,0x6a,
+	0x65,0x88,0x74,0x87,0xaf,0x8e,0x88,0xa1,
+	0x73,0x7a,0xa0,0x84,0x86,0x9e,0x6e,0x67,
+	0x84,0x69,0x75,0xa0,0x84,0x81,0x95,0x74,
+	0x74,0x94,0x86,0x7f,0x8f,0x74,0x62,0x74,
+	0x69,0x66,0x85,0x83,0x6e,0x80,0x7c,0x67,
+	0x89,0x93,0x7d,0x92,0x8f,0x62,0x7a,0x80,
+	0x61,0x87,0x93,0x68,0x85,0x89,0x63,0x8e,
+	0x9f,0x79,0x9f,0x9f,0x6a,0x88,0x8b,0x64,
+	0x8a,0x8e,0x65,0x7e,0x7d,0x5d,0x7d,0x8d,
+	0x76,0x8d,0x95,0x77,0x81,0x8c,0x78,0x81,
+	0x93,0x7c,0x74,0x87,0x70,0x6d,0x90,0x84,
+	0x7d,0x9d,0x89,0x75,0x9b,0x88,0x79,0xa3,
+	0x8c,0x6c,0x91,0x73,0x5c,0x8f,0x7e,0x69,
+	0x96,0x7f,0x68,0x94,0x80,0x70,0x9c,0x89,
+	0x71,0x8f,0x75,0x63,0x80,0x78,0x6b,0x84,
+	0x7c,0x6b,0x7c,0x84,0x77,0x88,0x96,0x7e,
+	0x83,0x8e,0x72,0x77,0x91,0x76,0x77,0x93,
+	0x6d,0x6e,0x93,0x73,0x7b,0xa4,0x7d,0x7b,
+	0x9e,0x73,0x76,0x9b,0x73,0x77,0x95,0x6a,
+	0x6c,0x8a,0x6b,0x75,0x96,0x7c,0x7b,0x93,
+	0x7c,0x7a,0x94,0x86,0x7d,0x91,0x81,0x6f,
+	0x82,0x7f,0x72,0x89,0x8e,0x75,0x88,0x8f,
+	0x73,0x8a,0x98,0x75,0x8b,0x94,0x69,0x7f,
+	0x8a,0x65,0x7e,0x90,0x68,0x80,0x8d,0x66,
+	0x80,0x95,0x72,0x88,0x94,0x6e,0x7b,0x8a,
+	0x6c,0x79,0x8d,0x6f,0x77,0x86,0x70,0x76,
+	0x8e,0x7d,0x7f,0x95,0x81,0x78,0x8f,0x7f,
+	0x76,0x8f,0x82,0x70,0x8a,0x7a,0x6b,0x8c,
+	0x84,0x72,0x92,0x88,0x70,0x8f,0x85,0x72,
+	0x90,0x87,0x6d,0x88,0x81,0x68,0x83,0x87,
+	0x70,0x87,0x8d,0x70,0x85,0x8f,0x75,0x88,
+	0x98,0x77,0x82,0x8f,0x6e,0x7a,0x91,0x76,
+	0x7d,0x94,0x76,0x76,0x8e,0x77,0x7c,0x9b,
+	0x7d,0x7b,0x8b,0x77,0x7b,0x8b,0x82,0x7c,
+	0x7c,0x6d,0x6f,0x79,0x84,0x83,0x80,0x83,
+	0x80,0x7c,0x85,0x7e,0x7d,0x84,0x7b,0x7f,
+	0x80,0x7a,0x7f,0x7f,0x7b,0x81,0x84,0x7d,
+	0x86,0x83,0x7d,0x87,0x80,0x7c,0x86,0x7c,
+	0x7e,0x84,0x79,0x80,0x84,0x7b,0x82,0x84,
+	0x7a,0x86,0x82,0x7c,0x86,0x80,0x7b,0x87,
+	0x7c,0x7e,0x86,0x7b,0x7e,0x86,0x7a,0x82,
+	0x84,0x79,0x86,0x82,0x79,0x87,0x80,0x7b,
+	0x87,0x7c,0x7e,0x88,0x7a,0x80,0x85,0x7b,
+	0x82,0x84,0x7a,0x83,0x82,0x7a,0x84,0x81,
+	0x7b,0x84,0x7f,0x7e,0x86,0x7e,0x7f,0x86,
+	0x7b,0x80,0x85,0x7b,0x81,0x82,0x79,0x83,
+	0x7f,0x7c,0x84,0x81,0x7d,0x86,0x7e,0x80,
+	0x86,0x7e,0x7f,0x84,0x7b,0x81,0x80,0x7a,
+	0x82,0x7f,0x7d,0x83,0x80,0x7f,0x86,0x80,
+	0x80,0x85,0x7e,0x80,0x85,0x60,0x37,0x6b,
+	0x62,0x7e,0xcd,0x8a,0x85,0x79,0x3e,0x7f,
+	0x65,0x67,0xb1,0x52,0x88,0xab,0x58,0xaa,
+	0x89,0x4e,0xa7,0x68,0x73,0xb8,0x5b,0x84,
+	0x8f,0x40,0x98,0x84,0x61,0xa8,0x59,0x52,
+	0x8b,0x44,0x7d,0x8f,0x41,0x7d,0x57,0x35,
+	0x88,0x51,0x65,0x83,0x2a,0x54,0x5c,0x3d,
+	0x8b,0x74,0x53,0x80,0x3f,0x4b,0x88,0x46,
+	0x70,0x68,0x1c,0x5c,0x4b,0x4d,0xa1,0x69,
+	0x6c,0x83,0x3f,0x75,0x8c,0x60,0x93,0x5b,
+	0x34,0x6b,0x48,0x74,0xaa,0x69,0x8e,0x7d,
+	0x57,0xa7,0x96,0x9a,0xb5,0x64,0x66,0x76,
+	0x66,0xa3,0xad,0x8c,0x98,0x7b,0x7a,0xbc,
+	0xbb,0xbf,0xc4,0x72,0x74,0x86,0x76,0xc1,
+	0xa9,0x7f,0x92,0x56,0x84,0xb9,0xa5,0xd0,
+	0x95,0x64,0x71,0x5b,0x8a,0x9b,0x82,0x70,
+	0x44,0x45,0x5e,0x86,0xa0,0x8a,0x76,0x47,
+	0x44,0x66,0x70,0x8e,0x70,0x47,0x40,0x33,
+	0x64,0x87,0x8e,0x8f,0x65,0x5d,0x60,0x81,
+	0xa0,0x98,0x99,0x66,0x59,0x75,0x77,0xb8,
+	0xbd,0x98,0xa2,0x70,0x8c,0xbd,0xb7,0xd9,
+	0xaf,0x77,0x8e,0x7d,0xa9,0xda,0xb7,0xaa,
+	0x95,0x6e,0x9e,0xc5,0xba,0xca,0x94,0x54,
+	0x70,0x64,0x7f,0xc2,0x9a,0x90,0x74,0x5c,
+	0xa1,0x9c,0x80,0xa2,0x41,0x30,0x4f,0x36,
+	0x95,0xb5,0x64,0x84,0x60,0x45,0x8c,0x7a,
+	0x8b,0x98,0x47,0x4e,0x63,0x55,0x9c,0x9b,
+	0x6a,0x73,0x3e,0x45,0x8e,0x7f,0x9a,0x91,
+	0x41,0x5b,0x5b,0x62,0xa5,0x83,0x61,0x5d,
+	0x27,0x4e,0x7c,0x75,0x92,0x74,0x44,0x5c,
+	0x5f,0x81,0xad,0x91,0x7f,0x6e,0x55,0x7f,
+	0xa3,0xae,0xb9,0x99,0x84,0x8c,0xa3,0xc9,
+	0xdb,0xce,0xb1,0x98,0x9b,0xaa,0xcc,0xd4,
+	0xbd,0xab,0x8b,0x8e,0xac,0xb7,0xc0,0xb1,
+	0x83,0x76,0x75,0x78,0x97,0x91,0x6f,0x67,
+	0x49,0x45,0x77,0x6a,0x77,0x7c,0x3c,0x54,
+	0x5a,0x4c,0x94,0x6f,0x5e,0x79,0x3c,0x6e,
+	0x93,0x75,0xae,0x8f,0x6f,0x9f,0x85,0x9f,
+	0xcc,0xa4,0xaa,0xb0,0x86,0xb3,0xc6,0xaa,
+	0xd6,0xb2,0x94,0xc7,0x9e,0xb1,0xdd,0x8f,
+	0xb5,0xa7,0x6c,0xbb,0x91,0x87,0xb9,0x65,
+	0x83,0x92,0x5a,0x9d,0x82,0x61,0x8c,0x55,
+	0x5f,0x7d,0x53,0x6f,0x73,0x4a,0x6b,0x69,
+	0x58,0x87,0x78,0x6c,0x9c,0x79,0x88,0xab,
+	0x6a,0x6d,0x73,0x51,0x83,0x72,0x71,0xb5,
+	0x81,0xad,0xc8,0x9b,0xd3,0xb0,0x71,0x97,
+	0x7c,0x7f,0x95,0x78,0x93,0x8b,0x81,0x9b,
+	0x93,0x8e,0x8c,0x7c,0x70,0x7a,0x76,0x6f,
+	0x77,0x5a,0x51,0x58,0x46,0x5f,0x63,0x4e,
+	0x58,0x3b,0x3b,0x51,0x46,0x59,0x4d,0x3d,
+	0x3f,0x37,0x52,0x5d,0x69,0x72,0x58,0x68,
+	0x67,0x77,0xa0,0x8c,0x9a,0x90,0x74,0x9f,
+	0x9d,0xac,0xd0,0xa3,0xac,0xad,0x9b,0xcc,
+	0xcb,0xc0,0xca,0x9b,0x97,0xac,0xa1,0xb7,
+	0xb5,0x8b,0x87,0x7c,0x71,0x99,0x94,0x7c,
+	0x84,0x4e,0x4c,0x6e,0x52,0x79,0x6e,0x35,
+	0x53,0x38,0x40,0x82,0x5b,0x6d,0x6a,0x30,
+	0x65,0x6a,0x69,0xa2,0x72,0x66,0x7a,0x5a,
+	0x91,0xb1,0x99,0xb3,0x95,0x7b,0xab,0xa9,
+	0xbb,0xda,0xa4,0x9d,0xa4,0x86,0xc3,0xcb,
+	0xac,0xc5,0x8d,0x84,0xb5,0x99,0xc0,0xc1,
+	0x79,0x90,0x73,0x6b,0xad,0x89,0x8a,0x90,
+	0x4c,0x70,0x84,0x79,0xaf,0x86,0x5f,0x73,
+	0x4b,0x72,0x9f,0x7c,0x8f,0x76,0x4c,0x8a,
+	0x8d,0xa1,0xc7,0x7b,0x56,0x5e,0x51,0x8c,
+	0x8f,0x7c,0x97,0x63,0x64,0x97,0x91,0xb4,
+	0xa5,0x55,0x6f,0x65,0x5a,0x90,0x8b,0x7d,
+	0x7e,0x47,0x52,0x74,0x6e,0x9a,0x87,0x55,
+	0x66,0x4f,0x63,0x98,0x77,0x77,0x5f,0x27,
+	0x50,0x4f,0x5b,0x7e,0x49,0x3f,0x3e,0x2d,
+	0x6a,0x74,0x6e,0x71,0x41,0x3e,0x54,0x5f,
+	0x81,0x7c,0x65,0x58,0x57,0x6e,0x93,0xb0,
+	0xa7,0x9e,0x8c,0x82,0xa9,0xb7,0xc6,0xc8,
+	0x98,0x99,0x97,0xa0,0xd6,0xcd,0xc6,0xb9,
+	0x8f,0xa7,0xaf,0xba,0xcc,0x9b,0x85,0x6c,
+	0x5f,0x86,0x87,0x8c,0x7b,0x50,0x54,0x51,
+	0x6a,0x83,0x6a,0x62,0x38,0x29,0x43,0x46,
+	0x6a,0x61,0x46,0x49,0x38,0x5a,0x85,0x87,
+	0x97,0x77,0x65,0x71,0x79,0x9f,0xa8,0x9b,
+	0x91,0x7b,0x8f,0xaa,0xc6,0xdb,0xc6,0xb6,
+	0xa5,0xaa,0xc8,0xcb,0xd0,0xb5,0x91,0x90,
+	0x8f,0xac,0xc9,0xb4,0xb2,0x92,0x85,0xa0,
+	0xa2,0xb7,0xaa,0x79,0x6d,0x59,0x66,0x8a,
+	0x89,0x86,0x75,0x59,0x6d,0x83,0x9a,0xae,
+	0x96,0x77,0x73,0x68,0x8a,0xa5,0x9d,0x8e,
+	0x6a,0x3a,0x5f,0x89,0xa8,0xad,0x80,0x7f,
+	0x71,0x71,0x91,0x6d,0x57,0x64,0x36,0x41,
+	0x3f,0x5c,0x7f,0x76,0x64,0x5e,0x51,0x70,
+	0x7d,0x82,0x6e,0x4e,0x3a,0x3c,0x52,0x68,
+	0x72,0x6b,0x4c,0x4f,0x51,0x62,0x7f,0x6b,
+	0x5a,0x46,0x20,0x41,0x47,0x54,0x6c,0x42,
+	0x49,0x50,0x4e,0x8d,0x8a,0x86,0x89,0x58,
+	0x6c,0x7b,0x7d,0xa5,0x8d,0x80,0x8a,0x7d,
+	0xaf,0xcb,0xd0,0xda,0xbc,0xaf,0xba,0xbf,
+	0xd2,0xd0,0xb2,0x9e,0x94,0x97,0xb2,0xc5,
+	0xbe,0xb4,0x9a,0x89,0x9a,0x97,0x9d,0x92,
+	0x63,0x52,0x41,0x41,0x62,0x60,0x59,0x56,
+	0x38,0x47,0x5c,0x62,0x76,0x60,0x46,0x41,
+	0x37,0x4c,0x66,0x61,0x68,0x5e,0x58,0x74,
+	0x8d,0x9f,0xb5,0x9a,0x92,0x93,0x8c,0xab,
+	0xb2,0xa3,0xa9,0x8d,0x93,0xb2,0xb5,0xd5,
+	0xcd,0xb4,0xbb,0xa6,0xb6,0xc4,0xb3,0xb2,
+	0x93,0x7d,0x8d,0x8e,0xaa,0xaf,0x9b,0x99,
+	0x88,0x90,0xa5,0xa4,0xa6,0x85,0x6f,0x66,
+	0x69,0x84,0x8b,0x8f,0x86,0x75,0x88,0x96,
+	0xb2,0xc2,0xad,0xa0,0x83,0x6c,0x77,0x63,
+	0x86,0x8a,0x67,0x69,0x47,0x57,0x5f,0x5a,
+	0x77,0x58,0x4b,0x46,0x44,0x59,0x55,0x3a,
+	0x38,0x2d,0x49,0x6b,0x76,0x81,0x68,0x5b,
+	0x60,0x62,0x7a,0x75,0x5e,0x4d,0x2a,0x35,
+	0x46,0x53,0x67,0x56,0x48,0x4a,0x48,0x68,
+	0x74,0x6b,0x61,0x40,0x39,0x47,0x54,0x6b,
+	0x6d,0x60,0x5f,0x66,0x7c,0xa0,0xab,0xab,
+	0x9e,0x87,0x8f,0x9f,0xa9,0xbc,0xac,0x9b,
+	0xa2,0xa1,0xc2,0xda,0xd6,0xda,0xbf,0xb2,
+	0xbd,0xba,0xc7,0xbd,0x9a,0x8d,0x7d,0x7f,
+	0x99,0x9c,0x96,0x87,0x6f,0x6a,0x74,0x76,
+	0x7a,0x67,0x41,0x37,0x2e,0x35,0x55,0x4a,
+	0x4a,0x47,0x2e,0x52,0x5f,0x67,0x82,0x5b,
+	0x53,0x5c,0x45,0x7b,0x7d,0x74,0x8c,0x65,
+	0x80,0xa4,0x9e,0xd4,0xbe,0xa7,0xbb,0x9a,
+	0xb7,0xcd,0xb3,0xc4,0xa3,0x96,0xb5,0xb1,
+	0xcf,0xdb,0xba,0xbc,0xaf,0xa7,0xc2,0xba,
+	0xaa,0xa3,0x82,0x7f,0x98,0x93,0xaa,0xaa,
+	0x8a,0x9a,0x90,0x93,0xbd,0x9d,0x9f,0x97,
+	0x68,0x90,0x8d,0x8d,0xb8,0x8b,0x91,0xa2,
+	0x7f,0xb4,0x9a,0x79,0x83,0x63,0x6d,0x65,
+	0x47,0x43,0x35,0x34,0x3a,0x34,0x41,0x4e,
+	0x40,0x51,0x40,0x33,0x48,0x45,0x52,0x59,
+	0x41,0x3b,0x3a,0x3c,0x56,0x63,0x5d,0x63,
+	0x54,0x49,0x64,0x58,0x5f,0x5d,0x36,0x3e,
+	0x34,0x31,0x58,0x46,0x51,0x58,0x3f,0x62,
+	0x67,0x67,0x84,0x62,0x65,0x65,0x58,0x7b,
+	0x7b,0x7f,0x8f,0x81,0x96,0xa9,0xb5,0xcf,
+	0xc7,0xc8,0xc5,0xbf,0xca,0xcb,0xcd,0xcb,
+	0xbf,0xc4,0xc1,0xce,0xda,0xd2,0xd4,0xc4,
+	0xbb,0xbb,0xa8,0xa8,0x9b,0x80,0x7b,0x6b,
+	0x65,0x6e,0x62,0x63,0x61,0x52,0x58,0x54,
+	0x4a,0x4e,0x3d,0x35,0x39,0x2b,0x34,0x3c,
+	0x34,0x49,0x4f,0x4d,0x6c,0x64,0x6d,0x81,
+	0x6c,0x83,0x86,0x75,0x94,0x80,0x89,0xab,
+	0x93,0xb7,0xbb,0xa9,0xd2,0xbe,0xc4,0xde,
+	0xb6,0xc8,0xbf,0xa4,0xc5,0xb3,0xb4,0xc9,
+	0xa6,0xbb,0xbd,0xae,0xce,0xbc,0xad,0xb6,
+	0x93,0x99,0xa5,0x90,0x9e,0x95,0x81,0x9a,
+	0x91,0x9f,0xb7,0xa0,0xa7,0xa5,0x8b,0xab,
+	0xa2,0x9b,0xa9,0x7e,0x7c,0x7c,0x5d,0x78,
+	0x71,0x7c,0x70,0x47,0x55,0x5a,0x5f,0x57,
+	0x4c,0x3b,0x37,0x24,0x39,0x42,0x3a,0x42,
+	0x37,0x3d,0x53,0x59,0x61,0x58,0x46,0x3f,
+	0x3c,0x4c,0x54,0x57,0x50,0x42,0x47,0x4e,
+	0x62,0x6f,0x68,0x5e,0x4c,0x46,0x53,0x59,
+	0x64,0x5e,0x4d,0x4e,0x53,0x68,0x82,0x8a,
+	0x87,0x7e,0x76,0x80,0x93,0x9e,0xa0,0x9a,
+	0x85,0x8e,0x9d,0xab,0xcf,0xc4,0xbd,0xc1,
+	0xad,0xd0,0xd7,0xce,0xdb,0xac,0xa4,0xb0,
+	0xa0,0xc7,0xbf,0xa5,0xaf,0x89,0x97,0xb1,
+	0x99,0xab,0x87,0x61,0x69,0x52,0x63,0x73,
+	0x54,0x51,0x41,0x33,0x53,0x5d,0x5e,0x66,
+	0x43,0x38,0x45,0x3e,0x5c,0x62,0x45,0x54,
+	0x43,0x4a,0x7e,0x78,0x90,0x94,0x6a,0x8e,
+	0x86,0x92,0xbd,0x94,0x9c,0x96,0x7b,0xb0,
+	0xb3,0xbe,0xd4,0xab,0xb4,0xbc,0xb5,0xdb,
+	0xcc,0xba,0xb3,0x97,0x9e,0xb3,0xb4,0xbf,
+	0xb4,0x9b,0xa5,0xab,0xb0,0xcc,0xb6,0xa2,
+	0x9e,0x80,0x97,0xa7,0x99,0xb1,0x8e,0x88,
+	0xa0,0x95,0xb8,0xba,0x99,0x9a,0x6e,0x67,
+	0x6e,0x5d,0x76,0x78,0x46,0x46,0x4e,0x59,
+	0x75,0x77,0x5b,0x50,0x59,0x55,0x54,0x4d,
+	0x45,0x30,0x28,0x2b,0x3b,0x4c,0x5c,0x51,
+	0x4e,0x4b,0x4a,0x5f,0x65,0x60,0x5a,0x3f,
+	0x3d,0x44,0x4c,0x60,0x5a,0x57,0x50,0x50,
+	0x61,0x6d,0x77,0x73,0x65,0x5b,0x57,0x65,
+	0x73,0x78,0x7c,0x70,0x73,0x85,0x91,0xab,
+	0xaf,0xa6,0xa6,0x99,0xa4,0xb3,0xb2,0xbb,
+	0xae,0xa4,0xb0,0xb4,0xc9,0xd9,0xcc,0xcc,
+	0xc0,0xb4,0xc2,0xbf,0xb6,0xb5,0x92,0x8c,
+	0x8e,0x84,0x9e,0x95,0x87,0x86,0x6d,0x70,
+	0x7b,0x6c,0x6d,0x57,0x3b,0x3d,0x36,0x3d,
+	0x4f,0x46,0x40,0x48,0x3b,0x50,0x61,0x58,
+	0x6b,0x4e,0x42,0x5a,0x49,0x69,0x77,0x61,
+	0x7f,0x71,0x7b,0xaa,0x9c,0xb9,0xb6,0x98,
+	0xaf,0x9e,0xac,0xc0,0xad,0xb2,0xaf,0xa7,
+	0xbd,0xcf,0xce,0xdb,0xcf,0xba,0xc8,0xba,
+	0xbd,0xce,0xa7,0xac,0xa6,0x91,0xbd,0xb2,
+	0xb7,0xce,0xa2,0xb6,0xba,0xa2,0xc8,0xa9,
+	0x9b,0xa2,0x7c,0x8e,0x92,0x7f,0x8f,0x72,
+	0x5d,0x6b,0x6a,0x8b,0xa5,0x62,0x5d,0x66,
+	0x40,0x4b,0x43,0x52,0x75,0x3d,0x3d,0x6d,
+	0x5c,0x73,0x62,0x45,0x4d,0x2e,0x2e,0x42,
+	0x2c,0x3d,0x3d,0x27,0x44,0x40,0x45,0x67,
+	0x50,0x52,0x5b,0x3c,0x57,0x55,0x44,0x60,
+	0x40,0x42,0x5d,0x47,0x6e,0x73,0x62,0x81,
+	0x69,0x70,0x88,0x74,0x85,0x85,0x6e,0x84,
+	0x85,0x89,0xa8,0xa3,0xa6,0xba,0xaa,0xbd,
+	0xce,0xb8,0xce,0xc1,0xa8,0xc7,0xad,0xba,
+	0xd6,0xac,0xcc,0xc1,0xaa,0xd6,0xb8,0xb9,
+	0xc1,0x92,0x9a,0x92,0x78,0x90,0x7b,0x6d,
+	0x76,0x5e,0x63,0x73,0x60,0x69,0x63,0x41,
+	0x4f,0x43,0x36,0x53,0x35,0x36,0x46,0x28,
+	0x4c,0x56,0x49,0x6f,0x56,0x54,0x70,0x55,
+	0x73,0x7d,0x63,0x7d,0x72,0x6e,0x9a,0x90,
+	0x9e,0xb7,0x99,0xaf,0xb8,0xa7,0xce,0xb9,
+	0xae,0xc3,0xa0,0xb4,0xc5,0xb4,0xcf,0xc4,
+	0xb3,0xcd,0xbd,0xc6,0xd6,0xbc,0xbc,0xb9,
+	0x9e,0xb5,0xb9,0xa8,0xc1,0xa9,0x9e,0xbd,
+	0x9d,0xb8,0xb9,0x8f,0xa3,0x7c,0x68,0x80,
+	0x55,0x6a,0x78,0x70,0x9c,0x73,0x66,0x9d,
+	0x86,0x76,0x5f,0x34,0x35,0x43,0x4a,0x6d,
+	0x53,0x26,0x56,0x64,0x68,0x7d,0x56,0x56,
+	0x4f,0x30,0x4f,0x41,0x3a,0x50,0x2a,0x34,
+	0x43,0x2f,0x55,0x4f,0x42,0x59,0x40,0x4a,
+	0x64,0x51,0x65,0x61,0x4a,0x5f,0x5b,0x5e,
+	0x7f,0x6d,0x71,0x7f,0x68,0x86,0x93,0x88,
+	0xa4,0x90,0x8a,0x9f,0x94,0xac,0xbc,0xa5,
+	0xb6,0xb2,0xa5,0xc7,0xc5,0xc3,0xd6,0xb4,
+	0xb5,0xc5,0xae,0xcf,0xc9,0xaa,0xbe,0x9e,
+	0x9e,0xb9,0x9f,0xb1,0x9f,0x7e,0x8b,0x7a,
+	0x7a,0x8c,0x77,0x64,0x5f,0x59,0x59,0x65,
+	0x5f,0x4b,0x4b,0x44,0x43,0x4b,0x41,0x4a,
+	0x45,0x42,0x4d,0x46,0x4f,0x53,0x50,0x5f,
+	0x5a,0x66,0x6b,0x68,0x76,0x57,0x55,0x6e,
+	0x89,0xb4,0xbe,0xce,0xd8,0xd2,0xdb,0xd1,
+	0xd1,0xd6,0xc9,0xd0,0xc7,0xc5,0xc8,0xbd,
+	0xc3,0xbd,0xb9,0xbd,0xb1,0xb6,0xb0,0xaa,
+	0xaf,0xa5,0xa7,0xa3,0x9e,0xa2,0x99,0x9c,
+	0x99,0x91,0x96,0x8c,0x8b,0x8b,0x82,0x86,
+	0x7d,0x7d,0x7c,0x76,0x7a,0x73,0x73,0x71,
+	0x6a,0x70,0x66,0x66,0x65,0x5d,0x5e,0x5b,
+	0x57,0x5a,0x54,0x57,0x55,0x54,0x56,0x51,
+	0x52,0x50,0x4d,0x4c,0x49,0x4a,0x47,0x47,
+	0x48,0x49,0x49,0x49,0x4d,0x4b,0x4e,0x4c,
+	0x4b,0x4d,0x4a,0x4a,0x4b,0x49,0x4c,0x4c,
+	0x4f,0x52,0x52,0x57,0x55,0x5c,0x5a,0x5a,
+	0x5f,0x5b,0x5b,0x5d,0x2b,0x3b,0x55,0x50,
+	0xa3,0x80,0x6e,0x6e,0x39,0x7f,0x6c,0x57,
+	0x98,0x3c,0x80,0xa9,0x74,0xc8,0x6c,0x68,
+	0x9a,0x62,0xc0,0xa7,0x7b,0xa3,0x4e,0x86,
+	0xa8,0x7c,0xb9,0x63,0x54,0x79,0x50,0xa1,
+	0x89,0x59,0x74,0x2a,0x62,0x84,0x68,0x8e,
+	0x43,0x33,0x48,0x40,0x87,0x7c,0x60,0x68,
+	0x3e,0x75,0x9a,0x91,0xaa,0x67,0x4e,0x69,
+	0x67,0xac,0xa7,0x88,0x8e,0x6d,0xa0,0xcf,
+	0xd0,0xda,0xa0,0x83,0x8f,0x98,0xc5,0xbe,
+	0x9c,0x86,0x70,0x9a,0xc7,0xd2,0xcc,0xa2,
+	0x7a,0x80,0xa0,0xbf,0xbc,0x97,0x60,0x5e,
+	0x76,0xb0,0xd5,0xc0,0xaa,0x88,0x96,0xce,
+	0xd2,0xd8,0x9c,0x4e,0x50,0x4d,0x86,0xb5,
+	0x9d,0xac,0x8b,0x97,0xd3,0xc0,0xc4,0x82,
+	0x3c,0x5c,0x57,0x9a,0xbd,0x89,0x91,0x5f,
+	0x71,0xbc,0xb2,0xd1,0xa4,0x6c,0x8c,0x7a,
+	0xb5,0xc3,0x86,0x8e,0x54,0x68,0xac,0x9b,
+	0xc5,0x95,0x63,0x8b,0x73,0xad,0xba,0x76,
+	0x79,0x33,0x40,0x7b,0x65,0x8b,0x5f,0x2f,
+	0x60,0x50,0x97,0xb2,0x7a,0x89,0x50,0x5d,
+	0xa1,0x8b,0xaf,0x87,0x53,0x80,0x75,0xb4,
+	0xd4,0x9b,0xa8,0x73,0x78,0xb4,0x9c,0xb2,
+	0x83,0x47,0x6c,0x60,0x9d,0xa6,0x69,0x75,
+	0x4c,0x66,0xab,0xa8,0xc0,0xa1,0x67,0x7b,
+	0x53,0x7a,0x90,0x62,0x60,0x3d,0x4d,0x85,
+	0x8f,0x9b,0x75,0x41,0x45,0x4d,0x71,0x83,
+	0x65,0x48,0x33,0x46,0x78,0xa3,0xaa,0x97,
+	0x82,0x73,0x99,0xb1,0xb6,0xa8,0x6b,0x57,
+	0x5d,0x68,0x9c,0x85,0x72,0x6b,0x48,0x81,
+	0x91,0x8f,0xa3,0x56,0x5d,0x64,0x5b,0xa2,
+	0x80,0x7b,0x8b,0x5c,0xac,0xb9,0xb7,0xe1,
+	0x91,0xa2,0xa4,0x80,0xc3,0x86,0x75,0x7d,
+	0x3a,0x80,0x7f,0x7a,0xbb,0x75,0x97,0x7b,
+	0x57,0x9f,0x63,0x69,0x7c,0x3e,0x86,0x85,
+	0x85,0xb5,0x51,0x78,0x7b,0x66,0xab,0x7c,
+	0x74,0x83,0x3c,0x68,0x4f,0x3b,0x62,0x2f,
+	0x4f,0x63,0x4c,0x8f,0x79,0x85,0xa6,0x7f,
+	0xa4,0x96,0x82,0xa0,0x7d,0x8b,0x93,0x77,
+	0x99,0x8a,0x8e,0xa7,0x89,0x97,0x85,0x69,
+	0x77,0x5d,0x5d,0x5d,0x40,0x50,0x53,0x61,
+	0x85,0x8f,0x9d,0xa8,0xa8,0xba,0xc7,0xc1,
+	0xc4,0xa9,0x95,0x9b,0x8f,0xa0,0xa3,0x8c,
+	0x95,0x85,0x91,0xad,0xa0,0xac,0x9a,0x7c,
+	0x91,0x54,0x5b,0x6c,0x38,0x5a,0x52,0x6e,
+	0xae,0xa9,0xc6,0x91,0x63,0x85,0x61,0x7f,
+	0x7e,0x4c,0x52,0x37,0x3a,0x6a,0x52,0x6e,
+	0x5f,0x44,0x72,0x67,0x85,0x93,0x60,0x73,
+	0x58,0x64,0x98,0x7f,0x9f,0x90,0x77,0xad,
+	0xa3,0xc4,0xd0,0x95,0x9d,0x75,0x6c,0x94,
+	0x65,0x6f,0x4e,0x27,0x57,0x52,0x7a,0x95,
+	0x65,0x84,0x71,0x7e,0xbb,0x99,0xac,0x90,
+	0x68,0x9d,0x92,0xb8,0xcd,0x96,0xaf,0x97,
+	0xa0,0xdb,0xac,0xb5,0x8e,0x58,0x85,0x72,
+	0x8f,0xa4,0x66,0x74,0x44,0x63,0xa5,0x7e,
+	0x9e,0x8c,0x6c,0xa3,0x7f,0x80,0x8f,0x3d,
+	0x53,0x3d,0x4d,0x8d,0x6b,0x80,0x66,0x41,
+	0x77,0x63,0x7f,0x83,0x3f,0x54,0x39,0x4b,
+	0x87,0x6b,0x8a,0x76,0x67,0xa4,0x9d,0xc7,
+	0xc9,0x92,0xa5,0x7f,0x8f,0xb0,0x82,0x8f,
+	0x62,0x4c,0x79,0x66,0x8e,0x87,0x58,0x72,
+	0x50,0x72,0x90,0x6e,0x83,0x5a,0x56,0x89,
+	0x7f,0xb5,0xad,0x8f,0xae,0x93,0xbe,0xd4,
+	0xb0,0xbc,0x85,0x79,0x95,0x7f,0xa2,0x87,
+	0x68,0x7f,0x6a,0x9f,0xb6,0xa1,0xa0,0x5c,
+	0x6e,0x87,0x74,0x9c,0x7d,0x62,0x55,0x44,
+	0x7b,0x7d,0x73,0x7e,0x55,0x65,0x7a,0x75,
+	0x8c,0x5e,0x44,0x3d,0x2f,0x59,0x60,0x5a,
+	0x5d,0x40,0x60,0x7e,0x98,0xb5,0x98,0x90,
+	0x8c,0x8f,0xb6,0xb5,0xaf,0x98,0x7d,0x8b,
+	0x99,0xae,0xaf,0x8b,0x74,0x5d,0x62,0x75,
+	0x6c,0x60,0x3c,0x2a,0x3a,0x54,0x7d,0x85,
+	0x84,0x80,0x86,0xae,0xcb,0xd6,0xd1,0xa9,
+	0x9f,0x9c,0xa9,0xc0,0xab,0x9c,0x82,0x7b,
+	0x9e,0xab,0xba,0xad,0x87,0x87,0x85,0xa0,
+	0xb2,0x8c,0x66,0x54,0x61,0x7b,0x83,0x86,
+	0x67,0x5d,0x5d,0x56,0x76,0x86,0x6f,0x5f,
+	0x39,0x38,0x50,0x56,0x61,0x4a,0x33,0x38,
+	0x43,0x69,0x7c,0x72,0x65,0x53,0x62,0x81,
+	0x97,0xa3,0x95,0x89,0x92,0xaa,0xce,0xd9,
+	0xcc,0xb1,0x9b,0x97,0xa0,0xa1,0x8a,0x61,
+	0x3d,0x31,0x3f,0x52,0x5b,0x50,0x43,0x45,
+	0x5d,0x85,0x9e,0x9e,0x93,0x84,0x8d,0xab,
+	0xbe,0xca,0xb7,0xa2,0xa4,0xad,0xcc,0xd5,
+	0xc2,0xae,0x8c,0x92,0xa1,0xa4,0xa8,0x89,
+	0x76,0x7e,0x85,0xac,0x9c,0x85,0x8e,0x75,
+	0x6b,0x57,0x72,0x78,0x4a,0x2d,0x32,0x39,
+	0x62,0x5d,0x52,0x47,0x31,0x4d,0x5e,0x66,
+	0x6e,0x44,0x40,0x3f,0x4c,0x75,0x69,0x6b,
+	0x65,0x5c,0x8c,0xa2,0xbf,0xc9,0xac,0xb5,
+	0xb3,0xc2,0xdb,0xbd,0xad,0x8b,0x71,0x83,
+	0x7c,0x7f,0x6d,0x45,0x46,0x40,0x56,0x6d,
+	0x5b,0x5d,0x4a,0x4e,0x78,0x81,0x9e,0x98,
+	0x88,0x9c,0x9e,0xc7,0xd8,0xc7,0xc6,0xa5,
+	0xaa,0xba,0xb7,0xbf,0xa0,0x85,0x88,0x83,
+	0xa7,0xad,0xa2,0xa1,0x89,0x9b,0xa2,0x91,
+	0xa1,0x82,0x58,0x3c,0x45,0x68,0x55,0x4a,
+	0x43,0x31,0x4f,0x5d,0x6b,0x6f,0x4a,0x44,
+	0x38,0x44,0x5c,0x50,0x4d,0x3a,0x31,0x57,
+	0x64,0x87,0x8c,0x78,0x89,0x8d,0xb1,0xcc,
+	0xc5,0xc8,0xaa,0xa9,0xbd,0xb9,0xcb,0xa9,
+	0x89,0x80,0x67,0x7d,0x79,0x60,0x57,0x2a,
+	0x35,0x45,0x4b,0x6a,0x51,0x53,0x61,0x68,
+	0xa0,0xa7,0xae,0xb3,0x98,0xb5,0xbe,0xca,
+	0xdb,0xaf,0xb0,0xa2,0xa0,0xc6,0xb2,0xb5,
+	0xa2,0x83,0xa4,0xa1,0xb7,0xbc,0x96,0x9c,
+	0x7c,0x71,0x95,0x78,0x6c,0x52,0x39,0x5a,
+	0x3e,0x60,0x56,0x3c,0x4b,0x35,0x53,0x63,
+	0x4f,0x58,0x31,0x35,0x4c,0x48,0x6c,0x57,
+	0x4c,0x59,0x4f,0x80,0x8b,0x8b,0x9d,0x7e,
+	0x9b,0xaf,0xb9,0xdc,0xbb,0xb8,0xb5,0xa3,
+	0xc4,0xaf,0xa1,0x8f,0x5c,0x69,0x5b,0x59,
+	0x67,0x39,0x3f,0x36,0x3b,0x68,0x5f,0x74,
+	0x6f,0x62,0x8d,0x8e,0xad,0xbd,0xa1,0xb2,
+	0xa6,0xb6,0xd4,0xc1,0xcd,0xaf,0xa2,0xb8,
+	0xab,0xc1,0xb7,0x97,0xa3,0x8b,0xaa,0xb6,
+	0xa9,0xac,0x80,0x64,0x7a,0x63,0x7a,0x71,
+	0x4c,0x4e,0x23,0x4a,0x47,0x4a,0x4c,0x34,
+	0x43,0x4c,0x4e,0x64,0x4a,0x49,0x44,0x43,
+	0x60,0x5c,0x63,0x63,0x55,0x71,0x7b,0x93,
+	0xa5,0x9b,0xaa,0xa8,0xb7,0xcf,0xc7,0xc9,
+	0xb4,0xa5,0xa6,0x9b,0x9c,0x89,0x70,0x63,
+	0x51,0x56,0x57,0x54,0x4e,0x42,0x47,0x50,
+	0x5f,0x70,0x73,0x7a,0x7e,0x90,0xa4,0xb2,
+	0xbd,0xba,0xbb,0xbd,0xc0,0xc9,0xc1,0xbc,
+	0xb0,0xa3,0xad,0xa3,0xa9,0xaa,0x9c,0xa8,
+	0xa1,0xab,0xb3,0x97,0x90,0x6c,0x75,0x61,
+	0x5c,0x64,0x4f,0x3b,0x3f,0x2e,0x49,0x4a,
+	0x43,0x5d,0x40,0x54,0x53,0x40,0x5b,0x3c,
+	0x48,0x54,0x3c,0x65,0x50,0x62,0x7e,0x6c,
+	0x99,0x90,0x96,0xb8,0x9c,0xc5,0xb9,0xad,
+	0xc8,0x9d,0xb6,0xb0,0x96,0xb0,0x7a,0x84,
+	0x7c,0x59,0x7c,0x51,0x50,0x56,0x2d,0x5d,
+	0x4c,0x59,0x76,0x53,0x80,0x80,0x8a,0xba,
+	0x97,0xb5,0xa9,0x9a,0xc6,0xa7,0xbd,0xb4,
+	0x8e,0xb1,0x94,0xac,0xba,0x96,0xaf,0x90,
+	0x95,0xb3,0x99,0xb5,0x8e,0x73,0x76,0x66,
+	0x84,0x70,0x63,0x66,0x48,0x55,0x62,0x5b,
+	0x70,0x49,0x48,0x52,0x4d,0x6d,0x5e,0x51,
+	0x50,0x3d,0x60,0x6f,0x73,0x7d,0x61,0x68,
+	0x74,0x82,0xa0,0x95,0x88,0x88,0x85,0xa5,
+	0xb9,0xb9,0xb5,0x97,0x93,0xa0,0xa1,0xaa,
+	0x8d,0x69,0x5d,0x4e,0x66,0x70,0x63,0x61,
+	0x45,0x50,0x73,0x7e,0x9b,0x84,0x72,0x7b,
+	0x77,0xa3,0xab,0x9a,0x9b,0x78,0x90,0xac,
+	0xb1,0xc9,0xa0,0x91,0x94,0x8c,0xb9,0xa9,
+	0x94,0x8b,0x60,0x86,0x94,0x99,0xa0,0x6a,
+	0x7a,0x75,0x74,0x96,0x7c,0x73,0x5b,0x32,
+	0x5f,0x5d,0x71,0x72,0x41,0x55,0x52,0x6d,
+	0x9a,0x75,0x78,0x59,0x4a,0x7b,0x73,0x89,
+	0x77,0x4e,0x6a,0x67,0x95,0xb7,0x98,0xa6,
+	0x83,0x8d,0xb9,0xaa,0xbe,0x90,0x6a,0x7a,
+	0x66,0x94,0x93,0x6f,0x76,0x4a,0x6a,0x89,
+	0x81,0x98,0x61,0x54,0x65,0x5e,0x99,0x84,
+	0x75,0x7b,0x5a,0x95,0xaa,0xaf,0xc2,0x86,
+	0x91,0x91,0x94,0xc0,0x91,0x88,0x74,0x5b,
+	0x96,0x91,0xa6,0xa5,0x73,0x8e,0x80,0x92,
+	0xb3,0x88,0x86,0x59,0x43,0x74,0x68,0x88,
+	0x67,0x48,0x67,0x5c,0x92,0x98,0x7a,0x7b,
+	0x4b,0x63,0x75,0x6f,0x83,0x55,0x51,0x5e,
+	0x65,0x9e,0x95,0x92,0x8a,0x70,0x95,0x98,
+	0xa6,0xa1,0x74,0x74,0x6d,0x84,0x9f,0x95,
+	0x94,0x78,0x77,0x8e,0x93,0x9f,0x84,0x67,
+	0x59,0x52,0x71,0x76,0x78,0x6d,0x5c,0x71,
+	0x84,0xa3,0xad,0x98,0x8e,0x7b,0x86,0x98,
+	0x95,0x94,0x75,0x6c,0x76,0x86,0xa8,0xa4,
+	0x9a,0x90,0x82,0x97,0xa0,0x9b,0x8d,0x64,
+	0x5e,0x68,0x77,0x8e,0x7f,0x76,0x68,0x6b,
+	0x8b,0x94,0x91,0x84,0x61,0x60,0x60,0x68,
+	0x7d,0x67,0x63,0x60,0x5f,0x89,0x8c,0x95,
+	0x93,0x6f,0x81,0x79,0x85,0x95,0x6f,0x78,
+	0x66,0x6a,0x97,0x8a,0xa7,0x96,0x7e,0x9e,
+	0x85,0xa0,0x9d,0x70,0x81,0x50,0x66,0x7e,
+	0x65,0x8e,0x65,0x6d,0x8a,0x73,0xac,0x8f,
+	0x83,0x8e,0x5c,0x89,0x7d,0x78,0x94,0x5f,
+	0x82,0x84,0x81,0xb9,0x90,0x9f,0x95,0x75,
+	0xa5,0x83,0x8d,0x8d,0x5a,0x7d,0x68,0x75,
+	0x9a,0x78,0x97,0x83,0x77,0xa2,0x80,0x90,
+	0x7c,0x5a,0x76,0x59,0x6f,0x7e,0x60,0x7e,
+	0x66,0x73,0x98,0x7f,0x9b,0x84,0x6a,0x83,
+	0x65,0x7e,0x82,0x60,0x7e,0x60,0x78,0x98,
+	0x82,0xab,0x8b,0x83,0x9d,0x78,0x9d,0x8c,
+	0x6d,0x85,0x57,0x78,0x84,0x6f,0x9e,0x70,
+	0x80,0x92,0x72,0xa9,0x7f,0x79,0x85,0x50,
+	0x83,0x73,0x70,0x93,0x5f,0x8b,0x86,0x82,
+	0xb5,0x85,0x99,0x90,0x6b,0x9d,0x74,0x86,
+	0x89,0x5c,0x8b,0x71,0x85,0xa5,0x7b,0x9b,
+	0x82,0x7a,0x9d,0x78,0x8f,0x7b,0x5d,0x7f,
+	0x5e,0x79,0x85,0x6d,0x8e,0x73,0x7c,0x93,
+	0x7a,0x94,0x79,0x6a,0x7d,0x5f,0x7c,0x7c,
+	0x68,0x84,0x69,0x81,0x91,0x81,0xa0,0x84,
+	0x7e,0x8f,0x70,0x8f,0x81,0x70,0x85,0x64,
+	0x80,0x8a,0x7c,0x9d,0x7c,0x85,0x93,0x74,
+	0x99,0x7b,0x74,0x83,0x5b,0x7f,0x77,0x72,
+	0x92,0x6b,0x8a,0x87,0x7e,0xa4,0x7c,0x8b,
+	0x88,0x68,0x8f,0x75,0x7e,0x8d,0x67,0x8d,
+	0x7e,0x83,0xa3,0x7e,0x97,0x86,0x76,0x94,
+	0x73,0x85,0x82,0x64,0x82,0x6b,0x7e,0x91,
+	0x78,0x8f,0x7d,0x76,0x92,0x78,0x8c,0x7e,
+	0x66,0x7a,0x66,0x7a,0x84,0x70,0x85,0x74,
+	0x79,0x91,0x82,0x91,0x85,0x73,0x83,0x73,
+	0x7f,0x89,0x72,0x83,0x72,0x77,0x91,0x83,
+	0x95,0x8a,0x77,0x8e,0x77,0x89,0x8d,0x70,
+	0x80,0x6b,0x6f,0x8c,0x76,0x90,0x82,0x71,
+	0x90,0x77,0x90,0x93,0x72,0x8a,0x69,0x74,
+	0x8c,0x75,0x91,0x7a,0x72,0x90,0x77,0x9c,
+	0x94,0x7a,0x94,0x6b,0x82,0x8d,0x75,0x95,
+	0x6d,0x6e,0x87,0x6d,0x9d,0x89,0x7b,0x90,
+	0x66,0x8b,0x89,0x7a,0x95,0x60,0x74,0x7b,
+	0x68,0x9a,0x78,0x7c,0x86,0x63,0x91,0x84,
+	0x84,0x95,0x64,0x7e,0x78,0x70,0x98,0x75,
+	0x81,0x7e,0x66,0x97,0x82,0x8e,0x95,0x6b,
+	0x86,0x77,0x7d,0x9a,0x73,0x82,0x74,0x68,
+	0x90,0x7c,0x91,0x8e,0x6b,0x87,0x75,0x85,
+	0x9a,0x74,0x84,0x6f,0x69,0x8d,0x7c,0x8e,
+	0x87,0x6d,0x86,0x77,0x8c,0x9c,0x7d,0x87,
+	0x72,0x70,0x8c,0x82,0x8f,0x84,0x6b,0x80,
+	0x77,0x8d,0x98,0x80,0x85,0x72,0x72,0x8c,
+	0x86,0x84,0x80,0x69,0x7c,0x84,0x84,0x8c,
+	0x7c,0x7b,0x7b,0x80,0x81,0x80,0x7e,0x7b,
+	0x7c,0x7d,0x7b,0x7d,0x7d,0x7e,0x80,0x80,
+	0x82,0x82,0x83,0x83,0x82,0x80,0x80,0x7d,
+	0x7d,0x7d,0x7c,0x7f,0x7f,0x80,0x81,0x82,
+	0x84,0x82,0x82,0x83,0x80,0x80,0x7d,0x7e,
+	0x7d,0x7c,0x7f,0x7d,0x81,0x82,0x80,0x85,
+	0x81,0x83,0x82,0x80,0x81,0x7e,0x7e,0x7e,
+	0x7c,0x7e,0x7f,0x7e,0x81,0x81,0x82,0x84,
+	0x82,0x83,0x7f,0x80,0x81,0x7c,0x80,0x7b,
+	0x7f,0x7f,0x7e,0x81,0x81,0x82,0x83,0x80,
+	0x85,0x80,0x80,0x80,0x7d,0x7e,0x7f,0x7c,
+	0x7f,0x7e,0x81,0x81,0x81,0x83,0x81,0x83,
+	0x82,0x7f,0x82,0x7e,0x7e,0x7f,0x7c,0x7f,
+	0x7e,0x81,0x81,0x80,0x84,0x82,0x80,0x85,
+	0x7d,0x82,0x7f,0x7d,0x80,0x7e,0x7e,0x81,
+	0x7c,0x85,0x72,0x4d,0x5c,0x7a,0x66,0x96,
+	0xbb,0x8a,0x7d,0x83,0x4a,0x3f,0x6e,0x7f,
+	0x87,0xa1,0xa1,0x83,0x76,0x73,0x71,0x81,
+	0x94,0x92,0x8b,0x7b,0x70,0x6c,0x6a,0x7f,
+	0x89,0x7c,0x85,0x77,0x5e,0x69,0x73,0x62,
+	0x73,0x7c,0x5f,0x60,0x72,0x57,0x56,0x7d,
+	0x53,0x55,0x70,0x52,0x4f,0x74,0x69,0x51,
+	0x89,0x64,0x4d,0x74,0x56,0x3e,0x5a,0x64,
+	0x37,0x73,0x7f,0x57,0x8b,0x87,0x5c,0x68,
+	0x85,0x43,0x60,0x84,0x44,0x62,0x7e,0x5c,
+	0x64,0xac,0x82,0x83,0xb9,0x72,0x61,0x85,
+	0x6d,0x57,0xa4,0x93,0x69,0xad,0x8c,0x73,
+	0xb5,0xc2,0x8f,0xb9,0xac,0x54,0x81,0x87,
+	0x67,0x9d,0xc8,0x91,0x9e,0xb8,0x73,0x8f,
+	0xba,0x95,0x92,0xa6,0x64,0x44,0x7b,0x62,
+	0x79,0xb7,0xa3,0x83,0x8f,0x6c,0x47,0x75,
+	0x75,0x65,0x79,0x61,0x37,0x43,0x59,0x5e,
+	0x90,0x9e,0x81,0x70,0x5a,0x3e,0x49,0x66,
+	0x72,0x80,0x81,0x69,0x61,0x6b,0x82,0xa4,
+	0xb7,0xb3,0x9b,0x76,0x67,0x71,0x85,0xa2,
+	0xbc,0xb1,0xa7,0xa3,0x93,0xa3,0xbb,0xc1,
+	0xbd,0xbd,0x97,0x79,0x8b,0x87,0xa0,0xc8,
+	0xce,0xb3,0xb3,0x97,0x7a,0xa2,0xa7,0x9e,
+	0xa0,0x86,0x4c,0x56,0x74,0x78,0xbc,0xb4,
+	0x9e,0x89,0x6b,0x36,0x37,0x6e,0x67,0x80,
+	0x85,0x62,0x48,0x62,0x5f,0x6c,0xb3,0x92,
+	0x78,0x7d,0x4f,0x41,0x71,0x8a,0x71,0xa4,
+	0x80,0x52,0x74,0x76,0x73,0x9d,0xaf,0x68,
+	0x6f,0x5c,0x26,0x53,0x74,0x70,0x7e,0x97,
+	0x56,0x52,0x72,0x55,0x76,0x95,0x78,0x56,
+	0x65,0x40,0x3d,0x88,0x87,0x98,0xb2,0x99,
+	0x6e,0x87,0x89,0x80,0xb8,0xb0,0x95,0x97,
+	0x8f,0x7d,0xa3,0xcc,0xc1,0xd9,0xca,0x9f,
+	0x90,0x97,0x8c,0x9d,0xb8,0x9a,0x90,0x89,
+	0x72,0x7c,0x97,0x9d,0x99,0x93,0x6e,0x4b,
+	0x48,0x47,0x54,0x6c,0x71,0x65,0x5d,0x52,
+	0x52,0x64,0x76,0x80,0x7c,0x68,0x56,0x48,
+	0x51,0x71,0x89,0xa1,0xa9,0xa3,0x8d,0x96,
+	0x9d,0x9e,0xc1,0xb8,0xa8,0x9c,0x95,0x89,
+	0xa2,0xcb,0xc1,0xdc,0xcd,0xa9,0x9c,0xa0,
+	0x93,0x9a,0xb8,0x8a,0x8a,0x85,0x69,0x79,
+	0x9a,0xa0,0x91,0xad,0x70,0x55,0x65,0x4b,
+	0x56,0x72,0x73,0x4a,0x70,0x56,0x43,0x82,
+	0x7d,0x78,0x85,0x7e,0x39,0x59,0x66,0x48,
+	0x97,0xa2,0x93,0xa2,0xb5,0x77,0x7d,0xc5,
+	0x8c,0xad,0xb0,0x67,0x50,0x86,0x67,0x77,
+	0xc5,0x96,0x9d,0xb5,0x8c,0x82,0xab,0x97,
+	0x79,0xa6,0x77,0x5a,0x84,0x76,0x6d,0x9a,
+	0x98,0x6b,0x89,0x71,0x43,0x65,0x65,0x41,
+	0x5c,0x5f,0x35,0x4f,0x62,0x45,0x64,0x7c,
+	0x50,0x5b,0x69,0x3f,0x4b,0x6b,0x52,0x5a,
+	0x84,0x64,0x6c,0x96,0x7f,0x88,0xa9,0x9a,
+	0x86,0xab,0x94,0x86,0xb2,0xa5,0xa1,0xbd,
+	0xbf,0xa7,0xc3,0xc3,0xa1,0xc2,0xb0,0x9a,
+	0xa0,0xa3,0x82,0x8e,0xa0,0x77,0x91,0x8e,
+	0x76,0x77,0x7d,0x62,0x53,0x6d,0x41,0x4b,
+	0x59,0x46,0x4a,0x56,0x55,0x44,0x6a,0x55,
+	0x56,0x6c,0x58,0x5a,0x61,0x6d,0x5d,0x85,
+	0x89,0x81,0xa3,0x99,0x9b,0xa3,0xb6,0xa3,
+	0xb7,0xbd,0xa1,0xb8,0xb1,0xb5,0xbb,0xcf,
+	0xc0,0xc3,0xcb,0xa7,0xb5,0xb0,0xa9,0xa5,
+	0xab,0x98,0x8b,0x9d,0x81,0x93,0x99,0x90,
+	0x88,0x86,0x74,0x61,0x74,0x62,0x67,0x71,
+	0x65,0x5e,0x62,0x67,0x5f,0x7f,0x79,0x75,
+	0x7a,0x6f,0x6c,0x79,0x8e,0x93,0xb0,0xb9,
+	0xb1,0xb3,0x9b,0x7d,0x91,0x8f,0x50,0x56,
+	0x63,0x48,0x4d,0x5e,0x6c,0x7f,0x88,0x81,
+	0x7e,0x7c,0x7b,0x7f,0x8a,0x82,0x7e,0x72,
+	0x65,0x62,0x65,0x6e,0x70,0x76,0x64,0x5b,
+	0x50,0x46,0x4d,0x4a,0x55,0x48,0x44,0x39,
+	0x36,0x3c,0x41,0x54,0x4d,0x54,0x48,0x42,
+	0x43,0x4c,0x5d,0x60,0x76,0x6b,0x72,0x74,
+	0x7a,0x8c,0x99,0xac,0xa4,0xb2,0xa1,0xa6,
+	0xb3,0xb9,0xcc,0xcc,0xd5,0xbe,0xc6,0xbd,
+	0xb9,0xcc,0xc5,0xc6,0xb2,0xb0,0x8f,0x97,
+	0x97,0x8d,0x9c,0x86,0x7d,0x64,0x64,0x53,
+	0x58,0x68,0x4d,0x57,0x42,0x39,0x30,0x43,
+	0x43,0x47,0x5e,0x3f,0x4a,0x43,0x4a,0x52,
+	0x6c,0x74,0x6b,0x84,0x6a,0x7b,0x86,0x95,
+	0xa1,0xad,0xb3,0x9d,0xb4,0xa3,0xb5,0xc2,
+	0xc8,0xcb,0xc1,0xc2,0xab,0xc1,0xb8,0xc4,
+	0xc8,0xbb,0xb4,0xa0,0xaa,0x95,0xad,0xa5,
+	0x9f,0x9e,0x88,0x86,0x76,0x8b,0x7c,0x8d,
+	0x82,0x73,0x73,0x60,0x72,0x66,0x82,0x74,
+	0x79,0x74,0x65,0x78,0x70,0x91,0x8b,0xa4,
+	0x9b,0x9f,0xaa,0xa8,0xbc,0x99,0x8c,0x5f,
+	0x60,0x42,0x56,0x4b,0x42,0x48,0x38,0x4c,
+	0x43,0x46,0x53,0x55,0x70,0x64,0x7f,0x60,
+	0x68,0x62,0x5d,0x6b,0x67,0x74,0x59,0x68,
+	0x49,0x4c,0x55,0x49,0x5b,0x4a,0x52,0x34,
+	0x46,0x35,0x3b,0x4e,0x3e,0x4b,0x3c,0x45,
+	0x32,0x4e,0x4d,0x4e,0x6c,0x57,0x66,0x63,
+	0x73,0x6d,0x8a,0x93,0x8a,0xa7,0x95,0xa5,
+	0xa8,0xbe,0xb8,0xcc,0xd2,0xbd,0xd7,0xc6,
+	0xce,0xd1,0xdb,0xcb,0xcd,0xd1,0xaf,0xc5,
+	0xb4,0xb2,0xad,0xab,0x94,0x88,0x91,0x69,
+	0x7b,0x6d,0x64,0x5c,0x59,0x4a,0x3c,0x55,
+	0x34,0x48,0x45,0x37,0x3a,0x40,0x3f,0x36,
+	0x5c,0x41,0x52,0x62,0x59,0x62,0x75,0x77,
+	0x6e,0x99,0x80,0x8e,0xa5,0x98,0xa1,0xb3,
+	0xb3,0xa3,0xcc,0xb3,0xb7,0xcf,0xbc,0xb9,
+	0xc6,0xc5,0xab,0xd2,0xb9,0xad,0xc5,0xac,
+	0xa5,0xb0,0xb3,0x91,0xb5,0x9c,0x87,0xa1,
+	0x8f,0x85,0x95,0x9a,0x72,0x95,0x83,0x6c,
+	0x8f,0x86,0x7d,0x8b,0x96,0x6d,0x93,0x94,
+	0x7f,0xa9,0xa9,0x9a,0xa4,0xb3,0x87,0x9d,
+	0x92,0x53,0x6e,0x67,0x3b,0x5b,0x56,0x38,
+	0x3f,0x4e,0x27,0x45,0x49,0x3a,0x48,0x70,
+	0x54,0x68,0x7b,0x4a,0x5a,0x62,0x54,0x5b,
+	0x7f,0x56,0x56,0x69,0x3c,0x4e,0x62,0x55,
+	0x4e,0x63,0x3e,0x31,0x50,0x33,0x4b,0x61,
+	0x54,0x47,0x5c,0x45,0x43,0x6e,0x61,0x6b,
+	0x7b,0x6b,0x5c,0x78,0x77,0x7e,0xaa,0x9d,
+	0x9d,0xa5,0x9d,0x98,0xb8,0xbf,0xba,0xd1,
+	0xbb,0xaf,0xb9,0xbd,0xbe,0xd7,0xd3,0xbf,
+	0xc0,0xaa,0x9c,0xab,0xae,0xa5,0xa6,0x95,
+	0x78,0x79,0x74,0x72,0x7e,0x7d,0x67,0x59,
+	0x49,0x3b,0x44,0x4d,0x54,0x54,0x4b,0x3b,
+	0x38,0x40,0x4e,0x5e,0x66,0x64,0x59,0x4e,
+	0x54,0x63,0x73,0x90,0x92,0x8f,0x8c,0x87,
+	0x8b,0xa5,0xb3,0xb3,0xc1,0xa9,0x9c,0xa3,
+	0xab,0xb5,0xd0,0xd2,0xba,0xc0,0xa6,0xa2,
+	0xb5,0xb9,0xb7,0xbb,0xac,0x88,0x9d,0x95,
+	0x9e,0xb7,0xb5,0x9d,0x97,0x8e,0x6f,0x95,
+	0x94,0x92,0x9f,0x92,0x77,0x82,0x92,0x85,
+	0xb5,0xad,0x9b,0x9c,0x8d,0x79,0x8d,0x9f,
+	0x81,0x90,0x6f,0x59,0x6e,0x5a,0x58,0x65,
+	0x7f,0x4a,0x5e,0x44,0x23,0x3d,0x50,0x50,
+	0x5f,0x69,0x41,0x56,0x58,0x56,0x6d,0x77,
+	0x5f,0x57,0x5a,0x39,0x58,0x6b,0x68,0x74,
+	0x74,0x52,0x4b,0x5b,0x47,0x62,0x6c,0x58,
+	0x51,0x4f,0x41,0x4e,0x72,0x6d,0x7f,0x7c,
+	0x62,0x5a,0x64,0x66,0x76,0x93,0x85,0x86,
+	0x88,0x82,0x94,0xb0,0xbc,0xc2,0xc3,0xab,
+	0xa1,0xa6,0xab,0xc1,0xd1,0xcf,0xc7,0xc0,
+	0xb7,0xb8,0xc6,0xc9,0xc5,0xb5,0x9b,0x8a,
+	0x7c,0x86,0x8c,0x95,0x92,0x83,0x72,0x60,
+	0x63,0x57,0x66,0x5f,0x4d,0x3f,0x34,0x2c,
+	0x38,0x55,0x4f,0x64,0x5c,0x4c,0x47,0x4e,
+	0x4d,0x5a,0x75,0x5c,0x6b,0x6a,0x69,0x7e,
+	0x9e,0xa2,0xa9,0xbd,0x91,0x9d,0xa0,0x9d,
+	0xa8,0xc4,0xb5,0xb1,0xcb,0xab,0xc3,0xd6,
+	0xcf,0xc7,0xd4,0xae,0x9a,0xb5,0x97,0xaa,
+	0xbf,0xb4,0xa8,0xbc,0xa5,0x9c,0xbe,0xa1,
+	0xa0,0xa7,0x8d,0x79,0x98,0x89,0x8c,0xb8,
+	0xa6,0xa0,0xb5,0xa2,0x91,0xac,0x95,0x7f,
+	0x89,0x64,0x4a,0x71,0x89,0x6f,0x8f,0x7b,
+	0x40,0x48,0x43,0x45,0x49,0x49,0x44,0x48,
+	0x3b,0x29,0x44,0x4a,0x39,0x5d,0x52,0x42,
+	0x51,0x49,0x36,0x45,0x4e,0x35,0x59,0x51,
+	0x4f,0x61,0x64,0x56,0x5d,0x62,0x41,0x58,
+	0x4a,0x44,0x4f,0x57,0x51,0x62,0x74,0x62,
+	0x81,0x79,0x74,0x73,0x78,0x6b,0x76,0x8a,
+	0x7c,0x9a,0x99,0xa2,0xab,0xbb,0xba,0xc0,
+	0xc7,0xb2,0xb8,0xae,0xb2,0xb5,0xc5,0xc8,
+	0xcc,0xcd,0xc5,0xc8,0xbf,0xc0,0xb6,0xac,
+	0x9c,0x8d,0x83,0x7e,0x86,0x85,0x8d,0x86,
+	0x79,0x6d,0x63,0x57,0x57,0x52,0x48,0x42,
+	0x3c,0x34,0x3d,0x4b,0x52,0x5f,0x62,0x57,
+	0x51,0x51,0x48,0x53,0x63,0x5f,0x6b,0x70,
+	0x70,0x7a,0x92,0x97,0xa4,0xb1,0x9c,0x9b,
+	0x97,0x97,0x9a,0xb6,0xb3,0xb7,0xc6,0xb2,
+	0xbc,0xc4,0xc9,0xc3,0xd2,0xb8,0xa6,0xb0,
+	0x9a,0xa8,0xba,0xc2,0xb6,0xc5,0xb1,0xa0,
+	0xb7,0xa8,0xac,0xaf,0xaa,0x89,0x9c,0x93,
+	0x8f,0xb6,0xb1,0xaf,0xac,0xa0,0x79,0x80,
+	0x75,0x59,0x76,0x73,0x85,0x71,0x78,0x79,
+	0x84,0x79,0x4b,0x4b,0x2f,0x29,0x4a,0x4d,
+	0x39,0x6d,0x68,0x3e,0x42,0x41,0x34,0x47,
+	0x61,0x47,0x4c,0x4f,0x25,0x36,0x44,0x43,
+	0x51,0x6d,0x4b,0x4d,0x5b,0x44,0x54,0x6f,
+	0x5e,0x54,0x60,0x3f,0x3e,0x62,0x59,0x6f,
+	0x8a,0x76,0x69,0x7c,0x6a,0x6e,0x95,0x8c,
+	0x84,0x98,0x80,0x77,0xa1,0xa6,0xac,0xd5,
+	0xc2,0xa8,0xba,0xa9,0xa2,0xcb,0xcb,0xb9,
+	0xcc,0xb9,0x9d,0xc1,0xc4,0xbe,0xd7,0xcc,
+	0x9b,0x9f,0x95,0x75,0x9a,0xa0,0x86,0x90,
+	0x85,0x5c,0x67,0x7c,0x5f,0x79,0x75,0x49,
+	0x41,0x44,0x2c,0x3e,0x68,0x4d,0x59,0x5c,
+	0x3b,0x3e,0x5b,0x53,0x5a,0x7d,0x53,0x50,
+	0x60,0x56,0x65,0x94,0x97,0x8a,0xaa,0x84,
+	0x7d,0x9d,0x9e,0x9f,0xbf,0xb6,0x91,0xb3,
+	0xa3,0xa4,0xd1,0xd4,0xc5,0xcd,0xc2,0x93,
+	0xb6,0xb5,0xaf,0xcb,0xc8,0xa9,0xab,0xb8,
+	0x98,0xc2,0xcb,0xb6,0xba,0xb1,0x8c,0x90,
+	0xaf,0x95,0xb3,0xba,0x97,0x91,0x91,0x7a,
+	0x74,0x91,0x6a,0x6c,0x7f,0x78,0x73,0x71,
+	0x80,0x8d,0xa3,0x6c,0x4d,0x46,0x27,0x2f,
+	0x5d,0x73,0x4d,0x56,0x50,0x4b,0x62,0x59,
+	0x51,0x64,0x5c,0x33,0x47,0x37,0x2b,0x4f,
+	0x53,0x49,0x4f,0x4f,0x2d,0x4d,0x57,0x52,
+	0x6c,0x6c,0x51,0x4c,0x57,0x3d,0x5f,0x75,
+	0x63,0x72,0x72,0x5c,0x5e,0x85,0x74,0x8b,
+	0x9e,0x7e,0x7b,0x85,0x7b,0x86,0xb6,0xa5,
+	0xac,0xba,0x9c,0x9c,0xb5,0xb9,0xb4,0xd7,
+	0xbc,0xa6,0xb8,0xa6,0xa7,0xca,0xd0,0xb5,
+	0xc9,0xb0,0x8e,0xa6,0xa4,0x97,0xa7,0xa7,
+	0x78,0x80,0x7b,0x61,0x80,0x89,0x74,0x6f,
+	0x6f,0x3f,0x45,0x58,0x42,0x59,0x61,0x47,
+	0x38,0x4e,0x36,0x43,0x6c,0x56,0x59,0x60,
+	0x48,0x3b,0x60,0x5f,0x65,0x8f,0x79,0x71,
+	0x80,0x80,0x78,0xa4,0xab,0x96,0xb0,0x9a,
+	0x8b,0xa0,0xb3,0xad,0xc9,0xd3,0xaf,0xbf,
+	0xb9,0xaf,0xbf,0xd3,0xbe,0xc1,0xc6,0xa0,
+	0xb4,0xbe,0xbd,0xc8,0xd7,0xbf,0xac,0xbd,
+	0x9e,0xac,0xbe,0xb3,0xac,0xae,0x9c,0x86,
+	0x9f,0x8c,0x8c,0x8d,0x75,0x5a,0x5f,0x75,
+	0x81,0x9c,0x73,0x78,0x95,0x82,0x60,0x4d,
+	0x4a,0x2e,0x4e,0x5b,0x60,0x4e,0x29,0x3b,
+	0x5d,0x7c,0x62,0x64,0x54,0x3d,0x3a,0x3a,
+	0x3e,0x38,0x47,0x31,0x2f,0x32,0x2d,0x3b,
+	0x46,0x54,0x4a,0x54,0x48,0x44,0x50,0x4d,
+	0x5b,0x5a,0x62,0x53,0x5e,0x60,0x67,0x7a,
+	0x7d,0x8a,0x82,0x88,0x7e,0x86,0x8f,0x92,
+	0xa3,0x9f,0xac,0xa4,0xaf,0xb6,0xbd,0xc6,
+	0xc8,0xcd,0xba,0xc7,0xba,0xbd,0xc6,0xc6,
+	0xc8,0xc3,0xcc,0xb4,0xc2,0xbc,0xae,0xb4,
+	0xa7,0x9b,0x89,0x97,0x75,0x82,0x82,0x70,
+	0x81,0x74,0x68,0x5c,0x59,0x3d,0x3f,0x4a,
+	0x3f,0x46,0x36,0x41,0x3a,0x43,0x44,0x44,
+	0x4e,0x45,0x50,0x47,0x46,0x3b,0x46,0x5d,
+	0x6b,0x85,0x90,0xaf,0xba,0xcd,0xd5,0xd3,
+	0xda,0xd0,0xd5,0xc8,0xce,0xc8,0xc9,0xcd,
+	0xc7,0xd1,0xc7,0xce,0xc5,0xc4,0xbe,0xb5,
+	0xb6,0xab,0xb0,0xa7,0xac,0xa9,0xad,0xae,
+	0xa8,0xac,0xa1,0xa4,0x98,0x95,0x8f,0x89,
+	0x8c,0x82,0x8a,0x86,0x8a,0x88,0x86,0x84,
+	0x7e,0x7b,0x71,0x6f,0x68,0x65,0x63,0x62,
+	0x65,0x64,0x68,0x63,0x66,0x64,0x5e,0x5a,
+	0x54,0x52,0x49,0x4a,0x48,0x4b,0x4d,0x51,
+	0x51,0x52,0x54,0x51,0x4e,0x4a,0x47,0x42,
+	0x41,0x42,0x42,0x45,0x49,0x4b,0x4f,0x53,
+	0x4f,0x52,0x4e,0x4d,0x4a,0x47,0x49,0x48,
+	0x4d,0x4f,0x55,0x57,0x5d,0x5e,0x61,0x60,
+	0x5f,0x44,0x23,0x4f,0x44,0x64,0xa0,0x6b,
+	0x72,0x63,0x3f,0x74,0x5a,0x66,0x9c,0x53,
+	0x87,0xa2,0x5f,0xaf,0x89,0x60,0xaf,0x71,
+	0x89,0xc4,0x76,0x91,0x9a,0x4c,0x9b,0x8f,
+	0x68,0xb1,0x5f,0x58,0x8a,0x4e,0x85,0x9c,
+	0x4e,0x77,0x57,0x2d,0x81,0x5b,0x64,0x84,
+	0x39,0x44,0x6c,0x46,0x9a,0x9b,0x65,0x96,
+	0x4e,0x5d,0x92,0x71,0x8e,0x8a,0x57,0x6b,
+	0x8a,0x89,0xd7,0xc2,0xa4,0xae,0x72,0x90,
+	0xaa,0xa1,0xb3,0x96,0x72,0x7e,0x95,0xaa,
+	0xdd,0xc5,0xaf,0x97,0x7a,0x8b,0x9a,0xa6,
+	0xa0,0x87,0x71,0x71,0x90,0xbb,0xd2,0xd5,
+	0xaf,0x8f,0x8a,0x93,0xb8,0xbe,0xa6,0x92,
+	0x73,0x68,0x98,0xa8,0xab,0xbc,0x83,0x88,
+	0x93,0x88,0xb9,0xa1,0x6e,0x5d,0x3e,0x44,
+	0x93,0x9a,0xb6,0xc3,0x6e,0x87,0x76,0x7b,
+	0xaf,0x8b,0x76,0x77,0x58,0x76,0xbb,0xa4,
+	0xcf,0xb9,0x71,0x9e,0x7c,0x95,0xc5,0x94,
+	0x88,0x7f,0x55,0x81,0xb0,0x8f,0xbc,0x7c,
+	0x46,0x6b,0x3a,0x6d,0x7f,0x4d,0x50,0x3e,
+	0x2c,0x72,0x90,0x8b,0xb8,0x6f,0x6c,0x85,
+	0x6d,0xb1,0xad,0x88,0x90,0x70,0x70,0xb5,
+	0xb2,0xbc,0xc0,0x69,0x79,0x6e,0x6b,0x9e,
+	0x7e,0x65,0x65,0x4e,0x70,0xaf,0x97,0xac,
+	0x99,0x67,0x8d,0x82,0x9d,0xa9,0x80,0x6f,
+	0x5f,0x50,0x7e,0xa2,0xa3,0xad,0x7c,0x54,
+	0x54,0x4d,0x61,0x70,0x4f,0x3e,0x2c,0x2f,
+	0x60,0x7f,0x99,0x96,0x7d,0x70,0x75,0x8f,
+	0xa4,0xb3,0x9c,0x89,0x79,0x86,0xa2,0xb7,
+	0xbd,0x93,0x7d,0x4d,0x51,0x60,0x5b,0x66,
+	0x46,0x31,0x3a,0x58,0x77,0xae,0xad,0x9b,
+	0xa7,0x78,0xa8,0xb4,0xad,0xc3,0x92,0x83,
+	0x8c,0x91,0xa4,0xcb,0x96,0x8d,0x79,0x3b,
+	0x78,0x57,0x5d,0x69,0x35,0x3f,0x5d,0x69,
+	0xa2,0xb2,0x6c,0x96,0x78,0x7a,0xc9,0x89,
+	0x95,0x93,0x5f,0x85,0x8a,0x7e,0xac,0xa0,
+	0x6d,0x95,0x45,0x54,0x6f,0x34,0x61,0x43,
+	0x23,0x50,0x4a,0x56,0x97,0x7b,0x81,0xa9,
+	0x6b,0xa9,0xab,0x91,0xc7,0x98,0x93,0xb5,
+	0x93,0xa8,0xc0,0x7f,0x93,0x7a,0x42,0x74,
+	0x42,0x41,0x5d,0x28,0x4b,0x62,0x53,0x95,
+	0x9c,0x89,0xc0,0x98,0xa2,0xcc,0x97,0xbc,
+	0xb4,0x88,0xb2,0x9e,0x93,0xbd,0x92,0x8b,
+	0x9d,0x5a,0x76,0x6e,0x44,0x6e,0x4f,0x48,
+	0x7d,0x66,0x91,0xac,0x6d,0x99,0x95,0x8a,
+	0xb8,0x7b,0x77,0x90,0x6c,0x85,0x97,0x73,
+	0x9d,0x8e,0x72,0x8f,0x60,0x58,0x62,0x36,
+	0x40,0x48,0x27,0x51,0x4d,0x4a,0x7f,0x6e,
+	0x88,0xa4,0x8c,0xaa,0xaf,0x9a,0xb7,0xaf,
+	0xa0,0xc4,0xa0,0xa3,0xad,0x80,0x93,0x7a,
+	0x5a,0x5e,0x41,0x30,0x42,0x37,0x42,0x65,
+	0x50,0x81,0x86,0x8e,0xbc,0xad,0xbb,0xbf,
+	0xad,0xae,0xbf,0xa9,0xbb,0xb8,0x98,0xb2,
+	0x90,0x9a,0x98,0x7f,0x7c,0x65,0x55,0x53,
+	0x68,0x6a,0x8f,0x8c,0x94,0x9c,0x73,0xad,
+	0x9b,0xa0,0x76,0x6c,0x67,0x5e,0x77,0x6f,
+	0x88,0x6e,0x75,0x6b,0x68,0x76,0x61,0x62,
+	0x40,0x3a,0x2a,0x34,0x42,0x42,0x5a,0x4d,
+	0x68,0x69,0x8f,0xa0,0xac,0xb7,0xa5,0xb5,
+	0xa6,0xc2,0xbe,0xc0,0xb8,0x9b,0x9d,0x82,
+	0x90,0x74,0x70,0x4e,0x39,0x33,0x29,0x47,
+	0x41,0x60,0x58,0x6c,0x7b,0x8f,0xb2,0xb1,
+	0xc8,0xaf,0xba,0xac,0xbd,0xc3,0xbe,0xc3,
+	0xa7,0xaf,0x9b,0xaa,0xa0,0x9a,0x8b,0x6e,
+	0x74,0x60,0x82,0x7f,0x99,0x97,0x97,0x84,
+	0x81,0xaf,0x91,0x84,0x5a,0x69,0x53,0x54,
+	0x6d,0x65,0x79,0x5e,0x69,0x5b,0x63,0x69,
+	0x59,0x59,0x32,0x39,0x24,0x3c,0x3f,0x4e,
+	0x5a,0x54,0x72,0x73,0xa0,0xa2,0xb9,0xb3,
+	0xac,0xb7,0xaa,0xc6,0xb8,0xc2,0xa8,0x9e,
+	0x91,0x82,0x88,0x6b,0x6a,0x40,0x3c,0x2c,
+	0x35,0x48,0x48,0x63,0x59,0x79,0x7c,0xa1,
+	0xb0,0xbb,0xc1,0xae,0xba,0xa9,0xc4,0xbd,
+	0xc3,0xbb,0xab,0xaf,0x9e,0xb2,0x9e,0xa3,
+	0x85,0x7d,0x76,0x76,0x8f,0x8d,0xa9,0x96,
+	0x8b,0x7b,0x9b,0xa0,0x76,0x66,0x56,0x5f,
+	0x41,0x53,0x5d,0x5e,0x69,0x52,0x61,0x4e,
+	0x63,0x58,0x57,0x47,0x31,0x36,0x27,0x45,
+	0x3f,0x5c,0x57,0x65,0x7b,0x83,0xad,0xa8,
+	0xc0,0xb1,0xb9,0xb3,0xba,0xbf,0xb8,0xbd,
+	0x9a,0xa3,0x83,0x88,0x7c,0x62,0x5b,0x38,
+	0x36,0x2b,0x3c,0x3b,0x58,0x57,0x67,0x85,
+	0x83,0xb4,0xad,0xbf,0xbe,0xb8,0xb8,0xbe,
+	0xbf,0xbf,0xcb,0xaa,0xc2,0xaa,0xac,0xb4,
+	0x95,0x9c,0x85,0x7a,0x7c,0x87,0x89,0xab,
+	0x9f,0x7f,0x94,0x90,0xa8,0x7c,0x4c,0x5d,
+	0x55,0x43,0x41,0x3b,0x42,0x5b,0x3d,0x5f,
+	0x53,0x49,0x63,0x3e,0x44,0x3d,0x25,0x31,
+	0x39,0x2d,0x54,0x58,0x60,0x92,0x84,0xaa,
+	0xbd,0xae,0xcb,0xc2,0xb8,0xcc,0xb8,0xb2,
+	0xc5,0x9c,0xac,0xa1,0x7a,0x8b,0x60,0x51,
+	0x54,0x2d,0x34,0x3b,0x25,0x4d,0x54,0x57,
+	0x8f,0x86,0x9e,0xbc,0xa4,0xc3,0xc2,0xac,
+	0xcd,0xb5,0xb1,0xcd,0xaf,0xc2,0xcd,0xa9,
+	0xbf,0xaa,0x8e,0xa9,0x86,0x8b,0x9d,0x7f,
+	0x9d,0x9a,0x6f,0x96,0x9e,0x8e,0x98,0x57,
+	0x4d,0x6d,0x44,0x55,0x3b,0x31,0x56,0x42,
+	0x51,0x64,0x46,0x56,0x52,0x2b,0x51,0x35,
+	0x33,0x51,0x28,0x4f,0x5a,0x5f,0x95,0x9b,
+	0x99,0xbf,0xa3,0xb3,0xd4,0xa6,0xd0,0xb2,
+	0x9b,0xb5,0x97,0xa5,0xad,0x8a,0x78,0x71,
+	0x42,0x54,0x38,0x3e,0x50,0x38,0x4a,0x42,
+	0x68,0x70,0x93,0x9b,0xa9,0xb2,0xac,0xbd,
+	0xa8,0xbd,0xaa,0xbb,0xb5,0xbf,0xc4,0xc0,
+	0xcb,0xbb,0xc3,0xac,0xae,0xa0,0x9c,0x9c,
+	0x8f,0x93,0x6a,0x86,0x90,0xa0,0x8a,0x77,
+	0x63,0x3d,0x58,0x49,0x4c,0x2a,0x36,0x33,
+	0x42,0x49,0x4d,0x57,0x4f,0x55,0x48,0x49,
+	0x3d,0x3f,0x42,0x45,0x57,0x61,0x7a,0x88,
+	0x9e,0xa9,0xb5,0xba,0xb9,0xb8,0xb2,0xaf,
+	0xa9,0xa6,0xa4,0xa2,0x9e,0x99,0x90,0x85,
+	0x73,0x66,0x52,0x47,0x3b,0x38,0x3f,0x42,
+	0x59,0x63,0x7d,0x87,0x9a,0xa1,0xa6,0xab,
+	0xa6,0xae,0xa3,0xb1,0xa9,0xb9,0xb9,0xc1,
+	0xc6,0xc1,0xc7,0xb8,0xb9,0xaa,0xa5,0x9f,
+	0x92,0x8b,0x6b,0x7e,0x86,0x99,0x89,0x83,
+	0x7a,0x69,0x53,0x4f,0x60,0x50,0x53,0x3d,
+	0x45,0x21,0x44,0x50,0x57,0x93,0x60,0x65,
+	0x48,0x34,0x67,0x44,0x59,0x73,0x46,0x96,
+	0x94,0x94,0xcd,0x76,0xb1,0x9f,0x8c,0xd4,
+	0x79,0xac,0x8f,0x75,0xb7,0x7f,0xa5,0x9b,
+	0x66,0x97,0x5e,0x6a,0x7e,0x39,0x74,0x48,
+	0x54,0x86,0x52,0x9f,0x81,0x87,0xb4,0x7e,
+	0xae,0x98,0x89,0xb6,0x8a,0xac,0xaa,0x94,
+	0xc8,0xab,0xc8,0xca,0xa1,0xba,0x95,0xa1,
+	0xaa,0x86,0x7c,0x63,0x73,0x92,0x8b,0x99,
+	0x8c,0x78,0x69,0x50,0x52,0x66,0x67,0x49,
+	0x36,0x29,0x4a,0x6a,0x6a,0x70,0x4b,0x47,
+	0x5a,0x61,0x78,0x6e,0x44,0x58,0x47,0x81,
+	0xab,0x90,0xb6,0x6c,0x8d,0xa1,0x99,0xce,
+	0x88,0x7c,0x76,0x62,0xae,0xa7,0x98,0xa1,
+	0x4e,0x81,0x85,0x81,0xb6,0x48,0x65,0x46,
+	0x47,0xa6,0x77,0x9a,0x78,0x4f,0x95,0x88,
+	0xb2,0xbb,0x67,0x8a,0x5e,0x84,0xca,0x8f,
+	0xc2,0x76,0x73,0xb1,0x94,0xdd,0xa9,0x78,
+	0x87,0x4f,0x91,0x9e,0x86,0x9f,0x49,0x63,
+	0x8b,0x81,0xc9,0x75,0x60,0x52,0x35,0x95,
+	0x82,0x76,0x6d,0x24,0x60,0x6c,0x82,0xae,
+	0x5b,0x61,0x4c,0x4d,0xa0,0x80,0x8c,0x70,
+	0x3e,0x83,0x86,0xb1,0xc2,0x73,0x81,0x5c,
+	0x7d,0xbc,0x92,0xa2,0x62,0x4e,0x85,0x89,
+	0xc0,0xaa,0x69,0x6b,0x4d,0x80,0xab,0x84,
+	0x8b,0x3f,0x45,0x7a,0x88,0xc7,0x93,0x71,
+	0x65,0x5e,0xa3,0xb7,0xa7,0x8c,0x52,0x60,
+	0x96,0xb1,0xda,0xa1,0x7e,0x74,0x78,0xc3,
+	0xc0,0xb0,0x74,0x3b,0x56,0x82,0xb6,0xab,
+	0x83,0x50,0x55,0x70,0xaa,0xb1,0x83,0x49,
+	0x2b,0x4a,0x77,0x9e,0x86,0x65,0x35,0x3f,
+	0x76,0x93,0xb4,0x6f,0x50,0x35,0x52,0x9a,
+	0xa6,0xa2,0x70,0x4e,0x69,0x98,0xb8,0xc9,
+	0x7c,0x62,0x55,0x65,0xbd,0x9c,0xa5,0x68,
+	0x44,0x7f,0x89,0xc2,0xac,0x6a,0x5d,0x47,
+	0x73,0xb0,0x8f,0x94,0x54,0x40,0x8b,0x82,
+	0xcd,0x9f,0x63,0x74,0x48,0x9f,0xb1,0x9b,
+	0xa0,0x51,0x68,0x96,0x9b,0xd9,0x99,0x76,
+	0x7e,0x56,0xb8,0x9f,0x8b,0x91,0x37,0x75,
+	0x79,0x90,0xc3,0x6f,0x6e,0x61,0x55,0xae,
+	0x85,0x83,0x77,0x2a,0x71,0x68,0x8c,0xaf,
+	0x52,0x6e,0x4a,0x5f,0xb0,0x7f,0x95,0x67,
+	0x37,0x82,0x75,0xac,0xb5,0x5d,0x85,0x52,
+	0x7e,0xc2,0x86,0xa9,0x5c,0x46,0x8e,0x72,
+	0xc1,0x9f,0x5e,0x80,0x49,0x92,0xb7,0x83,
+	0xa3,0x45,0x50,0x89,0x6f,0xc7,0x83,0x60,
+	0x7b,0x45,0xab,0xaa,0x90,0xa4,0x3f,0x6c,
+	0x8b,0x86,0xd4,0x7d,0x75,0x7e,0x56,0xc9,
+	0xac,0xa2,0xa5,0x39,0x81,0x77,0x8c,0xca,
+	0x60,0x72,0x5d,0x54,0xbf,0x8e,0x9d,0x83,
+	0x2f,0x81,0x63,0x92,0xaf,0x4a,0x6f,0x42,
+	0x5c,0xb4,0x78,0x9c,0x65,0x37,0x87,0x69,
+	0xa5,0xa3,0x50,0x7d,0x4b,0x80,0xbd,0x83,
+	0xb1,0x61,0x54,0x96,0x72,0xbd,0x93,0x5b,
+	0x7e,0x46,0x96,0xaf,0x85,0xa9,0x4f,0x64,
+	0x8f,0x74,0xc0,0x7b,0x60,0x73,0x46,0xa1,
+	0x9d,0x8a,0x9d,0x47,0x78,0x89,0x85,0xc1,
+	0x73,0x71,0x73,0x59,0xb3,0x98,0x9a,0x99,
+	0x52,0x8d,0x8b,0x98,0xc1,0x6d,0x76,0x62,
+	0x5d,0xb1,0x88,0x92,0x82,0x42,0x89,0x7a,
+	0x99,0xb2,0x5f,0x71,0x50,0x5e,0xa9,0x79,
+	0x8f,0x6c,0x3e,0x85,0x6f,0x9d,0xa5,0x58,
+	0x79,0x52,0x6b,0xad,0x79,0x9e,0x69,0x50,
+	0x93,0x79,0xb3,0xa3,0x66,0x82,0x54,0x80,
+	0xaa,0x7e,0x9d,0x62,0x54,0x95,0x76,0xb8,
+	0x98,0x62,0x84,0x4a,0x8c,0xa1,0x7c,0x99,
+	0x51,0x5d,0x8b,0x7a,0xbb,0x8f,0x67,0x83,
+	0x51,0x9a,0xa6,0x7f,0xa1,0x4b,0x6f,0x8e,
+	0x83,0xc8,0x84,0x7b,0x80,0x5d,0xa7,0x9c,
+	0x85,0x90,0x46,0x6e,0x88,0x7b,0xbf,0x72,
+	0x74,0x77,0x54,0xb1,0x86,0x89,0x80,0x3c,
+	0x73,0x74,0x84,0xad,0x6a,0x70,0x6d,0x58,
+	0xb0,0x87,0x8a,0x83,0x35,0x84,0x6e,0x95,
+	0xb2,0x65,0x84,0x64,0x73,0xb5,0x8f,0x96,
+	0x7d,0x45,0x85,0x75,0x95,0xb1,0x5b,0x89,
+	0x5d,0x78,0xb8,0x81,0xa4,0x64,0x51,0x81,
+	0x6f,0x9f,0x9a,0x60,0x7b,0x5f,0x7e,0xba,
+	0x81,0xa7,0x66,0x52,0x92,0x69,0xb4,0x90,
+	0x65,0x81,0x58,0x94,0xb2,0x91,0xa4,0x6a,
+	0x58,0x90,0x71,0xaa,0x90,0x56,0x83,0x47,
+	0x96,0xaa,0x87,0xaa,0x56,0x65,0x80,0x73,
+	0xab,0x82,0x59,0x6d,0x4c,0x89,0xac,0x81,
+	0xa4,0x53,0x62,0x8a,0x71,0xb8,0x77,0x61,
+	0x6b,0x4d,0x97,0xa3,0x94,0x9b,0x5d,0x6d,
+	0x8e,0x84,0xb7,0x7f,0x5f,0x6e,0x4a,0x9c,
+	0x9e,0x92,0x9a,0x54,0x74,0x87,0x8d,0xb4,
+	0x79,0x63,0x60,0x4f,0x96,0x9a,0x8e,0x92,
+	0x54,0x76,0x8d,0x94,0xba,0x7c,0x69,0x60,
+	0x58,0x9b,0x97,0x92,0x8d,0x57,0x7d,0x8c,
+	0xa0,0xb8,0x7e,0x6e,0x5d,0x5f,0x92,0x95,
+	0x8d,0x7e,0x56,0x73,0x8d,0x9f,0xb4,0x7d,
+	0x69,0x5a,0x60,0x93,0x8c,0x8b,0x6c,0x53,
+	0x6d,0x88,0xa5,0xa8,0x86,0x66,0x61,0x68,
+	0x92,0x94,0x84,0x6e,0x51,0x73,0x87,0xad,
+	0xa9,0x88,0x73,0x60,0x7d,0x8e,0x9e,0x81,
+	0x68,0x59,0x65,0x92,0xa1,0xa9,0x85,0x6f,
+	0x67,0x7b,0x94,0x95,0x85,0x5a,0x5d,0x5e,
+	0x8d,0xa4,0x9b,0x94,0x62,0x77,0x81,0x94,
+	0xa7,0x7d,0x67,0x5a,0x60,0x8d,0xa4,0x96,
+	0x94,0x69,0x74,0x90,0x8d,0xb3,0x7b,0x64,
+	0x63,0x50,0x93,0x93,0x92,0x91,0x5e,0x78,
+	0x8d,0x8d,0xb2,0x7a,0x64,0x67,0x4b,0x8f,
+	0x8f,0x85,0x92,0x59,0x79,0x8f,0x8d,0xb9,
+	0x7e,0x6a,0x6f,0x4d,0x92,0x89,0x81,0x92,
+	0x52,0x81,0x8a,0x91,0xb9,0x80,0x72,0x70,
+	0x56,0x8e,0x8a,0x78,0x8e,0x50,0x7b,0x8f,
+	0x87,0xbf,0x7b,0x7d,0x76,0x59,0x95,0x7f,
+	0x82,0x7f,0x58,0x75,0x8b,0x8b,0xb1,0x86,
+	0x7a,0x81,0x5e,0x97,0x81,0x79,0x84,0x51,
+	0x7a,0x7e,0x8e,0xa9,0x86,0x83,0x7d,0x72,
+	0x8c,0x89,0x7a,0x7c,0x5b,0x70,0x80,0x85,
+	0xa2,0x84,0x85,0x82,0x7a,0x8f,0x86,0x81,
+	0x75,0x64,0x6e,0x7a,0x85,0x91,0x88,0x84,
+	0x82,0x85,0x8b,0x8a,0x83,0x74,0x70,0x6a,
+	0x77,0x82,0x83,0x8a,0x81,0x84,0x8c,0x89,
+	0x8b,0x87,0x73,0x7b,0x6e,0x72,0x85,0x71,
+	0x8e,0x7c,0x83,0x95,0x7c,0x94,0x83,0x79,
+	0x85,0x6f,0x77,0x7e,0x6e,0x84,0x80,0x75,
+	0x96,0x6f,0x85,0x80,0x66,0x89,0x5f,0x6c,
+	0x6c,0x4f,0x74,0x5f,0x63,0x73,0x52,0x67,
+	0x63,0x54,0x72,0x4a,0x54,0x49,0x33,0x50,
+	0x4f,0x50,0x6f,0x4c,0x64,0x64,0x4e,0x6c,
+	0x43,0x41,0x3d,0x27,0x4e,0x56,0x5b,0x81,
+	0x5b,0x7a,0x69,0x68,0x74,0x54,0x49,0x45,
+	0x33,0x5c,0x6a,0x71,0x99,0x6b,0x93,0x80,
+	0x88,0x8e,0x77,0x63,0x60,0x56,0x78,0x93,
+	0x95,0xbe,0x8d,0xb9,0x9c,0xb1,0xa9,0x9a,
+	0x7b,0x79,0x6f,0x89,0xab,0xaa,0xca,0xa1,
+	0xba,0x9d,0xb9,0xa3,0xa0,0x78,0x68,0x63,
+	0x73,0x9c,0x9e,0xae,0x88,0x97,0x7b,0x9d,
+	0x7d,0x81,0x4d,0x3f,0x40,0x4c,0x77,0x7a,
+	0x80,0x69,0x6c,0x5a,0x81,0x5d,0x6d,0x3e,
+	0x33,0x3d,0x43,0x75,0x7f,0x82,0x7e,0x77,
+	0x70,0x94,0x7e,0x94,0x6a,0x5c,0x6c,0x6d,
+	0xa8,0xba,0xb4,0xb7,0xa4,0xa2,0xca,0xb2,
+	0xc3,0x9a,0x86,0x96,0x98,0xcb,0xd8,0xcb,
+	0xce,0xb4,0xb8,0xd9,0xbb,0xc9,0x9e,0x85,
+	0x97,0x97,0xc1,0xc6,0xab,0xad,0x7c,0x8c,
+	0x91,0x75,0x80,0x76,0x4f,0x5e,0x5e,0x68,
+	0x62,0x51,0x75,0x72,0x72,0x85,0x88,0x7a,
+	0x4b,0x2f,0x49,0x43,0x7b,0x80,0x75,0x84,
+	0x6c,0x81,0x8b,0x79,0x7c,0x57,0x49,0x5d,
+	0x57,0x89,0x86,0x79,0x80,0x5f,0x6f,0x72,
+	0x63,0x61,0x42,0x2e,0x45,0x42,0x73,0x6f,
+	0x6e,0x6a,0x58,0x68,0x71,0x6c,0x6b,0x53,
+	0x4a,0x66,0x6b,0xa1,0x9d,0xa6,0xa1,0x9c,
+	0xa8,0xb5,0xb2,0xae,0x9e,0x93,0xaa,0xae,
+	0xd9,0xd0,0xd7,0xc4,0xc1,0xbe,0xc4,0xb8,
+	0xaa,0x91,0x81,0x8a,0x8d,0xa8,0x99,0x9c,
+	0x7c,0x7d,0x6e,0x75,0x66,0x55,0x43,0x34,
+	0x3e,0x4d,0x65,0x62,0x6b,0x51,0x63,0x55,
+	0x6c,0x63,0x5d,0x57,0x54,0x65,0x81,0x97,
+	0xa0,0xac,0x95,0xb0,0x9b,0xba,0xac,0xa8,
+	0x9f,0x9b,0xa6,0xbf,0xc8,0xd4,0xd3,0xb6,
+	0xcd,0xaa,0xc5,0xaa,0x9f,0x92,0x87,0x88,
+	0xa3,0x9c,0xab,0x9f,0x83,0x98,0x6e,0x8c,
+	0x6a,0x63,0x55,0x4b,0x50,0x71,0x64,0x81,
+	0x6d,0x5d,0x73,0x4c,0x74,0x4f,0x52,0x4a,
+	0x49,0x59,0x89,0x81,0xb8,0x9b,0xa9,0xb1,
+	0x83,0x8b,0x76,0x82,0x77,0x8b,0x9b,0xbb,
+	0x82,0xb9,0x91,0x97,0x9d,0x8b,0xac,0x86,
+	0x88,0x7e,0x76,0x8b,0xa6,0x91,0xc1,0x80,
+	0x9b,0x82,0x74,0x80,0x5a,0x55,0x4e,0x3c,
+	0x5b,0x66,0x5a,0x81,0x44,0x66,0x45,0x44,
+	0x4c,0x32,0x2f,0x33,0x28,0x4f,0x54,0x5d,
+	0x7d,0x52,0x7d,0x5d,0x6e,0x74,0x66,0x6d,
+	0x78,0x71,0xa2,0xa0,0xb5,0xc9,0xa8,0xcf,
+	0xad,0xbd,0xba,0xac,0xac,0xb0,0xa2,0xcc,
+	0xb7,0xcd,0xc9,0xac,0xbd,0x96,0x9d,0x90,
+	0x77,0x72,0x6f,0x5b,0x83,0x61,0x7f,0x6d,
+	0x58,0x66,0x42,0x4e,0x41,0x32,0x39,0x37,
+	0x35,0x61,0x48,0x78,0x64,0x66,0x74,0x61,
+	0x71,0x6f,0x66,0x7a,0x79,0x83,0xaf,0x9a,
+	0xcb,0xb3,0xbd,0xc1,0xaf,0xb7,0xb2,0xa3,
+	0xb4,0xa8,0xb4,0xcc,0xb5,0xdb,0xb7,0xc1,
+	0xb3,0xa0,0x9f,0x91,0x7d,0x8e,0x74,0x8a,
+	0x91,0x85,0xa3,0x79,0x89,0x7b,0x6e,0x71,
+	0x60,0x55,0x67,0x4f,0x76,0x74,0x7b,0x94,
+	0x74,0x8c,0x7c,0x77,0x85,0x75,0x7f,0x92,
+	0x7d,0xa8,0x79,0x87,0xaf,0x93,0x9c,0x89,
+	0x80,0x81,0x40,0x4f,0x68,0x57,0x7d,0x6d,
+	0x90,0x91,0x7d,0x92,0x71,0x71,0x77,0x53,
+	0x6c,0x5a,0x62,0x83,0x70,0x88,0x7e,0x61,
+	0x74,0x46,0x54,0x47,0x30,0x43,0x2f,0x41,
+	0x5b,0x4c,0x68,0x58,0x4a,0x5b,0x35,0x50,
+	0x3f,0x3b,0x4f,0x47,0x61,0x7c,0x76,0x98,
+	0x85,0x88,0x96,0x79,0x9d,0x84,0x90,0x9a,
+	0x99,0xb0,0xc5,0xbc,0xdb,0xbb,0xc6,0xbe,
+	0xa9,0xbe,0x9e,0xa5,0xa3,0x9b,0xac,0xb3,
+	0xa3,0xb9,0x87,0x99,0x79,0x6e,0x73,0x54,
+	0x59,0x55,0x4c,0x63,0x61,0x5e,0x71,0x43,
+	0x61,0x3c,0x48,0x48,0x3b,0x47,0x4c,0x4d,
+	0x75,0x6d,0x83,0x8c,0x6f,0x95,0x71,0x8c,
+	0x86,0x84,0x91,0x97,0x99,0xc3,0xb1,0xcf,
+	0xc4,0xb2,0xc6,0xa2,0xbb,0xa8,0xa5,0xa9,
+	0xa7,0xa7,0xca,0xab,0xce,0xa8,0xa6,0xa1,
+	0x87,0x97,0x82,0x7b,0x81,0x74,0x87,0x98,
+	0x88,0xa7,0x76,0x83,0x72,0x68,0x77,0x64,
+	0x66,0x72,0x67,0x92,0x9b,0xa3,0xb8,0x8f,
+	0xa2,0x80,0x6f,0x62,0x5b,0x75,0x72,0x62,
+	0x95,0x94,0xa9,0x9c,0x65,0x54,0x4e,0x66,
+	0x6a,0x39,0x42,0x34,0x49,0x6e,0x6e,0x83,
+	0x72,0x54,0x61,0x46,0x59,0x56,0x3f,0x4f,
+	0x37,0x57,0x65,0x6d,0x6d,0x5b,0x3a,0x4b,
+	0x2c,0x4e,0x37,0x3a,0x37,0x34,0x51,0x66,
+	0x6d,0x71,0x61,0x50,0x5f,0x52,0x79,0x5f,
+	0x74,0x68,0x7d,0x92,0xae,0xb2,0xb9,0xa3,
+	0xa1,0xa4,0xa6,0xbe,0xa8,0xb5,0xa3,0xba,
+	0xc1,0xdb,0xce,0xcf,0xab,0xad,0x9e,0xa8,
+	0xa3,0x96,0x8c,0x7e,0x8a,0x8f,0x9f,0x8d,
+	0x83,0x5f,0x5c,0x52,0x5f,0x55,0x50,0x3f,
+	0x41,0x4a,0x5e,0x6c,0x62,0x59,0x46,0x47,
+	0x51,0x5e,0x62,0x62,0x59,0x68,0x77,0x94,
+	0xa4,0x9c,0x96,0x87,0x8a,0x9e,0xa1,0xae,
+	0xa1,0x9d,0xaa,0xb6,0xd0,0xd8,0xc0,0xbf,
+	0xa2,0xaf,0xb6,0xb6,0xbe,0xa2,0x9f,0xa9,
+	0xaf,0xc6,0xc0,0xa6,0xa5,0x79,0x9d,0x92,
+	0x9c,0x96,0x7c,0x7f,0x8c,0x92,0xb7,0x9d,
+	0x96,0x8b,0x6f,0xa1,0x8c,0xab,0x94,0x7e,
+	0x7c,0x76,0x66,0x8e,0x81,0x87,0x6b,0x4f,
+	0x73,0x60,0x86,0x66,0x5e,0x5f,0x58,0x54,
+	0x70,0x5d,0x6e,0x3a,0x3a,0x44,0x3e,0x57,
+	0x34,0x35,0x47,0x4d,0x72,0x72,0x4d,0x5c,
+	0x25,0x57,0x4d,0x5a,0x59,0x37,0x3a,0x46,
+	0x4b,0x73,0x58,0x4f,0x45,0x28,0x5b,0x4c,
+	0x64,0x59,0x43,0x4f,0x5c,0x6e,0x93,0x78,
+	0x80,0x6b,0x6d,0x94,0x92,0xaa,0x99,0x8c,
+	0xa0,0xa7,0xc6,0xd4,0xbd,0xbd,0xa8,0xb4,
+	0xcb,0xc8,0xd3,0xb9,0xab,0xb6,0xb5,0xd0,
+	0xc3,0xb3,0x9c,0x8c,0x8e,0x9c,0x96,0x91,
+	0x6e,0x66,0x64,0x70,0x78,0x6d,0x5a,0x43,
+	0x42,0x44,0x5c,0x50,0x51,0x37,0x3e,0x3f,
+	0x5f,0x5c,0x67,0x50,0x4f,0x59,0x62,0x83,
+	0x7a,0x80,0x73,0x7c,0x87,0xa8,0x9f,0xb6,
+	0x8f,0xa8,0xa2,0xb8,0xc9,0xbd,0xbe,0xb4,
+	0xb2,0xc5,0xcc,0xc6,0xd4,0xa3,0xc8,0xaa,
+	0xc8,0xc7,0xb7,0xb6,0xa6,0xa1,0xb9,0xa8,
+	0xb3,0xa9,0x8a,0xad,0x87,0xb4,0xa3,0x9c,
+	0xa0,0x97,0x9f,0xb2,0x9f,0xb6,0x94,0x8a,
+	0x90,0x5f,0x7a,0x52,0x87,0x7f,0x74,0x89,
+	0x6d,0x60,0x74,0x54,0x6b,0x67,0x5a,0x74,
+	0x3d,0x45,0x2a,0x4d,0x62,0x54,0x62,0x4e,
+	0x27,0x44,0x2e,0x3c,0x4a,0x35,0x4f,0x3c,
+	0x45,0x4d,0x41,0x4c,0x50,0x3c,0x5d,0x3e,
+	0x5a,0x4d,0x4c,0x5b,0x4b,0x54,0x55,0x4d,
+	0x5d,0x57,0x5a,0x6e,0x58,0x76,0x65,0x78,
+	0x7a,0x7a,0x82,0x81,0x82,0x91,0x92,0xa0,
+	0xa6,0xa0,0xb2,0xa8,0xbc,0xb9,0xbf,0xba,
+	0xb9,0xb5,0xbf,0xc1,0xc7,0xc4,0xbd,0xb9,
+	0xb8,0xbc,0xb7,0xb3,0x9d,0x9a,0x8d,0x93,
+	0x94,0x8c,0x88,0x75,0x71,0x71,0x6e,0x72,
+	0x61,0x50,0x50,0x41,0x57,0x57,0x51,0x57,
+	0x41,0x4e,0x57,0x57,0x6b,0x52,0x55,0x53,
+	0x54,0x77,0x75,0x7d,0x82,0x6d,0x8e,0x8d,
+	0x9d,0xac,0x8e,0x9a,0x95,0x9c,0xbf,0xb2,
+	0xc0,0xb8,0xa7,0xc8,0xbb,0xd2,0xcd,0xaf,
+	0xbb,0xa7,0xb9,0xcd,0xbb,0xc7,0xb0,0xa7,
+	0xc1,0xb1,0xcb,0xb4,0xa1,0xa5,0x94,0xac,
+	0xb7,0xa8,0xb9,0x97,0xa0,0xaf,0xa3,0xba,
+	0x97,0x82,0x77,0x54,0x69,0x6a,0x8b,0x8d,
+	0x6b,0x8f,0x79,0x6f,0x81,0x5d,0x5f,0x58,
+	0x52,0x6c,0x58,0x4b,0x40,0x25,0x63,0x5e,
+	0x62,0x81,0x41,0x42,0x2c,0x31,0x4b,0x41,
+	0x47,0x41,0x2e,0x4f,0x45,0x5d,0x5a,0x3e,
+	0x4a,0x38,0x4c,0x62,0x55,0x62,0x4d,0x49,
+	0x63,0x5f,0x77,0x6a,0x56,0x61,0x52,0x72,
+	0x80,0x79,0x84,0x71,0x77,0x8f,0x8e,0xae,
+	0x94,0x8e,0x92,0x8a,0xb0,0xb4,0xb3,0xb7,
+	0x9e,0xb0,0xbd,0xc2,0xd5,0xb3,0xaf,0xa7,
+	0xa4,0xc2,0xba,0xb9,0xad,0x95,0xa2,0xa6,
+	0xaa,0xaf,0x87,0x82,0x6e,0x76,0x89,0x7e,
+	0x7a,0x65,0x52,0x63,0x65,0x71,0x6b,0x4b,
+	0x47,0x39,0x4e,0x5e,0x5c,0x5b,0x4a,0x45,
+	0x5b,0x66,0x79,0x72,0x5d,0x5f,0x5b,0x78,
+	0x8c,0x8d,0x8e,0x7e,0x84,0x9c,0xa9,0xba,
+	0xad,0x9d,0x9b,0x9b,0xb6,0xc6,0xc2,0xc0,
+	0xaa,0xb4,0xc2,0xcd,0xd7,0xc2,0xb4,0xac,
+	0xae,0xc2,0xc9,0xc2,0xb9,0xa4,0xad,0xb7,
+	0xc1,0xc7,0xb3,0xa3,0x9e,0xa1,0xb2,0xb7,
+	0xaa,0xa2,0x86,0x8e,0x89,0x89,0x7c,0x60,
+	0x5f,0x78,0x8c,0x81,0x9f,0x97,0x80,0x61,
+	0x69,0x65,0x6d,0x60,0x48,0x35,0x25,0x31,
+	0x4f,0x73,0x58,0x4e,0x59,0x5f,0x53,0x5c,
+	0x4c,0x3f,0x33,0x33,0x41,0x4f,0x53,0x47,
+	0x43,0x38,0x4f,0x4e,0x66,0x56,0x4e,0x45,
+	0x4b,0x58,0x66,0x67,0x5c,0x56,0x4e,0x67,
+	0x6b,0x82,0x6f,0x6e,0x63,0x71,0x81,0x91,
+	0x93,0x8a,0x85,0x86,0xa1,0xa5,0xbe,0xa6,
+	0xaa,0x9c,0xaf,0xbc,0xcd,0xc5,0xbb,0xaf,
+	0xae,0xc4,0xc6,0xd6,0xb6,0xb4,0xa1,0xb2,
+	0xb7,0xc1,0xae,0x9d,0x8b,0x87,0x96,0x94,
+	0x9a,0x76,0x70,0x5a,0x6d,0x70,0x77,0x61,
+	0x51,0x40,0x44,0x53,0x59,0x5c,0x40,0x41,
+	0x32,0x4c,0x58,0x63,0x59,0x4c,0x43,0x55,
+	0x66,0x75,0x7d,0x68,0x6e,0x6a,0x88,0x99,
+	0xa2,0x9d,0x90,0x8a,0x9d,0xac,0xc0,0xc0,
+	0xac,0xae,0xab,0xc5,0xd4,0xd2,0xcc,0xb7,
+	0xae,0xbf,0xc3,0xd4,0xcb,0xb6,0xb5,0xaf,
+	0xc4,0xd2,0xc6,0xc2,0xa5,0xa4,0xb0,0xb2,
+	0xc3,0xb2,0xa5,0xa0,0x9a,0xa8,0xb1,0x9b,
+	0x92,0x68,0x60,0x62,0x63,0x89,0x93,0x8f,
+	0x6a,0x7a,0xa1,0xa0,0x81,0x70,0x3b,0x35,
+	0x2f,0x2a,0x48,0x4a,0x5e,0x3b,0x42,0x73,
+	0x7c,0x63,0x5d,0x30,0x3c,0x3a,0x3e,0x4d,
+	0x34,0x3a,0x32,0x3d,0x51,0x5b,0x4e,0x53,
+	0x30,0x48,0x48,0x52,0x63,0x48,0x51,0x4b,
+	0x58,0x6f,0x75,0x6c,0x6f,0x52,0x6b,0x6b,
+	0x79,0x8a,0x70,0x80,0x7a,0x8a,0xa8,0xa8,
+	0xa7,0xa7,0x8a,0xa9,0xa3,0xb6,0xc3,0xa7,
+	0xb7,0xad,0xbf,0xd8,0xd0,0xd0,0xc1,0xa7,
+	0xbf,0xb2,0xc0,0xc1,0x9f,0xab,0x98,0xa7,
+	0xbb,0xa5,0xa4,0x89,0x70,0x80,0x6e,0x7a,
+	0x75,0x52,0x5f,0x4c,0x5b,0x6f,0x58,0x62,
+	0x41,0x36,0x45,0x3a,0x4e,0x4a,0x34,0x45,
+	0x3d,0x52,0x71,0x5d,0x72,0x55,0x55,0x69,
+	0x63,0x7e,0x7a,0x6f,0x81,0x81,0x95,0xb4,
+	0x9f,0xb8,0x96,0x9f,0xaa,0xa5,0xba,0xb1,
+	0xa9,0xb4,0xb0,0xc0,0xda,0xbf,0xd6,0xb0,
+	0xb4,0xb9,0xb0,0xc0,0xb3,0xad,0xb1,0xae,
+	0xba,0xd0,0xb8,0xc9,0xa5,0xa9,0xa9,0xa2,
+	0xad,0x9e,0x95,0x94,0x8f,0x95,0x9b,0x7e,
+	0x7f,0x57,0x5d,0x6e,0x83,0x97,0x61,0x56,
+	0x70,0x6c,0x6c,0x5e,0x49,0x55,0x54,0x62,
+	0x40,0x33,0x5e,0x5a,0x52,0x4a,0x3f,0x4b,
+	0x49,0x46,0x42,0x30,0x2f,0x2e,0x2e,0x33,
+	0x2e,0x2c,0x35,0x38,0x4e,0x51,0x57,0x4f,
+	0x4b,0x47,0x49,0x4b,0x4f,0x4f,0x4d,0x59,
+	0x61,0x75,0x77,0x84,0x7a,0x80,0x79,0x80,
+	0x84,0x85,0x8c,0x8e,0x9b,0xa3,0xb6,0xba,
+	0xc8,0xbb,0xc7,0xb9,0xbf,0xc1,0xba,0xc4,
+	0xbc,0xc8,0xcb,0xd2,0xd2,0xda,0xc4,0xcd,
+	0xb4,0xb5,0xac,0x99,0xa4,0x8f,0x96,0x96,
+	0x8e,0x8f,0x8d,0x73,0x81,0x5c,0x5d,0x53,
+	0x3c,0x4c,0x3c,0x42,0x4a,0x3d,0x48,0x49,
+	0x39,0x51,0x32,0x3a,0x35,0x2e,0x44,0x42,
+	0x4d,0x53,0x54,0x65,0x79,0x77,0x7d,0x76,
+	0x79,0x79,0x81,0x84,0x7a,0x6d,0x76,0x96,
+	0xad,0xc3,0xc6,0xca,0xc5,0xc2,0xa3,0x8a,
+	0x92,0xa9,0xc0,0xcf,0xda,0xd9,0xd9,0xd3,
+	0xcc,0xc2,0xb9,0xb1,0xac,0xab,0xaa,0xab,
+	0xaf,0xae,0xae,0xac,0xa7,0x9d,0x97,0x8d,
+	0x88,0x81,0x82,0x80,0x84,0x86,0x87,0x88,
+	0x82,0x81,0x76,0x71,0x65,0x65,0x5d,0x5e,
+	0x5c,0x63,0x64,0x65,0x6a,0x63,0x62,0x57,
+	0x58,0x48,0x4a,0x42,0x48,0x45,0x4d,0x4f,
+	0x51,0x56,0x52,0x52,0x47,0x48,0x3b,0x41,
+	0x36,0x3f,0x3d,0x47,0x4a,0x4f,0x52,0x4f,
+	0x52,0x46,0x4d,0x3e,0x47,0x3c,0x4b,0x46,
+	0x53,0x55,0x5e,0x60,0x5e,0x62,0x5b,0x5d,
+	0x54,0x5b,0x55,0x61,0x5e,0x6c,0x6d,0x76,
+	0x78,0x78,0x7b,0x74,0x7b,0x6e,0x77,0x3d,
+	0x5e,0x67,0x91,0xbd,0x8a,0x98,0x5e,0x9c,
+	0xa1,0x93,0x6b,0x5f,0x74,0xb0,0xca,0xa6,
+	0x85,0x66,0x99,0xbc,0xc5,0xa2,0x60,0x6e,
+	0x76,0xb8,0x9e,0x7c,0x5f,0x51,0x9c,0x94,
+	0xaa,0x59,0x4d,0x59,0x70,0xa5,0x60,0x66,
+	0x28,0x62,0x77,0x85,0x79,0x2b,0x54,0x47,
+	0x9c,0x8b,0x75,0x61,0x47,0x96,0x84,0xa8,
+	0x59,0x47,0x61,0x72,0xc6,0x89,0xa1,0x68,
+	0x99,0xc3,0xb7,0xc5,0x5b,0x84,0x69,0xb5,
+	0xb7,0x93,0x9c,0x6d,0xd1,0xb9,0xe0,0xa0,
+	0x73,0x90,0x7f,0xcf,0x8b,0x98,0x6c,0x8e,
+	0xd0,0xbf,0xe0,0x7c,0x93,0x7c,0xb0,0xb6,
+	0x80,0x86,0x56,0xae,0xaf,0xc8,0x99,0x62,
+	0x7a,0x6f,0xb5,0x91,0x8b,0x6c,0x70,0xb0,
+	0xa4,0xba,0x66,0x6a,0x70,0x96,0xbe,0x87,
+	0x83,0x50,0x8a,0x9c,0xb4,0x9f,0x6f,0x8a,
+	0x96,0xd2,0xbb,0x9c,0x6f,0x6d,0x93,0xa7,
+	0xa7,0x86,0x74,0x90,0xb3,0xce,0xae,0x83,
+	0x63,0x65,0x83,0x78,0x60,0x37,0x38,0x59,
+	0x83,0x89,0x71,0x4b,0x55,0x62,0x84,0x6e,
+	0x53,0x42,0x4f,0x94,0x9b,0xbd,0x88,0x9b,
+	0x9a,0xbe,0xc1,0x96,0x81,0x59,0x8b,0x8e,
+	0xaa,0x8f,0x78,0x91,0x98,0xc7,0xa4,0x93,
+	0x55,0x43,0x74,0x67,0x90,0x61,0x80,0x8b,
+	0xb8,0xd5,0x9b,0x82,0x46,0x70,0x65,0x7b,
+	0x66,0x41,0x67,0x58,0x9e,0x75,0x77,0x53,
+	0x4c,0x70,0x55,0x76,0x31,0x55,0x56,0x7e,
+	0xa9,0x86,0xa4,0x6f,0xac,0x94,0xa1,0x89,
+	0x55,0x7b,0x5a,0xa8,0x7d,0x8f,0x78,0x6e,
+	0xa2,0x73,0x9b,0x41,0x59,0x48,0x5e,0x89,
+	0x59,0x98,0x5c,0xb3,0xa1,0xbd,0xb0,0x77,
+	0xa4,0x6c,0xb7,0x7f,0x94,0x82,0x7f,0xb9,
+	0x90,0xc1,0x72,0x84,0x6c,0x67,0x8e,0x51,
+	0x91,0x49,0x73,0x6f,0x7e,0x9a,0x68,0xac,
+	0x67,0xbc,0x7d,0x9b,0x65,0x46,0x80,0x4f,
+	0x9d,0x5b,0x87,0x6d,0x72,0x7f,0x47,0x62,
+	0x2a,0x53,0x4f,0x58,0x7d,0x54,0x9c,0x70,
+	0xb0,0x89,0x8f,0x8c,0x64,0xa0,0x60,0xab,
+	0x6b,0xa4,0x91,0x9f,0xb3,0x86,0xa7,0x61,
+	0x86,0x5a,0x65,0x64,0x4c,0x79,0x5f,0x95,
+	0x86,0x8e,0x9b,0x74,0xa8,0x65,0xa3,0x67,
+	0x92,0x8d,0x93,0xca,0x95,0xe3,0x8f,0xd5,
+	0x8c,0xa5,0x83,0x6d,0x80,0x5a,0x94,0x7e,
+	0xa9,0xab,0x87,0x8b,0x6c,0x7b,0x5f,0x69,
+	0x6e,0x59,0x98,0x6c,0xc9,0x76,0x97,0x73,
+	0x79,0x76,0x53,0x75,0x2b,0x66,0x23,0x5e,
+	0x41,0x5e,0x6d,0x67,0x89,0x6e,0x87,0x6f,
+	0x6c,0x76,0x5d,0x88,0x69,0x97,0x8d,0x9b,
+	0xb4,0x90,0xbf,0x76,0xa6,0x5f,0x85,0x66,
+	0x6a,0x7b,0x61,0x9a,0x72,0xa6,0x7f,0x8b,
+	0x7e,0x6c,0x7d,0x5c,0x7b,0x62,0x80,0x92,
+	0x98,0xbf,0xa0,0xc6,0xa3,0xba,0xa5,0x9a,
+	0x9e,0x7a,0xa6,0x87,0xb6,0x9e,0xb1,0xb7,
+	0xb1,0xce,0x83,0x6e,0x51,0x4d,0x51,0x5d,
+	0x7d,0x68,0x9a,0x84,0xbc,0xa8,0xa1,0x5c,
+	0x43,0x4f,0x29,0x50,0x35,0x4f,0x4b,0x5d,
+	0x70,0x68,0x6b,0x59,0x5a,0x63,0x5b,0x76,
+	0x54,0x7c,0x6c,0x9a,0x99,0x9c,0x9b,0x7e,
+	0x9c,0x70,0x97,0x5f,0x7b,0x62,0x81,0x89,
+	0x8f,0x98,0x87,0x95,0x8d,0x8f,0x84,0x70,
+	0x71,0x69,0x7b,0x82,0x7c,0x92,0x77,0xab,
+	0x7e,0xb4,0x78,0xa0,0x7e,0x98,0xa2,0x96,
+	0xb9,0x95,0xca,0xa7,0xd2,0xb1,0xb9,0xb5,
+	0xae,0xba,0x84,0x6c,0x75,0x60,0x72,0x66,
+	0x8a,0x6b,0x86,0x73,0x81,0x8c,0x79,0x92,
+	0x3a,0x5a,0x3f,0x55,0x38,0x49,0x52,0x42,
+	0x66,0x3f,0x6a,0x4a,0x68,0x6b,0x6d,0x8c,
+	0x6f,0x9e,0x75,0x9b,0x7e,0x82,0x83,0x67,
+	0x85,0x5d,0x84,0x64,0x7d,0x7a,0x76,0x8e,
+	0x75,0x98,0x7f,0x95,0x93,0x87,0xa7,0x7a,
+	0xb3,0x79,0xa9,0x7c,0x90,0x87,0x73,0x94,
+	0x5d,0x9b,0x5e,0x9d,0x7b,0x99,0x95,0x94,
+	0xae,0x9e,0xba,0xab,0xb4,0xc2,0xb4,0xdb,
+	0xb6,0xcb,0x7a,0x85,0x90,0x62,0x82,0x46,
+	0x8e,0x4a,0x95,0x60,0x85,0x76,0x74,0x97,
+	0x69,0x7c,0x1f,0x5a,0x35,0x37,0x43,0x39,
+	0x5a,0x41,0x69,0x62,0x6e,0x7d,0x61,0x93,
+	0x67,0xa6,0x78,0x97,0x7f,0x7a,0x91,0x64,
+	0x8f,0x49,0x77,0x4f,0x71,0x73,0x64,0x86,
+	0x5f,0xa1,0x81,0xad,0x8e,0x90,0x9e,0x8a,
+	0xb9,0x84,0xab,0x78,0x9a,0x94,0x8d,0x98,
+	0x65,0x89,0x60,0x91,0x76,0x7f,0x7d,0x78,
+	0xa9,0x97,0xbd,0x9e,0xad,0xb5,0xb4,0xd9,
+	0xa6,0xbc,0x66,0x93,0x8f,0x92,0x7d,0x5b,
+	0x81,0x5e,0x9a,0x66,0x80,0x57,0x6e,0x80,
+	0x7d,0x8a,0x48,0x48,0x49,0x6f,0x59,0x3c,
+	0x3c,0x2f,0x58,0x5d,0x72,0x6d,0x61,0x88,
+	0x7f,0xb5,0x86,0x96,0x69,0x7d,0x84,0x77,
+	0x7d,0x46,0x6d,0x50,0x91,0x6e,0x7f,0x5e,
+	0x6c,0x81,0x8b,0x97,0x79,0x83,0x8d,0xb0,
+	0xc0,0xb6,0xa5,0x98,0xa1,0xb1,0x99,0x8e,
+	0x59,0x6d,0x65,0x92,0x80,0x80,0x71,0x82,
+	0xa7,0xa9,0xb3,0x88,0x99,0x9a,0xc8,0xc7,
+	0xc9,0xa7,0x90,0x94,0xbb,0xae,0x7f,0x5e,
+	0x5e,0x72,0x78,0x77,0x5a,0x61,0x69,0x92,
+	0x95,0x8f,0x74,0x61,0x4d,0x53,0x63,0x48,
+	0x2a,0x30,0x4f,0x72,0x74,0x70,0x69,0x7b,
+	0x95,0x95,0x8e,0x64,0x70,0x6c,0x93,0x87,
+	0x7a,0x6a,0x60,0x85,0x79,0x83,0x52,0x50,
+	0x54,0x6f,0x8d,0x78,0x88,0x73,0xad,0xb4,
+	0xc7,0xb0,0x8d,0x9d,0x8d,0xb8,0x8b,0x8a,
+	0x65,0x7c,0x97,0x94,0x9f,0x64,0x7e,0x6b,
+	0x9c,0x8d,0x82,0x7a,0x76,0xb1,0xb8,0xd9,
+	0xb5,0xb1,0xaf,0x96,0xb5,0x8d,0x8b,0x4b,
+	0x6b,0x76,0x83,0x7f,0x5a,0x80,0x72,0xac,
+	0x7e,0x7e,0x57,0x5e,0x73,0x52,0x4f,0x32,
+	0x56,0x47,0x6a,0x6a,0x5d,0x52,0x49,0x73,
+	0x7b,0x8b,0x6d,0x69,0x7c,0x93,0xb2,0x95,
+	0x83,0x64,0x6d,0x7c,0x69,0x5f,0x2f,0x48,
+	0x4f,0x87,0x7f,0x82,0x76,0x88,0xad,0xb1,
+	0xb3,0x8a,0x8d,0x90,0xb9,0xb4,0xb3,0x90,
+	0x9a,0x9f,0xb2,0x9c,0x7d,0x63,0x58,0x7a,
+	0x75,0x8d,0x68,0x8b,0x8c,0xc9,0xc8,0xcb,
+	0xba,0xae,0xbe,0xa9,0x91,0x7b,0x87,0x8b,
+	0x92,0x91,0x86,0x7b,0x6f,0x6e,0x84,0x6f,
+	0x7a,0x49,0x6e,0x5c,0x8e,0x77,0x63,0x44,
+	0x43,0x7d,0x53,0x6c,0x1c,0x46,0x33,0x5f,
+	0x70,0x6c,0x8e,0x71,0xa9,0x8e,0xaa,0x81,
+	0x77,0x6f,0x62,0x74,0x58,0x65,0x56,0x61,
+	0x7b,0x6f,0x8a,0x62,0x80,0x6c,0x83,0x89,
+	0x7b,0x9f,0x7e,0xc4,0x9f,0xd2,0xa7,0xb5,
+	0xa8,0x93,0xa4,0x6b,0x8d,0x53,0x84,0x67,
+	0x88,0x84,0x83,0x9b,0x89,0xa8,0x8f,0xa1,
+	0x94,0x9c,0xab,0xa4,0xb3,0x94,0x92,0xa8,
+	0xa4,0xaf,0x77,0x88,0x5c,0x75,0x5a,0x6b,
+	0x6c,0x6b,0x8a,0x70,0x9c,0x76,0x98,0x67,
+	0x5d,0x3a,0x4a,0x55,0x46,0x54,0x3f,0x63,
+	0x5f,0x80,0x80,0x8c,0x85,0x7b,0x7b,0x7a,
+	0x79,0x77,0x73,0x75,0x7a,0x85,0x87,0x7a,
+	0x77,0x63,0x71,0x60,0x6f,0x5a,0x68,0x6e,
+	0x87,0x9b,0xa2,0xa6,0x9d,0xab,0xa5,0xad,
+	0x8e,0x8a,0x75,0x89,0x84,0x96,0x83,0x86,
+	0x81,0x8e,0x95,0x83,0x83,0x61,0x81,0x77,
+	0x9f,0x8e,0x9b,0x9e,0xaf,0xca,0xb2,0xa7,
+	0x70,0x8f,0x81,0x91,0x76,0x64,0x67,0x67,
+	0x8c,0x8f,0x91,0x81,0x6e,0x83,0x78,0x8c,
+	0x61,0x54,0x3d,0x52,0x84,0x6d,0x7f,0x45,
+	0x71,0x66,0x82,0x77,0x5b,0x6a,0x57,0x96,
+	0x7b,0x9b,0x75,0x80,0x92,0x8f,0xa2,0x69,
+	0x71,0x4d,0x70,0x75,0x6f,0x75,0x55,0x88,
+	0x82,0xad,0x91,0x85,0x82,0x79,0xa6,0x83,
+	0x9c,0x69,0x85,0x92,0xa0,0xb1,0x7f,0x8e,
+	0x68,0x96,0x85,0x80,0x6d,0x54,0x82,0x7b,
+	0xae,0x8d,0x8f,0x8f,0x96,0xc2,0x99,0xae,
+	0x68,0x83,0x74,0x96,0xa0,0x74,0x8a,0x5f,
+	0xa9,0x82,0x95,0x66,0x5d,0x79,0x70,0x9d,
+	0x62,0x79,0x5a,0x7d,0x7f,0x83,0x7b,0x50,
+	0x65,0x5e,0x7c,0x6b,0x54,0x61,0x60,0x9e,
+	0x8c,0x9a,0x75,0x71,0x93,0x82,0xa5,0x5d,
+	0x76,0x51,0x87,0x8d,0x83,0x86,0x54,0x94,
+	0x73,0xb1,0x74,0x77,0x61,0x72,0x9f,0x88,
+	0x9c,0x66,0x8d,0x8c,0xae,0xa0,0x7d,0x75,
+	0x66,0x8d,0x8b,0x84,0x71,0x5d,0x88,0x8c,
+	0xaf,0x88,0x7b,0x79,0x80,0xb0,0x88,0x9e,
+	0x5f,0x92,0x8f,0xaf,0x9d,0x73,0x89,0x6c,
+	0xac,0x7e,0x90,0x55,0x61,0x73,0x84,0x9e,
+	0x75,0x7a,0x67,0x8c,0x93,0x7e,0x6e,0x4b,
+	0x69,0x6c,0x84,0x76,0x5a,0x65,0x61,0x9a,
+	0x8a,0x8e,0x67,0x66,0x81,0x86,0x9f,0x6c,
+	0x77,0x62,0x8f,0x9b,0x90,0x85,0x5a,0x82,
+	0x7b,0x9f,0x80,0x6a,0x6d,0x6b,0xa2,0x8c,
+	0x98,0x69,0x74,0x8d,0x90,0xa7,0x6c,0x7c,
+	0x5e,0x94,0x92,0x8e,0x7d,0x5b,0x89,0x7d,
+	0xae,0x7b,0x7c,0x68,0x7d,0xa1,0x93,0x95,
+	0x6c,0x82,0x8d,0xa6,0xa5,0x83,0x7c,0x6f,
+	0x8d,0x9b,0x8c,0x7e,0x58,0x81,0x7d,0x9e,
+	0x7c,0x6c,0x6e,0x6f,0xa7,0x7a,0x8e,0x48,
+	0x73,0x73,0x8f,0x89,0x5a,0x69,0x50,0x92,
+	0x7d,0x8d,0x68,0x63,0x7f,0x85,0xa4,0x77,
+	0x76,0x63,0x80,0x98,0x8c,0x88,0x60,0x7e,
+	0x85,0x9c,0x96,0x70,0x77,0x66,0x9a,0x89,
+	0x8c,0x6e,0x63,0x86,0x88,0xaa,0x79,0x7b,
+	0x68,0x84,0x98,0x85,0x81,0x57,0x78,0x7e,
+	0x9d,0x91,0x73,0x7e,0x6e,0xa7,0x90,0x94,
+	0x6e,0x69,0x8b,0x87,0xb0,0x75,0x8c,0x6f,
+	0x9b,0xa3,0x93,0x86,0x57,0x81,0x73,0x9e,
+	0x7a,0x71,0x6a,0x70,0x9f,0x94,0x93,0x6c,
+	0x63,0x76,0x7d,0x92,0x65,0x64,0x5c,0x76,
+	0x9c,0x7e,0x8d,0x56,0x85,0x75,0x97,0x83,
+	0x62,0x71,0x5a,0xa4,0x80,0xa0,0x6d,0x7b,
+	0x8b,0x8d,0xa9,0x6c,0x7b,0x5a,0x85,0x8e,
+	0x88,0x88,0x63,0x8b,0x86,0xa4,0x8e,0x70,
+	0x73,0x60,0x93,0x79,0x88,0x68,0x68,0x8f,
+	0x86,0xb0,0x75,0x88,0x66,0x86,0x91,0x7d,
+	0x86,0x57,0x8a,0x7f,0xaa,0x97,0x82,0x88,
+	0x75,0xa6,0x84,0x91,0x67,0x66,0x7d,0x7d,
+	0xa6,0x75,0x89,0x6f,0x8f,0x96,0x85,0x85,
+	0x53,0x77,0x68,0x8f,0x7c,0x73,0x76,0x6f,
+	0x9c,0x86,0x8e,0x68,0x65,0x75,0x74,0x8c,
+	0x67,0x75,0x6d,0x87,0xa2,0x8a,0x98,0x64,
+	0x8b,0x76,0x91,0x7f,0x66,0x7a,0x65,0xa4,
+	0x86,0xa2,0x78,0x83,0x86,0x86,0x95,0x68,
+	0x74,0x5a,0x7e,0x86,0x89,0x87,0x76,0x88,
+	0x8a,0x93,0x8a,0x6f,0x70,0x65,0x88,0x7e,
+	0x86,0x7e,0x78,0x9a,0x8d,0xa9,0x7d,0x87,
+	0x6f,0x7d,0x85,0x7a,0x85,0x6b,0x8a,0x87,
+	0x9e,0x8e,0x89,0x7e,0x7a,0x81,0x7b,0x78,
+	0x6b,0x6f,0x77,0x88,0x89,0x8c,0x81,0x84,
+	0x7c,0x85,0x76,0x71,0x68,0x69,0x76,0x7f,
+	0x85,0x83,0x84,0x87,0x8b,0x89,0x82,0x73,
+	0x76,0x6b,0x7e,0x78,0x85,0x81,0x89,0x92,
+	0x8a,0x99,0x7d,0x89,0x70,0x7a,0x76,0x71,
+	0x80,0x72,0x8d,0x80,0x93,0x8b,0x83,0x8c,
+	0x72,0x83,0x67,0x7b,0x71,0x77,0x86,0x78,
+	0x99,0x7f,0x9d,0x85,0x88,0x84,0x6f,0x86,
+	0x6a,0x86,0x72,0x84,0x89,0x86,0xa2,0x81,
+	0x99,0x76,0x83,0x7c,0x70,0x83,0x5f,0x88,
+	0x6c,0x96,0x8b,0x88,0x90,0x6f,0x96,0x6d,
+	0x8b,0x65,0x6b,0x71,0x6e,0x92,0x78,0x93,
+	0x76,0x8a,0x8e,0x82,0x89,0x63,0x76,0x67,
+	0x7f,0x87,0x76,0x8f,0x70,0xa0,0x89,0x9b,
+	0x81,0x6e,0x7e,0x67,0x95,0x6c,0x87,0x6b,
+	0x85,0x94,0x91,0x9c,0x73,0x7f,0x6d,0x84,
+	0x7d,0x73,0x6e,0x68,0x83,0x90,0x96,0x92,
+	0x77,0x86,0x7b,0x93,0x7f,0x71,0x6a,0x67,
+	0x8e,0x89,0x9e,0x7d,0x86,0x80,0x95,0x94,
+	0x82,0x6f,0x61,0x74,0x81,0x93,0x80,0x80,
+	0x74,0x94,0x96,0xa0,0x72,0x76,0x66,0x77,
+	0x83,0x72,0x79,0x72,0x89,0x86,0x92,0x83,
+	0x88,0x76,0x7d,0x70,0x76,0x71,0x79,0x7e,
+	0x82,0x8a,0x87,0x8f,0x84,0x8a,0x7a,0x7e,
+	0x71,0x79,0x70,0x7d,0x7d,0x86,0x8a,0x8b,
+	0x8e,0x86,0x88,0x79,0x7d,0x71,0x79,0x70,
+	0x80,0x7b,0x89,0x89,0x8d,0x8c,0x86,0x87,
+	0x79,0x7c,0x6f,0x7b,0x71,0x80,0x7c,0x8b,
+	0x86,0x90,0x89,0x88,0x83,0x7a,0x7b,0x71,
+	0x78,0x73,0x81,0x7c,0x8b,0x87,0x91,0x87,
+	0x89,0x80,0x7c,0x78,0x72,0x77,0x73,0x82,
+	0x7d,0x8c,0x86,0x91,0x86,0x8a,0x7d,0x7d,
+	0x75,0x74,0x77,0x76,0x80,0x80,0x8b,0x87,
+	0x91,0x84,0x89,0x7c,0x7e,0x73,0x76,0x74,
+	0x79,0x7f,0x81,0x8c,0x87,0x91,0x83,0x8a,
+	0x79,0x7f,0x71,0x79,0x74,0x7c,0x7e,0x84,
+	0x89,0x8a,0x8c,0x84,0x89,0x62,0x42,0x66,
+	0x5f,0xab,0x91,0x80,0x6d,0x5f,0xaa,0x8e,
+	0x80,0x4f,0x53,0x7a,0xb1,0xa2,0x75,0x53,
+	0x58,0x9f,0xac,0xb4,0x69,0x59,0x66,0x8a,
+	0xb1,0x74,0x6b,0x37,0x75,0x8e,0xa0,0x89,
+	0x47,0x5f,0x5c,0x9f,0x87,0x66,0x49,0x38,
+	0x7d,0x72,0x8e,0x44,0x3a,0x4b,0x67,0xa5,
+	0x67,0x6f,0x30,0x61,0x76,0x75,0x70,0x1b,
+	0x48,0x3f,0x95,0x8e,0x72,0x66,0x3a,0x89,
+	0x6c,0x8c,0x46,0x36,0x55,0x62,0xb7,0x7a,
+	0x8b,0x4f,0x71,0x90,0x82,0x90,0x39,0x69,
+	0x5e,0xaa,0xb0,0x8e,0x8e,0x5c,0xa5,0x8e,
+	0xa9,0x73,0x59,0x7f,0x82,0xd3,0x9e,0xa6,
+	0x75,0x84,0xaa,0x95,0xaa,0x56,0x7a,0x73,
+	0xad,0xc0,0x96,0x97,0x5f,0x9a,0x8c,0x9c,
+	0x74,0x4f,0x70,0x70,0xb8,0x90,0x8b,0x61,
+	0x61,0x86,0x74,0x80,0x3d,0x4d,0x57,0x81,
+	0x9e,0x76,0x6e,0x43,0x6c,0x71,0x79,0x61,
+	0x39,0x56,0x65,0xa3,0x99,0x87,0x6a,0x64,
+	0x87,0x89,0x92,0x6a,0x69,0x7f,0xa8,0xc4,
+	0xb6,0xa3,0x87,0x9d,0xac,0xae,0x9e,0x85,
+	0x94,0xb0,0xd6,0xd2,0xb9,0xa1,0x9b,0xaf,
+	0xb6,0xa7,0x88,0x85,0x98,0xb9,0xc4,0xaa,
+	0x7e,0x6b,0x71,0x95,0xaa,0x96,0x66,0x81,
+	0xa6,0xad,0xa3,0x71,0x43,0x3d,0x47,0x5e,
+	0x56,0x66,0x43,0x6f,0x9f,0x95,0x88,0x4b,
+	0x49,0x4b,0x75,0x75,0x5e,0x50,0x4b,0x87,
+	0x9e,0xa9,0x7d,0x57,0x59,0x5e,0x85,0x5e,
+	0x5c,0x3c,0x5f,0x88,0x8e,0x8f,0x4b,0x53,
+	0x43,0x6b,0x6a,0x51,0x53,0x43,0x86,0x89,
+	0xa2,0x76,0x5e,0x69,0x68,0x9a,0x77,0x85,
+	0x70,0x93,0xba,0xba,0xc9,0x8b,0xa1,0x8c,
+	0xb6,0xb4,0xa1,0xab,0x93,0xcf,0xc0,0xda,
+	0xae,0x94,0x9c,0x8a,0xb8,0x87,0x98,0x77,
+	0x8f,0xa6,0x96,0xa4,0x5d,0x71,0x51,0x73,
+	0x6e,0x57,0x66,0x43,0x84,0x6c,0x8b,0x5e,
+	0x4d,0x5c,0x49,0x84,0x55,0x7a,0x5b,0x7c,
+	0x9b,0x8f,0xac,0x6a,0x92,0x72,0xa0,0xa1,
+	0x93,0xab,0x8a,0xd1,0xb1,0xd3,0xac,0x9a,
+	0xa7,0x91,0xcc,0x93,0xba,0x91,0xb1,0xbf,
+	0xac,0xc0,0x74,0x9a,0x6e,0x9a,0x8b,0x7c,
+	0x8a,0x62,0xa5,0x78,0x9e,0x65,0x5b,0x60,
+	0x51,0x88,0x4f,0x7c,0x4b,0x7a,0x84,0x7f,
+	0x92,0x50,0x84,0x5e,0xa5,0x89,0x7d,0x63,
+	0x4f,0x9a,0x67,0xa5,0x67,0x7b,0x7b,0x84,
+	0xbc,0x8f,0xc3,0x8e,0xc6,0xaa,0x8b,0x99,
+	0x5a,0x7f,0x5c,0xa5,0x83,0x8b,0x83,0x70,
+	0xab,0x79,0xa2,0x50,0x63,0x53,0x5e,0x80,
+	0x4b,0x72,0x34,0x73,0x5e,0x6a,0x60,0x2a,
+	0x56,0x2b,0x76,0x46,0x5d,0x4b,0x47,0x7c,
+	0x58,0x8a,0x3f,0x66,0x54,0x75,0x93,0x6c,
+	0x96,0x5f,0xab,0x93,0xb1,0xa0,0x7e,0xa8,
+	0x88,0xd3,0xa0,0xbe,0x9e,0xa8,0xcc,0xad,
+	0xd3,0x85,0xad,0x8b,0xb1,0xb4,0x8e,0xa6,
+	0x68,0xaa,0x7f,0xa0,0x77,0x5a,0x74,0x54,
+	0x94,0x56,0x73,0x44,0x58,0x70,0x58,0x7d,
+	0x31,0x63,0x42,0x73,0x71,0x5d,0x70,0x43,
+	0x8f,0x6a,0x9b,0x71,0x72,0x87,0x7d,0xbd,
+	0x85,0xad,0x7d,0xa3,0xb2,0xad,0xc5,0x8a,
+	0xba,0x96,0xd2,0xb8,0xae,0xad,0x8e,0xc9,
+	0xa4,0xce,0x93,0x9f,0x9c,0xa1,0xc2,0x8b,
+	0xa3,0x67,0x99,0x90,0x9a,0x94,0x62,0x88,
+	0x69,0xa8,0x7d,0x81,0x66,0x64,0x96,0x84,
+	0xad,0x71,0x8f,0x86,0xa0,0xa2,0x51,0x53,
+	0x3b,0x71,0x5c,0x7b,0x67,0x55,0x78,0x75,
+	0xb6,0x8e,0x9b,0x7a,0x93,0xb5,0xa6,0xa1,
+	0x3b,0x61,0x64,0x83,0x6f,0x57,0x4d,0x34,
+	0x70,0x6b,0x85,0x58,0x4f,0x58,0x64,0x86,
+	0x59,0x51,0x28,0x49,0x5d,0x67,0x5f,0x32,
+	0x47,0x46,0x74,0x61,0x4c,0x33,0x31,0x5f,
+	0x6a,0x79,0x54,0x54,0x60,0x81,0x96,0x7a,
+	0x6a,0x58,0x7f,0x9a,0xad,0x9d,0x85,0x95,
+	0xac,0xcc,0xbe,0xa2,0x87,0x94,0xb9,0xcd,
+	0xc5,0xa3,0x9a,0xa9,0xc5,0xc4,0xa4,0x7e,
+	0x74,0x8b,0xa8,0xa6,0x88,0x6e,0x6e,0x8c,
+	0x92,0x83,0x52,0x41,0x4b,0x6c,0x7d,0x69,
+	0x54,0x43,0x64,0x77,0x7b,0x59,0x39,0x44,
+	0x5d,0x89,0x7f,0x73,0x5f,0x72,0x99,0x9e,
+	0x9a,0x68,0x70,0x7c,0xae,0xb9,0xa6,0x9c,
+	0x8e,0xc1,0xc2,0xcf,0x9d,0x8a,0x97,0xab,
+	0xd9,0xb3,0xb7,0x8f,0xb5,0xc5,0xc5,0xb3,
+	0x74,0x8c,0x83,0xc2,0xa7,0x9e,0x84,0x7d,
+	0xb1,0x9e,0xb0,0x63,0x6f,0x6c,0x94,0xb3,
+	0x8c,0x99,0x6f,0xb3,0xa9,0xb8,0x7d,0x38,
+	0x3d,0x59,0xa1,0x6e,0x64,0x3d,0x5e,0x89,
+	0x84,0x95,0x4c,0x75,0x67,0xad,0xa7,0x92,
+	0x7f,0x52,0x76,0x5c,0x95,0x48,0x3b,0x2a,
+	0x42,0x72,0x47,0x5a,0x2d,0x63,0x6c,0x72,
+	0x60,0x26,0x47,0x37,0x7d,0x5b,0x5d,0x41,
+	0x47,0x77,0x65,0x79,0x2f,0x43,0x3c,0x69,
+	0x7b,0x5d,0x67,0x45,0x88,0x7e,0x97,0x6a,
+	0x54,0x69,0x74,0xad,0x8a,0x97,0x77,0x9c,
+	0xb6,0xb8,0xb6,0x7b,0x92,0x8c,0xc4,0xbb,
+	0xae,0xa1,0x9a,0xca,0xc1,0xca,0x90,0x86,
+	0x87,0xa1,0xb8,0x97,0x95,0x74,0x99,0xa1,
+	0xa1,0x7f,0x55,0x5b,0x60,0x85,0x74,0x68,
+	0x52,0x5f,0x79,0x7c,0x70,0x43,0x3c,0x47,
+	0x67,0x72,0x66,0x58,0x5b,0x7a,0x8f,0x89,
+	0x70,0x5b,0x66,0x84,0x96,0x9b,0x88,0x90,
+	0x9f,0xbd,0xc5,0xaa,0x9c,0x8b,0xb0,0xb6,
+	0xc9,0xb4,0xae,0xbe,0xc6,0xe2,0xbd,0xbb,
+	0x94,0xab,0xb6,0xb8,0xbd,0x98,0xb7,0xa6,
+	0xcf,0xb0,0xa7,0x90,0x84,0xa7,0x93,0xb4,
+	0x88,0xa5,0x9e,0xb6,0xbe,0x9c,0xa5,0x71,
+	0x8f,0x5f,0x5e,0x54,0x6f,0x7a,0x71,0x7a,
+	0x4e,0x65,0x46,0x60,0x6d,0x6e,0x8d,0x6b,
+	0x9b,0x78,0xa2,0x72,0x61,0x3c,0x38,0x6e,
+	0x46,0x69,0x26,0x46,0x3b,0x4a,0x57,0x3e,
+	0x57,0x31,0x53,0x3b,0x4e,0x49,0x42,0x59,
+	0x43,0x64,0x43,0x5b,0x44,0x4b,0x4a,0x42,
+	0x58,0x4a,0x6b,0x59,0x6e,0x65,0x6c,0x73,
+	0x64,0x75,0x63,0x7a,0x7a,0x8f,0x93,0x93,
+	0x9b,0x99,0xa9,0xa2,0xa5,0x9a,0x9e,0xac,
+	0xb6,0xc0,0xbb,0xb7,0xb8,0xbf,0xc0,0xb4,
+	0xa7,0x9f,0xa1,0xb0,0xb0,0xad,0x9b,0x97,
+	0x9c,0x98,0x99,0x75,0x73,0x62,0x78,0x7c,
+	0x75,0x6d,0x53,0x6d,0x5e,0x75,0x51,0x4c,
+	0x41,0x49,0x6c,0x5a,0x6b,0x47,0x63,0x66,
+	0x77,0x77,0x57,0x6a,0x56,0x8e,0x84,0x96,
+	0x82,0x7f,0xa2,0x9b,0xbf,0x8f,0xa0,0x8d,
+	0xad,0xc3,0xb8,0xc3,0x98,0xc4,0xb6,0xd9,
+	0xc0,0xaa,0xae,0xa2,0xd6,0xb7,0xcc,0xa0,
+	0xad,0xb8,0xbc,0xce,0x97,0xa9,0x8b,0xb9,
+	0xb3,0xb2,0xa7,0x88,0xb3,0xa3,0xcb,0x9e,
+	0x99,0x8a,0x8d,0xa9,0x7d,0x7a,0x37,0x65,
+	0x87,0x8a,0x99,0x63,0x5d,0x46,0x79,0x6c,
+	0x78,0x61,0x58,0x78,0x6a,0x82,0x3c,0x39,
+	0x20,0x67,0x6f,0x63,0x67,0x1f,0x44,0x36,
+	0x5b,0x43,0x35,0x37,0x34,0x65,0x4f,0x5b,
+	0x34,0x41,0x52,0x5b,0x6d,0x41,0x4d,0x3a,
+	0x66,0x65,0x63,0x52,0x3d,0x5e,0x61,0x81,
+	0x61,0x5c,0x58,0x69,0x8e,0x7f,0x85,0x5f,
+	0x79,0x86,0xa3,0xa1,0x86,0x8e,0x8d,0xb9,
+	0xb6,0xb6,0x9e,0x98,0xb2,0xbf,0xd2,0xaf,
+	0xac,0xa4,0xbe,0xce,0xc3,0xb1,0x91,0xa2,
+	0xaa,0xbc,0xa8,0x8c,0x81,0x89,0xa3,0x99,
+	0x87,0x62,0x5e,0x6d,0x7a,0x77,0x5a,0x4c,
+	0x4c,0x65,0x70,0x64,0x49,0x37,0x48,0x5b,
+	0x69,0x5a,0x48,0x4a,0x61,0x7c,0x7e,0x6e,
+	0x5b,0x60,0x79,0x91,0x91,0x81,0x79,0x8b,
+	0xa9,0xba,0xb0,0x9a,0x91,0xa1,0xb8,0xc1,
+	0xb3,0xa4,0xa5,0xbd,0xd1,0xd0,0xb8,0xa5,
+	0xa3,0xb8,0xc4,0xbb,0xa8,0x9b,0xab,0xbf,
+	0xcb,0xb6,0x9e,0x91,0x9c,0xb1,0xae,0xa2,
+	0x8d,0x95,0xaa,0xbe,0xb8,0x9c,0x8b,0x86,
+	0x94,0x91,0x7a,0x58,0x4c,0x7c,0xa2,0x97,
+	0x9b,0x81,0x65,0x67,0x70,0x63,0x52,0x34,
+	0x37,0x3c,0x4e,0x5c,0x5f,0x40,0x4f,0x6d,
+	0x57,0x48,0x2f,0x2c,0x42,0x53,0x62,0x49,
+	0x3e,0x37,0x48,0x57,0x50,0x46,0x34,0x4c,
+	0x5c,0x71,0x67,0x51,0x4a,0x48,0x64,0x5f,
+	0x5b,0x46,0x4d,0x68,0x79,0x8a,0x6e,0x6b,
+	0x62,0x7b,0x84,0x7f,0x78,0x6b,0x8a,0x9a,
+	0xb7,0xa9,0x9c,0x97,0x9b,0xb7,0xae,0xae,
+	0x96,0xa4,0xbc,0xcd,0xd8,0xb8,0xb6,0xa5,
+	0xc0,0xb9,0xb1,0xa0,0x8d,0xa7,0xac,0xc3,
+	0xa4,0x94,0x82,0x82,0x92,0x7d,0x73,0x51,
+	0x5f,0x6a,0x7c,0x7c,0x5b,0x53,0x45,0x5b,
+	0x57,0x4d,0x3b,0x30,0x4d,0x59,0x76,0x60,
+	0x57,0x4e,0x5b,0x72,0x68,0x65,0x50,0x67,
+	0x7f,0x9c,0xa5,0x8e,0x8d,0x8b,0xa8,0xa7,
+	0xa5,0x94,0x8d,0xac,0xc0,0xd9,0xc3,0xb9,
+	0xad,0xba,0xca,0xbd,0xb3,0x99,0xaa,0xbd,
+	0xd4,0xd1,0xb7,0xaf,0xa7,0xbe,0xb7,0xad,
+	0x94,0x8f,0xa3,0xb8,0xc9,0xb3,0xa5,0x9a,
+	0xa6,0xb1,0xa3,0x91,0x78,0x7e,0x8d,0x94,
+	0x85,0x66,0x64,0x7f,0x9f,0x80,0x89,0x74,
+	0x57,0x59,0x59,0x55,0x36,0x28,0x3c,0x61,
+	0x51,0x5a,0x56,0x34,0x36,0x45,0x56,0x51,
+	0x3e,0x35,0x3a,0x4b,0x4e,0x41,0x2f,0x2c,
+	0x43,0x59,0x66,0x57,0x4a,0x47,0x54,0x5e,
+	0x59,0x44,0x3a,0x45,0x61,0x75,0x75,0x64,
+	0x5c,0x67,0x76,0x7e,0x6e,0x60,0x62,0x78,
+	0x98,0xa4,0x9e,0x8e,0x94,0xa5,0xb3,0xaf,
+	0x9b,0x94,0xa1,0xc1,0xd2,0xd3,0xc3,0xb7,
+	0xc4,0xcd,0xd2,0xbb,0xa7,0xa0,0xb3,0xcc,
+	0xca,0xbd,0xa0,0xa0,0xa2,0xa6,0x99,0x75,
+	0x6b,0x62,0x81,0x85,0x7e,0x68,0x51,0x5d,
+	0x5a,0x65,0x42,0x31,0x2b,0x3c,0x5d,0x56,
+	0x5b,0x3a,0x47,0x4f,0x5c,0x60,0x3e,0x47,
+	0x43,0x73,0x80,0x88,0x7f,0x6e,0x8b,0x8b,
+	0xa8,0x8a,0x84,0x87,0x96,0xc5,0xbc,0xc9,
+	0xa7,0xb6,0xbe,0xc5,0xca,0xa2,0xab,0x9f,
+	0xcb,0xd0,0xcf,0xc6,0xab,0xc4,0xb8,0xd0,
+	0xaa,0xa3,0x9d,0xa4,0xcc,0xba,0xc8,0x9f,
+	0xad,0xae,0xb2,0xb6,0x8c,0x96,0x82,0xa6,
+	0xa5,0x9d,0x8c,0x61,0x75,0x5f,0x7e,0x73,
+	0x7f,0x66,0x54,0x93,0x7b,0x75,0x3b,0x3c,
+	0x48,0x63,0x70,0x28,0x46,0x4a,0x6c,0x66,
+	0x5b,0x51,0x2e,0x49,0x36,0x51,0x35,0x2c,
+	0x32,0x32,0x5d,0x4c,0x5f,0x3e,0x4c,0x50,
+	0x4f,0x5e,0x38,0x4b,0x38,0x61,0x66,0x68,
+	0x6a,0x4e,0x6d,0x5e,0x79,0x63,0x5d,0x64,
+	0x66,0x94,0x85,0x9e,0x81,0x8e,0x98,0x9c,
+	0xac,0x8c,0x9f,0x94,0xbb,0xc6,0xc9,0xcd,
+	0xb3,0xcf,0xbf,0xd4,0xc0,0xb5,0xb8,0xb4,
+	0xd6,0xc8,0xd0,0xb5,0xb0,0xb3,0xa7,0xac,
+	0x88,0x8a,0x79,0x8b,0x90,0x85,0x7f,0x62,
+	0x68,0x5c,0x5d,0x4d,0x3c,0x3d,0x3a,0x4e,
+	0x4c,0x4e,0x43,0x3e,0x40,0x40,0x42,0x3a,
+	0x3a,0x41,0x52,0x62,0x6d,0x6a,0x6d,0x6e,
+	0x77,0x79,0x7c,0x7e,0x7f,0x94,0x9c,0xb0,
+	0xb0,0xb3,0xb4,0xad,0xb9,0xad,0xb8,0xae,
+	0xba,0xc4,0xc5,0xd8,0xc6,0xd3,0xc2,0xc3,
+	0xbd,0xb1,0xbf,0xad,0xc6,0xb8,0xc8,0xc4,
+	0xbd,0xc7,0xaa,0xb9,0x9d,0xac,0xa2,0xa5,
+	0xaf,0x9c,0xb1,0x92,0x9e,0x7f,0x6d,0x63,
+	0x46,0x6c,0x6a,0x9b,0x6d,0x57,0x66,0x69,
+	0x79,0x4c,0x5a,0x4d,0x6d,0x67,0x3e,0x5a,
+	0x59,0x7f,0x62,0x6e,0x58,0x3f,0x40,0x20,
+	0x42,0x2c,0x49,0x39,0x3b,0x48,0x3f,0x5a,
+	0x39,0x45,0x2f,0x3b,0x4c,0x49,0x62,0x46,
+	0x5e,0x54,0x69,0x6b,0x57,0x5c,0x48,0x6c,
+	0x6a,0x80,0x7b,0x77,0x89,0x86,0xa3,0x8f,
+	0x90,0x82,0x8a,0xa8,0xab,0xbe,0xac,0xb8,
+	0xbb,0xca,0xd2,0xbd,0xb8,0xa7,0xbf,0xca,
+	0xd5,0xcd,0xbc,0xc1,0xc2,0xcd,0xbf,0xa7,
+	0x91,0x90,0x9d,0xa7,0xa1,0x8e,0x7d,0x7e,
+	0x83,0x80,0x6b,0x4d,0x47,0x43,0x5d,0x50,
+	0x50,0x41,0x40,0x49,0x45,0x3b,0x33,0x31,
+	0x33,0x3a,0x41,0x44,0x4c,0x5e,0x6c,0x7a,
+	0x80,0x83,0x86,0x88,0x8e,0x8e,0x9e,0xb4,
+	0xc7,0xd3,0xd6,0xd4,0xd2,0xcc,0xcb,0xc8,
+	0xcd,0xcf,0xd4,0xd5,0xd4,0xce,0xc6,0xbf,
+	0xb7,0xb0,0xae,0xad,0xb2,0xb5,0xb9,0xb7,
+	0xb3,0xad,0xa2,0x9a,0x92,0x8e,0x8d,0x8f,
+	0x94,0x96,0x96,0x95,0x8e,0x86,0x7d,0x75,
+	0x6e,0x6f,0x6d,0x74,0x77,0x78,0x77,0x72,
+	0x6c,0x64,0x59,0x55,0x50,0x54,0x57,0x5a,
+	0x5e,0x5f,0x5c,0x57,0x4f,0x47,0x41,0x40,
+	0x3e,0x43,0x47,0x4f,0x4f,0x51,0x4f,0x49,
+	0x43,0x3e,0x3c,0x3e,0x3f,0x47,0x4c,0x52,
+	0x53,0x54,0x51,0x4d,0x49,0x46,0x47,0x4b,
+	0x4e,0x58,0x5b,0x61,0x5f,0x63,0x5b,0x5e,
+	0x57,0x5d,0x56,0x67,0x40,0x54,0x5c,0x89,
+	0x8b,0x71,0x5b,0x5f,0x80,0x83,0x6e,0x36,
+	0x6c,0x7e,0xd0,0x82,0x83,0x48,0xae,0x95,
+	0xb7,0x48,0x7c,0x6d,0xd8,0x8b,0x92,0x46,
+	0xa0,0x91,0xb4,0x50,0x60,0x58,0xac,0x8a,
+	0x73,0x3c,0x66,0x84,0x91,0x5b,0x3b,0x4a,
+	0x76,0x87,0x58,0x43,0x45,0x91,0x91,0x8c,
+	0x45,0x69,0x70,0xa4,0x65,0x5e,0x43,0x9e,
+	0xa7,0xbe,0x75,0x8d,0x8a,0xc2,0x8f,0x81,
+	0x5f,0xa5,0xbd,0xd6,0x99,0x95,0x97,0xc2,
+	0xab,0x90,0x6c,0x95,0xc2,0xd3,0xb1,0x96,
+	0x96,0xb1,0xb4,0x88,0x6d,0x80,0xad,0xbf,
+	0xaf,0x8d,0x90,0xab,0xb3,0x96,0x74,0x7b,
+	0x9f,0xb7,0x9f,0x71,0x5e,0x7d,0x8f,0x8f,
+	0x74,0x8b,0xa9,0xd7,0xbf,0x9d,0x6b,0x6d,
+	0x6f,0x77,0x5a,0x66,0x83,0xbd,0xc1,0xae,
+	0x8e,0x92,0xa5,0x9d,0x84,0x70,0x8b,0xac,
+	0xca,0xa6,0x93,0x7a,0x9b,0x8b,0x8d,0x5c,
+	0x82,0x84,0xbc,0x88,0x89,0x4f,0x7f,0x60,
+	0x7e,0x3d,0x67,0x60,0xa8,0x7b,0x84,0x45,
+	0x74,0x5f,0x7f,0x4b,0x69,0x6d,0xab,0x9b,
+	0x94,0x6a,0x7b,0x81,0x90,0x7a,0x76,0x91,
+	0xb2,0xc9,0xa3,0x96,0x79,0x9f,0x8d,0xa3,
+	0x78,0xa4,0x7a,0xb8,0x73,0x80,0x49,0x88,
+	0x61,0x8f,0x47,0x90,0x79,0xd5,0x91,0xa8,
+	0x33,0x6f,0x3b,0x71,0x34,0x6f,0x59,0xa5,
+	0x74,0x82,0x42,0x6e,0x59,0x80,0x5c,0x74,
+	0x79,0xa8,0x9f,0x8b,0x67,0x5f,0x6d,0x67,
+	0x69,0x50,0x78,0x7c,0xa5,0x70,0x7c,0x49,
+	0x89,0x64,0x9c,0x5e,0xad,0x8b,0xdd,0x85,
+	0xa8,0x4d,0x98,0x57,0x9a,0x49,0x96,0x68,
+	0xbd,0x73,0x98,0x48,0x89,0x60,0x9b,0x66,
+	0x9b,0x83,0xbf,0x94,0x99,0x67,0x7a,0x74,
+	0x8f,0x8c,0x96,0x83,0x89,0x8e,0x77,0x75,
+	0x59,0x7b,0x63,0x81,0x61,0x94,0x7f,0xb4,
+	0x80,0x8d,0x33,0x70,0x3a,0x7f,0x49,0x8f,
+	0x63,0xa7,0x65,0x8f,0x4b,0x8c,0x5f,0x9e,
+	0x6a,0xa5,0x7e,0xb4,0x7a,0x91,0x52,0x73,
+	0x55,0x76,0x59,0x77,0x6c,0x87,0x7b,0x7b,
+	0x6c,0x72,0x80,0x8c,0x9b,0x99,0xb1,0xaa,
+	0xba,0x91,0x94,0x6b,0x8c,0x6b,0x90,0x64,
+	0x96,0x6f,0xa3,0x63,0x88,0x4a,0x90,0x61,
+	0xa8,0x6d,0xb7,0x86,0xca,0x7f,0xaf,0x64,
+	0xb1,0x81,0xcf,0x6c,0x9b,0x6a,0xa4,0x71,
+	0x8c,0x4d,0x7b,0x59,0x86,0x5d,0x87,0x71,
+	0xa1,0x88,0x90,0x48,0x4a,0x49,0x59,0x63,
+	0x68,0x7c,0x81,0x90,0x75,0x78,0x62,0x8b,
+	0x7a,0x9d,0x79,0xa5,0x84,0xae,0x66,0x7f,
+	0x3d,0x77,0x47,0x80,0x40,0x83,0x57,0xa1,
+	0x5a,0x8e,0x4d,0x9f,0x74,0xbf,0x82,0xc6,
+	0x97,0xd8,0x90,0xae,0x63,0x99,0x69,0x9a,
+	0x62,0x8b,0x6c,0x98,0x71,0x7f,0x56,0x7a,
+	0x75,0x95,0x88,0x96,0x9b,0xaf,0xaf,0xa5,
+	0xa3,0xa1,0xbe,0x9f,0x8d,0x7c,0x8b,0x78,
+	0x9b,0x68,0x7a,0x4c,0x81,0x60,0x8c,0x5a,
+	0x92,0x72,0xaf,0x6b,0x6b,0x1e,0x6b,0x2d,
+	0x76,0x3d,0x80,0x59,0xa1,0x64,0x8f,0x51,
+	0x99,0x71,0xac,0x73,0xa2,0x79,0xac,0x72,
+	0x81,0x46,0x6a,0x53,0x74,0x4f,0x67,0x5e,
+	0x87,0x78,0x7b,0x67,0x7e,0x92,0xa5,0xa2,
+	0x9f,0xad,0xb6,0xbd,0x98,0x8d,0x74,0x94,
+	0x81,0x8e,0x65,0x84,0x79,0x9d,0x6a,0x78,
+	0x57,0x94,0x82,0xab,0x7b,0xb2,0x9f,0xda,
+	0xa5,0xbe,0x90,0xd0,0x96,0xa0,0x70,0x8b,
+	0x69,0xa3,0x6c,0x7b,0x45,0x7d,0x68,0x8e,
+	0x5b,0x7e,0x74,0xa9,0x80,0x67,0x22,0x58,
+	0x48,0x5f,0x42,0x58,0x5c,0x8b,0x7f,0x79,
+	0x5d,0x77,0x88,0x9b,0x85,0x7f,0x86,0x9f,
+	0x97,0x77,0x59,0x56,0x6c,0x6f,0x64,0x4f,
+	0x63,0x79,0x8f,0x74,0x68,0x65,0x96,0xa1,
+	0xa8,0x8e,0xa3,0xb5,0xcc,0xa7,0x8b,0x72,
+	0x92,0x92,0x90,0x66,0x71,0x83,0x9f,0x84,
+	0x6a,0x5c,0x81,0x9a,0x9f,0x8a,0x93,0xb1,
+	0xd4,0xcd,0xb0,0xa3,0xb8,0xc1,0x95,0x80,
+	0x78,0x7a,0x90,0x8c,0x66,0x52,0x5e,0x7f,
+	0x82,0x6c,0x60,0x7b,0x9c,0x9e,0x64,0x24,
+	0x39,0x55,0x51,0x3d,0x35,0x4d,0x79,0x88,
+	0x75,0x56,0x65,0x84,0x9f,0x85,0x79,0x79,
+	0xa5,0xa0,0x8d,0x53,0x5c,0x63,0x85,0x5d,
+	0x59,0x4a,0x86,0x85,0x8f,0x53,0x71,0x77,
+	0xb2,0x8d,0x99,0x7e,0xc2,0xb6,0xc3,0x79,
+	0x8a,0x78,0xaf,0x7b,0x82,0x57,0x97,0x8b,
+	0xa4,0x5d,0x73,0x68,0xa7,0x86,0x95,0x75,
+	0xb2,0xb6,0xd1,0x98,0xa7,0xa0,0xcd,0x9d,
+	0x82,0x6c,0x95,0x8c,0x93,0x66,0x5f,0x5d,
+	0x84,0x7b,0x73,0x61,0x7e,0x98,0x9f,0x76,
+	0x3c,0x40,0x62,0x5c,0x3d,0x37,0x47,0x73,
+	0x7c,0x72,0x57,0x68,0x77,0x8f,0x77,0x74,
+	0x74,0xa3,0x9f,0x98,0x68,0x73,0x70,0x8a,
+	0x66,0x64,0x59,0x8a,0x8b,0x8f,0x62,0x72,
+	0x78,0x99,0x83,0x83,0x7b,0xad,0xb6,0xb5,
+	0x87,0x86,0x86,0x9b,0x82,0x73,0x69,0x8c,
+	0x9d,0x9b,0x7d,0x72,0x7f,0x94,0x91,0x82,
+	0x87,0xa6,0xc7,0xc9,0xb4,0xa7,0xb6,0xc2,
+	0xc0,0x99,0x71,0x81,0xa9,0x92,0x75,0x5c,
+	0x69,0x70,0x77,0x62,0x67,0x74,0x98,0x96,
+	0x82,0x51,0x40,0x5b,0x55,0x39,0x28,0x40,
+	0x58,0x6f,0x62,0x64,0x5c,0x75,0x6f,0x73,
+	0x63,0x80,0x89,0xa8,0x8d,0x90,0x76,0x8e,
+	0x74,0x80,0x5b,0x7c,0x74,0x9f,0x7c,0x90,
+	0x6b,0x90,0x73,0x8c,0x63,0x8e,0x80,0xb4,
+	0x91,0xaa,0x7a,0x9e,0x74,0x8f,0x5c,0x85,
+	0x6e,0xa5,0x82,0xa4,0x7b,0xa0,0x7e,0x9d,
+	0x78,0xa0,0x93,0xc6,0xb4,0xd3,0xb4,0xcd,
+	0xb1,0xc4,0x9f,0xa7,0x7b,0x8c,0x96,0xa0,
+	0x81,0x72,0x65,0x66,0x5d,0x66,0x71,0x80,
+	0x89,0x86,0x6f,0x4d,0x56,0x4e,0x45,0x2e,
+	0x35,0x3d,0x50,0x56,0x67,0x60,0x66,0x5a,
+	0x63,0x60,0x71,0x73,0x89,0x8d,0xa0,0x93,
+	0x97,0x7e,0x88,0x7a,0x87,0x7d,0x8f,0x8d,
+	0xa0,0x95,0x91,0x7a,0x7b,0x74,0x7b,0x75,
+	0x7e,0x85,0x95,0x92,0x88,0x75,0x6f,0x70,
+	0x72,0x71,0x74,0x84,0x96,0xa2,0x99,0x90,
+	0x88,0x97,0x97,0x9e,0x9b,0xb1,0xbf,0xd2,
+	0xc5,0xbb,0xae,0xb5,0xb1,0xa8,0x90,0x7c,
+	0x89,0xaa,0x9a,0x83,0x5e,0x68,0x67,0x6d,
+	0x63,0x71,0x7e,0x80,0x60,0x50,0x53,0x4e,
+	0x4e,0x2e,0x31,0x2a,0x51,0x58,0x6f,0x53,
+	0x5b,0x50,0x6f,0x5a,0x6c,0x5a,0x88,0x8e,
+	0xaf,0x87,0x97,0x7c,0xa2,0x85,0x93,0x71,
+	0x9e,0x98,0xbf,0x8e,0x98,0x73,0x97,0x74,
+	0x80,0x55,0x7f,0x78,0xa2,0x76,0x7e,0x5c,
+	0x82,0x6a,0x75,0x54,0x76,0x80,0xab,0x96,
+	0x96,0x84,0x9e,0x9c,0x9c,0x87,0x95,0xac,
+	0xc5,0xc0,0xaf,0xa4,0xab,0xb7,0xa5,0x96,
+	0x87,0x9f,0x95,0x96,0x85,0x87,0x7b,0x84,
+	0x69,0x69,0x53,0x7d,0x7b,0x88,0x51,0x68,
+	0x57,0x7b,0x4c,0x4d,0x25,0x56,0x56,0x80,
+	0x56,0x67,0x50,0x7d,0x61,0x6d,0x46,0x72,
+	0x77,0xa4,0x82,0x8f,0x79,0xa8,0x90,0x99,
+	0x6d,0x8c,0x93,0xbc,0x9b,0x98,0x81,0x9e,
+	0x91,0x87,0x5c,0x65,0x73,0x92,0x80,0x71,
+	0x62,0x77,0x7f,0x72,0x55,0x53,0x77,0x92,
+	0x9c,0x82,0x88,0x95,0xb2,0x9d,0x8e,0x76,
+	0xa1,0xb3,0xc6,0x9f,0xa4,0xa0,0xc3,0xa8,
+	0x99,0x74,0x9b,0xa7,0xba,0x85,0x72,0x79,
+	0xa6,0x90,0x78,0x46,0x6b,0x75,0x91,0x58,
+	0x59,0x5a,0x83,0x70,0x58,0x2c,0x3e,0x57,
+	0x78,0x60,0x56,0x50,0x75,0x77,0x69,0x48,
+	0x51,0x6c,0x90,0x88,0x79,0x77,0x95,0xa9,
+	0x9a,0x7e,0x75,0x93,0xad,0xaf,0x8f,0x8b,
+	0x94,0xad,0x94,0x77,0x58,0x72,0x83,0x90,
+	0x69,0x63,0x66,0x8b,0x7b,0x69,0x48,0x67,
+	0x7f,0x9a,0x7f,0x7c,0x80,0xaa,0xa7,0x96,
+	0x73,0x86,0x9f,0xbb,0xa0,0x93,0x8e,0xaf,
+	0xb2,0xa0,0x79,0x7f,0x97,0xb0,0x9d,0x83,
+	0x71,0x88,0xa0,0x8d,0x6d,0x5a,0x75,0x89,
+	0x7e,0x56,0x5d,0x72,0x8c,0x72,0x51,0x3f,
+	0x59,0x73,0x7a,0x5c,0x54,0x64,0x85,0x7b,
+	0x64,0x4b,0x64,0x7e,0x91,0x75,0x70,0x79,
+	0xa1,0x9f,0x8e,0x6f,0x82,0x9a,0xae,0x97,
+	0x83,0x84,0xa4,0xa3,0x8d,0x67,0x69,0x7f,
+	0x92,0x7b,0x63,0x60,0x7e,0x8a,0x7a,0x5a,
+	0x59,0x76,0x8f,0x8b,0x74,0x72,0x8e,0xa8,
+	0x9d,0x80,0x76,0x8e,0xa8,0xa7,0x8a,0x80,
+	0x92,0xaf,0xa3,0x88,0x72,0x85,0xa1,0xa5,
+	0x88,0x77,0x7a,0x94,0x97,0x83,0x66,0x70,
+	0x83,0x90,0x6c,0x5b,0x62,0x86,0x88,0x72,
+	0x4f,0x57,0x6f,0x85,0x71,0x5e,0x5b,0x79,
+	0x89,0x7b,0x5d,0x5a,0x75,0x8d,0x87,0x6d,
+	0x6c,0x83,0xa2,0x95,0x80,0x6e,0x8c,0x9e,
+	0xa6,0x81,0x7e,0x82,0xa7,0x97,0x86,0x5f,
+	0x7a,0x84,0x97,0x6d,0x69,0x60,0x8f,0x82,
+	0x7e,0x54,0x70,0x7a,0x99,0x7c,0x76,0x6e,
+	0x98,0x9c,0x97,0x74,0x7c,0x8d,0xa9,0x97,
+	0x81,0x7a,0x94,0xa5,0x99,0x7e,0x6f,0x8d,
+	0x9b,0x9f,0x79,0x7a,0x78,0x9c,0x8b,0x83,
+	0x5e,0x81,0x80,0x96,0x5f,0x6d,0x62,0x98,
+	0x7c,0x7b,0x4b,0x70,0x71,0x96,0x66,0x6c,
+	0x59,0x8e,0x7f,0x85,0x56,0x6e,0x76,0x98,
+	0x7b,0x74,0x6a,0x90,0x96,0x93,0x74,0x76,
+	0x8a,0xa0,0x97,0x7c,0x79,0x85,0xa4,0x8d,
+	0x7e,0x61,0x84,0x84,0x96,0x65,0x72,0x65,
+	0x98,0x7a,0x81,0x53,0x81,0x79,0xa1,0x6d,
+	0x7f,0x69,0xa4,0x8a,0x99,0x64,0x8c,0x84,
+	0xad,0x80,0x86,0x6f,0x9e,0x94,0x98,0x6f,
+	0x7d,0x85,0xa0,0x8d,0x7b,0x73,0x82,0x95,
+	0x88,0x7b,0x68,0x81,0x83,0x90,0x62,0x75,
+	0x69,0x98,0x76,0x81,0x50,0x7f,0x71,0x99,
+	0x61,0x7a,0x5d,0x96,0x76,0x8a,0x57,0x7e,
+	0x72,0x9b,0x74,0x7e,0x6a,0x94,0x8d,0x91,
+	0x72,0x7c,0x85,0x99,0x8e,0x80,0x7b,0x86,
+	0x97,0x86,0x7e,0x69,0x83,0x80,0x8f,0x6e,
+	0x79,0x70,0x8f,0x7a,0x81,0x62,0x7f,0x7c,
+	0x97,0x75,0x83,0x76,0x96,0x88,0x8e,0x70,
+	0x86,0x84,0x99,0x84,0x87,0x7b,0x90,0x8e,
+	0x8b,0x7b,0x7b,0x84,0x8f,0x8b,0x80,0x7c,
+	0x80,0x8a,0x85,0x7c,0x71,0x7b,0x82,0x81,
+	0x79,0x77,0x7b,0x83,0x7b,0x75,0x6f,0x72,
+	0x7e,0x7f,0x7e,0x75,0x7a,0x7d,0x82,0x76,
+	0x77,0x74,0x81,0x80,0x85,0x7d,0x85,0x81,
+	0x8a,0x80,0x80,0x7d,0x85,0x89,0x88,0x87,
+	0x83,0x86,0x84,0x83,0x78,0x7f,0x76,0x85,
+	0x78,0x88,0x76,0x87,0x72,0x87,0x6e,0x84,
+	0x70,0x8a,0x76,0x91,0x79,0x93,0x77,0x8f,
+	0x74,0x8e,0x77,0x8e,0x7b,0x90,0x83,0x90,
+	0x7f,0x85,0x7b,0x86,0x81,0x82,0x83,0x7f,
+	0x8c,0x82,0x89,0x73,0x84,0x72,0x8c,0x71,
+	0x85,0x6b,0x93,0x78,0x92,0x65,0x82,0x66,
+	0x8f,0x6d,0x87,0x67,0x90,0x79,0x94,0x6a,
+	0x7c,0x6a,0x8c,0x7a,0x84,0x70,0x88,0x8a,
+	0x92,0x7e,0x73,0x79,0x82,0x8f,0x7e,0x81,
+	0x79,0x95,0x8c,0x8d,0x6a,0x79,0x75,0x92,
+	0x79,0x80,0x6d,0x8f,0x88,0x8f,0x6a,0x71,
+	0x70,0x90,0x82,0x80,0x71,0x88,0x92,0x94,
+	0x79,0x6c,0x74,0x8c,0x91,0x83,0x78,0x82,
+	0x94,0x97,0x81,0x6d,0x6f,0x87,0x91,0x88,
+	0x75,0x7b,0x8a,0x9a,0x82,0x70,0x63,0x81,
+	0x88,0x90,0x6e,0x79,0x7e,0x9c,0x82,0x74,
+	0x5a,0x78,0x84,0x93,0x74,0x76,0x79,0x96,
+	0x8c,0x78,0x61,0x6d,0x88,0x91,0x87,0x6f,
+	0x80,0x8a,0x9f,0x77,0x72,0x5e,0x91,0x8a,
+	0x9a,0x6a,0x87,0x7c,0xa7,0x75,0x7d,0x52,
+	0x8a,0x82,0x9f,0x6c,0x81,0x74,0xa2,0x7e,
+	0x7b,0x56,0x7b,0x86,0x9b,0x7e,0x79,0x7b,
+	0x95,0x93,0x76,0x68,0x69,0x8f,0x94,0x92,
+	0x71,0x84,0x83,0xa2,0x74,0x74,0x5c,0x90,
+	0x8a,0x9d,0x6d,0x85,0x79,0xa0,0x78,0x73,
+	0x58,0x7e,0x8a,0x96,0x84,0x7b,0x7f,0x83,
+	0x85,0x74,0x71,0x74,0x7f,0x86,0x87,0x87,
+	0x83,0x80,0x7a,0x75,0x76,0x78,0x7f,0x86,
+	0x88,0x89,0x86,0x82,0x7a,0x77,0x75,0x79,
+	0x80,0x86,0x89,0x8c,0x87,0x81,0x7c,0x76,
+	0x74,0x7a,0x7e,0x85,0x8a,0x8b,0x87,0x83,
+	0x7b,0x77,0x76,0x78,0x7c,0x85,0x8a,0x8b,
+	0x87,0x84,0x7b,0x77,0x75,0x77,0x7e,0x84,
+	0x88,0x8b,0x8a,0x84,0x7c,0x77,0x74,0x77,
+	0x7c,0x84,0x88,0x8d,0x88,0x84,0x7c,0x78,
+	0x74,0x77,0x7b,0x84,0x88,0x8c,0x89,0x86,
+	0x7d,0x79,0x74,0x76,0x7b,0x82,0x88,0x8c,
+	0x89,0x86,0x7e,0x79,0x74,0x77,0x79,0x83,
+	0x87,0x8a,0x8a,0x86,0x7f,0x78,0x74,0x78,
+	0x78,0x81,0x87,0x8a,0x89,0x88,0x80,0x7a,
+	0x75,0x76,0x79,0x81,0x85,0x8c,0x89,0x88,
+	0x7e,0x7e,0x6c,0x46,0x5b,0x83,0xaf,0x89,
+	0x6e,0x75,0xa3,0x93,0x6d,0x31,0x5d,0x93,
+	0xac,0x7e,0x68,0x81,0xaa,0x91,0x62,0x5c,
+	0x8c,0x9e,0x7f,0x62,0x7a,0x9c,0x8f,0x61,
+	0x56,0x77,0x8a,0x74,0x58,0x67,0x87,0x82,
+	0x5f,0x4f,0x67,0x79,0x6a,0x4e,0x54,0x6b,
+	0x6d,0x52,0x49,0x64,0x7b,0x71,0x55,0x50,
+	0x63,0x64,0x4f,0x41,0x55,0x70,0x73,0x61,
+	0x5c,0x69,0x6b,0x58,0x46,0x55,0x73,0x7b,
+	0x6b,0x65,0x6f,0x74,0x62,0x52,0x61,0x7e,
+	0x89,0x7e,0x73,0x7e,0x86,0x78,0x68,0x71,
+	0x8d,0x9c,0x98,0x8e,0x93,0x96,0x88,0x7b,
+	0x82,0x9e,0xaf,0xa9,0x9b,0x9b,0xa0,0x95,
+	0x86,0x86,0x9e,0xae,0xab,0x9e,0x98,0x96,
+	0x8c,0x7c,0x7a,0x8b,0x9d,0x9e,0x8e,0x86,
+	0x7f,0x6f,0x61,0x61,0x6f,0x82,0x84,0x74,
+	0x67,0x60,0x57,0x4d,0x4b,0x58,0x69,0x6f,
+	0x6c,0x62,0x59,0x50,0x4d,0x52,0x5f,0x70,
+	0x7b,0x81,0x7e,0x73,0x6c,0x69,0x6f,0x84,
+	0x9a,0xa5,0xa7,0x9f,0x92,0x92,0x98,0x9d,
+	0xa9,0xb2,0xbb,0xc1,0xc2,0xb6,0xab,0xa4,
+	0xa5,0xae,0xc1,0xc7,0xc8,0xbe,0xab,0x98,
+	0x9e,0x9e,0xa2,0x9f,0x9e,0x95,0x8f,0x80,
+	0x80,0x91,0x9f,0x86,0xa5,0xaf,0x9c,0x86,
+	0x6a,0x4d,0x40,0x3f,0x44,0x55,0x7f,0x89,
+	0x7c,0x89,0x5f,0x50,0x4c,0x56,0x62,0x75,
+	0x7e,0x7e,0x73,0x64,0x5d,0x62,0x6f,0x77,
+	0x7d,0x82,0x7e,0x76,0x60,0x55,0x56,0x5f,
+	0x67,0x71,0x75,0x75,0x66,0x56,0x48,0x4e,
+	0x58,0x65,0x6d,0x79,0x7c,0x72,0x64,0x5a,
+	0x61,0x72,0x81,0x8f,0x9e,0xa4,0xa0,0x94,
+	0x8b,0x93,0xa2,0xb3,0xbf,0xca,0xce,0xca,
+	0xba,0xa9,0xab,0xb6,0xc0,0xc7,0xca,0xca,
+	0xbf,0xa8,0x92,0x8b,0x91,0x97,0x98,0x97,
+	0x96,0x8a,0x71,0x5b,0x53,0x59,0x62,0x65,
+	0x69,0x6d,0x65,0x54,0x43,0x3f,0x4c,0x5d,
+	0x65,0x71,0x7a,0x7c,0x71,0x63,0x65,0x74,
+	0x8a,0x97,0xa2,0xad,0xb2,0xa9,0x99,0x95,
+	0xa3,0xb6,0xbf,0xc8,0xcc,0xce,0xc0,0xaa,
+	0xa1,0xa7,0xb3,0xba,0xbd,0xc0,0xba,0xa8,
+	0x8f,0x82,0x83,0x8c,0x93,0x95,0x96,0x90,
+	0x7e,0x67,0x59,0x59,0x63,0x6e,0x73,0x77,
+	0x75,0x67,0x56,0x48,0x4e,0x5d,0x6e,0x7f,
+	0x8c,0x92,0x8d,0x85,0x7c,0x75,0x5e,0x60,
+	0x83,0x81,0x8c,0x8c,0x8a,0x86,0x90,0xa0,
+	0xba,0xc7,0xc6,0x9a,0x86,0x88,0x6a,0x71,
+	0x7d,0x86,0x92,0x9a,0x95,0x89,0x77,0x6a,
+	0x63,0x63,0x6c,0x79,0x80,0x7a,0x6b,0x5c,
+	0x4d,0x46,0x43,0x4d,0x5a,0x65,0x62,0x56,
+	0x48,0x43,0x3c,0x3b,0x48,0x59,0x6b,0x6c,
+	0x64,0x5f,0x5d,0x5b,0x5d,0x6b,0x81,0x96,
+	0x9a,0x95,0x91,0x91,0x90,0x90,0x9a,0xb1,
+	0xc1,0xc4,0xbb,0xb4,0xb0,0xaa,0xa3,0xa5,
+	0xb5,0xc3,0xc0,0xb2,0xa4,0x9b,0x90,0x82,
+	0x7f,0x89,0x95,0x91,0x80,0x6f,0x67,0x5c,
+	0x51,0x4a,0x5a,0x68,0x69,0x5d,0x52,0x50,
+	0x4c,0x45,0x43,0x57,0x6e,0x78,0x6f,0x6c,
+	0x6d,0x6f,0x6a,0x6d,0x81,0x9d,0xa9,0xa0,
+	0x9d,0xa1,0xa2,0x99,0x96,0xa5,0xc0,0xca,
+	0xbc,0xb4,0xb5,0xb4,0xa6,0x9b,0xa7,0xbf,
+	0xc4,0xb3,0xa6,0xa4,0xa1,0x8e,0x7f,0x88,
+	0x9f,0xa6,0x94,0x84,0x83,0x82,0x71,0x5e,
+	0x68,0x81,0x8e,0x7d,0x70,0x74,0x79,0x6b,
+	0x5a,0x67,0x8c,0x9e,0x97,0x8b,0x96,0x99,
+	0x7d,0x4a,0x48,0x83,0x94,0x7d,0x72,0x84,
+	0x98,0x8f,0x7c,0x7e,0x98,0x8e,0x71,0x75,
+	0x76,0x78,0x65,0x4d,0x51,0x7b,0x92,0x84,
+	0x6f,0x75,0x83,0x70,0x4e,0x4b,0x6b,0x83,
+	0x70,0x58,0x5d,0x6a,0x57,0x36,0x30,0x4f,
+	0x68,0x5a,0x43,0x4a,0x59,0x51,0x2e,0x28,
+	0x4d,0x6b,0x64,0x51,0x5b,0x74,0x71,0x54,
+	0x51,0x78,0x9a,0x98,0x86,0x92,0xae,0xad,
+	0x8f,0x87,0xac,0xcd,0xc9,0xb3,0xba,0xd2,
+	0xcf,0xaa,0x9a,0xb6,0xd1,0xc7,0xaa,0xa9,
+	0xbc,0xb3,0x89,0x72,0x83,0x9e,0x91,0x71,
+	0x6d,0x7e,0x79,0x51,0x37,0x4a,0x66,0x5f,
+	0x45,0x43,0x5b,0x5f,0x3e,0x29,0x41,0x65,
+	0x67,0x52,0x57,0x75,0x80,0x66,0x53,0x6e,
+	0x93,0x9c,0x87,0x8b,0xac,0xb8,0xa0,0x88,
+	0x9e,0xc3,0xc5,0xaf,0xae,0xcc,0xd3,0xb5,
+	0x99,0xaa,0xc7,0xc6,0xab,0xa5,0xbb,0xc5,
+	0xa2,0x84,0x8d,0xab,0xa8,0x8a,0x83,0x99,
+	0xa3,0x84,0x62,0x6c,0x8c,0x8b,0x6e,0x69,
+	0x8a,0xa0,0x84,0x67,0x75,0x9a,0x9e,0x87,
+	0x84,0xaa,0xb9,0x9e,0x70,0x6c,0x70,0x83,
+	0x7e,0x78,0x8e,0x92,0x7a,0x53,0x52,0x5d,
+	0x4c,0x51,0x50,0x6b,0x6c,0x4c,0x32,0x3b,
+	0x66,0x69,0x52,0x49,0x6b,0x7c,0x68,0x46,
+	0x4c,0x69,0x6b,0x4c,0x41,0x59,0x6b,0x55,
+	0x35,0x39,0x53,0x56,0x39,0x2f,0x47,0x59,
+	0x4b,0x30,0x38,0x51,0x5b,0x45,0x40,0x58,
+	0x70,0x69,0x58,0x61,0x7e,0x8a,0x7c,0x7a,
+	0x92,0xaa,0xa7,0x99,0xa4,0xbb,0xc5,0xb7,
+	0xb3,0xc3,0xd5,0xce,0xc0,0xc2,0xd1,0xd4,
+	0xc3,0xb6,0xbd,0xc3,0xb9,0xa4,0x9e,0xa7,
+	0xa2,0x8e,0x7c,0x7b,0x7f,0x71,0x5f,0x57,
+	0x61,0x5c,0x4c,0x40,0x40,0x47,0x40,0x37,
+	0x3a,0x43,0x4b,0x43,0x40,0x46,0x52,0x55,
+	0x56,0x5c,0x70,0x79,0x7b,0x7c,0x86,0x90,
+	0x96,0x98,0xa2,0xb1,0xb9,0xba,0xb9,0xbc,
+	0xc4,0xc1,0xc1,0xc5,0xcd,0xcf,0xd0,0xc5,
+	0xc3,0xc1,0xb4,0xb2,0xb9,0xc2,0xb2,0xa7,
+	0xa6,0xa8,0x9e,0x95,0x91,0x93,0x96,0x95,
+	0x93,0x8e,0x87,0x83,0x7e,0x7f,0x82,0x8a,
+	0x90,0x92,0x91,0x92,0x91,0x93,0x96,0x9e,
+	0xa2,0xa5,0x9c,0x8a,0x6c,0x74,0x88,0x7b,
+	0x78,0x48,0x37,0x2c,0x58,0x4c,0x51,0x33,
+	0x30,0x36,0x41,0x4e,0x55,0x52,0x4f,0x49,
+	0x47,0x47,0x4a,0x52,0x59,0x5c,0x5b,0x55,
+	0x4c,0x46,0x41,0x41,0x48,0x4d,0x51,0x51,
+	0x4b,0x43,0x3e,0x3a,0x3d,0x45,0x4e,0x56,
+	0x59,0x59,0x57,0x53,0x56,0x5c,0x67,0x74,
+	0x83,0x8b,0x8e,0x8f,0x90,0x8f,0x99,0xa2,
+	0xb0,0xba,0xc1,0xc6,0xc1,0xbc,0xba,0xbb,
+	0xbe,0xc5,0xc8,0xca,0xc6,0xbe,0xb3,0xab,
+	0xa3,0xa1,0xa0,0xa2,0x9d,0x97,0x8c,0x81,
+	0x75,0x6f,0x6a,0x6d,0x6a,0x6d,0x66,0x62,
+	0x58,0x59,0x3a,0x40,0x4b,0x68,0x73,0x62,
+	0x56,0x50,0x6d,0x6c,0x64,0x3a,0x68,0x75,
+	0xb4,0x7a,0x7d,0x51,0xa0,0x94,0xb2,0x6a,
+	0x91,0x89,0xcf,0x95,0x9e,0x66,0xaf,0xa2,
+	0xc6,0x7b,0x9c,0x90,0xd6,0xab,0xa9,0x72,
+	0xa3,0x9e,0xb5,0x76,0x81,0x83,0xbd,0xae,
+	0x9f,0x75,0x8b,0x9a,0xa0,0x79,0x68,0x7a,
+	0xa0,0xb2,0x8f,0x7d,0x76,0x9f,0x96,0x8d,
+	0x62,0x86,0x94,0xc2,0x94,0x8e,0x6c,0x9c,
+	0x7c,0x7d,0x40,0x6e,0x5c,0xa0,0x69,0x75,
+	0x3b,0x83,0x5d,0x71,0x28,0x51,0x4b,0x96,
+	0x66,0x74,0x41,0x7d,0x69,0x86,0x40,0x5c,
+	0x54,0x99,0x77,0x7a,0x49,0x75,0x6f,0x83,
+	0x48,0x4f,0x53,0x88,0x7e,0x73,0x4e,0x65,
+	0x74,0x7a,0x5a,0x46,0x59,0x7e,0x92,0x77,
+	0x66,0x66,0x8f,0x8a,0x80,0x58,0x76,0x8e,
+	0xbd,0x94,0x93,0x7b,0xb7,0xa6,0xb0,0x72,
+	0x98,0x9d,0xdd,0xaf,0xb0,0x89,0xc3,0xb1,
+	0xbf,0x77,0x92,0x90,0xcf,0xa4,0xa2,0x70,
+	0xa2,0x93,0xa1,0x5a,0x64,0x61,0x9b,0x81,
+	0x76,0x47,0x69,0x6e,0x76,0x43,0x37,0x42,
+	0x72,0x75,0x60,0x46,0x50,0x72,0x72,0x5b,
+	0x38,0x56,0x75,0x9c,0x7a,0x71,0x66,0x9c,
+	0x95,0x95,0x5d,0x83,0x91,0xd0,0xa2,0xa6,
+	0x81,0xc2,0xb3,0xbf,0x7a,0x99,0x9a,0xde,
+	0xb5,0xb5,0x86,0xbd,0xb2,0xc0,0x7b,0x89,
+	0x8a,0xc9,0xae,0xa7,0x7a,0xa0,0xa4,0xac,
+	0x79,0x72,0x7b,0xab,0xb0,0x9e,0x80,0x8c,
+	0xaa,0xa8,0x8e,0x6e,0x84,0xa0,0xbd,0x97,
+	0x86,0x71,0x91,0x78,0x67,0x2f,0x57,0x57,
+	0x8a,0x85,0x72,0x43,0x83,0x64,0x65,0x22,
+	0x3d,0x3e,0x7b,0x56,0x5d,0x35,0x6b,0x62,
+	0x73,0x38,0x4a,0x4b,0x85,0x6f,0x6c,0x45,
+	0x69,0x6c,0x77,0x48,0x44,0x4d,0x7b,0x7d,
+	0x6b,0x51,0x5e,0x76,0x78,0x5d,0x44,0x59,
+	0x79,0x93,0x77,0x6e,0x66,0x92,0x8a,0x87,
+	0x5b,0x7a,0x89,0xbf,0x98,0x9d,0x80,0xb8,
+	0xab,0xb8,0x7c,0x9b,0x9e,0xdb,0xb6,0xba,
+	0x90,0xc2,0xb6,0xc3,0x83,0x95,0x90,0xca,
+	0xab,0xa5,0x7a,0x9a,0x95,0x9e,0x69,0x60,
+	0x63,0x8c,0x89,0x74,0x54,0x5a,0x72,0x6a,
+	0x56,0x2d,0x47,0x5b,0x80,0x58,0x55,0x3f,
+	0x73,0x63,0x6a,0x31,0x5a,0x5d,0xa1,0x73,
+	0x81,0x57,0x97,0x86,0xa1,0x5c,0x83,0x7e,
+	0xcb,0xa5,0xb0,0x7f,0xb4,0xab,0xc1,0x88,
+	0x93,0x95,0xd1,0xc5,0xb9,0x95,0xa8,0xb8,
+	0xbb,0x9a,0x80,0x97,0xb2,0xcb,0xa7,0x99,
+	0x89,0xb3,0xa0,0xa3,0x6a,0x8e,0x92,0xcb,
+	0x99,0xa1,0x75,0xb0,0x96,0xab,0x68,0x8d,
+	0x82,0xc3,0x90,0x91,0x55,0x7b,0x60,0x75,
+	0x45,0x52,0x3f,0x95,0x92,0x7c,0x46,0x6f,
+	0x69,0x67,0x3e,0x34,0x3e,0x63,0x6f,0x59,
+	0x47,0x45,0x61,0x5e,0x55,0x33,0x51,0x60,
+	0x87,0x62,0x60,0x42,0x71,0x5f,0x6b,0x36,
+	0x5a,0x59,0x93,0x69,0x70,0x48,0x75,0x68,
+	0x7d,0x4a,0x62,0x65,0x9d,0x86,0x88,0x64,
+	0x86,0x85,0x97,0x74,0x79,0x87,0xb0,0xb5,
+	0xa8,0x92,0x99,0xae,0xaf,0xa2,0x8d,0xa4,
+	0xbb,0xd3,0xb5,0xaa,0x96,0xb6,0xa9,0xa9,
+	0x82,0x98,0x9d,0xc3,0xa1,0x95,0x74,0x8d,
+	0x83,0x86,0x5c,0x65,0x6d,0x8f,0x7d,0x69,
+	0x4b,0x58,0x5d,0x5c,0x43,0x3e,0x4f,0x6d,
+	0x74,0x5e,0x46,0x49,0x5c,0x62,0x55,0x4b,
+	0x5e,0x82,0x94,0x87,0x6f,0x70,0x80,0x90,
+	0x84,0x80,0x84,0xae,0xbd,0xc0,0x9b,0x9a,
+	0x9b,0xb8,0xa5,0xa7,0x99,0xc4,0xd0,0xdb,
+	0xb1,0xa9,0x9f,0xb9,0xad,0xa9,0x9b,0xb5,
+	0xcb,0xcf,0xb7,0x9a,0x99,0x9f,0xab,0x97,
+	0x9d,0x9a,0xc4,0xb9,0xbd,0x8a,0x97,0x82,
+	0xa3,0x7c,0x8e,0x6d,0x96,0x76,0x83,0x48,
+	0x65,0x57,0x6c,0x31,0x62,0x53,0x91,0x8a,
+	0x85,0x49,0x63,0x50,0x5c,0x4a,0x4a,0x3f,
+	0x4e,0x5a,0x57,0x4f,0x36,0x3c,0x35,0x4e,
+	0x3d,0x57,0x4a,0x72,0x57,0x6c,0x3c,0x56,
+	0x35,0x60,0x42,0x6b,0x50,0x80,0x5f,0x7e,
+	0x4e,0x68,0x47,0x6f,0x58,0x7e,0x71,0x93,
+	0x85,0x94,0x7d,0x84,0x78,0x89,0x91,0x9f,
+	0xac,0xb5,0xbe,0xb8,0xb7,0xa6,0xaf,0xa2,
+	0xb9,0xb3,0xd2,0xc5,0xd8,0xbb,0xc7,0xa9,
+	0xb3,0x97,0xa8,0x9e,0xb8,0xae,0xb2,0x97,
+	0x94,0x80,0x7c,0x69,0x64,0x64,0x73,0x79,
+	0x72,0x60,0x53,0x4d,0x47,0x3e,0x37,0x3a,
+	0x4e,0x5e,0x62,0x50,0x49,0x42,0x53,0x48,
+	0x4f,0x45,0x6b,0x74,0x91,0x74,0x7a,0x67,
+	0x88,0x78,0x89,0x72,0x9a,0xa0,0xc6,0xaa,
+	0xa8,0x93,0xaa,0xa8,0xac,0x9a,0xa8,0xbf,
+	0xd0,0xcc,0xae,0xa8,0xa4,0xbd,0xa6,0xae,
+	0x97,0xc1,0xbf,0xd8,0xa2,0xaa,0x8b,0xbb,
+	0x9a,0xb0,0x83,0xb4,0xaa,0xd1,0x98,0x98,
+	0x6e,0x94,0x7a,0x7f,0x52,0x65,0x6e,0x90,
+	0x89,0x7e,0x57,0x4d,0x66,0x6a,0x5c,0x4f,
+	0x78,0x8e,0x97,0x4e,0x3d,0x4b,0x7f,0x6c,
+	0x68,0x42,0x62,0x5d,0x71,0x3f,0x39,0x27,
+	0x50,0x49,0x4e,0x33,0x4c,0x5b,0x71,0x54,
+	0x41,0x37,0x52,0x61,0x5e,0x4d,0x52,0x6a,
+	0x80,0x75,0x57,0x4e,0x60,0x7b,0x7e,0x6f,
+	0x70,0x83,0xa0,0x9c,0x88,0x72,0x86,0x9a,
+	0xb0,0x9b,0x9d,0xa1,0xc8,0xc4,0xb9,0x95,
+	0xa5,0xb4,0xd0,0xb9,0xb5,0xad,0xce,0xcf,
+	0xc2,0x9a,0x98,0xa5,0xb9,0xae,0x97,0x92,
+	0x9c,0xac,0x95,0x79,0x5d,0x74,0x78,0x83,
+	0x5b,0x60,0x57,0x7c,0x5d,0x58,0x2a,0x51,
+	0x55,0x7f,0x5b,0x73,0x62,0x96,0x80,0x87,
+	0x57,0x7b,0x82,0xb3,0x9a,0xa7,0x9b,0xc5,
+	0xbf,0xbd,0x9b,0xa1,0xad,0xc2,0xbd,0xab,
+	0xa9,0xb4,0xc9,0xb3,0xa7,0x8c,0xad,0xac,
+	0xc6,0x99,0xaa,0x99,0xc7,0xa2,0xab,0x79,
+	0xa2,0x95,0xbe,0x8b,0x9f,0x81,0xb2,0x94,
+	0x9e,0x69,0x8a,0x7f,0xa6,0x83,0x86,0x72,
+	0x91,0x89,0x84,0x63,0x64,0x70,0x82,0x7d,
+	0x68,0x66,0x69,0x7d,0x67,0x5d,0x41,0x61,
+	0x5f,0x74,0x4c,0x59,0x48,0x6e,0x4f,0x55,
+	0x2d,0x4e,0x46,0x66,0x3f,0x4b,0x37,0x5b,
+	0x46,0x4b,0x2a,0x3d,0x3e,0x56,0x42,0x42,
+	0x36,0x4a,0x4a,0x45,0x33,0x35,0x41,0x4e,
+	0x4d,0x3f,0x41,0x43,0x52,0x4a,0x42,0x39,
+	0x4a,0x51,0x59,0x4d,0x4d,0x4e,0x62,0x67,
+	0x69,0x63,0x71,0x7d,0x85,0x7d,0x75,0x76,
+	0x7c,0x82,0x7f,0x79,0x7f,0x87,0x89,0x85,
+	0x77,0x75,0x76,0x74,0x65,0x5b,0x54,0x5a,
+	0x5b,0x58,0x4c,0x49,0x4e,0x51,0x50,0x46,
+	0x4a,0x4d,0x5a,0x59,0x5e,0x56,0x67,0x67,
+	0x74,0x68,0x75,0x73,0x8e,0x86,0x95,0x89,
+	0x9d,0x99,0xad,0x9e,0xaf,0xa5,0xbe,0xb1,
+	0xc4,0xb2,0xbf,0xb5,0xc5,0xae,0xb6,0xae,
+	0xbd,0xbc,0xc3,0xaf,0xb1,0xb1,0xb5,0xba,
+	0xb9,0xb3,0xaa,0xb9,0xb5,0xc8,0xc0,0xcb,
+	0xb6,0xcc,0xb6,0xc2,0xb1,0xc2,0x9a,0xa5,
+	0x7a,0x86,0x60,0x7f,0x72,0xad,0xa6,0xd1,
+	0xb7,0xce,0x9e,0x9f,0x67,0x74,0x57,0x7b,
+	0x72,0xa1,0x97,0xb6,0xa6,0xb7,0x93,0x95,
+	0x8e,0x9c,0x9b,0xa2,0x9d,0x9a,0xa9,0xa9,
+	0xb3,0xa5,0xb3,0xa1,0xb8,0x9b,0xac,0x8c,
+	0xa7,0x81,0x94,0x63,0x7a,0x53,0x74,0x45,
+	0x5f,0x34,0x5b,0x37,0x5d,0x32,0x58,0x3e,
+	0x6e,0x50,0x75,0x5d,0x89,0x7c,0x9e,0x85,
+	0x9e,0x96,0xb4,0xa9,0xb0,0xa2,0xad,0xa7,
+	0xa7,0x99,0x8e,0x91,0x92,0x97,0x80,0x94,
+	0x8d,0xad,0x75,0x6c,0x54,0x65,0x6d,0x93,
+	0x83,0xa3,0x90,0xc1,0x9d,0x85,0x56,0x72,
+	0x58,0x8c,0x5a,0x79,0x46,0x6d,0x45,0x62,
+	0x30,0x51,0x30,0x5e,0x3e,0x5c,0x41,0x6e,
+	0x5e,0x83,0x69,0x85,0x79,0x9a,0x90,0x9b,
+	0x8d,0x9c,0x98,0x9d,0x8b,0x82,0x7c,0x7c,
+	0x7c,0x68,0x68,0x5b,0x6c,0x5d,0x69,0x50,
+	0x69,0x5c,0x83,0x6a,0x8b,0x78,0xa8,0x93,
+	0xb7,0x92,0xb8,0x9b,0xc6,0x9e,0xba,0x8f,
+	0xb6,0x8c,0xa6,0x6f,0x88,0x60,0x86,0x5e,
+	0x7b,0x60,0x91,0x89,0x98,0x48,0x63,0x4c,
+	0x79,0x75,0x8c,0x88,0xaa,0xb5,0xb1,0x73,
+	0x71,0x65,0x70,0x6f,0x60,0x5d,0x53,0x5f,
+	0x4c,0x54,0x34,0x4a,0x3a,0x59,0x41,0x60,
+	0x4c,0x7e,0x6a,0x91,0x6f,0x9b,0x84,0xb5,
+	0x93,0xb8,0x93,0xc1,0x9b,0xb8,0x83,0x9c,
+	0x70,0x93,0x66,0x7c,0x50,0x74,0x56,0x70,
+	0x4b,0x63,0x50,0x77,0x69,0x84,0x79,0x9b,
+	0x9d,0xb1,0xa7,0xb1,0xaf,0xba,0xb8,0xb7,
+	0xb2,0xaf,0xb2,0xa5,0x9d,0x85,0x87,0x76,
+	0x84,0x6e,0x81,0x79,0x9b,0x94,0x94,0x4d,
+	0x6e,0x4f,0x76,0x6e,0x99,0x91,0xc0,0xa3,
+	0x8c,0x68,0x78,0x51,0x7c,0x57,0x76,0x50,
+	0x6f,0x4a,0x62,0x38,0x4f,0x2d,0x4a,0x31,
+	0x54,0x44,0x69,0x5f,0x7e,0x74,0x90,0x85,
+	0xa2,0x99,0xb6,0xae,0xc1,0xb6,0xbd,0xaa,
+	0xa6,0x8f,0x85,0x76,0x70,0x69,0x61,0x5d,
+	0x55,0x54,0x4e,0x51,0x4b,0x59,0x60,0x7c,
+	0x84,0x9c,0x9e,0xb6,0xb1,0xc1,0xb2,0xc0,
+	0xb8,0xca,0xbe,0xc6,0xb2,0xb7,0xa0,0x9f,
+	0x82,0x81,0x71,0x85,0x80,0x8f,0x8c,0xa1,
+	0x9a,0x77,0x59,0x68,0x55,0x7e,0x8f,0xa8,
+	0xa8,0x89,0x72,0x80,0x57,0x5b,0x53,0x61,
+	0x60,0x61,0x52,0x54,0x4c,0x4b,0x3b,0x2d,
+	0x27,0x35,0x43,0x4e,0x55,0x62,0x73,0x85,
+	0x8a,0x8a,0x90,0xa4,0xba,0xc4,0xc3,0xc5,
+	0xc5,0xc6,0xae,0x97,0x7c,0x77,0x6e,0x6d,
+	0x58,0x51,0x4c,0x54,0x46,0x42,0x32,0x4c,
+	0x5b,0x7d,0x7a,0x94,0x9d,0xc3,0xbc,0xc5,
+	0xaa,0xc1,0xbf,0xda,0xbf,0xc7,0xb4,0xcc,
+	0xae,0xa8,0x7b,0x86,0x7b,0x96,0x7e,0x8a,
+	0x85,0xad,0xa5,0x9e,0x56,0x68,0x75,0x85,
+	0x85,0x92,0x78,0x75,0x87,0x71,0x4f,0x51,
+	0x59,0x69,0x62,0x58,0x55,0x5d,0x65,0x54,
+	0x3e,0x2e,0x3c,0x44,0x4f,0x43,0x54,0x63,
+	0x88,0x7e,0x84,0x76,0x99,0xa3,0xbd,0xa9,
+	0xbe,0xba,0xdd,0xbe,0xb5,0x85,0x95,0x7d,
+	0x8b,0x57,0x61,0x4a,0x6e,0x4f,0x53,0x27,
+	0x49,0x47,0x6f,0x57,0x77,0x7a,0xb6,0xb0,
+	0xbf,0x9b,0xb8,0xb7,0xd4,0xb4,0xbd,0xb1,
+	0xd6,0xc3,0xbf,0x8d,0x92,0x8b,0x9c,0x7f,
+	0x7f,0x79,0xa1,0xa6,0xab,0x8e,0x8e,0x78,
+	0x86,0x8e,0x79,0x64,0x63,0x7d,0x7b,0x51,
+	0x4a,0x58,0x65,0x5d,0x4d,0x4c,0x5d,0x6d,
+	0x5f,0x45,0x33,0x3c,0x47,0x42,0x34,0x39,
+	0x52,0x73,0x7b,0x74,0x74,0x89,0xa5,0xab,
+	0xa7,0xa7,0xc0,0xd6,0xd8,0xbd,0xac,0xa0,
+	0xa5,0x8f,0x78,0x5a,0x62,0x64,0x68,0x47,
+	0x3d,0x35,0x4f,0x4c,0x50,0x46,0x6c,0x83,
+	0xa6,0x99,0xa2,0x9f,0xc3,0xbb,0xc1,0xa6,
+	0xbe,0xc3,0xd8,0xb8,0xb1,0x98,0xab,0x9c,
+	0x97,0x76,0x86,0x8f,0xb1,0xa2,0xa2,0x99,
+	0xad,0x9a,0x81,0x72,0x74,0x5a,0x65,0x66,
+	0x55,0x3e,0x4c,0x56,0x50,0x44,0x42,0x54,
+	0x60,0x60,0x48,0x46,0x43,0x51,0x41,0x3e,
+	0x33,0x53,0x5e,0x75,0x68,0x7a,0x7d,0xa2,
+	0x9a,0xa7,0x9d,0xc2,0xc3,0xdc,0xc0,0xc6,
+	0xae,0xc0,0x9b,0x92,0x69,0x76,0x65,0x6f,
+	0x4a,0x4e,0x3a,0x4f,0x3f,0x4a,0x39,0x5a,
+	0x67,0x8a,0x85,0x9b,0x9a,0xba,0xb4,0xbf,
+	0xae,0xc0,0xc3,0xd4,0xc3,0xc3,0xb3,0xbb,
+	0xab,0xa3,0x8e,0x92,0x95,0xa0,0x9d,0x9f,
+	0xa0,0xaf,0xb0,0xaa,0x87,0x6c,0x6a,0x61,
+	0x66,0x54,0x4a,0x3f,0x4a,0x47,0x42,0x3c,
+	0x47,0x4a,0x4c,0x49,0x46,0x45,0x42,0x3e,
+	0x37,0x38,0x3e,0x4d,0x57,0x65,0x6c,0x80,
+	0x86,0x9a,0x9a,0xad,0xb2,0xc7,0xc6,0xd7,
+	0xcc,0xd3,0xbc,0xbb,0x9a,0x98,0x78,0x7b,
+	0x5c,0x62,0x47,0x51,0x36,0x44,0x30,0x47,
+	0x3d,0x5b,0x59,0x80,0x7e,0xa0,0x98,0xb4,
+	0xaa,0xc3,0xb7,0xcb,0xbc,0xd0,0xc3,0xcd,
+	0xb7,0xbb,0xa6,0xae,0x9c,0xa1,0x94,0xa2,
+	0xa1,0xad,0xa8,0xac,0xab,0xa9,0x8a,0x5f,
+	0x52,0x65,0x70,0x55,0x43,0x34,0x41,0x3e,
+	0x4e,0x41,0x4d,0x42,0x57,0x4a,0x54,0x3b,
+	0x48,0x39,0x4d,0x38,0x4b,0x40,0x66,0x60,
+	0x82,0x72,0x94,0x8f,0xb6,0xa5,0xc1,0xb3,
+	0xd8,0xc9,0xdd,0xb8,0xc3,0xa4,0xb2,0x87,
+	0x85,0x5f,0x6d,0x55,0x5c,0x38,0x3f,0x32,
+	0x49,0x3d,0x4b,0x44,0x69,0x75,0x91,0x8c,
+	0x9e,0xa4,0xbe,0xbd,0xc1,0xb9,0xc9,0xcf,
+	0xd5,0xc5,0xbb,0xb6,0xba,0xb6,0xa6,0x9f,
+	0x9e,0xb0,0xb3,0xb1,0xa6,0xb0,0xaf,0xa8,
+	0x70,0x3c,0x4f,0x76,0x73,0x53,0x23,0x2f,
+	0x30,0x47,0x38,0x3b,0x31,0x4c,0x4c,0x4f,
+	0x36,0x3b,0x3b,0x4c,0x3e,0x3e,0x38,0x57,
+	0x65,0x75,0x6c,0x7e,0x8d,0xaa,0xad,0xb1,
+	0xaf,0xca,0xd4,0xda,0xc5,0xbc,0xb5,0xb8,
+	0xa3,0x8a,0x6e,0x6b,0x6a,0x62,0x4a,0x3c,
+	0x3c,0x46,0x4a,0x44,0x41,0x56,0x72,0x88,
+	0x8a,0x8b,0x9a,0xb0,0xbe,0xb7,0xb1,0xb7,
+	0xca,0xd0,0xc6,0xb5,0xaf,0xb8,0xba,0xaa,
+	0x99,0x95,0xa6,0xb3,0xb0,0xa1,0xa1,0xaf,
+	0xb1,0x94,0x55,0x3b,0x6b,0x7b,0x72,0x3c,
+	0x2e,0x38,0x49,0x4c,0x3d,0x37,0x45,0x5a,
+	0x5a,0x49,0x3b,0x43,0x52,0x51,0x43,0x3d,
+	0x4c,0x69,0x77,0x74,0x72,0x80,0x9d,0xab,
+	0xa8,0xa0,0xaf,0xc7,0xd6,0xc7,0xb5,0xab,
+	0xb4,0xac,0x96,0x72,0x6c,0x6d,0x75,0x5c,
+	0x4a,0x3b,0x51,0x55,0x54,0x42,0x4f,0x66,
+	0x8a,0x89,0x89,0x84,0xa3,0xb2,0xb9,0xa2,
+	0xa5,0xb1,0xca,0xc1,0xb4,0x9f,0xac,0xb0,
+	0xaf,0x93,0x8b,0x91,0xab,0xad,0x9e,0x93,
+	0x9d,0xad,0xa1,0x76,0x45,0x5a,0x7d,0x86,
+	0x61,0x40,0x40,0x58,0x5b,0x55,0x3f,0x4d,
+	0x5c,0x71,0x5c,0x52,0x47,0x61,0x5f,0x61,
+	0x43,0x52,0x60,0x83,0x78,0x79,0x6f,0x91,
+	0x9b,0xa6,0x8e,0x9b,0xa5,0xc5,0xbc,0xaf,
+	0x9a,0xa2,0xa4,0x9c,0x7c,0x6b,0x6b,0x7c,
+	0x76,0x63,0x4d,0x53,0x63,0x66,0x59,0x50,
+	0x63,0x7f,0x91,0x8b,0x84,0x8a,0xa1,0xa9,
+	0xa2,0x91,0x9a,0xaa,0xbc,0xac,0x9c,0x92,
+	0xa1,0xa4,0x98,0x83,0x85,0x93,0xa7,0xa3,
+	0x92,0x8c,0x97,0x99,0x83,0x62,0x5b,0x6f,
+	0x87,0x79,0x62,0x4c,0x5b,0x66,0x68,0x58,
+	0x52,0x5e,0x73,0x75,0x69,0x59,0x5c,0x6a,
+	0x6d,0x60,0x55,0x61,0x7b,0x88,0x84,0x79,
+	0x7d,0x90,0x9c,0x94,0x8b,0x90,0xa7,0xb2,
+	0xad,0x95,0x90,0x91,0x97,0x84,0x72,0x69,
+	0x76,0x7f,0x7a,0x63,0x5c,0x61,0x71,0x69,
+	0x64,0x5f,0x77,0x8c,0x97,0x89,0x84,0x8a,
+	0x9c,0x9c,0x92,0x87,0x97,0xa7,0xad,0x9e,
+	0x8b,0x8d,0x95,0x97,0x88,0x7f,0x83,0x9b,
+	0xa0,0x9c,0x87,0x87,0x87,0x87,0x76,0x6c,
+	0x62,0x7f,0x7d,0x81,0x5e,0x61,0x61,0x75,
+	0x66,0x64,0x5a,0x74,0x79,0x81,0x67,0x66,
+	0x61,0x75,0x6a,0x6a,0x62,0x74,0x86,0x90,
+	0x83,0x7d,0x7f,0x8e,0x93,0x8b,0x89,0x8e,
+	0xa4,0xa4,0xa0,0x84,0x89,0x82,0x8d,0x74,
+	0x79,0x66,0x86,0x78,0x85,0x5f,0x6f,0x5f,
+	0x7e,0x67,0x78,0x67,0x8f,0x87,0x9e,0x7f,
+	0x8b,0x7f,0x97,0x89,0x92,0x84,0x99,0x9b,
+	0xa4,0x8e,0x89,0x83,0x8a,0x8a,0x84,0x85,
+	0x87,0x9b,0x93,0x96,0x7b,0x7e,0x71,0x8b,
+	0x6f,0x7a,0x66,0x89,0x76,0x89,0x5d,0x74,
+	0x5b,0x7d,0x60,0x7b,0x63,0x87,0x72,0x89,
+	0x65,0x76,0x60,0x7b,0x68,0x7d,0x70,0x88,
+	0x84,0x90,0x81,0x82,0x7f,0x85,0x8a,0x89,
+	0x91,0x8f,0x9c,0x90,0x94,0x7c,0x85,0x73,
+	0x84,0x70,0x84,0x73,0x88,0x74,0x83,0x67,
+	0x78,0x63,0x7e,0x6c,0x89,0x7a,0x94,0x83,
+	0x93,0x7f,0x8b,0x7b,0x8c,0x82,0x93,0x8c,
+	0x99,0x8e,0x92,0x86,0x86,0x7f,0x81,0x80,
+	0x88,0x8f,0x8e,0x8f,0x85,0x82,0x79,0x81,
+	0x75,0x7c,0x71,0x80,0x7c,0x84,0x75,0x7a,
+	0x6f,0x73,0x69,0x71,0x70,0x7f,0x7e,0x81,
+	0x76,0x76,0x74,0x76,0x71,0x70,0x74,0x82,
+	0x8a,0x88,0x83,0x7e,0x83,0x86,0x83,0x7e,
+	0x80,0x8d,0x94,0x98,0x87,0x84,0x7d,0x87,
+	0x7c,0x7c,0x6d,0x81,0x82,0x8f,0x77,0x7b,
+	0x6b,0x80,0x75,0x7d,0x6a,0x80,0x82,0x9a,
+	0x83,0x85,0x75,0x8c,0x85,0x8a,0x78,0x84,
+	0x8c,0x9d,0x91,0x84,0x7c,0x80,0x8c,0x85,
+	0x7f,0x76,0x8f,0x8e,0x9a,0x77,0x7b,0x70,
+	0x90,0x7a,0x84,0x62,0x82,0x7c,0x9b,0x70,
+	0x7b,0x60,0x86,0x72,0x82,0x61,0x7e,0x7b,
+	0x96,0x78,0x77,0x66,0x7e,0x7e,0x81,0x6f,
+	0x75,0x85,0x94,0x8f,0x77,0x76,0x7a,0x92,
+	0x86,0x83,0x72,0x8f,0x8e,0x9f,0x78,0x7b,
+	0x6e,0x8f,0x7f,0x85,0x66,0x82,0x83,0x99,
+	0x74,0x73,0x67,0x86,0x82,0x84,0x6d,0x7c,
+	0x87,0x9a,0x88,0x78,0x70,0x84,0x8f,0x8b,
+	0x7c,0x7a,0x8c,0x96,0x93,0x7a,0x73,0x7c,
+	0x90,0x8b,0x80,0x74,0x85,0x90,0x92,0x7b,
+	0x6f,0x75,0x85,0x8c,0x7c,0x71,0x74,0x8a,
+	0x8f,0x80,0x69,0x6c,0x7a,0x8a,0x7e,0x72,
+	0x70,0x84,0x8e,0x84,0x6f,0x6a,0x7b,0x87,
+	0x89,0x74,0x77,0x7e,0x95,0x8a,0x80,0x6a,
+	0x82,0x85,0x98,0x77,0x81,0x76,0x9c,0x87,
+	0x8a,0x66,0x7e,0x79,0x98,0x75,0x7f,0x6d,
+	0x90,0x84,0x89,0x69,0x74,0x79,0x8e,0x83,
+	0x7a,0x78,0x85,0x92,0x87,0x7b,0x6e,0x84,
+	0x87,0x94,0x78,0x83,0x7b,0x9a,0x84,0x88,
+	0x67,0x86,0x7d,0x9a,0x78,0x85,0x71,0x95,
+	0x80,0x8a,0x69,0x7d,0x79,0x91,0x7b,0x7e,
+	0x72,0x87,0x85,0x81,0x72,0x71,0x7a,0x84,
+	0x85,0x76,0x7b,0x7b,0x8b,0x7d,0x7d,0x6d,
+	0x7e,0x80,0x8c,0x79,0x81,0x7b,0x8d,0x82,
+	0x83,0x74,0x80,0x80,0x8d,0x81,0x82,0x7f,
+	0x88,0x83,0x83,0x78,0x7a,0x7e,0x86,0x82,
+	0x7e,0x7c,0x81,0x83,0x7f,0x79,0x79,0x7c,
+	0x84,0x81,0x84,0x7e,0x84,0x81,0x87,0x79,
+	0x83,0x7b,0x88,0x80,0x8b,0x7d,0x8b,0x7c,
+	0x89,0x7a,0x86,0x78,0x88,0x7d,0x8a,0x7b,
+	0x89,0x7b,0x85,0x79,0x82,0x79,0x84,0x7c,
+	0x82,0x7f,0x82,0x80,0x7b,0x7e,0x7a,0x7e,
+	0x79,0x81,0x7a,0x85,0x7d,0x87,0x79,0x82,
+	0x7c,0x83,0x71,0x80,0x7f,0x8e,0x82,0x82,
+	0x7c,0x80,0x7e,0x82,0x7d,0x82,0x80,0x85,
+	0x82,0x84,0x81,0x80,0x80,0x7e,0x7f,0x80,
+	0x81,0x82,0x81,0x82,0x80,0x7f,0x7c,0x80,
+	0x7c,0x81,0x7f,0x83,0x81,0x82,0x80,0x80,
+	0x7e,0x7e,0x7e,0x7e,0x7f,0x82,0x82,0x82,
+	0x82,0x80,0x7e,0x7e,0x7e,0x7f,0x7f,0x82,
+	0x82,0x82,0x80,0x80,0x80,0x7e,0x7d,0x7f,
+	0x7f,0x81,0x81,0x82,0x81,0x81,0x7f,0x7d,
+	0x7e,0x7f,0x7f,0x80,0x82,0x82,0x81,0x81,
+	0x80,0x7d,0x7e,0x7f,0x7f,0x81,0x80,0x83,
+	0x82,0x80,0x80,0x7e,0x7e,0x7f,0x7e,0x81,
+	0x81,0x83,0x81,0x81,0x80,0x7e,0x7e,0x7e,
+	0x7f,0x7f,0x82,0x83,0x82,0x82,0x80,0x7f,
+	0x7e,0x7d,0x7e,0x80,0x80,0x82,0x83,0x81,
+	0x80,0x7f,0x7e,0x7e,0x7d,0x80,0x80,0x84,
+	0x5d,0x47,0x74,0x69,0xc5,0x81,0x88,0x55,
+	0x67,0xa4,0x85,0x74,0x40,0x5b,0x89,0xc4,
+	0xa2,0x72,0x46,0x67,0xa2,0xb9,0x9e,0x56,
+	0x4e,0x68,0xa2,0xaa,0x7d,0x55,0x43,0x80,
+	0x99,0x9f,0x65,0x40,0x4d,0x73,0x9f,0x7d,
+	0x5b,0x36,0x51,0x77,0x81,0x6e,0x31,0x37,
+	0x4a,0x84,0x8b,0x69,0x4e,0x39,0x6e,0x72,
+	0x78,0x3e,0x23,0x36,0x5e,0x96,0x7b,0x6c,
+	0x46,0x62,0x7f,0x7e,0x6a,0x29,0x3a,0x49,
+	0x90,0x97,0x7c,0x69,0x56,0x8e,0x8b,0x93,
+	0x54,0x40,0x57,0x7e,0xbc,0x9a,0x92,0x6a,
+	0x90,0xac,0xaa,0x96,0x4e,0x6a,0x76,0xc0,
+	0xc2,0xa8,0x8f,0x7b,0xb9,0xaf,0xb9,0x70,
+	0x5e,0x70,0x94,0xd1,0xa4,0xa2,0x6e,0x95,
+	0xaa,0xa4,0x8f,0x42,0x5e,0x60,0xab,0xa0,
+	0x88,0x6f,0x5a,0x96,0x81,0x8d,0x42,0x36,
+	0x46,0x67,0x9e,0x6f,0x71,0x42,0x6f,0x7e,
+	0x7d,0x6b,0x29,0x49,0x4a,0x96,0x8d,0x82,
+	0x6d,0x61,0x9d,0x88,0xa1,0x60,0x61,0x6e,
+	0x93,0xc3,0x9b,0xad,0x80,0xb4,0xb9,0xbc,
+	0xa1,0x74,0x94,0x95,0xd9,0xc1,0xb7,0xa4,
+	0xa2,0xd2,0xc0,0xc7,0x7d,0x88,0x90,0xb9,
+	0xd1,0xab,0xa3,0x7e,0xb2,0xa9,0xa7,0x76,
+	0x47,0x5e,0x77,0xc5,0x97,0x8d,0x74,0x66,
+	0x79,0x63,0x60,0x2f,0x53,0x44,0x8c,0x95,
+	0x6b,0x60,0x47,0x7b,0x81,0x8f,0x5f,0x44,
+	0x53,0x6a,0xa2,0x87,0x82,0x5f,0x79,0x94,
+	0x93,0x83,0x42,0x4b,0x4e,0x85,0x85,0x6f,
+	0x5c,0x4f,0x7e,0x7b,0x7f,0x43,0x30,0x3b,
+	0x5b,0x84,0x6a,0x62,0x48,0x6f,0x87,0x8f,
+	0x76,0x49,0x55,0x69,0xa0,0xa2,0x95,0x87,
+	0x8f,0xbe,0xc7,0xc6,0x96,0x8e,0x99,0xc0,
+	0xdb,0xc7,0xb9,0xa9,0xca,0xd9,0xd9,0xb4,
+	0x8b,0x8a,0x99,0xb9,0xab,0x95,0x79,0x7f,
+	0x9a,0x99,0x85,0x52,0x42,0x49,0x66,0x70,
+	0x5b,0x49,0x41,0x5d,0x71,0x70,0x4e,0x36,
+	0x3c,0x59,0x78,0x76,0x68,0x60,0x76,0x96,
+	0xa6,0x98,0x7b,0x75,0x8d,0xad,0xb9,0xae,
+	0x9d,0xa6,0xbe,0xd6,0xce,0xaf,0x99,0x9c,
+	0xb8,0xc2,0xbf,0xa2,0x9c,0xa6,0xbd,0xbf,
+	0x9f,0x83,0x71,0x8a,0x93,0x98,0x7d,0x68,
+	0x73,0x7d,0x98,0x77,0x67,0x44,0x56,0x6a,
+	0x6f,0x6f,0x46,0x59,0x59,0x82,0x79,0x64,
+	0x53,0x44,0x76,0x74,0x92,0x6f,0x79,0x8f,
+	0xa7,0xcc,0x9b,0x88,0x61,0x9d,0x9c,0xae,
+	0x8f,0x56,0x89,0x71,0xa8,0x8c,0x8d,0x76,
+	0x73,0xa0,0x8c,0xab,0x6e,0x85,0x7c,0x98,
+	0xa2,0x77,0x82,0x50,0x84,0x6d,0x83,0x65,
+	0x4d,0x66,0x50,0x84,0x4f,0x60,0x36,0x4a,
+	0x5a,0x4d,0x64,0x2a,0x54,0x3a,0x67,0x5c,
+	0x4f,0x59,0x3c,0x77,0x58,0x87,0x5f,0x6c,
+	0x7a,0x7a,0xa9,0x80,0xa5,0x7e,0xac,0xab,
+	0xb2,0xc0,0x9a,0xc4,0xa4,0xd8,0xb8,0xc0,
+	0xb7,0xaa,0xd0,0xaa,0xcf,0x96,0xae,0x97,
+	0x9e,0xa7,0x7d,0x97,0x62,0x8d,0x6b,0x7b,
+	0x66,0x4f,0x63,0x3d,0x69,0x39,0x54,0x37,
+	0x44,0x55,0x42,0x63,0x36,0x60,0x42,0x64,
+	0x5f,0x5b,0x74,0x5a,0x91,0x74,0x9e,0x87,
+	0x97,0x9f,0x94,0xb7,0x96,0xc0,0xa1,0xc6,
+	0xbd,0xc4,0xcf,0xb7,0xd2,0xad,0xc8,0xac,
+	0xb9,0xb4,0xac,0xbd,0xa3,0xba,0x9c,0xaf,
+	0x94,0x90,0x88,0x79,0x8c,0x79,0x88,0x72,
+	0x7e,0x77,0x7a,0x78,0x5f,0x63,0x53,0x69,
+	0x65,0x6c,0x68,0x67,0x77,0x7f,0x87,0x7f,
+	0x77,0x7c,0x8f,0xa7,0xb4,0xb4,0xb4,0xaa,
+	0x9b,0x8e,0x85,0x48,0x40,0x5a,0x56,0x69,
+	0x60,0x6a,0x6c,0x83,0x9b,0x89,0x8a,0x5f,
+	0x77,0x72,0x8c,0x7f,0x6c,0x75,0x69,0x94,
+	0x77,0x7d,0x4d,0x4d,0x56,0x58,0x6d,0x3f,
+	0x57,0x3d,0x68,0x61,0x5a,0x4b,0x27,0x4c,
+	0x3b,0x67,0x43,0x4c,0x4a,0x59,0x83,0x68,
+	0x7b,0x49,0x6d,0x6a,0x8b,0x8c,0x77,0x90,
+	0x83,0xc2,0xac,0xbe,0x99,0x97,0xae,0xaf,
+	0xce,0xa3,0xb7,0xa2,0xca,0xce,0xc0,0xb6,
+	0x8c,0xa8,0x97,0xb4,0x91,0x87,0x81,0x81,
+	0xa4,0x83,0x88,0x4f,0x5c,0x58,0x65,0x64,
+	0x3e,0x4b,0x3b,0x6d,0x61,0x60,0x43,0x34,
+	0x4d,0x4f,0x6b,0x4b,0x55,0x50,0x75,0x8f,
+	0x8b,0x85,0x66,0x82,0x89,0xa5,0x9a,0x8d,
+	0x95,0xa2,0xcf,0xc9,0xc7,0xa4,0xa5,0xb3,
+	0xc2,0xc3,0xa8,0xa4,0xa6,0xc7,0xd0,0xc4,
+	0xa7,0x8e,0x97,0xa2,0xa6,0x90,0x7a,0x7a,
+	0x96,0xaa,0xa9,0x8d,0x73,0x6d,0x80,0x89,
+	0x7d,0x69,0x5d,0x76,0x90,0xa2,0x8e,0x77,
+	0x6d,0x7e,0x99,0x92,0x92,0x7b,0x98,0xb2,
+	0xcd,0xc5,0x94,0x70,0x3e,0x5c,0x63,0x6e,
+	0x41,0x2f,0x46,0x5a,0x78,0x56,0x59,0x48,
+	0x67,0x73,0x69,0x65,0x46,0x6f,0x74,0x97,
+	0x7c,0x66,0x5f,0x56,0x79,0x5b,0x65,0x3b,
+	0x50,0x5f,0x6f,0x7b,0x4d,0x58,0x3a,0x60,
+	0x52,0x54,0x42,0x36,0x5f,0x5b,0x83,0x5c,
+	0x65,0x54,0x65,0x78,0x69,0x75,0x57,0x82,
+	0x84,0xa9,0xa1,0x92,0x9d,0x8e,0xb6,0xa1,
+	0xb0,0x97,0xa3,0xb8,0xbf,0xd4,0xb2,0xbd,
+	0xa5,0xbb,0xb2,0xa9,0xa1,0x89,0xa4,0x9c,
+	0xb2,0x96,0x8d,0x7e,0x77,0x82,0x67,0x69,
+	0x47,0x5b,0x5a,0x69,0x66,0x4f,0x53,0x3e,
+	0x56,0x45,0x49,0x39,0x3a,0x54,0x5a,0x76,
+	0x61,0x6b,0x62,0x71,0x7d,0x74,0x7e,0x6d,
+	0x90,0x96,0xb5,0xb2,0xae,0xb0,0xa9,0xc1,
+	0xb2,0xb8,0xa6,0xaf,0xbf,0xc8,0xd7,0xc0,
+	0xc3,0xb0,0xbc,0xb4,0xaa,0xa1,0x93,0xa4,
+	0xa5,0xb7,0xa7,0x9e,0x96,0x8d,0x95,0x83,
+	0x83,0x70,0x7a,0x85,0x90,0x97,0x88,0x88,
+	0x7e,0x8d,0x85,0x84,0x7f,0x82,0x97,0xa6,
+	0xb9,0xb4,0xb2,0xa8,0x9e,0x89,0x5a,0x35,
+	0x35,0x56,0x70,0x62,0x51,0x31,0x2e,0x2c,
+	0x36,0x39,0x39,0x36,0x40,0x4e,0x60,0x68,
+	0x68,0x5f,0x5c,0x5b,0x58,0x53,0x48,0x4a,
+	0x4a,0x5b,0x5f,0x60,0x57,0x4f,0x51,0x46,
+	0x49,0x3c,0x40,0x3e,0x4c,0x59,0x58,0x62,
+	0x55,0x60,0x58,0x5f,0x5e,0x5b,0x68,0x6c,
+	0x8a,0x8a,0x9b,0x96,0x9d,0xa2,0x9f,0xab,
+	0xa1,0xb2,0xaf,0xc4,0xcb,0xd0,0xd7,0xc7,
+	0xd6,0xc1,0xca,0xb9,0xb8,0xbb,0xb2,0xc4,
+	0xb0,0xbd,0xa5,0xa3,0x93,0x85,0x81,0x67,
+	0x74,0x5b,0x6d,0x5d,0x61,0x5c,0x4a,0x52,
+	0x36,0x43,0x2c,0x39,0x37,0x3c,0x4c,0x44,
+	0x5e,0x4b,0x5f,0x53,0x5b,0x61,0x5b,0x75,
+	0x6c,0x8e,0x87,0x9c,0xa2,0xa0,0xad,0x9d,
+	0xb5,0xa1,0xb9,0xb6,0xc0,0xcc,0xc4,0xd9,
+	0xc2,0xd4,0xbc,0xc3,0xbb,0xb2,0xc2,0xae,
+	0xc6,0xb1,0xc1,0xb4,0xae,0xae,0x96,0xa6,
+	0x8b,0x9e,0x90,0x9b,0x9d,0x93,0xa5,0x8c,
+	0xa2,0x86,0x94,0x8c,0x8f,0x9c,0x91,0xaf,
+	0x9a,0xb3,0xa3,0xa8,0x9c,0x82,0x7b,0x4e,
+	0x54,0x51,0x52,0x50,0x79,0x57,0x4e,0x50,
+	0x24,0x34,0x25,0x35,0x3e,0x3a,0x54,0x42,
+	0x60,0x4e,0x5b,0x55,0x4d,0x59,0x47,0x62,
+	0x4c,0x61,0x52,0x59,0x5e,0x4d,0x5e,0x40,
+	0x55,0x40,0x50,0x4f,0x4a,0x5c,0x46,0x63,
+	0x4d,0x63,0x54,0x58,0x62,0x59,0x79,0x65,
+	0x84,0x76,0x8b,0x91,0x8c,0xa3,0x8d,0xac,
+	0x99,0xba,0xb3,0xbb,0xc9,0xbc,0xd9,0xc2,
+	0xdb,0xc4,0xcc,0xcc,0xc1,0xd8,0xba,0xd1,
+	0xb2,0xc1,0xb3,0xab,0xae,0x8a,0x9d,0x79,
+	0x90,0x74,0x74,0x6d,0x59,0x6b,0x47,0x5e,
+	0x39,0x44,0x3b,0x35,0x46,0x2c,0x48,0x2c,
+	0x47,0x3c,0x43,0x4d,0x3c,0x5c,0x46,0x6e,
+	0x5e,0x71,0x79,0x75,0x93,0x81,0xa5,0x91,
+	0xaa,0xa9,0xad,0xc3,0xb0,0xcf,0xb6,0xd3,
+	0xc7,0xcc,0xd6,0xc3,0xdb,0xc0,0xd9,0xc3,
+	0xcc,0xc6,0xbb,0xca,0xb0,0xc6,0xac,0xbb,
+	0xae,0xab,0xb0,0x9f,0xb4,0x9b,0xae,0x9e,
+	0xa5,0xa9,0x9f,0xb1,0x9b,0xae,0x9c,0xa9,
+	0xa3,0x9e,0xa5,0x8f,0x98,0x7b,0x75,0x5e,
+	0x5b,0x7a,0x5e,0x51,0x4e,0x44,0x47,0x58,
+	0x40,0x52,0x5b,0x36,0x3a,0x27,0x31,0x31,
+	0x32,0x3c,0x34,0x48,0x43,0x50,0x4a,0x46,
+	0x4a,0x42,0x4f,0x46,0x4f,0x48,0x4f,0x55,
+	0x54,0x5b,0x4b,0x51,0x47,0x50,0x51,0x52,
+	0x57,0x53,0x63,0x64,0x6e,0x6d,0x68,0x69,
+	0x6c,0x7b,0x7c,0x87,0x87,0x93,0x9f,0xa7,
+	0xb0,0xa9,0xaa,0xa9,0xb4,0xbc,0xc0,0xc4,
+	0xc3,0xce,0xd3,0xd8,0xce,0xc3,0xbc,0xba,
+	0xbb,0xbd,0xb6,0xaf,0xaa,0xac,0xab,0xa0,
+	0x8f,0x7a,0x74,0x6f,0x70,0x6c,0x5d,0x5d,
+	0x56,0x60,0x59,0x4f,0x40,0x2f,0x3b,0x39,
+	0x4a,0x3e,0x43,0x45,0x50,0x62,0x58,0x5d,
+	0x47,0x56,0x5e,0x71,0x7f,0x73,0x88,0x81,
+	0xa5,0xa3,0xa4,0x9c,0x8c,0xa7,0xa5,0xc5,
+	0xb4,0xba,0xbc,0xc0,0xdc,0xc4,0xcc,0xa7,
+	0xb3,0xb8,0xc0,0xd0,0xb2,0xc4,0xad,0xd0,
+	0xc6,0xba,0xae,0x8d,0xac,0x9e,0xc0,0xaa,
+	0xa5,0xa8,0xa3,0xc6,0xa6,0xb1,0x87,0x91,
+	0x9a,0x9e,0xb2,0x86,0x92,0x70,0x81,0x74,
+	0x6c,0x81,0x62,0x64,0x69,0x83,0x50,0x34,
+	0x36,0x47,0x79,0x41,0x62,0x42,0x36,0x3f,
+	0x3f,0x58,0x33,0x43,0x30,0x4e,0x53,0x46,
+	0x42,0x22,0x42,0x41,0x60,0x56,0x4a,0x51,
+	0x48,0x6d,0x57,0x59,0x3c,0x3d,0x52,0x5c,
+	0x76,0x5b,0x65,0x57,0x71,0x7e,0x70,0x6e,
+	0x51,0x6d,0x77,0x99,0x95,0x8a,0x90,0x8f,
+	0xb3,0xab,0xa8,0x93,0x90,0xac,0xbc,0xd5,
+	0xbe,0xbe,0xb8,0xc7,0xd4,0xc8,0xb8,0x9f,
+	0xaa,0xb9,0xcc,0xc7,0xb0,0xa5,0xa2,0xae,
+	0xa8,0x94,0x75,0x68,0x72,0x83,0x88,0x7b,
+	0x62,0x57,0x5f,0x64,0x60,0x3f,0x31,0x2c,
+	0x45,0x5b,0x59,0x51,0x39,0x4a,0x4f,0x62,
+	0x53,0x3f,0x44,0x47,0x79,0x7c,0x89,0x76,
+	0x73,0x8a,0x89,0xa3,0x80,0x84,0x81,0x9c,
+	0xc1,0xb7,0xc6,0xa1,0xb8,0xb8,0xc4,0xc5,
+	0xa2,0xb1,0xa0,0xd1,0xce,0xd3,0xc6,0xab,
+	0xc7,0xb3,0xd0,0xaa,0xa4,0xa2,0xa6,0xcf,
+	0xba,0xcc,0xa2,0xae,0xae,0xad,0xb6,0x8e,
+	0x9c,0x86,0xa9,0xa9,0x9d,0x90,0x64,0x70,
+	0x58,0x74,0x76,0x7f,0x69,0x53,0x91,0x7c,
+	0x6e,0x40,0x32,0x49,0x5a,0x61,0x26,0x48,
+	0x52,0x60,0x64,0x52,0x4f,0x31,0x3a,0x30,
+	0x39,0x33,0x27,0x30,0x35,0x4c,0x4e,0x52,
+	0x4a,0x43,0x45,0x46,0x48,0x40,0x41,0x48,
+	0x54,0x61,0x69,0x62,0x62,0x5d,0x60,0x62,
+	0x61,0x68,0x66,0x7b,0x85,0x97,0x99,0x96,
+	0x9e,0x92,0xa2,0x96,0xa6,0xa7,0xb0,0xc3,
+	0xc0,0xd8,0xc4,0xd5,0xc6,0xc3,0xc4,0xb5,
+	0xcb,0xb7,0xd2,0xc4,0xcc,0xca,0xb8,0xc4,
+	0x9d,0xa9,0x88,0x91,0x8d,0x84,0x94,0x75,
+	0x8c,0x6c,0x79,0x61,0x4f,0x50,0x30,0x50,
+	0x38,0x54,0x42,0x43,0x4e,0x3c,0x58,0x31,
+	0x44,0x2c,0x3b,0x4d,0x4b,0x6c,0x50,0x74,
+	0x63,0x7c,0x7a,0x6b,0x7a,0x62,0x8f,0x87,
+	0xa7,0xa1,0xa0,0xb6,0xa7,0xc9,0xa9,0xb3,
+	0xa1,0xa7,0xc2,0xbd,0xd8,0xb9,0xcd,0xc3,
+	0xcf,0xd0,0xb5,0xba,0x9d,0xbe,0xbb,0xcb,
+	0xc5,0xb4,0xc3,0xb5,0xcc,0xb2,0xab,0x96,
+	0x95,0xac,0xa8,0xb3,0x94,0x95,0x89,0x89,
+	0x82,0x5f,0x52,0x41,0x69,0x8a,0x9c,0x74,
+	0x4d,0x67,0x6f,0x74,0x5d,0x4e,0x51,0x5f,
+	0x64,0x4c,0x62,0x6a,0x69,0x64,0x67,0x5f,
+	0x47,0x2f,0x25,0x2f,0x42,0x4d,0x44,0x3d,
+	0x39,0x48,0x50,0x4e,0x3e,0x2f,0x36,0x48,
+	0x61,0x5d,0x5b,0x50,0x55,0x69,0x69,0x6a,
+	0x4d,0x54,0x5b,0x77,0x89,0x7f,0x81,0x74,
+	0x90,0x95,0x9c,0x8f,0x7c,0x8e,0x96,0xbd,
+	0xb6,0xb6,0xab,0xae,0xc8,0xc0,0xcb,0xa3,
+	0xab,0xad,0xc5,0xd7,0xc2,0xc3,0xa8,0xc2,
+	0xbc,0xbe,0xa8,0x88,0x95,0x8c,0xb0,0x9c,
+	0x94,0x7d,0x75,0x89,0x7c,0x78,0x4f,0x50,
+	0x4b,0x5b,0x5e,0x52,0x4d,0x49,0x49,0x46,
+	0x40,0x39,0x38,0x39,0x3d,0x42,0x51,0x62,
+	0x73,0x7e,0x85,0x85,0x86,0x86,0x85,0x88,
+	0x97,0xa9,0xbd,0xc9,0xd3,0xd1,0xd1,0xc9,
+	0xc6,0xc2,0xc2,0xc2,0xc7,0xc8,0xcd,0xca,
+	0xc6,0xc1,0xba,0xb2,0xac,0xa9,0xa8,0xab,
+	0xae,0xb0,0xb0,0xaf,0xab,0xa2,0x9b,0x94,
+	0x8d,0x8e,0x8e,0x8f,0x94,0x94,0x94,0x8f,
+	0x8a,0x81,0x79,0x74,0x71,0x6e,0x72,0x73,
+	0x76,0x76,0x76,0x6f,0x67,0x60,0x5a,0x55,
+	0x54,0x54,0x57,0x59,0x5d,0x5c,0x5a,0x56,
+	0x4f,0x48,0x44,0x43,0x44,0x46,0x4a,0x4e,
+	0x50,0x50,0x4d,0x49,0x45,0x40,0x40,0x3e,
+	0x42,0x45,0x4b,0x4e,0x50,0x51,0x4f,0x4a,
+	0x49,0x46,0x47,0x47,0x4e,0x50,0x57,0x5a,
+	0x5d,0x5b,0x5c,0x56,0x58,0x54,0x59,0x2c,
+	0x44,0x53,0x6e,0xa2,0x66,0x76,0x39,0x70,
+	0x7e,0x6d,0x52,0x3c,0x66,0xa2,0xc8,0xa1,
+	0x75,0x58,0x86,0xb1,0xbb,0x8b,0x58,0x64,
+	0x8d,0xc5,0xb5,0x85,0x59,0x5f,0x95,0xa4,
+	0x96,0x52,0x3e,0x51,0x88,0x9b,0x71,0x4a,
+	0x31,0x5e,0x7d,0x83,0x52,0x23,0x33,0x5b,
+	0x9d,0x8c,0x70,0x49,0x5d,0x8b,0x95,0x88,
+	0x44,0x42,0x5f,0xa2,0xc3,0xa9,0x8f,0x7b,
+	0xa9,0xbc,0xbc,0x89,0x5e,0x75,0x99,0xda,
+	0xc8,0xb3,0x8c,0x9f,0xc2,0xbd,0xa9,0x66,
+	0x68,0x7c,0xba,0xc8,0xaa,0x95,0x83,0xb4,
+	0xc0,0xb8,0x80,0x5f,0x76,0x9c,0xdc,0xc3,
+	0xb1,0x97,0xa9,0xcd,0xcf,0xb7,0x6b,0x65,
+	0x64,0x9a,0xa7,0x95,0x96,0x8e,0xc6,0xc3,
+	0xba,0x6f,0x38,0x41,0x5f,0x9f,0x89,0x8a,
+	0x70,0x97,0xbb,0xb4,0x9f,0x57,0x57,0x63,
+	0xa7,0xb2,0x9e,0x8d,0x7d,0xb9,0xbe,0xc8,
+	0x89,0x70,0x80,0xa0,0xd7,0xb2,0xa6,0x7a,
+	0x9a,0xb0,0xa7,0x87,0x34,0x3d,0x3f,0x7b,
+	0x71,0x58,0x3e,0x33,0x71,0x72,0x7e,0x3c,
+	0x31,0x46,0x79,0xad,0x95,0x92,0x77,0xac,
+	0xc8,0xcf,0xab,0x71,0x7a,0x89,0xc0,0xac,
+	0x92,0x70,0x77,0x9f,0xa2,0x91,0x4e,0x43,
+	0x56,0x90,0xb1,0x99,0x67,0x5f,0x8b,0xb9,
+	0xc9,0xa2,0x67,0x54,0x7b,0x98,0x9a,0x81,
+	0x6e,0x7b,0x98,0x9e,0x7b,0x42,0x2c,0x38,
+	0x5d,0x65,0x4e,0x32,0x38,0x5c,0x7f,0x7c,
+	0x5d,0x47,0x56,0x8b,0xac,0xb3,0x99,0x96,
+	0xac,0xce,0xd4,0xab,0x81,0x5f,0x78,0x86,
+	0x86,0x62,0x3f,0x48,0x5b,0x7b,0x64,0x4b,
+	0x33,0x4a,0x79,0x92,0x9d,0x7f,0x93,0xa7,
+	0xd3,0xd8,0xb6,0x9e,0x85,0xaa,0xac,0xb3,
+	0x88,0x70,0x7c,0x86,0xa4,0x75,0x63,0x3a,
+	0x52,0x6d,0x76,0x7d,0x59,0x80,0x80,0x95,
+	0x92,0x7e,0x7e,0x81,0xa0,0x89,0xa3,0x72,
+	0x7e,0x84,0x97,0xac,0x7e,0x74,0x47,0x65,
+	0x64,0x69,0x5b,0x31,0x4a,0x43,0x77,0x5c,
+	0x5a,0x4a,0x52,0x80,0x82,0xa6,0x7e,0x99,
+	0xa0,0xc0,0xd1,0xac,0xb0,0x82,0xab,0x94,
+	0x9f,0x7a,0x5b,0x68,0x55,0x7f,0x4c,0x5a,
+	0x34,0x4e,0x67,0x66,0x88,0x59,0x92,0x80,
+	0xbd,0xb5,0xad,0xb2,0x96,0xcc,0xa6,0xca,
+	0x92,0x9b,0x93,0x8c,0xab,0x6b,0x88,0x47,
+	0x75,0x60,0x6a,0x6b,0x47,0x77,0x5b,0xa5,
+	0x87,0x8c,0x6b,0x78,0xa5,0x87,0x9c,0x68,
+	0x8e,0x73,0x98,0x9a,0x76,0x92,0x53,0x8d,
+	0x54,0x75,0x4d,0x43,0x51,0x2f,0x64,0x28,
+	0x59,0x2e,0x57,0x5d,0x60,0x8a,0x6a,0xac,
+	0x8f,0xc8,0xb8,0xc5,0xd0,0xb6,0xda,0xa3,
+	0xc7,0x8d,0x99,0x7b,0x6a,0x6b,0x3d,0x5a,
+	0x2d,0x4d,0x33,0x46,0x53,0x50,0x78,0x67,
+	0x96,0x86,0xb3,0xb0,0xc0,0xc9,0xb9,0xd6,
+	0xbd,0xd5,0xb5,0xb4,0xa3,0x9b,0xa2,0x89,
+	0x8e,0x6d,0x78,0x70,0x78,0x78,0x6e,0x76,
+	0x7e,0x9b,0xa5,0x8c,0x81,0x91,0x8a,0x77,
+	0x7f,0x78,0x64,0x6e,0x78,0x86,0x81,0x6f,
+	0x65,0x5e,0x67,0x61,0x54,0x3f,0x30,0x3b,
+	0x3d,0x52,0x41,0x46,0x48,0x64,0x82,0x81,
+	0x90,0x7e,0xa4,0xae,0xcd,0xc7,0xb8,0xbb,
+	0xad,0xce,0xaa,0xa9,0x72,0x6d,0x6c,0x66,
+	0x6d,0x3b,0x49,0x2e,0x5e,0x59,0x61,0x5b,
+	0x4b,0x7f,0x7c,0xb3,0x93,0xa4,0x9e,0xb4,
+	0xd3,0xba,0xc6,0x8e,0xb0,0xa1,0xbb,0xa7,
+	0x82,0x8b,0x6f,0xa5,0x81,0x90,0x61,0x6a,
+	0x83,0x8c,0xb4,0x81,0x95,0x63,0xa2,0xa2,
+	0x78,0x64,0x4c,0x70,0x63,0x97,0x6a,0x68,
+	0x5a,0x66,0x8a,0x69,0x6b,0x2f,0x49,0x47,
+	0x62,0x59,0x36,0x3e,0x37,0x76,0x6d,0x7c,
+	0x60,0x68,0x8f,0xa7,0xcb,0xa5,0xae,0xa5,
+	0xcc,0xd9,0xc5,0xa9,0x7c,0x8c,0x88,0x95,
+	0x6c,0x4a,0x3b,0x45,0x62,0x5b,0x4c,0x30,
+	0x41,0x62,0x86,0x8c,0x80,0x7c,0x97,0xbe,
+	0xd3,0xc6,0xac,0xa6,0xb3,0xcf,0xc7,0xb3,
+	0x8d,0x91,0x9f,0xad,0xa5,0x7c,0x72,0x6d,
+	0x96,0x98,0x99,0x87,0x82,0x9f,0x91,0xaa,
+	0x8a,0x66,0x3c,0x6b,0x7e,0x65,0x66,0x42,
+	0x69,0x68,0x8a,0x6a,0x50,0x4b,0x41,0x6f,
+	0x50,0x5b,0x2d,0x41,0x51,0x62,0x75,0x4e,
+	0x64,0x55,0x92,0x96,0xa3,0x9c,0x8d,0xbc,
+	0xb8,0xdf,0xaf,0xae,0x97,0x9e,0xaf,0x8a,
+	0x8b,0x4d,0x67,0x57,0x6a,0x5b,0x3b,0x47,
+	0x37,0x72,0x60,0x78,0x63,0x70,0x93,0x9c,
+	0xc2,0x9a,0xb2,0x9c,0xc2,0xc7,0xbd,0xb7,
+	0x92,0xb4,0xa0,0xbf,0x99,0x8d,0x85,0x82,
+	0xa7,0x8c,0xa0,0x7a,0x99,0x9e,0xa3,0x91,
+	0x78,0x90,0x5f,0x63,0x5e,0x6f,0x51,0x3d,
+	0x5c,0x57,0x75,0x4f,0x55,0x45,0x4f,0x5f,
+	0x49,0x4d,0x28,0x44,0x3e,0x5a,0x50,0x47,
+	0x55,0x59,0x86,0x84,0x9b,0x8f,0xa2,0xb8,
+	0xc7,0xd9,0xbe,0xc5,0xb5,0xc4,0xb9,0xa9,
+	0x91,0x71,0x71,0x62,0x61,0x49,0x3a,0x33,
+	0x3a,0x4a,0x4e,0x54,0x56,0x68,0x7d,0x95,
+	0xa1,0xa7,0xae,0xbe,0xc9,0xd5,0xcf,0xc6,
+	0xc1,0xbe,0xc4,0xb5,0xb0,0xa0,0xa5,0xa4,
+	0xa4,0xa7,0x9a,0xa3,0x9b,0xb0,0xa5,0x92,
+	0x74,0x89,0x97,0x73,0x52,0x3a,0x5b,0x4d,
+	0x40,0x42,0x39,0x4c,0x38,0x51,0x3f,0x4a,
+	0x44,0x38,0x43,0x2a,0x45,0x2b,0x47,0x3f,
+	0x4f,0x61,0x61,0x85,0x79,0xa0,0x96,0xb2,
+	0xb8,0xbc,0xd4,0xc0,0xde,0xbd,0xce,0xb2,
+	0xa6,0x9a,0x77,0x7d,0x4c,0x61,0x3f,0x4c,
+	0x42,0x3c,0x50,0x3b,0x62,0x4b,0x6f,0x68,
+	0x81,0x99,0x96,0xc0,0xab,0xcf,0xbb,0xcf,
+	0xc5,0xbb,0xc6,0xa9,0xc7,0xa9,0xc1,0xab,
+	0xad,0xb1,0x9e,0xb8,0x94,0xae,0x8d,0x8e,
+	0x76,0x86,0xa1,0x7f,0x80,0x48,0x52,0x51,
+	0x53,0x52,0x2d,0x4c,0x34,0x58,0x3e,0x50,
+	0x49,0x45,0x53,0x37,0x4f,0x32,0x55,0x51,
+	0x62,0x6f,0x65,0x89,0x74,0x9e,0x8a,0x9e,
+	0x9c,0xa1,0xc1,0xb1,0xd3,0xae,0xc2,0xaa,
+	0xa9,0xa1,0x7d,0x84,0x58,0x76,0x5b,0x6a,
+	0x5b,0x4c,0x5c,0x46,0x69,0x4a,0x64,0x57,
+	0x6d,0x89,0x8e,0xb2,0x96,0xbb,0xa9,0xc2,
+	0xba,0xae,0xb6,0xa0,0xc7,0xb1,0xd0,0xb4,
+	0xb4,0xb6,0xa8,0xc0,0x98,0xab,0x83,0x8c,
+	0x79,0x8c,0xa5,0x84,0x8c,0x5c,0x6d,0x36,
+	0x45,0x4c,0x40,0x59,0x36,0x5d,0x3b,0x49,
+	0x44,0x42,0x54,0x32,0x49,0x2a,0x51,0x57,
+	0x66,0x76,0x5f,0x82,0x6c,0x95,0x80,0x8b,
+	0x8f,0x8f,0xbb,0xae,0xd2,0xae,0xbb,0xac,
+	0xa3,0xa8,0x7c,0x8b,0x5f,0x80,0x73,0x7b,
+	0x77,0x57,0x6e,0x49,0x6c,0x4d,0x5b,0x58,
+	0x5d,0x8d,0x83,0xb1,0x8f,0xab,0x9e,0xa8,
+	0xb2,0x97,0xae,0x91,0xbe,0xb6,0xc8,0xc3,
+	0xa9,0xbe,0x97,0xbd,0x91,0x9f,0x89,0x7f,
+	0x8a,0x85,0xb1,0x83,0x8d,0x6a,0x72,0x6a,
+	0x3c,0x49,0x3e,0x71,0x60,0x68,0x58,0x42,
+	0x58,0x35,0x5d,0x31,0x4c,0x3a,0x4d,0x6f,
+	0x66,0x8b,0x61,0x82,0x68,0x7d,0x80,0x6f,
+	0x8f,0x75,0xb3,0xa2,0xc6,0xb1,0xa1,0xaa,
+	0x85,0xa6,0x70,0x8a,0x6c,0x7e,0x90,0x7f,
+	0x9a,0x60,0x7e,0x52,0x69,0x5d,0x51,0x6b,
+	0x55,0x94,0x80,0xaa,0x93,0x90,0x9a,0x81,
+	0xa8,0x7d,0xa3,0x8a,0xac,0xbc,0xb6,0xd0,
+	0x99,0xba,0x8e,0xa7,0x97,0x8e,0x97,0x75,
+	0x97,0x85,0xae,0x8b,0x7e,0x74,0x5f,0x7e,
+	0x52,0x70,0x41,0x68,0x7c,0x73,0x81,0x43,
+	0x65,0x37,0x55,0x45,0x47,0x5d,0x4e,0x81,
+	0x6b,0x8d,0x75,0x74,0x78,0x60,0x83,0x62,
+	0x8d,0x7d,0x9a,0xa6,0x9e,0xb2,0x8a,0xa2,
+	0x7a,0x88,0x7b,0x77,0x8c,0x79,0x9e,0x82,
+	0x97,0x80,0x78,0x73,0x5b,0x6f,0x55,0x78,
+	0x70,0x84,0x8e,0x88,0x9c,0x7f,0x93,0x77,
+	0x82,0x7e,0x85,0x9c,0x96,0xb3,0xa0,0xb1,
+	0xa2,0x9e,0x9b,0x83,0x90,0x81,0x98,0x93,
+	0x91,0x8c,0x8d,0x97,0x81,0x7f,0x66,0x68,
+	0x65,0x6e,0x7f,0x73,0x78,0x75,0x7a,0x75,
+	0x65,0x5c,0x4b,0x4e,0x50,0x67,0x70,0x7a,
+	0x7b,0x76,0x7d,0x7a,0x7a,0x6e,0x67,0x69,
+	0x7a,0x8b,0x97,0x98,0x94,0x90,0x92,0x91,
+	0x87,0x79,0x6d,0x78,0x86,0x94,0x95,0x8c,
+	0x88,0x7f,0x87,0x7a,0x73,0x62,0x61,0x75,
+	0x80,0x95,0x85,0x88,0x7e,0x86,0x8a,0x7e,
+	0x7b,0x66,0x80,0x8a,0xa5,0xa5,0x97,0x99,
+	0x8a,0xa2,0x90,0x8d,0x7a,0x7a,0x92,0x94,
+	0xad,0x85,0x8b,0x7b,0x86,0x8a,0x70,0x75,
+	0x52,0x76,0x7a,0x98,0x92,0x6d,0x78,0x62,
+	0x87,0x6c,0x68,0x52,0x48,0x70,0x70,0x9c,
+	0x74,0x7b,0x6a,0x73,0x8c,0x6e,0x7f,0x50,
+	0x78,0x7f,0x9d,0xa8,0x7f,0x90,0x6b,0x9c,
+	0x86,0x87,0x73,0x5a,0x8c,0x82,0xb6,0x89,
+	0x86,0x74,0x74,0x98,0x70,0x83,0x4e,0x6f,
+	0x7e,0x95,0xa7,0x75,0x85,0x63,0x92,0x86,
+	0x80,0x75,0x57,0x8d,0x8a,0xba,0x96,0x8a,
+	0x82,0x7b,0xa6,0x86,0x92,0x63,0x7a,0x93,
+	0xa3,0xb8,0x7f,0x7f,0x67,0x8c,0x8d,0x79,
+	0x70,0x4f,0x7c,0x84,0xac,0x92,0x74,0x66,
+	0x62,0x8b,0x77,0x72,0x4e,0x56,0x77,0x8a,
+	0xa0,0x78,0x6e,0x61,0x79,0x89,0x7c,0x70,
+	0x59,0x75,0x8e,0xaa,0x9c,0x80,0x73,0x75,
+	0x8f,0x8e,0x7f,0x69,0x69,0x84,0xa0,0xa7,
+	0x8e,0x74,0x6b,0x7d,0x8c,0x87,0x6b,0x64,
+	0x6a,0x90,0xa1,0x9a,0x80,0x65,0x75,0x7e,
+	0x91,0x7c,0x69,0x6b,0x7b,0xaa,0xa2,0x9e,
+	0x75,0x74,0x83,0x8d,0x99,0x73,0x78,0x70,
+	0x9b,0xae,0xa0,0x91,0x5c,0x7d,0x76,0x94, 
+};
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/test/test_pwm.sh linux-3.13/drivers/armadeus/pwm/test/test_pwm.sh
--- linux-3.13/drivers/armadeus/pwm/test/test_pwm.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/test/test_pwm.sh	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,119 @@
+#!/bin/sh
+
+#
+# Script to test Armadeus Software release
+#
+#  Copyright (C) 2010-2013 The Armadeus Project - Armadeus Systems
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+
+#
+# Script to test your PWM: plug either an oscilloscope or a buzzer on the signal
+#   and launch this script
+#
+
+source ./test_helpers.sh
+source ./test_env.sh
+
+SYS_DIR="/sys/class/pwm/pwm0/"
+PERIOD="1000 2000 3000 4000 5000 6000 7000 8000 9000 10000"
+FREQUENCY="100 200 300 400 500 600 700 800"
+DUTY="001 250 333 500 666 750 999"
+SLEEP_TIME=4
+
+load_driver()
+{
+	if [ "$1" == "APF9328" ] || [ "$1" == "APF27" ] || [ "$1" == "APF51" ]; then
+		modprobe imx-pwm
+		if [ ! -d "$SYS_DIR" ]; then
+			echo "can't find /sys/ interface"
+			exit_failed
+		fi
+	elif [ "$1" == "APF28" ]; then
+		SYS_DIR="/sys/class/pwm/pwm4/"
+		if [ ! -d "$SYS_DIR" ]; then
+			echo "can't find /sys/ interface"
+			exit_failed
+		fi
+	else
+		echo "Platform not supported by this test"
+		exit 0
+	fi
+}
+
+prepare_test()
+{
+	OSCILLO="Please connect your oscilloscope probe"
+	WHEN_READY="then press ENTER when ready"
+	if [ "$1" == "APF9328" ]; then
+		PLAT_MSG="to pin 4 of X21/Timer connector (GND is on pin 8)"
+	elif [ "$1" == "APF27" ]; then
+		PLAT_MSG="to pin 4 of J22 connector (GND is on pin 6 or 40)"
+	elif [ "$1" == "APF51" ]; then
+		PLAT_MSG="to pin 6 of J35 (Extension) connector (GND is on pin 9 or 10)"
+		EXTRA_PLAT_MSG="\n (you can also watch i.MX LED; requires a custom built kernel)"
+	elif [ "$1" == "APF28" ]; then
+		PLAT_MSG="to pin 26 of J10 connector (GND is on pin 32 or 34)"
+	fi
+
+	ask_user "$OSCILLO $PLAT_MSG, $WHEN_READY $EXTRA_PLAT_MSG"
+}
+
+test_pwm()
+{
+	show_test_banner "PWM"
+
+	execute_for_target load_driver
+
+	if [ "$1" != "" ]; then
+		prepare_test $1
+	else
+		execute_for_target prepare_test
+	fi
+
+	ask_user "Press ENTER when ready to check PWM output (frequencies starting at 100Hz)"
+	echo 1 > $SYS_DIR/active
+	# Test frequency setting
+	for freq in $FREQUENCY; do
+		echo $freq > $SYS_DIR/frequency
+		echo "Setting PWM frequency to $freq Hz"
+		sleep $SLEEP_TIME
+	done
+
+	ask_user "Press ENTER when ready to check PWM output (periods)"
+	# Test period setting
+	for period in $PERIOD; do
+		echo $period > $SYS_DIR/period
+		freq=$((1000000/period))
+		echo "Setting PWM period to $period us (-> $freq Hz)"
+		sleep $SLEEP_TIME
+	done
+
+	ask_user "Press ENTER when ready to check PWM output (duty cycle @ 100Hz)"
+	# Test duty cycle setting @ 100Hz -> duty value = positive width signal value
+	echo 100 > $SYS_DIR/frequency
+	for duty in $DUTY; do
+		echo $duty > $SYS_DIR/duty
+		echo "Setting duty cycle to $duty/1000 "
+		sleep $SLEEP_TIME
+	done
+
+	echo 500 > $SYS_DIR/duty
+	echo 0 > $SYS_DIR/active
+	echo "End of PWM test"
+
+	ask_user "Did you get correct signals ? (y/N)"
+	if [ "$response" != "y" ] && [ "$response" != "yes" ]; then
+		exit_failed
+	fi
+
+	echo_test_ok
+	exit 0
+}
+
+test_pwm $1
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/test/testplaymode.c linux-3.13/drivers/armadeus/pwm/test/testplaymode.c
--- linux-3.13/drivers/armadeus/pwm/test/testplaymode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/test/testplaymode.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,103 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Copyright (C) 2002 Motorola Semiconductors HK Ltd
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+//#include <errno.h>
+//#include "MX1_def.h"
+#include "../pwm.h"
+
+#define	T8_8
+//#define	T16_8
+//#define	T32_8
+
+#ifdef T8_8
+#include "TEST8.H"
+#define SAM_RATE	PWM_SAMPLING_8KHZ
+#define DATA_LEN	PWM_DATA_8BIT
+#define DATA_SZ		0xd998
+#elif defined(T16_8)
+#include "T16K_8B.H"
+#define SAM_RATE	PWM_SAMPLING_16KHZ
+#define DATA_LEN	PWM_DATA_8BIT
+#define DATA_SZ		0x7520
+#elif defined(T32_8)
+#include "T32K_8B.H"
+#define SAM_RATE	PWM_SAMPLING_32KHZ
+#define DATA_LEN	PWM_DATA_8BIT
+#define DATA_SZ		0x7520
+#endif
+
+#define BUFFER_SIZE (16*1024)
+
+
+int main( int argc, char* argv[] )
+{
+    int handle, readfd = 0, nb = 0, written = 0;
+    short	ret;
+    unsigned char* buffer;
+
+    if (argc != 1) {
+        printf("Opening file: %s\n", argv[1]);
+        readfd = open( argv[1], O_RDONLY );
+    }
+
+    handle = open("/dev/pwm", O_RDWR);
+    if (handle < 0) {
+        printf("can not open file /dev/pwm\n");
+        exit(1);
+    }
+
+    printf("Playing wave file...\n");
+
+    /* Play wave */
+    ioctl(handle, PWM_IOC_SMODE, PWM_PLAY_MODE);
+    ioctl(handle, PWM_IOC_SFREQ, SAM_RATE);
+    ioctl(handle, PWM_IOC_SDATALEN, DATA_LEN);
+
+    if (readfd) {
+        buffer = (unsigned char*)malloc( BUFFER_SIZE );
+        if (buffer) {
+            while ( (nb = read( readfd, buffer, BUFFER_SIZE )) > 0 ) {
+                write( handle, buffer, nb );
+                printf("read %d\n", nb);
+            }
+        }
+    } else {
+        printf("No data file given, playing default sound of size %d\n", DATA_SZ);
+        buffer = (unsigned char*)data;
+        while (nb < DATA_SZ) {
+            written = write(handle, buffer, DATA_SZ);
+            buffer += written;
+            nb += written;
+            printf("  Written %d, total %d\n", written, nb);
+        }
+        buffer = 0;
+    }
+
+    printf("End of sound playing\n");
+    close(handle);
+    close(readfd);
+    if (buffer)
+        free( buffer );
+
+    exit(0);
+}
+
diff '--exclude=*.cmd' '--exclude=*.o' -ruN linux-3.13/drivers/armadeus/pwm/test/testtonemode.c linux-3.13/drivers/armadeus/pwm/test/testtonemode.c
--- linux-3.13/drivers/armadeus/pwm/test/testtonemode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.13/drivers/armadeus/pwm/test/testtonemode.c	2013-11-24 11:27:23.000000000 +0100
@@ -0,0 +1,50 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Copyright (C) 2002 Motorola Semiconductors HK Ltd
+ *
+ */
+
+#include <stdio.h>
+#include <fcntl.h>
+//#include "MX1_def.h"
+#include "../pwm.h"
+
+int main(void)
+{
+	int handle;
+	short	ret;
+	unsigned short data[]= {100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100};
+
+	handle = open("/dev/pwm", O_RDWR);
+	if(handle == 0){
+		printf("can not open file pwm\n");
+		return -1;
+	}
+
+	printf("Play tone file...\n");
+
+	// Play tone
+	ioctl(handle, PWM_IOC_SMODE, PWM_TONE_MODE);
+	ioctl(handle, PWM_IOC_SPERIOD, 250);	// period in ms
+	ioctl(handle, PWM_IOC_SSAMPLE, 0x75); // Sample register
+
+	write(handle, data, sizeof(data));
+
+	close(handle);
+
+	return 1;
+}
+
